<?xml version="1.0" encoding="UTF-8" standalone="yes"?><EtherCATTest Name="TF-2302 CoE SDO Complete Access" xsi:noNamespaceSchemaLocation="EtherCATTest.xsd" SchemaVersion="1.0.31" TestId="8962" TestVersion="1.1.0" RealeaseState="Released" TestVendorId="1" Url="http://www.ethercat.org/en/conformance.html" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
	<Comment>This test represents a group of the Mailbox CoE Complete Access acording to the ETG 1020. 
With the Complete Access all SubIndexes of an object are uploaded or downloaded with a single SDO service. For the data of the object there are the following rules for the correct alignment:
1.	SubIndex 0 is padded to 16 bit
2.	SubIndixes of bit data type (BOOLEAN and BIT1 to BIT7) will be filled over the byte border, the next non-bit data type will start at the next BYTE address
3.	To define gaps in the byte stream of a Complete Access, it is allowed to define gap entries (Data_Type = 0, Bit_Length = gap size in bits)
4.	SubIndixes that donâ€™t exist will not need space
5.	The Complete Access can start with SubIndex 0 or SubIndex 1, other subindixes are not allowed
6.	If the slave supports Complete Access all objects which fit in the mailbox should be accessible by SDO with Complete Access
7.	If the slave supports Complete Access and Segmented SDO Transfer all objects should be accessible by SDO with Complete Access
8.	For ENUM objects Complete Access may not be supported
9.	Objects may deny the Complete Access by responding the Abort Codes 0x06010004 (Complete Access not supported) and 0x06010000 (Unsupported access to an object)
10.	Objects whose entries have variable Bit Sizes should not support the Complete Access.
11.	The length of the responsed Complete Access data shall either match to the current byte length of the object or to the Bit Size of the object description
12.	The current max SubIndex may exceed the number of entry descriptions of the offline object dictionary. 
13.	The value of gaps shall be 0.
14.	Array and Record objects with current max SubIndex = 0 shall respond 2 bytes if uploaded by Complete Access

Definitions and abbreviations used in this Test:
ESI	EtherCAT Slave Information file
DuT	Device under Test
Online Dictionary	Data structure addressed by Index and Subindex that contains descriptions of the objects. The DuTs online object dictionary is accessed by the SDO Info protocol.
Offline Dictionary	Data structure addressed by Index and Subindex that contains descriptions of the objects. The DuTs offline dictionary is reprsented by the /EtherCATInfo/Descriptions/Devices/Device/Profile/Dictionary- element of the ESI
SI0	Subindex 0
SI1	Subindex 1
Single Access	With the Single Access the complete object data is uploaded or downloaded separately by every SubIndex
Object Description	Represents the object description of an online or offline object dictionary
Entry Description	Represents the entry description of an online or offline dictionary
Current Byte Length of the object	Is calculated by the entry description of the current max SI (BitOffset+BitLen+7)/8. If the max SI exceeds the number of entry descriptions, the current byte length is determined by the bit size of the object description (only valid for offline dictionary)
</Comment>
	<History>
		<HistoryEntry Editor="O.H." TestVersion="0.0.0" Date="2011-10-20">Created.</HistoryEntry>
		<HistoryEntry Editor="O.H." TestVersion="0.0.33" Date="2015-10-16">TestFunction: 'CheckRWObject': Additional abort code (0x8000020) allowed for CA download.</HistoryEntry>
		<HistoryEntry Editor="O.H." TestVersion="0.0.33" Date="2015-10-16">TestFunction: 'CheckRWObject' and 'CheckROObject': Complete Access started from SI1 skipped if the current max subindex is 0.</HistoryEntry>
		<HistoryEntry Editor="O.H." TestVersion="0.0.34" Date="2016-02-16">Where: 1.3, 2.3, 3.3, 4.3
Reason: The test cases shall throw an error if no real time extension is available and a Dc-Op Mode is set.
Solution: New test function 'EcBaseFunctions.CheckIfCurrentConfigRequiresCu2508' added to the named test cases to check whether Cu2508 is connected.</HistoryEntry>
		<HistoryEntry Editor="B.L." TestVersion="0.0.35" Date="2016-02-17" Id="EN_TF_2302_160217" Type="Enhancement">Update to Schema version 1.0.24</HistoryEntry>
		<HistoryEntry Editor="O.H." TestVersion="0.0.36" Date="2016-04-28" Id="EN_TF_2302_160428_1" Type="Enhancement">TestFunction: 'CheckRWObject': Additional abort code (0x06010006) in Operational allowed for CA download.</HistoryEntry>
		<HistoryEntry Editor="O.H." TestVersion="0.0.37" Date="2016-05-13" Id="EN_TF_2302_160513_1" Type="Enhancement">TestFunction: 'UploadSingleAccess': All abortcodes allowed.</HistoryEntry>
		<HistoryEntry Editor="B.L." TestVersion="0.0.38" Date="2016-06-17" Id="EN_TF_2302_160617_1">Remove unused WriteLine.</HistoryEntry>
		<HistoryEntry Editor="O.H." TestVersion="0.0.39" Date="2016-07-01" Id="EN_TF_2302_160701_1">Version incremented</HistoryEntry>
		<HistoryEntry Editor="F.H." TestVersion="1.0.0" Date="2016-07-05">Release version</HistoryEntry>
		<HistoryEntry Editor="R.H." TestVersion="1.0.0" Date="2017-03-20">OP based tests: init mailbox (offline check) before checking realtime extension</HistoryEntry>
		<HistoryEntry Editor="G.E." TestVersion="1.0.1" Date="2018-01-18">Where: 4.1, 4.2, 4.3
Reason: Copy/Paste mistake in Test description under Action step 3. Test group filters for RW in PreOp objects based on the online dictionary, not offline.
Solution: Change word "offline" to "online".
Where: 4.3
Reason: Copy/Paste mistake in Test description under PreCondition point 2. Test provides an online dictionary, not offline.
Solution: Change word "offline" to "online".</HistoryEntry>
		<HistoryEntry Editor="B.L." TestVersion="1.0.2" Date="2018-09-14">Add output IDs and update Schema version to 1.0.31</HistoryEntry>
		<HistoryEntry Editor="F.E." TestVersion="1.0.3" Date="2018-10-17" Type="Bug">Correct r.safeOPTimeout to be 10000ms (before 3000ms) according to ETG.2000</HistoryEntry>
    <HistoryEntry Editor="O.H." TestVersion="1.0.4" Date="2018-11-09" Type="Bug">Testfunction 401: Missing parameter in output (Id =7) added</HistoryEntry>
	</History>
	<TestVariables>
		<TestVariable>
			<Name>r.preOPTimeout</Name>
			<Type>Int32</Type>
			<Comment>ESM timeout</Comment>
		</TestVariable>
		<TestVariable>
			<Name>r.safeOPTimeout</Name>
			<Type>Int32</Type>
			<Comment>ESM timeout</Comment>
		</TestVariable>
		<TestVariable>
			<Name>sourceDictionary</Name>
			<Type>ObjectDictionary</Type>
		</TestVariable>
		<TestVariable>
			<Name>object.completeAccessAbort</Name>
			<Type>Bool</Type>
		</TestVariable>
		<TestVariable>
			<Name>stringCurrentDictionaryType</Name>
			<Type>String</Type>
			<Comment>Type of current object dictionary</Comment>
		</TestVariable>
	</TestVariables>
	<Variables>
		<Variable>
			<Name>object.count</Name>
			<Type>Int32</Type>
		</Variable>
		<Variable>
			<Name>object.list</Name>
			<Type>ObjectList</Type>
		</Variable>
		<Variable>
			<Name>object.listIndex</Name>
			<Type>Int32</Type>
		</Variable>
	</Variables>
	<IncludedTestFunctions>
		<FileName Version="0.0.47">EcBaseFunctions_V1i0i0.xml</FileName>
	</IncludedTestFunctions>
	<TestFunctions>
		<TestFunction Name="CheckCoECompleteAccess" FunctionId="101">
			<?MAX_OUTPUT_ID 3?>
			<TestStep Name="CheckMailboxSupport">
				<Description Id="0" Level="Verbose">Checking mailbox CoE Complete Access support...</Description>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Mailbox</Value1>
						<Value2>false</Value2>
						<SkipCase Id="1">DuT does not support the mailbox protocol.</SkipCase>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Mailbox.CoE</Value1>
						<Value2>false</Value2>
						<SkipCase Id="2">DuT does not support the CoE mailbox protocol.</SkipCase>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Mailbox.CoE.CompleteAccess</Value1>
						<Value2>true</Value2>
						<WriteLine Id="3">DuT supports the SDO Complete Access</WriteLine>
					</Equal>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction Name="CheckROObject" FunctionId="201">
			<?MAX_OUTPUT_ID 26?>
			<Parameter>
				<Name>CheckROObject.ObjectList</Name>
				<Type>ObjectList</Type>
			</Parameter>
			<Parameter>
				<Name>CheckROObject.ListIndex</Name>
				<Type>Int32</Type>
			</Parameter>
			<LocalVariables>
				<Name>CheckROObject.Data</Name>
				<Type>ArrayOfBytes</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckROObject.Data1</Name>
				<Type>ArrayOfBytes</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckROObject.Data2</Name>
				<Type>ArrayOfBytes</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckROObject.Index</Name>
				<Type>UInt16</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckROObject.Name</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckROObject.BitSize</Name>
				<Type>Int32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckROObject.SdoAccess</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckROObject.LengthToCopy</Name>
				<Type>Int32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckROObject.TempString1</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckROObject.ObjectCurrentByteLength</Name>
				<Type>Int32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckROObject.DataLength</Name>
				<Type>Int32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckROObject.MaxSubIndex</Name>
				<Type>Byte</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckROObject.SI0Data</Name>
				<Type>Byte</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckROObject.TempString2</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckROObject.Entries</Name>
				<Type>ObjectList</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckROObject.EntryCount</Name>
				<Type>Int32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckROObject.AbortMessage</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckROObject.Si0Value</Name>
				<Type>Byte</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckROObject.AbortCode</Name>
				<Type>UInt32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckROObject.DataValid</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<TestStep Name="GetObjectDescription">
				<Description Id="0" Level="Verbose" Param0="object.listIndex">Test Function 'CheckROObject':  Requesting object description of list index {0}...</Description>
				<GetObjectDescriptionFromList Source="CheckROObject.ObjectList" ListIndex="CheckROObject.ListIndex">
					<Index>CheckROObject.Index</Index>
					<Name>CheckROObject.Name</Name>
					<BitSize>CheckROObject.BitSize</BitSize>
					<Flags>
						<SdoAccess>CheckROObject.SdoAccess</SdoAccess>
					</Flags>
					<MaxSubIndex>CheckROObject.MaxSubIndex</MaxSubIndex>
				</GetObjectDescriptionFromList>
				<RaiseErrorOnFailure Id="1">Test Function 'CheckROObject': Failed to get object description</RaiseErrorOnFailure>
			</TestStep>
			<TestStep Name="CheckForDiagHistory">
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Mailbox.CoE.DiagHistory</Value1>
						<Value2>false</Value2>
						<GotoStep>CheckForSubIndexAccess</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckROObject.Index</Value1>
						<Value2>#x10f3</Value2>
						<GotoStep>CheckForSubIndexAccess</GotoStep>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="TryReadDiagHistory">
				<Description Id="2" Level="Verbose">Test Function 'CheckROObject': Trying to read Diag History...</Description>
				<CallTestFunction Name="DiagnosisHistory"></CallTestFunction>
				<RaiseErrorOnFailure Id="3" Param0="CheckROObject.Index" Param1="CheckROObject.Name">Test Function 'CheckROObject': 0x{0:X4} '{1}': Uploading DiagHistory failed</RaiseErrorOnFailure>
			</TestStep>
			<TestStep Name="CheckForSubIndexAccess">
				<Description Id="4" Level="Output" Param0="CheckROObject.SdoAccess">Test Function 'CheckROObject': SdoAccess {0}...</Description>
				<Compare>
					<Equal>
						<Value1>CheckROObject.SdoAccess</Value1>
						<Value2>"None"</Value2>
						<GotoStep>GetEntries</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckROObject.SdoAccess</Value1>
						<Value2>"CompleteAccess"</Value2>
						<GotoStep>GetEntries</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckROObject.SdoAccess</Value1>
						<Value2>"SubIndexAccess"</Value2>
						<Return Id="5" Param0="CheckROObject.Name" Param1="CheckROObject.Index">Test Function 'CheckROObject': 0x{1:X4} '{0}' is skipped, because the SubIndexAccess is set in the object description</Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="GetEntries">
				<Description Id="6" Level="Verbose" Param0="CheckROObject.Name" Param1="CheckROObject.Index">Test Function 'CheckROObject': 0x{1:X4} '{0}': Requesting entry descriptions...</Description>
				<GetObjectList SourceDict="sourceDictionary" Target="CheckROObject.Entries" Count="CheckROObject.EntryCount">
					<Index>CheckROObject.Index</Index>
				</GetObjectList>
				<RaiseErrorOnFailure Id="7" Param0="CheckROObject.Name" Param1="CheckROObject.Index">Test Function 'CheckROObject': Failed to get entries of '{0}' 0x{1:X4}</RaiseErrorOnFailure>
				<Compare>
					<Equal>
						<Value1>CheckROObject.EntryCount</Value1>
						<Value2>1</Value2>
						<Return Id="8" Param0="CheckROObject.Name" Param1="CheckROObject.Index">Test Function 'CheckROObject': 0x{1:X4} '{0}' is skipped, because the object description does not contain more than one SubIndex.</Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="SetString1">
				<SetVariable Target="CheckROObject.TempString1">SI0 Complete Access data</SetVariable>
			</TestStep>
			<TestStep Name="SetString2">
				<SetVariable Target="CheckROObject.TempString2">SI1 Complete Access data</SetVariable>
			</TestStep>
			<TestStep Name="GetMaxSubIndex">
				<Description Id="9" Level="Verbose" Param0="CheckROObject.Index">Test Function 'CheckROObject': 0x{0:X4}:0 Uploading current max subIndex...</Description>
				<UploadCoEObject>
					<Index>CheckROObject.Index</Index>
					<SubIndex>0</SubIndex>
					<DataVar>CheckROObject.SI0Data</DataVar>
					<BitLen>8</BitLen>
					<AbortCode>CheckROObject.AbortCode</AbortCode>
					<AbortMessage>CheckROObject.AbortMessage</AbortMessage>
				</UploadCoEObject>
				<RaiseErrorOnFailure Id="10" Param0="CheckROObject.Index">Test Function 'CheckROObject': 0x{0:X4}:0: Failed to upload data </RaiseErrorOnFailure>
				<Compare>
					<NotEqual>
						<Value1>CheckROObject.AbortMessage</Value1>
						<Value2>EmptyString</Value2>
						<RaiseError Id="11" Param0="CheckROObject.Name" Param1="CheckROObject.Index" Param2="0" Param3="CheckROObject.AbortMessage">Test Function 'CheckROObject': '{0}' 0x{1:X4}:{2:X} Failed to upload current max SubIndex. {3}</RaiseError>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckROObject.AbortCode</Value1>
						<Value2>0U</Value2>
						<RaiseError Id="12" Param0="CheckROObject.Name" Param1="CheckROObject.Index" Param2="0" Param3="CheckROObject.AbortCode">Test Function 'CheckROObject': '{0}' 0x{1:X4}:{2:X}: Failed to upload current max SubIndex. Unexpected abort code received 0x{3:X8}</RaiseError>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckROObject.AbortCode</Value1>
						<Value2>0</Value2>
						<WriteLine Id="13" Level="Verbose" Param0="CheckROObject.Index" Param1="CheckROObject.Name" Param2="CheckROObject.SI0Data">Test Function 'CheckROObject': 0x{0:X4}:0 '{1}' data (max subindex): {2}</WriteLine>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="GetObjectLength">
				<CallTestFunction Name="GetCurrentObjectLength">
					<Parameter>CheckROObject.Index</Parameter>
					<Parameter>CheckROObject.BitSize</Parameter>
					<Parameter>CheckROObject.Name</Parameter>
					<Parameter>CheckROObject.MaxSubIndex</Parameter>
					<Parameter>CheckROObject.SI0Data</Parameter>
					<OutParameter>CheckROObject.ObjectCurrentByteLength</OutParameter>
				</CallTestFunction>
			</TestStep>
			<TestStep Name="SetSI0ValueTo0">
				<SetVariable Target="CheckROObject.Si0Value">0</SetVariable>
			</TestStep>
			<TestStep Name="UploadCompleteAccessDataAndCheckSize">
				<Description Id="14" Level="Output" Param0="CheckROObject.Name" Param1="CheckROObject.Index">Test Function 'CheckROObject': 0x{1:X4} '{0}': Uploading Complete Access data starting at SI0...</Description>
				<CallTestFunction Name="UploadCompleteAccess">
					<Parameter>CheckROObject.Index</Parameter>
					<Parameter>CheckROObject.BitSize</Parameter>
					<Parameter>CheckROObject.Si0Value</Parameter>
					<Parameter>CheckROObject.Name</Parameter>
					<Parameter>CheckROObject.ObjectCurrentByteLength</Parameter>
					<OutParameter>CheckROObject.Data</OutParameter>
				</CallTestFunction>
			</TestStep>
			<TestStep Name="CheckForValidAbort">
				<Compare>
					<Equal>
						<Value1>object.completeAccessAbort</Value1>
						<Value2>true</Value2>
						<Return Id="15"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="GetData1Length">
				<SizeOf UInt32Var="CheckROObject.DataLength">CheckROObject.Data</SizeOf>
			</TestStep>
			<TestStep Name="IntData1">
				<Description Id="16" Level="Verbose" Param0="CheckROObject.DataLength">Test Function 'CheckROObject': Init data1[{0}]</Description>
				<InitArray Length="CheckROObject.DataLength" TargetArray="CheckROObject.Data1"></InitArray>
			</TestStep>
			<TestStep Name="StoreSI0CAData">
				<CopyArray>
					<SourceArray>CheckROObject.Data</SourceArray>
					<DestinationArray>CheckROObject.Data1</DestinationArray>
					<SourceIndex>0</SourceIndex>
					<Length>CheckROObject.DataLength</Length>
				</CopyArray>
			</TestStep>
			<TestStep Name="SkipSi1UploadForEmptyObjects">
				<Compare>
					<Equal>
						<Value1>CheckROObject.SI0Data</Value1>
						<Value2>0</Value2>
						<WriteLine Id="17" Param0="CheckROObject.Index">Test Function 'CheckROObject': 0x{0:X4} SDO complete access upload started from SI1 skipped because the current max subIndex is 0. </WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckROObject.SI0Data</Value1>
						<Value2>0</Value2>
						<GotoStep>SetSingleAccessString2</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="SetSI0ValueTo1">
				<SetVariable Target="CheckROObject.Si0Value">1</SetVariable>
			</TestStep>
			<TestStep Name="UploadCompleteAccessSI1">
				<Description Id="18" Level="Output" Param0="CheckROObject.Name" Param1="CheckROObject.Index">Test Function 'CheckROObject': 0x{1:X4} '{0}': Uploading Complete Access data starting at SI1...</Description>
				<CallTestFunction Name="UploadCompleteAccess">
					<Parameter>CheckROObject.Index</Parameter>
					<Parameter>CheckROObject.BitSize</Parameter>
					<Parameter>CheckROObject.Si0Value</Parameter>
					<Parameter>CheckROObject.Name</Parameter>
					<Parameter>CheckROObject.ObjectCurrentByteLength</Parameter>
					<OutParameter>CheckROObject.Data</OutParameter>
				</CallTestFunction>
			</TestStep>
			<TestStep Name="CheckForInvalidAbort">
				<Compare>
					<Equal>
						<Value1>object.completeAccessAbort</Value1>
						<Value2>true</Value2>
						<RaiseError Id="19" Param0="CheckROObject.Index">Test Function 'CheckROObject': 0x{0:X4} SDO complete access of SI1 failed due to an Abort Code although the previous SDO complete access upload of SI0 was successful. </RaiseError>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="GetData2Length">
				<SizeOf UInt32Var="CheckROObject.DataLength">CheckROObject.Data</SizeOf>
			</TestStep>
			<TestStep Name="IntData2">
				<Description Id="20" Level="Verbose" Param0="CheckROObject.DataLength+2">Test Function 'CheckROObject': Init data2[{0}]</Description>
				<InitArray Length="CheckROObject.DataLength+2" TargetArray="CheckROObject.Data2"></InitArray>
			</TestStep>
			<TestStep Name="CopySI0Data">
				<SetArrayItem Index="0" TargetArray="CheckROObject.Data2">CheckROObject.SI0Data</SetArrayItem>
			</TestStep>
			<TestStep Name="StoreSI1CAData">
				<CopyArray>
					<SourceArray>CheckROObject.Data</SourceArray>
					<DestinationArray>CheckROObject.Data2</DestinationArray>
					<SourceIndex>0</SourceIndex>
					<DestinationIndex>2</DestinationIndex>
					<Length>CheckROObject.DataLength</Length>
				</CopyArray>
			</TestStep>
			<TestStep Name="Compare.SI0.Si1">
				<CallTestFunction Name="CompareObjectData">
					<Parameter>false</Parameter>
					<Parameter>"None"</Parameter>
					<Parameter>CheckROObject.Entries</Parameter>
					<Parameter>CheckROObject.Index</Parameter>
					<Parameter>CheckROObject.Name</Parameter>
					<Parameter>CheckROObject.SI0Data</Parameter>
					<Parameter>CheckROObject.Data1</Parameter>
					<Parameter>CheckROObject.Data2</Parameter>
					<Parameter>CheckROObject.TempString1</Parameter>
					<Parameter>CheckROObject.TempString2</Parameter>
				</CallTestFunction>
				<RaiseErrorOnFailure Id="21" Param0="CheckROObject.Index" Param1="CheckROObject.Name" Param2="CheckROObject.TempString1" Param3="CheckROObject.TempString2">Test Function 'CheckROObject': 0x{0:X4} '{1}': Comparison of {2} to {3} failed</RaiseErrorOnFailure>
				<WriteLine Id="22" Level="Verbose" Param0="CheckROObject.Index" Param1="CheckROObject.Name" Param2="CheckROObject.TempString1" Param3="CheckROObject.TempString2">Test Function 'CheckROObject': 0x{0:X4} '{1}': Uploaded {2} is equivalent to {3} </WriteLine>
			</TestStep>
			<TestStep Name="SetSingleAccessString2">
				<SetVariable Target="CheckROObject.TempString2">Single Access data</SetVariable>
			</TestStep>
			<TestStep Name="UploadSingleAccess">
				<Description Id="23" Level="Output" Param0="CheckROObject.Name" Param1="CheckROObject.Index">Test Function 'CheckROObject': 0x{1:X4} '{0}': Uploading Single Acces...</Description>
				<CallTestFunction Name="UploadSingleAccess">
					<Parameter>CheckROObject.Index</Parameter>
					<Parameter>CheckROObject.Entries</Parameter>
					<Parameter>CheckROObject.Name</Parameter>
					<Parameter>CheckROObject.ObjectCurrentByteLength</Parameter>
					<Parameter>CheckROObject.SI0Data</Parameter>
					<OutParameter>CheckROObject.Data</OutParameter>
				</CallTestFunction>
				<WriteLine Id="24" Level="Verbose" Param0="CheckROObject.Name" Param1="CheckROObject.Index" Param2="CheckROObject.Data" Param3="CheckROObject.TempString2">Test Function 'CheckROObject': 0x{1:X4} '{0}': Uploaded  {3} {2}</WriteLine>
			</TestStep>
			<TestStep Name="StoreSingleAccessData">
				<SetVariable Target="CheckROObject.Data2">CheckROObject.Data</SetVariable>
			</TestStep>
			<TestStep Name="CompareSI0CAToSA">
				<CallTestFunction Name="CompareObjectData">
					<Parameter>false</Parameter>
					<Parameter>"None"</Parameter>
					<Parameter>CheckROObject.Entries</Parameter>
					<Parameter>CheckROObject.Index</Parameter>
					<Parameter>CheckROObject.Name</Parameter>
					<Parameter>CheckROObject.SI0Data</Parameter>
					<Parameter>CheckROObject.Data1</Parameter>
					<Parameter>CheckROObject.Data2</Parameter>
					<Parameter>CheckROObject.TempString1</Parameter>
					<Parameter>CheckROObject.TempString2</Parameter>
				</CallTestFunction>
				<RaiseErrorOnFailure Id="25" Param0="CheckROObject.Index" Param1="CheckROObject.Name" Param2="CheckROObject.TempString1" Param3="CheckROObject.TempString2">Test Function 'CheckROObject': 0x{0:X4} '{1}': Comparison of {2} to {3} failed</RaiseErrorOnFailure>
				<WriteLine Id="26" Level="Verbose" Param0="CheckROObject.Index" Param1="CheckROObject.Name" Param2="CheckROObject.TempString1" Param3="CheckROObject.TempString2">Test Function 'CheckROObject': 0x{0:X4} '{1}': Uploaded {2} is equivalent to {3} </WriteLine>
			</TestStep>
		</TestFunction>
		<TestFunction Name="CheckRWObject" FunctionId="202">
			<?MAX_OUTPUT_ID 37?>
			<Parameter>
				<Name>CheckRWObject.ObjectList</Name>
				<Type>ObjectList</Type>
			</Parameter>
			<Parameter>
				<Name>CheckRWObject.ListIndex</Name>
				<Type>Int32</Type>
			</Parameter>
			<Parameter>
				<Name>CheckRWObject.StringState</Name>
				<Type>String</Type>
			</Parameter>
			<Parameter>
				<Name>CheckRWObject.AllowSdoBlocked</Name>
				<Type>Bool</Type>
			</Parameter>
			<LocalVariables>
				<Name>CheckRWObject.AbortCode</Name>
				<Type>UInt32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckRWObject.AbortMessage</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckRWObject.BitSize</Name>
				<Type>Int32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckRWObject.Data</Name>
				<Type>ArrayOfBytes</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckRWObject.Data1</Name>
				<Type>ArrayOfBytes</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckRWObject.Data2</Name>
				<Type>ArrayOfBytes</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckRWObject.DataLength</Name>
				<Type>Int32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckRWObject.Data1Length</Name>
				<Type>Int32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckRWObject.Entries</Name>
				<Type>ObjectList</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckRWObject.EntryCount</Name>
				<Type>Int32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckRWObject.Index</Name>
				<Type>UInt16</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckRWObject.LengthToCopy</Name>
				<Type>Int32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckRWObject.MaxSubIndex</Name>
				<Type>Byte</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckRWObject.Name</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckRWObject.ObjectCurrentByteLength</Name>
				<Type>Int32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckRWObject.SdoAccess</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckRWObject.SI0Data</Name>
				<Type>Byte</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckRWObject.Si0Value</Name>
				<Type>Byte</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckRWObject.TempString1</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckRWObject.TempString2</Name>
				<Type>String</Type>
			</LocalVariables>
			<TestStep Name="SetSI0Value">
				<SetVariable Target="CheckRWObject.Si0Value">0</SetVariable>
			</TestStep>
			<TestStep Name="SetString1">
				<SetVariable Target="CheckRWObject.TempString1">data1</SetVariable>
			</TestStep>
			<TestStep Name="SetString2">
				<SetVariable Target="CheckRWObject.TempString2">data2</SetVariable>
			</TestStep>
			<TestStep Name="GetObjectDescription">
				<Description Id="0" Level="Verbose" Param0="CheckRWObject.ListIndex">Test Function 'CheckRWObject': Requesting object description of list index {0}...</Description>
				<GetObjectDescriptionFromList Source="CheckRWObject.ObjectList" ListIndex="CheckRWObject.ListIndex">
					<Index>CheckRWObject.Index</Index>
					<Name>CheckRWObject.Name</Name>
					<BitSize>CheckRWObject.BitSize</BitSize>
					<Flags>
						<SdoAccess>CheckRWObject.SdoAccess</SdoAccess>
					</Flags>
					<MaxSubIndex>CheckRWObject.MaxSubIndex</MaxSubIndex>
				</GetObjectDescriptionFromList>
				<RaiseErrorOnFailure Id="1">Test Function 'CheckRWObject': Failed to get object description</RaiseErrorOnFailure>
			</TestStep>
			<TestStep Name="CheckForDiagHistory">
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Mailbox.CoE.DiagHistory</Value1>
						<Value2>false</Value2>
						<GotoStep>CheckForSubIndexAccess</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckRWObject.Index</Value1>
						<Value2>#x10f3</Value2>
						<GotoStep>CheckForSubIndexAccess</GotoStep>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="TryReadDiagHistory">
				<Description Id="2" Level="Verbose">Test Function 'CheckRWObject': Trying to read Diag History...</Description>
				<CallTestFunction Name="DiagnosisHistory"></CallTestFunction>
				<RaiseErrorOnFailure Id="3" Param0="CheckRWObject.Index" Param1="CheckRWObject.Name">Test Function 'CheckRWObject': 0x{0:X4} '{1}': Uploading DiagHistory failed</RaiseErrorOnFailure>
			</TestStep>
			<TestStep Name="CheckForSubIndexAccess">
				<Compare>
					<Equal>
						<Value1>CheckRWObject.SdoAccess</Value1>
						<Value2>"None"</Value2>
						<GotoStep>GetEntries</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckROObject.SdoAccess</Value1>
						<Value2>"CompleteAccess"</Value2>
						<GotoStep>GetEntries</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckRWObject.SdoAccess</Value1>
						<Value2>"SubIndexAccess"</Value2>
						<Return Id="4" Param0="CheckRWObject.Name" Param1="CheckRWObject.Index">Test Function 'ChecckRWObject': 0x{1:X4} '{0}' is skipped, because the SubIndexAccess is set in the object description</Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="GetEntries">
				<Description Id="5" Level="Verbose" Param0="CheckRWObject.Name" Param1="CheckRWObject.Index">Test Function 'CheckRWObject': 0x{1:X4} '{0}': Requesting entry descriptions...</Description>
				<GetObjectList SourceDict="sourceDictionary" Target="CheckRWObject.Entries" Count="CheckRWObject.EntryCount">
					<Index>CheckRWObject.Index</Index>
				</GetObjectList>
				<RaiseErrorOnFailure Id="6" Param0="CheckRWObject.Name" Param1="CheckRWObject.Index">Test Function 'CheckRWObject': Failed to get entries of '{0}' 0x{1:X4}</RaiseErrorOnFailure>
				<Compare>
					<NotEqual>
						<Value1>CheckRWObject.EntryCount</Value1>
						<Value2>1</Value2>
						<WriteLine Id="7" Level="Verbose" Param0="CheckRWObject.Name" Param1="CheckRWObject.Index" Param2="CheckRWObject.EntryCount">Test Function 'CheckRWObject': 0x{1:X4} '{0}' No of entries {2}</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckRWObject.EntryCount</Value1>
						<Value2>1</Value2>
						<Return Id="8" Param0="CheckRWObject.Name" Param1="CheckRWObject.Index">Test Function 'CheckRWObject': 0x{1:X4} '{0}' is skipped, because the object description does not contain more than one SubIndex.</Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="GetMaxSubIndex">
				<Description Id="9" Level="Verbose" Param0="CheckRWObject.Index">Test Function 'CheckRWObject': 0x{0:X4}:0 Uploading current max subIndex...</Description>
				<UploadCoEObject>
					<Index>CheckRWObject.Index</Index>
					<SubIndex>0</SubIndex>
					<DataVar>CheckRWObject.SI0Data</DataVar>
					<BitLen>8</BitLen>
					<AbortCode>CheckRWObject.AbortCode</AbortCode>
					<AbortMessage>CheckRWObject.AbortMessage</AbortMessage>
				</UploadCoEObject>
				<RaiseErrorOnFailure Id="10" Param0="CheckRWObject.Index">Test Function 'CheckRWObject': 0x{0:X4}:0: Failed to upload data </RaiseErrorOnFailure>
				<Compare>
					<NotEqual>
						<Value1>CheckRWObject.AbortMessage</Value1>
						<Value2>EmptyString</Value2>
						<RaiseError Id="11" Param0="CheckRWObject.Name" Param1="CheckRWObject.Index" Param2="0" Param3="CheckRWObject.AbortMessage">Test Function 'CheckRWObject': '{0}' 0x{1:X4}:{2:X} Failed to upload current max SubIndex. {3}</RaiseError>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckRWObject.AbortCode</Value1>
						<Value2>0U</Value2>
						<RaiseError Id="12" Param0="CheckRWObject.Name" Param1="CheckRWObject.Index" Param2="0" Param3="CheckRWObject.AbortCode">Test Function 'CheckRWObject': '{0}' 0x{1:X4}:{2:X}: Failed to upload current max SubIndex. Unexpected abort code received 0x{3:X8}</RaiseError>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckRWObject.AbortCode</Value1>
						<Value2>0</Value2>
						<WriteLine Id="13" Level="Verbose" Param0="CheckRWObject.Index" Param1="CheckRWObject.Name" Param2="CheckRWObject.SI0Data">Test Function 'CheckRWObject': 0x{0:X4}:0 '{1}' data (max subindex): {2}</WriteLine>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="GetObjectLength">
				<CallTestFunction Name="GetCurrentObjectLength">
					<Parameter>CheckRWObject.Index</Parameter>
					<Parameter>CheckRWObject.BitSize</Parameter>
					<Parameter>CheckRWObject.Name</Parameter>
					<Parameter>CheckRWObject.MaxSubIndex</Parameter>
					<Parameter>CheckRWObject.SI0Data</Parameter>
					<OutParameter>CheckRWObject.ObjectCurrentByteLength</OutParameter>
				</CallTestFunction>
			</TestStep>
			<TestStep Name="UploadCompleteAccessDataAndCheckSize">
				<Description Id="14" Level="Output" Param0="CheckRWObject.Name" Param1="CheckRWObject.Index">Test Function 'CheckRWObject': 0x{1:X4} '{0}': Uploading Complete Access data starting at SI0...</Description>
				<CallTestFunction Name="UploadCompleteAccess">
					<Parameter>CheckRWObject.Index</Parameter>
					<Parameter>CheckRWObject.BitSize</Parameter>
					<Parameter>CheckRWObject.Si0Value</Parameter>
					<Parameter>CheckRWObject.Name</Parameter>
					<Parameter>CheckRWObject.ObjectCurrentByteLength</Parameter>
					<OutParameter>CheckRWObject.Data</OutParameter>
				</CallTestFunction>
			</TestStep>
			<TestStep Name="CheckForValidAbort">
				<Compare>
					<Equal>
						<Value1>object.completeAccessAbort</Value1>
						<Value2>true</Value2>
						<Return Id="15"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="GetData1Length">
				<SizeOf UInt32Var="CheckRWObject.DataLength">CheckRWObject.Data</SizeOf>
				<WriteLine Id="16" Level="Output" Param0="CheckRWObject.Name" Param1="CheckRWObject.Index" Param2="CheckRWObject.Data" Param3="CheckRWObject.DataLength">Test Function 'CheckRWObject': 0x{1:X4} '{0}': Uploaded Complete Access data: {2} length: {3}</WriteLine>
			</TestStep>
			<TestStep Name="UploadSingleAccess">
				<Description Id="17" Level="Output" Param0="CheckRWObject.Name" Param1="CheckRWObject.Index">Test Function 'CheckRWObject': 0x{1:X4} '{0}': Uploading Single Acces...</Description>
				<CallTestFunction Name="UploadSingleAccess">
					<Parameter>CheckRWObject.Index</Parameter>
					<Parameter>CheckRWObject.Entries</Parameter>
					<Parameter>CheckRWObject.Name</Parameter>
					<Parameter>CheckRWObject.DataLength</Parameter>
					<Parameter>CheckRWObject.SI0Data</Parameter>
					<OutParameter>CheckRWObject.Data</OutParameter>
				</CallTestFunction>
				<WriteLine Id="18" Level="Output" Param0="CheckRWObject.Name" Param1="CheckRWObject.Index" Param2="CheckRWObject.Data" Param3="CheckRWObject.TempString1">Test Function 'CheckRWObject': 0x{1:X4} '{0}': Uploaded Single Access {3}: {2}</WriteLine>
			</TestStep>
			<TestStep Name="GetSingleAccessLength">
				<SizeOf UInt32Var="CheckRWObject.Data1Length">CheckRWObject.Data</SizeOf>
			</TestStep>
			<TestStep Name="StoreSingleAccessData1">
				<SetVariable Target="CheckRWObject.Data1">CheckRWObject.Data</SetVariable>
			</TestStep>
			<TestStep Name="DownloadCompleteAccess">
				<Description Id="19" Level="Output" Param0="CheckRWObject.Name" Param1="CheckRWObject.Index" Param2="CheckRWObject.Si0Value">Test Function 'CheckRWObject': 0x{1:X4} '{0}': Downloading Complete Access data1 starting at subIndex {2}...</Description>
				<DownloadCoEObject>
					<Index>CheckRWObject.Index</Index>
					<SubIndex>CheckRWObject.Si0Value</SubIndex>
					<DataVar>CheckRWObject.Data</DataVar>
					<AbortCode>CheckRWObject.AbortCode</AbortCode>
					<AbortMessage>CheckRWObject.AbortMessage</AbortMessage>
					<CompleteAccess>true</CompleteAccess>
				</DownloadCoEObject>
				<RaiseErrorOnFailure Id="20" Param0="CheckRWObject.Name" Param1="CheckRWObject.Index">Test Function 'CheckRWObject': 0x{1:X4} '{0}': Failed to download Complete Access data1 SI0 </RaiseErrorOnFailure>
				<WriteLine Id="21" Level="Output" Param0="CheckRWObject.Name" Param1="CheckRWObject.Index" Param2="CheckRWObject.Data" Param3="CheckRWObject.TempString1">Test Function 'CheckRWObject': 0x{1:X4} '{0}': Downloaded Complete Access {3}: {2}</WriteLine>
				<Compare>
					<NotEqual>
						<Value1>CheckRWObject.AbortMessage</Value1>
						<Value2>EmptyString</Value2>
						<RaiseError Id="22" Param0="CheckRWObject.Index" Param1="CheckRWObject.AbortMessage" Param2="CheckRWObject.Name">Test Function 'CheckRWObject': '{2}' 0x{0:X4}:0 Serious error while downloading {1} </RaiseError>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckRWObject.AbortCode</Value1>
						<Value2>#x06010000</Value2>
						<WriteLine Id="23" Param0="CheckRWObject.Index" Param1="CheckRWObject.Name">Test Function 'CheckRWObject': 0x{0:X4} '{1}' SDO Complete Access download failed. Allowed Abort Code 0x06010000 (Unsupported Access) received.</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckRWObject.AbortCode</Value1>
						<Value2>#x06010000</Value2>
						<GotoStep>AllowedAbortSI0</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckRWObject.AbortCode == #x06010002 AND CheckRWObject.Si0Value == 0</Value1>
						<Value2>true</Value2>
						<RaiseWarning Id="24" Param0="CheckRWObject.Index" Param1="CheckRWObject.Name">Test Function 'CheckRWObject': 0x{0:X4} '{1}' SDO Complete Access download failed. Allowed Abort Code 0x06010002 (Attemt to write a read only object) received.</RaiseWarning>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckRWObject.AbortCode == #x06010002 AND CheckRWObject.Si0Value == 0</Value1>
						<Value2>true</Value2>
						<GotoStep>AllowedAbortSI0</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckRWObject.AbortCode</Value1>
						<Value2>#x08000021</Value2>
						<WriteLine Id="25" Param0="CheckRWObject.Index" Param1="CheckRWObject.Name">Test Function 'CheckRWObject': 0x{0:X4} '{1}' SDO Complete Access download failed. Allowed Abort Code 0x08000021 (Data cannot be transferred or stored to the application because of local control) received.</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckRWObject.AbortCode</Value1>
						<Value2>#x08000021</Value2>
						<GotoStep>AllowedAbortSI0</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckRWObject.AbortCode</Value1>
						<Value2>#x08000020</Value2>
						<RaiseWarning Id="26" Param0="CheckRWObject.Index" Param1="CheckRWObject.Name">Test Function 'CheckRWObject': 0x{0:X4} '{1}' SDO Complete Access download failed. Not recommended Abort Code 0x08000020 (Data cannot be transferred or stored to the application) received.</RaiseWarning>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckRWObject.AbortCode</Value1>
						<Value2>#x08000020</Value2>
						<GotoStep>AllowedAbortSI0</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckRWObject.AbortCode</Value1>
						<Value2>#x06010004</Value2>
						<WriteLine Id="27" Param0="CheckRWObject.Index" Param1="CheckRWObject.Name">Test Function 'CheckRWObject': 0x{0:X4} '{1}' SDO Complete Access download failed. Allowed Abort Code 0x06010004 (Complete Access not supported) received.</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckRWObject.AbortCode</Value1>
						<Value2>#x06010004</Value2>
						<GotoStep>AllowedAbortSI0</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckRWObject.AbortCode == #x6010006 AND CheckRWObject.AllowSdoBlocked</Value1>
						<Value2>True</Value2>
						<WriteLine Id="28" Param0="CheckRWObject.Index" Param1="CheckRWObject.Name">Test Function 'CheckRWObject': 0x{0:X4} '{1}' SDO Complete Access download failed. Allowed Abort Code 0x06010006 (Object mapped to RXPDO, SDO Download blocked) received.</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckRWObject.AbortCode == #x6010006 AND CheckRWObject.AllowSdoBlocked</Value1>
						<Value2>True</Value2>
						<GotoStep>AllowedAbortSI0</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckRWObject.AbortCode</Value1>
						<Value2>0</Value2>
						<RaiseError Id="29" Param0="CheckRWObject.Name" Param1="CheckRWObject.Index" Param2="CheckRWObject.AbortCode">Test Function 'CheckRWObject': 0x{1:X4} '{0}': SDO Complete Access download failed. The received  Abort Code (0x{2:X8}) was not expected.</RaiseError>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="UploadSingleAccess2">
				<Description Id="30" Level="Output" Param0="CheckRWObject.Name" Param1="CheckRWObject.Index" Param2="CheckRWObject.TempString2">Test Function 'CheckRWObject': 0x{1:X4} '{0}': Uploading Single Access {2}...</Description>
				<CallTestFunction Name="UploadSingleAccess">
					<Parameter>CheckRWObject.Index</Parameter>
					<Parameter>CheckRWObject.Entries</Parameter>
					<Parameter>CheckRWObject.Name</Parameter>
					<Parameter>CheckRWObject.ObjectCurrentByteLength</Parameter>
					<Parameter>CheckRWObject.SI0Data</Parameter>
					<OutParameter>CheckRWObject.Data</OutParameter>
				</CallTestFunction>
				<WriteLine Id="31" Level="Output" Param0="CheckRWObject.Name" Param1="CheckRWObject.Index" Param2="CheckRWObject.Data" Param3="CheckRWObject.TempString2">Test Function 'CheckRWObject': 0x{1:X4} '{0}': Uploaded Single Access {3}: {2}</WriteLine>
			</TestStep>
			<TestStep Name="StoreSingleAccessData2">
				<SetVariable Target="CheckRWObject.Data2">CheckRWObject.Data</SetVariable>
			</TestStep>
			<TestStep Name="CompareData1Data2AndReturnIfSI0Equals1OrSI0Is0">
				<Description Id="32" Level="Output" Param0="CheckRWObject.Name" Param1="CheckRWObject.Index" Param2="CheckRWObject.TempString1" Param3="CheckRWObject.TempString2">Test Function 'CheckRWObject': 0x{1:X4} '{0}': Comparing Single Access {2} against {3}...</Description>
				<CallTestFunction Name="CompareObjectData">
					<Parameter>false</Parameter>
					<Parameter>CheckRWObject.StringState</Parameter>
					<Parameter>CheckRWObject.Entries</Parameter>
					<Parameter>CheckRWObject.Index</Parameter>
					<Parameter>CheckRWObject.Name</Parameter>
					<Parameter>CheckRWObject.SI0Data</Parameter>
					<Parameter>CheckRWObject.Data1</Parameter>
					<Parameter>CheckRWObject.Data2</Parameter>
					<Parameter>CheckRWObject.TempString1</Parameter>
					<Parameter>CheckRWObject.TempString2</Parameter>
				</CallTestFunction>
				<RaiseErrorOnFailure Id="33" Param0="CheckRWObject.Index" Param1="CheckRWObject.Name" Param2="CheckRWObject.TempString1" Param3="CheckRWObject.TempString2">Test Function 'CheckRWObject': 0x{0:X4} '{1}': Comparison of single access {2} to {3} failed</RaiseErrorOnFailure>
				<WriteLine Id="34" Level="Verbose" Param0="CheckRWObject.Index" Param1="CheckRWObject.Name" Param2="CheckRWObject.TempString1" Param3="CheckRWObject.TempString2">Test Function 'CheckRWObject': 0x{0:X4} '{1}': Uploaded Single Access {2} is equivalent to theSingle Access {3} </WriteLine>
				<Compare>
					<Equal>
						<Value1>CheckRWObject.Si0Value</Value1>
						<Value2>1</Value2>
						<Return Id="35" Param0="CheckRWObject.Index" Param1="CheckRWObject.Name">Test Function 'CheckRWObject': 0x{0:X4} '{1}': Download via complete access succeeded</Return>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckRWObject.SI0Data</Value1>
						<Value2>0</Value2>
						<Return Id="36" Param0="CheckRWObject.Index" Param1="CheckRWObject.Name">Test Function 'CheckRWObject': 0x{0:X4} '{1}': Download via complete access SI0 succeeded. Download started from SI1 skipped because the current max Subindex is 0.</Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="SetString3">
				<SetVariable Target="CheckRWObject.TempString2">data3</SetVariable>
			</TestStep>
			<TestStep Name="InitCompleteAccessDataSi1">
				<InitArray Length="CheckRWObject.DataLength-2" TargetArray="CheckRWObject.Data"></InitArray>
			</TestStep>
			<TestStep Name="CopySI0ToSI1">
				<CopyArray>
					<SourceArray>CheckRWObject.Data1</SourceArray>
					<DestinationArray>CheckRWObject.Data</DestinationArray>
					<SourceIndex>2</SourceIndex>
					<Length>CheckRWObject.Data1Length-2</Length>
				</CopyArray>
			</TestStep>
			<TestStep Name="IncrementSi0">
				<SetVariable Target="CheckRWObject.Si0Value">CheckRWObject.Si0Value+1</SetVariable>
				<Compare>
					<Equal>
						<Value1>0</Value1>
						<Value2>0</Value2>
						<GotoStep>DownloadCompleteAccess</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="AllowedAbortSI0">
				<SetVariable Target="object.completeAccessAbort">true</SetVariable>
				<Compare>
					<Equal>
						<Value1>0</Value1>
						<Value2>0</Value2>
						<Return Id="37"></Return>
					</Equal>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction Name="CompareObjectData" FunctionId="301">
			<?MAX_OUTPUT_ID 22?>
			<Parameter>
				<Name>CompareObjectData.BoolOnlyRW</Name>
				<Type>Bool</Type>
				<Comment>Only RW entries are checked. This parameter is used in conjunction with the StringState parameter.</Comment>
			</Parameter>
			<Parameter>
				<Name>CompareObjectData.StringState</Name>
				<Type>String</Type>
				<Comment>State of the RW access that is checked. Allowed values PreOp, SafeOp, Op, None.</Comment>
			</Parameter>
			<Parameter>
				<Name>CompareObjectData.Entries</Name>
				<Type>ObjectList</Type>
				<Comment>List of the objects entries</Comment>
			</Parameter>
			<Parameter>
				<Name>CompareObjectData.Index</Name>
				<Type>UInt16</Type>
			</Parameter>
			<Parameter>
				<Name>CompareObjectData.Name</Name>
				<Type>String</Type>
			</Parameter>
			<Parameter>
				<Name>CompareObjectData.SI0Data</Name>
				<Type>Byte</Type>
			</Parameter>
			<Parameter>
				<Name>CompareObjectData.Data1</Name>
				<Type>ArrayOfBytes</Type>
			</Parameter>
			<Parameter>
				<Name>CompareObjectData.Data2</Name>
				<Type>ArrayOfBytes</Type>
			</Parameter>
			<Parameter>
				<Name>CompareObjectData.DataName1</Name>
				<Type>String</Type>
			</Parameter>
			<Parameter>
				<Name>CompareObjectData.DataName2</Name>
				<Type>String</Type>
			</Parameter>
			<LocalVariables>
				<Name>CompareObjectData.BoolDataIsEqual</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CompareObjectData.BoolDataIs0</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CompareObjectData.BoolIsGap</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CompareObjectData.EntryName</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CompareObjectData.ListIndex</Name>
				<Type>Int32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CompareObjectData.SubIndex</Name>
				<Type>Byte</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CompareObjectData.Type</Name>
				<Type>UInt16</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CompareObjectData.BitSize</Name>
				<Type>Int32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CompareObjectData.BitOffset</Name>
				<Type>Int32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CompareObjectData.DefaultData</Name>
				<Type>ArrayOfBytes</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CompareObjectData.DefaultDataLength</Name>
				<Type>ArrayOfInt32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CompareObjectData.Skip</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CompareObjectData.ReadInPreOp</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CompareObjectData.ReadInSafeOp</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CompareObjectData.ReadInOp</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CompareObjectData.WriteInPreOp</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CompareObjectData.WriteInSafeOp</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CompareObjectData.WriteInOp</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CompareObjectData.EntryDataChanged</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CompareObjectData.EntryData1</Name>
				<Type>ArrayOfBytes</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CompareObjectData.EntryData2</Name>
				<Type>ArrayOfBytes</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CompareObjectData.SdoAccess</Name>
				<Type>String</Type>
			</LocalVariables>
			<TestStep Name="initEntryListIndex">
				<SetVariable Target="CompareObjectData.ListIndex">0</SetVariable>
			</TestStep>
			<TestStep Name="GetEntryDescription">
				<Description Id="0" Level="Verbose" Param0="CompareObjectData.Index" Param1="CompareObjectData.ListIndex">Test Function 'CompareObjectData': 0x{0:X4} Requesting Entry description (list index {1}) ...</Description>
				<GetObjectDescriptionFromList ListIndex="CompareObjectData.ListIndex" Source="CompareObjectData.Entries">
					<SubIdx>CompareObjectData.SubIndex</SubIdx>
					<Name>CompareObjectData.EntryName</Name>
					<Type>CompareObjectData.Type</Type>
					<BitSize>CompareObjectData.BitSize</BitSize>
					<BitOffs>CompareObjectData.BitOffset</BitOffs>
					<DefaultData>CompareObjectData.DefaultData</DefaultData>
					<Flags>
						<Access ReadInPreop="CompareObjectData.ReadInPreOp" ReadInSafeOP="CompareObjectData.ReadInSafeOp" ReadInOP="CompareObjectData.ReadInOp" WriteInPreOp="CompareObjectData.WriteInPreOp" WriteinOP="CompareObjectData.WriteInOp" WriteInSafeOp="CompareObjectData.WriteInSafeOp">CompareObjectData.SdoAccess</Access>
					</Flags>
					<ExcludeFromTest>CompareObjectData.Skip</ExcludeFromTest>
				</GetObjectDescriptionFromList>
				<RaiseErrorOnFailure Id="1" Param0="CompareObjectData.Index" Param1="CompareObjectData.ListIndex">Test Function 'CompareObjectData': 0x{0:X4} Failed to get entry description list index {1}</RaiseErrorOnFailure>
				<WriteLine Id="2" Level="Verbose" Param0="CompareObjectData.DefaultData" Param1="CompareObjectData.Index" Param2="CompareObjectData.SubIndex" Param3="CompareObjectData.EntryName">Test Function 'CompareObjectData': 0x{1:X4}:{2:X}: Entry description('{3}', Default Data: {0}</WriteLine>
				<WriteLine Id="3" Level="Verbose" Param0="CompareObjectData.BitSize" Param1="CompareObjectData.BitOffset">BitSize: {0} BitOffset: {1})</WriteLine>
			</TestStep>
			<TestStep Name="SwitchState">
				<Compare>
					<Equal>
						<Value1>CompareObjectData.StringState</Value1>
						<Value2>"None"</Value2>
						<GotoStep>CheckIfSkipped</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CompareObjectData.StringState</Value1>
						<Value2>"PreOp"</Value2>
						<GotoStep>CheckPreOpAccess</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CompareObjectData.StringState</Value1>
						<Value2>"SafeOp"</Value2>
						<GotoStep>CheckSafeOpAccess</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CompareObjectData.StringState</Value1>
						<Value2>"Op"</Value2>
						<GotoStep>CheckOpAccess</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CheckPreOpAccess">
				<Compare>
					<Equal>
						<Value1>CompareObjectData.ReadInPreOp AND CompareObjectData.WriteInPreOp</Value1>
						<Value2>true</Value2>
						<GotoStep>CheckIfSkipped</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CompareObjectData.ReadInPreOp AND CompareObjectData.WriteInPreOp</Value1>
						<Value2>false</Value2>
						<WriteLine Id="4" Level="Verbose" Param0="CompareObjectData.Index" Param1="CompareObjectData.SubIndex">Test Function 'CompareObjectData': 0x{0:X4}:{1:X} Entry skipped, because only RW entries are checked.</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CompareObjectData.ReadInPreOp AND CompareObjectData.WriteInPreOp</Value1>
						<Value2>false</Value2>
						<GotoStep>incrementEntryIndex</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CheckSafeOpAccess">
				<Compare>
					<Equal>
						<Value1>CompareObjectData.ReadInSafeOp AND CompareObjectData.WriteInSafeOp</Value1>
						<Value2>true</Value2>
						<GotoStep>CheckIfSkipped</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CompareObjectData.ReadInSafeOp AND CompareObjectData.WriteInSafeOp</Value1>
						<Value2>false</Value2>
						<WriteLine Id="5" Level="Verbose" Param0="CompareObjectData.Index" Param1="CompareObjectData.SubIndex">Test Function 'CompareObjectData': 0x{0:X4}:{1:X} Entry skipped, because only RW entries are checked.</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CompareObjectData.ReadInSafeOp AND CompareObjectData.WriteInSafeOp</Value1>
						<Value2>false</Value2>
						<GotoStep>incrementEntryIndex</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CheckOpAccess">
				<Compare>
					<Equal>
						<Value1>CompareObjectData.ReadInPreOp AND CompareObjectData.WriteInPreOp</Value1>
						<Value2>true</Value2>
						<GotoStep>CheckIfSkipped</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CompareObjectData.ReadInOp AND CompareObjectData.WriteInOp</Value1>
						<Value2>false</Value2>
						<WriteLine Id="6" Level="Verbose" Param0="CompareObjectData.Index" Param1="CompareObjectData.SubIndex">Test Function 'CompareObjectData': 0x{0:X4}:{1:X} Entry skipped, because only RW entries are checked.</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CompareObjectData.ReadInOp AND CompareObjectData.WriteInOp</Value1>
						<Value2>false</Value2>
						<GotoStep>incrementEntryIndex</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CheckIfSkipped">
				<Compare>
					<Equal>
						<Value1>CompareObjectData.Skip</Value1>
						<Value2>true</Value2>
						<WriteLine Id="7" Level="Output" Param0="CompareObjectData.Index" Param1="CompareObjectData.SubIndex">Test Function 'CompareObjectData': 0x{0:X4}:{1:X} Entry skipped by user.</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CompareObjectData.Skip</Value1>
						<Value2>true</Value2>
						<GotoStep>incrementEntryIndex</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="initIsEqual">
				<SetVariable Target="CompareObjectData.BoolDataIsEqual">false</SetVariable>
			</TestStep>
			<TestStep Name="initIsGap">
				<SetVariable Target="CompareObjectData.BoolIsGap">false</SetVariable>
			</TestStep>
			<TestStep Name="CheckForGap">
				<Description Id="8" Level="Verbose" Param2="CompareObjectData.EntryName" Param1="CompareObjectData.SubIndex" Param0="CompareObjectData.Index">Test Function 'CompareObjectData': 0x{0:X4}:{1:X} '{2}': Checking data type...</Description>
				<Compare>
					<Equal>
						<Value1>CompareObjectData.Type</Value1>
						<Value2>0</Value2>
						<WriteLine Id="9" Param0="CompareObjectData.Index" Param1="CompareObjectData.SubIndex" Level="Verbose">Test Function 'CompareObjectData': 0x{0:X4}:{1:X} Gap entry detected because data type is 0. The data comparison of this entry data should be 0.</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CompareObjectData.Type</Value1>
						<Value2>0</Value2>
						<SetVariable Target="CompareObjectData.BoolIsGap">true</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CheckForDefaultData">
				<Description Id="10" Level="Verbose" Param2="CompareObjectData.EntryName" Param1="CompareObjectData.SubIndex" Param0="CompareObjectData.Index" Param3="CompareObjectData.DefaultData">Test Function 'CompareObjectData': 0x{0:X4}:{1:X} '{2}': Checking for default data...</Description>
				<SizeOf UInt32Var="CompareObjectData.DefaultDataLength">CompareObjectData.DefaultData</SizeOf>
				<Compare>
					<NotEqual>
						<Value1>CompareObjectData.DefaultDataLength</Value1>
						<Value2>0</Value2>
						<WriteLine Id="11" Param0="CompareObjectData.Index" Param1="CompareObjectData.SubIndex" Param2="CompareObjectData.DefaultDataLength" Level="Verbose">Test Function 'CompareObjectData': 0x{0:X4}:{1:X} Entry description provides default data. The data comparison of this entry will be done and throws an error in case of a not matching data segment.</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CompareObjectData.DefaultDataLength</Value1>
						<Value2>0</Value2>
						<WriteLine Id="12" Param0="CompareObjectData.Index" Param1="CompareObjectData.SubIndex" Param2="CompareObjectData.DefaultDataLength" Level="Verbose">Test Function 'CompareObjectData': 0x{0:X4}:{1:X} Entry description does not  provide default data. The data comparison of this entry will lead to an Warning if the comparison fails.</WriteLine>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CheckSubIndex1BitOffset">
				<Compare>
					<NotEqual>
						<Value1>CompareObjectData.SubIndex</Value1>
						<Value2>1</Value2>
						<GotoStep>initDataSegment1</GotoStep>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CompareObjectData.BitOffset</Value1>
						<Value2>16</Value2>
						<RaiseError Id="13" Param0="CompareObjectData.BitOffset" Param1="CompareObjectData.Index" Param2="CompareObjectData.Name">Test Function 'CompareObjectData':{2} 0x{1:X4}:1: Unexpected BitOffset ({0}) found at the entry description (expected offset = 16)</RaiseError>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="initDataSegment1">
				<InitArray Length="(CompareObjectData.BitSize+7)/8" TargetArray="CompareObjectData.EntryData1"></InitArray>
			</TestStep>
			<TestStep Name="initDataSegment2">
				<InitArray Length="(CompareObjectData.BitSize+7)/8" TargetArray="CompareObjectData.EntryData2"></InitArray>
			</TestStep>
			<TestStep Name="CopyDataBitwise1">
				<GetBits Source="CompareObjectData.Data1" Target="CompareObjectData.EntryData1">
					<Offset>CompareObjectData.BitOffset</Offset>
					<Length>CompareObjectData.BitSize</Length>
				</GetBits>
				<WriteLine Id="14" Level="Verbose" Param0="CompareObjectData.EntryData1" Param1="CompareObjectData.BitOffset" Param2="CompareObjectData.BitSize">Data1 (BitOffset {1}, BitSize {2}) ==&gt; {0}</WriteLine>
			</TestStep>
			<TestStep Name="CopyDataBitwise2">
				<GetBits Source="CompareObjectData.Data2" Target="CompareObjectData.EntryData2">
					<Offset>CompareObjectData.BitOffset</Offset>
					<Length>CompareObjectData.BitSize</Length>
				</GetBits>
				<WriteLine Id="15" Level="Verbose" Param0="CompareObjectData.EntryData2" Param1="CompareObjectData.BitOffset" Param2="CompareObjectData.BitSize">Data2 (BitOffset {1}, BitSize {2}) ==&gt; {0}</WriteLine>
			</TestStep>
			<TestStep Name="CompareData">
				<Description Id="16" Level="Verbose" Param0="CompareObjectData.Index" Param1="CompareObjectData.SubIndex" Param2="CompareObjectData.BitSize" Param3="CompareObjectData.BitOffset">Test Function 'CompareObjectData': 0x{0:X4}:{1:X}: Comparing data (BitOffset = {3}, BitSize = {2}) bit wise...</Description>
				<Compare>
					<Equal>
						<Value1>CompareObjectData.EntryData1</Value1>
						<Value2>CompareObjectData.EntryData2</Value2>
						<SetVariable Target="CompareObjectData.BoolDataIsEqual">true</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CompareObjectData.BoolIsGap</Value1>
						<Value2>true</Value2>
						<GotoStep>ThrowErrorIfGapDataNot0</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CompareObjectData.BoolDataIsEqual</Value1>
						<Value2>false</Value2>
						<GotoStep>ThrowErrorIfNoDefault</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CompareObjectData.BoolDataIsEqual</Value1>
						<Value2>true</Value2>
						<WriteLine Id="17" Level="Verbose" Param0="CompareObjectData.Index" Param1="CompareObjectData.SubIndex" Param2="CompareObjectData.DataName1" Param3="CompareObjectData.DataName2">Test Function 'CompareObjectData': 0x{0:X4}:{1:X} {2} is equivalent to {3} </WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CompareObjectData.BoolDataIsEqual</Value1>
						<Value2>true</Value2>
						<GotoStep>incrementEntryIndex</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="ThrowErrorIfGapDataNot0">
				<Compare>
					<Equal>
						<Value1>CompareObjectData.BoolIsGap</Value1>
						<Value2>true</Value2>
						<CallTestFunction Name="CheckDataIs0">
							<Parameter>CompareObjectData.EntryData1</Parameter>
							<OutParameter>CompareObjectData.BoolDataIs0</OutParameter>
						</CallTestFunction>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CompareObjectData.BoolDataIs0</Value1>
						<Value2>false</Value2>
						<RaiseError Id="18" Param0="CompareObjectData.Index" Param1="CompareObjectData.SubIndex" Param2="CompareObjectData.EntryData1" Param3="CompareObjectData.DataName1">Test Function 'CompareObjectData': 0x{0:X4}:{1:X} {3} ({2}) shall be 0 because it is a padding entry.</RaiseError>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CompareObjectData.BoolIsGap</Value1>
						<Value2>true</Value2>
						<CallTestFunction Name="CheckDataIs0">
							<Parameter>CompareObjectData.EntryData2</Parameter>
							<OutParameter>CompareObjectData.BoolDataIs0</OutParameter>
						</CallTestFunction>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CompareObjectData.BoolDataIs0</Value1>
						<Value2>false</Value2>
						<RaiseError Id="19" Param0="CompareObjectData.Index" Param1="CompareObjectData.SubIndex" Param2="CompareObjectData.EntryData2" Param3="CompareObjectData.DataName2">Test Function 'CompareObjectData': 0x{0:X4}:{1:X} {3} ({2})  shall be 0 because it is a padding entry.</RaiseError>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>0</Value1>
						<Value2>0</Value2>
						<GotoStep>incrementEntryIndex</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="ThrowErrorIfNoDefault">
				<Compare>
					<NotEqual>
						<Value1>CompareObjectData.DefaultDataLength</Value1>
						<Value2>0</Value2>
						<RaiseError Id="20" Param0="CompareObjectData.Index" Param1="CompareObjectData.SubIndex" Param2="CompareObjectData.DataName1" Param3="CompareObjectData.DataName2">Test Function 'CompareObjectData': 0x{0:X4}:{1:X} {2} is dfferent to {3}, although the entry description provides default data</RaiseError>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CompareObjectData.DefaultDataLength</Value1>
						<Value2>0</Value2>
						<CallTestFunction Name="VerifyData">
							<Parameter>CompareObjectData.Index</Parameter>
							<Parameter>CompareObjectData.SubIndex</Parameter>
							<Parameter>CompareObjectData.BitSize</Parameter>
							<OutParameter>CompareObjectData.EntryDataChanged</OutParameter>
						</CallTestFunction>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CompareObjectData.EntryDataChanged</Value1>
						<Value2>false</Value2>
						<RaiseWarning Id="21" Param0="CompareObjectData.Index" Param1="CompareObjectData.SubIndex" Param2="CompareObjectData.DataName1" Param3="CompareObjectData.DataName2">Test Function 'CompareObjectData': 0x{0:X4}:{1:X} {2} is dfferent to {3}. The entry data may change because the entry description provides no default data. But the single access upload of this entry is ten times in the same value.</RaiseWarning>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>0</Value1>
						<Value2>0</Value2>
						<GotoStep>incrementEntryIndex</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="incrementEntryIndex">
				<SetVariable Target="CompareObjectData.ListIndex">CompareObjectData.ListIndex+1</SetVariable>
				<Compare>
					<Lower>
						<Value1>CompareObjectData.SubIndex</Value1>
						<Value2>CompareObjectData.SI0Data</Value2>
						<GotoStep>GetEntryDescription</GotoStep>
					</Lower>
				</Compare>
			</TestStep>
			<TestStep Name="end">
				<WriteLine Id="22" Level="Output" Param0="CompareObjectData.ListIndex" Param1="CompareObjectData.Index" Param2="CompareObjectData.Name ">Test Function 'CompareObjectData': 0x{1:X4} '{2}': {0} entries compared.</WriteLine>
			</TestStep>
		</TestFunction>
		<TestFunction Name="GetCurrentObjectLength" FunctionId="401">
			<?MAX_OUTPUT_ID 8?>
			<Parameter>
				<Name>GetCurrentObjectLength.Index</Name>
				<Type>UInt16</Type>
			</Parameter>
			<Parameter>
				<Name>GetCurrentObjectLength.BitSize</Name>
				<Type>Int32</Type>
			</Parameter>
			<Parameter>
				<Name>GetCurrentObjectLength.Name</Name>
				<Type>String</Type>
			</Parameter>
			<Parameter>
				<Name>GetCurrentObjectLength.MaxSubIndex</Name>
				<Type>Byte</Type>
			</Parameter>
			<Parameter>
				<Name>GetCurrentObjectLength.SI0Data</Name>
				<Type>Byte</Type>
			</Parameter>
			<LocalVariables>
				<Name>GetCurrentObjectLength.SdoAccess</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>GetCurrentObjectLength.AbortCode</Name>
				<Type>UInt32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>GetCurrentObjectLength.AbortMessage</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>GetCurrentObjectLength.LastEntryBitSize</Name>
				<Type>Int32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>GetCurrentObjectLength.LastEntryBitOffset</Name>
				<Type>Int32</Type>
			</LocalVariables>
			<OutParameter>
				<Name>GetCurrentObjectLength.ObjectByteLength</Name>
				<Type>Int32</Type>
			</OutParameter>
			<TestStep Name="CheckLengthParameter">
				<Compare>
					<Equal>
						<Value1>GetCurrentObjectLength.SI0Data</Value1>
						<Value2>0</Value2>
						<GotoStep>SetLengthForEmptyObject</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>stringCurrentDictionaryType</Value1>
						<Value2>"online"</Value2>
						<GotoStep>GetLastEntryDescription</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Greater>
						<Value1>GetCurrentObjectLength.SI0Data</Value1>
						<Value2>GetCurrentObjectLength.MaxSubIndex</Value2>
						<GotoStep>SetCurrentByteLengthByObjectBitSize</GotoStep>
					</Greater>
				</Compare>
			</TestStep>
			<TestStep Name="GetLastEntryDescription">
				<Description Id="0" Level="Verbose" Param0="GetCurrentObjectLength.Index" Param1="GetCurrentObjectLength.SI0Data">Test Function 'GetCurrentObjectLength': 0x{0:X4} Requesting entry description  of max SubIndex '{1}' ...</Description>
				<GetObjectDescription Index="GetCurrentObjectLength.Index" SourceDictionary="sourceDictionary" SubIndex="GetCurrentObjectLength.SI0Data">
					<BitSize>GetCurrentObjectLength.LastEntryBitSize</BitSize>
					<BitOffs>GetCurrentObjectLength.LastEntryBitOffset</BitOffs>
				</GetObjectDescription>
				<RaiseErrorOnFailure Id="1" Param0="GetCurrentObjectLength.Index" Param1="GetCurrentObjectLength.SI0Data">Test Function 'GetCurrentObjectLength': 0x{0:X4} Failed to get max entry description SubIndex {1}</RaiseErrorOnFailure>
				<WriteLine Id="2" Param0="GetCurrentObjectLength.LastEntryBitSize" Level="Verbose" Param1="GetCurrentObjectLength.LastEntryBitOffset">Test Function 'GetCurrentObjectLength': BitSize: {0};BitOffset: {1}</WriteLine>
			</TestStep>
			<TestStep Name="SetCurrentByteLengthByLastEntry">
				<Description Id="3" Level="Verbose" Param2="GetCurrentObjectLength.Name" Param1="GetCurrentObjectLength.SI0Data" Param0="GetCurrentObjectLength.Index">Test Function 'GetCurrentObjectLength': 0x{0:X4}:{1:X} '{2}': Calculating current object size using bit offset and bit length of the current max SubIndex...</Description>
				<SetVariable Target="GetCurrentObjectLength.ObjectByteLength">(GetCurrentObjectLength.LastEntryBitOffset+GetCurrentObjectLength.LastEntryBitSize+7)/8</SetVariable>
				<Compare>
					<Equal>
						<Value1>0</Value1>
						<Value2>0</Value2>
						<Return Id="4" Param0="GetCurrentObjectLength.ObjectByteLength">Test Function 'GetCurrentObjectLength': Current object byte length: {0}</Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="SetCurrentByteLengthByObjectBitSize">
				<Description Id="5" Level="Output" Param2="GetCurrentObjectLength.Name" Param1="GetCurrentObjectLength.SI0Data" Param0="GetCurrentObjectLength.Index" Param3="GetCurrentObjectLength.MaxSubIndex">Test Function 'GetCurrentObjectLength': 0x{0:X4}: '{2}': Setting current object size to the objects bit size of the offline description. Because the current max SubIndex '{1}' exceeds the number of offline entry descriptions '{3}' of the offline dictionary...</Description>
				<SetVariable Target="GetCurrentObjectLength.ObjectByteLength">GetCurrentObjectLength.BitSize/8</SetVariable>
				<Compare>
					<Equal>
						<Value1>0</Value1>
						<Value2>0</Value2>
						<Return Id="6" Param0="GetCurrentObjectLength.ObjectByteLength">Test Function 'GetCurrentObjectLength': Current object byte length: {0}</Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="SetLengthForEmptyObject">
				<Description Id="7" Level="Output" Param1="GetCurrentObjectLength.Name" Param0="GetCurrentObjectLength.Index">Test Function 'GetCurrentObjectLength': 0x{0:X4}: '{1}': Setting current object size to 2 bytes (current max SubIndex is 0)...</Description>
				<SetVariable Target="GetCurrentObjectLength.ObjectByteLength">2</SetVariable>
				<WriteLine Id="8" Level="Verbose" Param0="GetCurrentObjectLength.ObjectByteLength">Test Function 'GetCurrentObjectLength': Current object byte length: {0}</WriteLine>
			</TestStep>
		</TestFunction>
		<TestFunction Name="InitMailbox" FunctionId="501">
			<?MAX_OUTPUT_ID 0?>
			<TestStep>
				<CallTestFunction Name="SetStateMachTimeouts"></CallTestFunction>
			</TestStep>
			<TestStep>
				<CallTestFunction Name="Reset"></CallTestFunction>
				<RaiseErrorOnFailure Id="0">Reset test function failed</RaiseErrorOnFailure>
			</TestStep>
		</TestFunction>
		<TestFunction Name="SetStateMachTimeouts" FunctionId="601">
			<?MAX_OUTPUT_ID 1?>
			<TestStep>
				<SetVariable Target="r.preOPTimeout">3000</SetVariable>
			</TestStep>
			<TestStep>
				<SetVariable Target="r.safeOPTimeout">10000</SetVariable>
			</TestStep>
			<TestStep>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Info</Value1>
						<Value2>false</Value2>
						<Return Id="0"></Return>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Info.StateMachine.Timeout</Value1>
						<Value2>false</Value2>
						<Return Id="1"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<SetVariable Target="r.preOPTimeout">DeviceDescr.Info.StateMachine.Timeout.PreopTimeout</SetVariable>
			</TestStep>
			<TestStep>
				<SetVariable Target="r.safeOPTimeout">DeviceDescr.Info.StateMachine.Timeout.SafeopOpTimeout</SetVariable>
			</TestStep>
		</TestFunction>
		<TestFunction Name="UploadCompleteAccess" FunctionId="602">
			<?MAX_OUTPUT_ID 15?>
			<Parameter>
				<Name>UploadCompleteAccess.Index</Name>
				<Type>UInt16</Type>
				<Comment>The objects index</Comment>
			</Parameter>
			<Parameter>
				<Name>UploadCompleteAccess.BitSize</Name>
				<Type>Int32</Type>
				<Comment>The bit size of the object description</Comment>
			</Parameter>
			<Parameter>
				<Name>UploadCompleteAccess.Si0Value</Name>
				<Type>Byte</Type>
				<Comment>From this value starts the complete access</Comment>
			</Parameter>
			<Parameter>
				<Name>UploadCompleteAccess.Name</Name>
				<Type>String</Type>
			</Parameter>
			<Parameter>
				<Name>UploadCompleteAccess.ObjectCurrentByteLength</Name>
				<Type>Int32</Type>
				<Comment>Value that holds the current object length calculated by the current max subIndex and the entry description of that entry.</Comment>
			</Parameter>
			<LocalVariables>
				<Name>UploadCompleteAccess.AbortCode</Name>
				<Type>UInt32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>UploadCompleteAccess.AbortMessage</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>UploadCompleteAccess.Data.Length</Name>
				<Type>Int32</Type>
			</LocalVariables>
			<OutParameter>
				<Name>UploadCompleteAccess.Data</Name>
				<Type>ArrayOfBytes</Type>
			</OutParameter>
			<TestStep Name="checkParameter">
				<Compare>
					<Equal>
						<Value1>UploadCompleteAccess.Index</Value1>
						<Value2>0</Value2>
						<RaiseError Id="0">0 is not a valid value for the object index</RaiseError>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>UploadCompleteAccess.BitSize</Value1>
						<Value2>0</Value2>
						<RaiseError Id="1">0 is not a valid value for the object bit size</RaiseError>
					</Equal>
				</Compare>
				<Compare>
					<Greater>
						<Value1>UploadCompleteAccess.Si0Value</Value1>
						<Value2>1</Value2>
						<RaiseError Id="2">Invalid SI0 value for Complete Access</RaiseError>
					</Greater>
				</Compare>
			</TestStep>
			<TestStep Name="initVars">
				<SetVariable Target="object.completeAccessAbort">false</SetVariable>
			</TestStep>
			<TestStep Name="InitArray">
				<InitArray Length="0" TargetArray="UploadCompleteAccess.Data"></InitArray>
			</TestStep>
			<TestStep Name="UploadSDO">
				<Description Id="3" Level="Verbose" Param0="UploadCompleteAccess.Index" Param1="UploadCompleteAccess.Si0Value">Test Function: UploadCompleteAccessData: 0x{0:X4} Uploading complete access data of SI{1}</Description>
				<UploadCoEObject>
					<Index>UploadCompleteAccess.Index</Index>
					<SubIndex>UploadCompleteAccess.Si0Value</SubIndex>
					<DataVar>UploadCompleteAccess.Data</DataVar>
					<BitLen>UploadCompleteAccess.BitSize</BitLen>
					<AbortCode>UploadCompleteAccess.AbortCode</AbortCode>
					<AbortMessage>UploadCompleteAccess.AbortMessage</AbortMessage>
					<CompleteAccess>true</CompleteAccess>
				</UploadCoEObject>
				<RaiseErrorOnFailure Id="4" Param0="UploadCompleteAccess.Index" Param1="UploadCompleteAccess.Name" Param2="UploadCompleteAccess.Si0Value">Test Function 'UploadCompleteAccess': 0x{1:X4} '{0}' Failed to upload SDO with Complete Access starting at subIndex {2}</RaiseErrorOnFailure>
				<WriteLine Id="5" Level="Output" Param1="UploadCompleteAccess.Index" Param0="UploadCompleteAccess.Name" Param2="UploadCompleteAccess.Data" Param3="UploadCompleteAccess.Si0Value">Test Function 'UploadCompleteAccess': 0x{1:X4}:{3:X} '{0}':  Complete Access data {2}</WriteLine>
				<Compare>
					<NotEqual>
						<Value1>UploadCompleteAccess.AbortMessage</Value1>
						<Value2>EmptyString</Value2>
						<RaiseError Id="6" Param0="UploadCompleteAccess.Index" Param1="UploadCompleteAccess.AbortMessage" Param2="UploadCompleteAccess.Name">Test Function 'UploadCompleteAccess': '{2}' 0x{0:X4}:0 Serious error while uploading {1} </RaiseError>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>UploadCompleteAccess.AbortCode</Value1>
						<Value2>#x06010000</Value2>
						<WriteLine Id="7" Param0="UploadCompleteAccess.Index" Param1="UploadCompleteAccess.Name">0x{0:X4} '{1}' SDO Complete Access upload failed. Allowed Abort Code 0x06010000 (Unsupported Access) received.</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>UploadCompleteAccess.AbortCode</Value1>
						<Value2>#x06010000</Value2>
						<GotoStep>AllowedAbort</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>UploadCompleteAccess.AbortCode</Value1>
						<Value2>#x06010004</Value2>
						<WriteLine Id="8" Param0="UploadCompleteAccess.Index" Param1="UploadCompleteAccess.Name">0x{0:X4} '{1}' SDO Complete Access upload failed. Allowed Abort Code 0x06010004 (Unsupported Complete Access) received.</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>UploadCompleteAccess.AbortCode</Value1>
						<Value2>#x06010004</Value2>
						<GotoStep>AllowedAbort</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>UploadCompleteAccess.AbortCode</Value1>
						<Value2>#x08000021</Value2>
						<WriteLine Id="9" Param0="UploadCompleteAccess.Name" Param1="UploadCompleteAccess.Index" Param2="SI0Value" Level="Output">TestFunction 'UploadCompleteAccess': '{0}' 0x{1:X4}:{2:X}: Allowed abort code (0x08000021 Data cannot be transferred or stored to the application because of local control) received.</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>UploadCompleteAccess.AbortCode</Value1>
						<Value2>#x08000021</Value2>
						<GotoStep>AllowedAbort</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>UploadCompleteAccess.AbortCode</Value1>
						<Value2>0</Value2>
						<RaiseError Id="10" Param0="UploadCompleteAccess.Name" Param1="UploadCompleteAccess.Index" Param2="UploadCompleteAccess.AbortCode">0x{1:X4} '{0}': SDO Complete Access upload failed. The received  Abort Code (0x{2:X8}) was not expected.</RaiseError>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="GetResponseDataLength">
				<SizeOf UInt32Var="UploadCompleteAccess.Data.Length">UploadCompleteAccess.Data</SizeOf>
			</TestStep>
			<TestStep Name="CheckReceivedByteLength">
				<Compare>
					<Greater>
						<Value1>UploadCompleteAccess.Data.Length*8</Value1>
						<Value2>UploadCompleteAccess.BitSize-UploadCompleteAccess.Si0Value*16</Value2>
						<RaiseError Id="11" Param0="UploadCompleteAccess.Data.Length*8" Param1="UploadCompleteAccess.BitSize" Param3="UploadCompleteAccess.Index" Param2="UploadCompleteAccess.Si0Value">Test Function 'UploadCompleteAccess': 0x{3:X4} The received bit length ({0}) of the CA SI{2} exceeds the bit length of the object description ({1}). </RaiseError>
					</Greater>
				</Compare>
				<Compare>
					<Equal>
						<Value1>UploadCompleteAccess.Data.Length+UploadCompleteAccess.Si0Value*2</Value1>
						<Value2>UploadCompleteAccess.ObjectCurrentByteLength</Value2>
						<WriteLine Id="12" Param0="UploadCompleteAccess.Index" Param1="UploadCompleteAccess.Data.Length+UploadCompleteAccess.Si0Value*2" Param2="UploadCompleteAccess.ObjectCurrentByteLength" Level="Verbose">Test Function 'UploadCompleteAccess': 0x{0:X4}: Comparison of the current object ByteLength of the object description (MaxSubIndex) ({2}) and the actual received Complete Access SI0 data bytes ({1}) succeeded</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>UploadCompleteAccess.Data.Length+UploadCompleteAccess.Si0Value*2</Value1>
						<Value2>UploadCompleteAccess.ObjectCurrentByteLength</Value2>
						<GotoStep>End</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>UploadCompleteAccess.Data.Length*8</Value1>
						<Value2>UploadCompleteAccess.BitSize-UploadCompleteAccess.Si0Value*16</Value2>
						<WriteLine Id="13" Param0="UploadCompleteAccess.Index" Param1="UploadCompleteAccess.Data.Length" Param2="UploadCompleteAccess.BitSize" Level="Verbose">Test Function 'UploadCompleteAccess': 0x{0:X4}: Comparison of BitSize of the object description ({2}) and the actual received Complete Access SI0 data bytes ({1}) succeeded</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>UploadCompleteAccess.Data.Length*8</Value1>
						<Value2>UploadCompleteAccess.BitSize-UploadCompleteAccess.Si0Value*16</Value2>
						<GotoStep>End</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>0</Value1>
						<Value2>0</Value2>
						<RaiseError Id="14" Param0="UploadCompleteAccess.Index" Param1="UploadCompleteAccess.Data.Length" Param2="UploadCompleteAccess.BitSize" Param3="UploadCompleteAccess.ObjectCurrentByteLength">Test Function 'UploadCompleteAccess': 0x{0:X4}: The length of the received CA bytes ({1}) is different to the BitSize of the object description ({2}) and the current object byte length {3}.</RaiseError>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="AllowedAbort">
				<SetVariable Target="object.completeAccessAbort">true</SetVariable>
				<Compare>
					<Equal>
						<Value1>0</Value1>
						<Value2>0</Value2>
						<Return Id="15"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="End"></TestStep>
		</TestFunction>
		<TestFunction Name="CheckDataIs0" FunctionId="701">
			<Parameter>
				<Name>CheckDataIs0.BaData</Name>
				<Type>ArrayOfBytes</Type>
			</Parameter>
			<LocalVariables>
				<Name>CheckDataIs0.Ba0Array</Name>
				<Type>ArrayOfBytes</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckDataIs0.Int32Length</Name>
				<Type>ArrayOfBytes</Type>
			</LocalVariables>
			<OutParameter>
				<Name>CheckDataIs0.BoolIs0</Name>
				<Type>Bool</Type>
			</OutParameter>
			<TestStep Name="InitLength">
				<SizeOf UInt32Var="CheckDataIs0.Int32Length">CheckDataIs0.BaData</SizeOf>
			</TestStep>
			<TestStep Name="InitReturnValue">
				<SetVariable Target="CheckDataIs0.BoolIs0">false</SetVariable>
			</TestStep>
			<TestStep Name="InitCompareArray">
				<InitArray Length="CheckDataIs0.Int32Length" TargetArray="CheckDataIs0.Ba0Array"></InitArray>
			</TestStep>
			<TestStep Name="CompareData">
				<Compare>
					<Equal>
						<Value1>CheckDataIs0.Ba0Array</Value1>
						<Value2>CheckDataIs0.BaData</Value2>
						<SetVariable Target="CheckDataIs0.BoolIs0">true</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction Name="VerifyData" FunctionId="801">
			<?MAX_OUTPUT_ID 12?>
			<Description>
				<PreCondition>Mailbox CoE support</PreCondition>
				<Action>Executes 10 SDO Uploads </Action>
				<PostCondition>Returns true if the uploaded data remains unchanged, otherwise false.</PostCondition>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>VerifyData.UInt16Index</Name>
				<Type>UInt16</Type>
			</Parameter>
			<Parameter>
				<Name>VerifyData.ByteSubIndex</Name>
				<Type>Byte</Type>
			</Parameter>
			<Parameter>
				<Name>VerifyData.Int32BitLen</Name>
				<Type>Int32</Type>
			</Parameter>
			<LocalVariables>
				<Name>VerifyData.ByteArraySource</Name>
				<Type>ArrayOfBytes</Type>
				<Comment>Source Data to compare to</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>VerifyData.ByteArrayUploaded</Name>
				<Type>ArrayOfBytes</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>VerifyData.UInt16AbortCode</Name>
				<Type>UInt16</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>VerifyData.AbortMessage</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>VerifyData.Count</Name>
				<Type>Int32</Type>
			</LocalVariables>
			<OutParameter>
				<Name>VerifyData.BoolHasChanged</Name>
				<Type>Bool</Type>
			</OutParameter>
			<TestStep Name="uploadSingleAccess1" Delay="100">
				<UploadCoEObject>
					<Index>VerifyData.UInt16Index</Index>
					<SubIndex>VerifyData.ByteSubIndex</SubIndex>
					<DataVar>VerifyData.ByteArraySource</DataVar>
					<BitLen>VerifyData.Int32BitLen</BitLen>
					<AbortCode>VerifyData.UInt16AbortCode</AbortCode>
					<AbortMessage>VerifyData.AbortMessage</AbortMessage>
				</UploadCoEObject>
				<WriteLine Id="0" Level="Verbose" Param0="VerifyData.UInt16Index" Param1="VerifyData.ByteSubIndex" Param2="VerifyData.ByteArraySource">Test Function 'VerifyData': 0x{0:X4}:{1:X} Single access data: {2}</WriteLine>
				<Compare>
					<NotEqual>
						<Value1>VerifyData.AbortMessage</Value1>
						<Value2>EmptyString</Value2>
						<RaiseError Id="1" Param0="VerifyData.UInt16Index" Param1="VerifyData.ByteSubIndex" Param2="VerifyData.AbortMessage">TestFunction 'VerifyData': 0x{0:X4}:{1:X} SDO upload failed. {2}</RaiseError>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyData.UInt16AbortCode</Value1>
						<Value2>#x06090011</Value2>
						<WriteLine Id="2" Param0="VerifyData.UInt16Index" Param1="VerifyData.ByteSubIndex" Level="Output">TestFunction 'VerifyData': 0x{0:X4}:{1:X}: Allowed Abort code (0x06090011 SubIndex does not exist) received. This entry will be skipped.</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyData.UInt16AbortCode</Value1>
						<Value2>#x06090011</Value2>
						<GotoStep>ReturnTrue</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyData.UInt16AbortCode</Value1>
						<Value2>#x08000021</Value2>
						<WriteLine Id="3" Param0="VerifyData.UInt16Index" Param1="VerifyData.ByteSubIndex" Level="Output">TestFunction 'VerifyData': 0x{0:X4}:{1:X}: Allowed abort code (0x08000021 Data cannot be transferred or stored to the application because of local control) received. This entry will be skipped.</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyData.UInt16AbortCode</Value1>
						<Value2>#x08000021</Value2>
						<GotoStep>ReturnTrue</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyData.UInt16AbortCode</Value1>
						<Value2>#x06010001</Value2>
						<WriteLine Id="4" Param0="VerifyData.UInt16Index" Param1="VerifyData.ByteSubIndex" Level="Output">TestFunction 'VerifyData': 0x{0:X4}:{1:X}: Allowed abort code (0x06010001 Attempt to read to a write only object) received. This entry will be skipped.</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyData.UInt16AbortCode</Value1>
						<Value2>#x06010001</Value2>
						<GotoStep>ReturnTrue</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>VerifyData.UInt16AbortCode</Value1>
						<Value2>0</Value2>
						<RaiseError Id="5" Param0="VerifyData.UInt16Index" Param1="VerifyData.ByteSubIndex" Param2="VerifyData.UInt16AbortCode">TestFunction 'VerifyData': 0x{0:X4}:{1:X}: Sdo upload failed. Unexpected abort code received 0x{2:X8}</RaiseError>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="uploadSingleAccess2" Delay="100">
				<UploadCoEObject>
					<Index>VerifyData.UInt16Index</Index>
					<SubIndex>VerifyData.ByteSubIndex</SubIndex>
					<DataVar>VerifyData.ByteArrayUploaded</DataVar>
					<BitLen>VerifyData.Int32BitLen</BitLen>
					<AbortCode>VerifyData.UInt16AbortCode</AbortCode>
					<AbortMessage>VerifyData.AbortMessage</AbortMessage>
				</UploadCoEObject>
				<WriteLine Id="6" Level="Verbose" Param0="VerifyData.UInt16Index" Param1="VerifyData.ByteSubIndex" Param2="VerifyData.ByteArrayUploaded">Test Function 'VerifyData': 0x{0:X4}:{1:X} Single access data: {2}</WriteLine>
				<Compare>
					<NotEqual>
						<Value1>VerifyData.AbortMessage</Value1>
						<Value2>EmptyString</Value2>
						<RaiseError Id="7" Param0="VerifyData.UInt16Index" Param1="VerifyData.ByteSubIndex" Param2="VerifyData.AbortMessage">TestFunction 'VerifyData': 0x{0:X4}:{1:X} SDO upload failed. {2}</RaiseError>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyData.UInt16AbortCode</Value1>
						<Value2>#x06090011</Value2>
						<WriteLine Id="8" Param0="VerifyData.UInt16Index" Param1="VerifyData.ByteSubIndex" Level="Output">TestFunction 'VerifyData': 0x{0:X4}:{1:X}: Allowed Abort code (0x06090011 SubIndex does not exist) received. This entry will be skipped.</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyData.UInt16AbortCode</Value1>
						<Value2>#x06090011</Value2>
						<GotoStep>ReturnTrue</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyData.UInt16AbortCode</Value1>
						<Value2>#x08000021</Value2>
						<WriteLine Id="9" Param0="VerifyData.UInt16Index" Param1="VerifyData.ByteSubIndex" Level="Output">TestFunction 'VerifyData': 0x{0:X4}:{1:X}: Allowed abort code (0x08000021 Data cannot be transferred or stored to the application because of local control) received. This entry will be skipped.</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyData.UInt16AbortCode</Value1>
						<Value2>#x08000021</Value2>
						<GotoStep>ReturnTrue</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyData.UInt16AbortCode</Value1>
						<Value2>#x06010001</Value2>
						<WriteLine Id="10" Param0="VerifyData.UInt16Index" Param1="VerifyData.ByteSubIndex" Level="Output">TestFunction 'VerifyData': 0x{0:X4}:{1:X}: Allowed abort code (0x06010001 Attempt to read to a write only object) received. This entry will be skipped.</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyData.UInt16AbortCode</Value1>
						<Value2>#x06010001</Value2>
						<GotoStep>ReturnTrue</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>VerifyData.UInt16AbortCode</Value1>
						<Value2>0</Value2>
						<RaiseError Id="11" Param0="VerifyData.UInt16Index" Param1="VerifyData.ByteSubIndex" Param2="VerifyData.UInt16AbortCode">TestFunction 'VerifyData': 0x{0:X4}:{1:X}: Sdo upload failed. Unexpected abort code received 0x{2:X8}</RaiseError>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="Compare">
				<Compare>
					<NotEqual>
						<Value1>VerifyData.ByteArraySource</Value1>
						<Value2>VerifyData.ByteArrayUploaded</Value2>
						<GotoStep>ReturnTrue</GotoStep>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="initExecutedCount">
				<SetVariable Target="VerifyData.Count">VerifyData.Count+1</SetVariable>
				<Compare>
					<Lower>
						<Value1>VerifyData.Count</Value1>
						<Value2>9</Value2>
						<GotoStep>uploadSingleAccess2</GotoStep>
					</Lower>
				</Compare>
			</TestStep>
			<TestStep Name="ReturnFalse">
				<Compare>
					<Equal>
						<Value1>0</Value1>
						<Value2>0</Value2>
						<SetVariable Target="VerifyData.BoolHasChanged">False</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>0</Value1>
						<Value2>0</Value2>
						<Return Id="12"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="ReturnTrue">
				<Compare>
					<Equal>
						<Value1>0</Value1>
						<Value2>0</Value2>
						<SetVariable Target="VerifyData.BoolHasChanged">True</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction Name="UploadSingleAccess" FunctionId="901">
			<?MAX_OUTPUT_ID 17?>
			<Parameter>
				<Name>UploadSingleAccess.Index</Name>
				<Type>UInt16</Type>
				<Comment>Index of the object</Comment>
			</Parameter>
			<Parameter>
				<Name>UploadSingleAccess.Entries</Name>
				<Type>ObjectList</Type>
				<Comment>All entry descriptions of the object</Comment>
			</Parameter>
			<Parameter>
				<Name>UploadSingleAccess.ObjectName</Name>
				<Type>String</Type>
				<Comment>Name of the object description</Comment>
			</Parameter>
			<Parameter>
				<Name>UploadSingleAccess.DataLength</Name>
				<Type>Int32</Type>
				<Comment>Complete object data length</Comment>
			</Parameter>
			<Parameter>
				<Name>UploadSingleAccess.SI0Data</Name>
				<Type>Byte</Type>
				<Comment>Uploaded value of SubIndex 0</Comment>
			</Parameter>
			<LocalVariables>
				<Name>UploadSingleAccess.ListIndex</Name>
				<Type>Int32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>UploadSingleAccess.ExecutedSICount</Name>
				<Type>Int32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>UploadSingleAccess.AbortMessage</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>UploadSingleAccess.AbortCode</Name>
				<Type>UInt32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>UploadSingleAccess.SubIndex</Name>
				<Type>Byte</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>UploadSingleAccess.Name</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>UploadSingleAccess.Type</Name>
				<Type>UInt16</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>UploadSingleAccess.BitSize</Name>
				<Type>Int32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>UploadSingleAccess.BitOffset</Name>
				<Type>Int32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>UploadSingleAccess.DefaultData</Name>
				<Type>ArrayOfBytes</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>UploadSingleAccess.EntryData</Name>
				<Type>ArrayOfBytes</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>UploadSingleAccess.EntryDataLength</Name>
				<Type>Int32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>UploadSingleAccess.EntryByteData</Name>
				<Type>Byte</Type>
				<Comment>If bitsize lower  than 8</Comment>
			</LocalVariables>
			<OutParameter>
				<Name>UploadSingleAccess.Data</Name>
				<Type>ArrayOfBytes</Type>
			</OutParameter>
			<TestStep Name="initEntryListIndex">
				<SetVariable Target="UploadSingleAccess.ListIndex">1</SetVariable>
			</TestStep>
			<TestStep Name="initExecutedCount">
				<SetVariable Target="UploadSingleAccess.ExecutedSICount">1</SetVariable>
			</TestStep>
			<TestStep Name="initSingleAccessArray">
				<InitArray TargetArray="UploadSingleAccess.Data" Length="UploadSingleAccess.DataLength"></InitArray>
			</TestStep>
			<TestStep Name="CopySI0DataSingleAccessArray">
				<SetArrayItem TargetArray="UploadSingleAccess.Data" Index="0">UploadSingleAccess.SI0Data</SetArrayItem>
			</TestStep>
			<TestStep Name="CheckForEmtyObject">
				<Compare>
					<Equal>
						<Value1>UploadSingleAccess.SI0Data</Value1>
						<Value2>0</Value2>
						<GotoStep>end</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="GetEntryDescription">
				<Description Id="0" Level="Verbose" Param0="UploadSingleAccess.Index" Param1="UploadSingleAccess.ListIndex">TestFunction 'UploadSingleAccess': 0x{0:X4} Requesting Entry description (list index {1}) ...</Description>
				<GetObjectDescriptionFromList ListIndex="UploadSingleAccess.ListIndex" Source="UploadSingleAccess.Entries">
					<SubIdx>UploadSingleAccess.SubIndex</SubIdx>
					<Name>UploadSingleAccess.Name</Name>
					<Type>UploadSingleAccess.Type</Type>
					<BitSize>UploadSingleAccess.BitSize</BitSize>
					<BitOffs>UploadSingleAccess.BitOffset</BitOffs>
					<DefaultData>UploadSingleAccess.DefaultData</DefaultData>
				</GetObjectDescriptionFromList>
				<RaiseErrorOnFailure Id="1" Param0="UploadSingleAccess.Index" Param1="UploadSingleAccess.ListIndex">TestFunction 'UploadSingleAccess': 0x{0:X4} Failed to get entry description list index {1}</RaiseErrorOnFailure>
				<WriteLine Id="2" Level="Verbose" Param0="UploadSingleAccess.DefaultData" Param1="UploadSingleAccess.Index" Param2="UploadSingleAccess.SubIndex" Param3="UploadSingleAccess.Name">TestFunction 'UploadSingleAccess': 0x{1:X4}:{2:X}: Entry description('{3}', Default Data: {0}</WriteLine>
				<WriteLine Id="3" Level="Verbose" Param0="UploadSingleAccess.BitSize" Param1="UploadSingleAccess.BitOffset">BitSize: {0} BitOffset: {1})</WriteLine>
			</TestStep>
			<TestStep Name="CheckForGap">
				<Description Id="4" Level="Verbose" Param2="UploadSingleAccess.Name" Param1="UploadSingleAccess.SubIndex" Param0="UploadSingleAccess.Index">TestFunction 'UploadSingleAccess': 0x{0:X4}:{1:X} '{2}': Checking data type...</Description>
				<Compare>
					<Equal>
						<Value1>UploadSingleAccess.Type</Value1>
						<Value2>0</Value2>
						<WriteLine Id="5" Level="Verbose">TestFunction 'UploadSingleAccess': Gap entry detected because the data type is 0.</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>UploadSingleAccess.Type</Value1>
						<Value2>0</Value2>
						<GotoStep>incrementEntryIndex</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CheckSubIndex1BitOffset">
				<Compare>
					<NotEqual>
						<Value1>UploadSingleAccess.SubIndex</Value1>
						<Value2>1</Value2>
						<GotoStep>UploadValueEntryValue</GotoStep>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>UploadSingleAccess.BitOffset</Value1>
						<Value2>16</Value2>
						<RaiseError Id="6" Param0="UploadSingleAccess.BitOffset" Param1="UploadSingleAccess.Index" Param2="UploadSingleAccess.Name">TestFunction 'UploadSingleAccess': {2} 0x{1:X4}:1: Unexpected BitOffset ({0}) found at the entry description (expected offset = 16)</RaiseError>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="UploadValueEntryValue">
				<Description Id="7" Level="Verbose" Param2="UploadSingleAccess.Name" Param1="UploadSingleAccess.SubIndex" Param0="UploadSingleAccess.Index">TestFunction 'UploadSingleAccess': 0x{0:X4}:{1:X} '{2}': Uploading data...</Description>
				<UploadCoEObject>
					<Index>UploadSingleAccess.Index</Index>
					<SubIndex>UploadSingleAccess.SubIndex</SubIndex>
					<DataVar>UploadSingleAccess.EntryData</DataVar>
					<BitLen>UploadSingleAccess.BitSize</BitLen>
					<AbortCode>UploadSingleAccess.AbortCode</AbortCode>
					<AbortMessage>UploadSingleAccess.AbortMessage</AbortMessage>
				</UploadCoEObject>
				<RaiseErrorOnFailure Id="8" Param0="UploadSingleAccess.Index" Param1="UploadSingleAccess.SubIndex">TestFunction 'UploadSingleAccess': 0x{0:X4}:{1:X}: Failed to upload data </RaiseErrorOnFailure>
				<WriteLine Id="9" Param0="UploadSingleAccess.EntryData" Level="Verbose" Param1="UploadSingleAccess.Index" Param2="UploadSingleAccess.SubIndex" Param3="UploadSingleAccess.Name">TestFunction 'UploadSingleAccess': 0x{1:X4}:{2:X} '{3}' : Uploaded data {0}</WriteLine>
				<Compare>
					<NotEqual>
						<Value1>UploadSingleAccess.AbortMessage</Value1>
						<Value2>EmptyString</Value2>
						<RaiseError Id="10" Param0="UploadSingleAccess.Name" Param1="UploadSingleAccess.Index" Param2="UploadSingleAccess.SubIndex" Param3="UploadSingleAccess.AbortMessage">TestFunction 'UploadSingleAccess': 0x{1:X4}:{2:X} '{0}' SDO upload failed. {3}</RaiseError>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>UploadSingleAccess.AbortCode</Value1>
						<Value2>#x06090011</Value2>
						<WriteLine Id="11" Param0="UploadSingleAccess.Name" Param1="UploadSingleAccess.Index" Param2="UploadSingleAccess.SubIndex" Level="Output">TestFunction 'UploadSingleAccess': '{0}'  0x{1:X4}:{2:X}: Allowed Abort code (0x06090011 SubIndex does not exist) received. This entry will be skipped. </WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>UploadSingleAccess.AbortCode</Value1>
						<Value2>#x06090011</Value2>
						<GotoStep>incrementEntryIndex</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>UploadSingleAccess.AbortCode</Value1>
						<Value2>#x08000020</Value2>
						<WriteLine Id="12" Param0="UploadSingleAccess.Name" Param1="UploadSingleAccess.Index" Param2="UploadSingleAccess.SubIndex" Level="Output">TestFunction 'UploadSingleAccess': '{0}' 0x{1:X4}:{2:X}: Allowed abort code (0x08000020 Data cannot be transferred or stored to the application) received. This entry will be skipped.</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>UploadSingleAccess.AbortCode</Value1>
						<Value2>#x08000020</Value2>
						<GotoStep>incrementEntryIndex</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>UploadSingleAccess.AbortCode</Value1>
						<Value2>#x08000021</Value2>
						<WriteLine Id="13" Param0="UploadSingleAccess.Name" Param1="UploadSingleAccess.Index" Param2="UploadSingleAccess.SubIndex" Level="Output">TestFunction 'UploadSingleAccess': '{0}' 0x{1:X4}:{2:X}: Allowed abort code (0x08000021 Data cannot be transferred or stored to the application because of local control) received. This entry will be skipped.</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>UploadSingleAccess.AbortCode</Value1>
						<Value2>#x08000021</Value2>
						<GotoStep>incrementEntryIndex</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>UploadSingleAccess.AbortCode</Value1>
						<Value2>#x06010001</Value2>
						<WriteLine Id="14" Param0="UploadSingleAccess.Name" Param1="UploadSingleAccess.Index" Param2="UploadSingleAccess.SubIndex" Level="Output">TestFunction 'UploadSingleAccess': '{0}' 0x{1:X4}:{2:X}: Allowed abort code (0x06010001 Attempt to read to a write only object) received. This entry will be skipped.</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>UploadSingleAccess.AbortCode</Value1>
						<Value2>#x06010001</Value2>
						<GotoStep>incrementEntryIndex</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>UploadSingleAccess.AbortCode</Value1>
						<Value2>0</Value2>
						<WriteLine Id="15" Param0="UploadSingleAccess.Name" Param1="UploadSingleAccess.Index" Param2="UploadSingleAccess.SubIndex" Param3="UploadSingleAccess.AbortCode">TestFunction 'UploadSingleAccess': '{0}' 0x{1:X4}:{2:X}: Sdo upload failed. Abort code received 0x{3:X8}</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>UploadSingleAccess.AbortCode</Value1>
						<Value2>0</Value2>
						<GotoStep>incrementEntryIndex</GotoStep>
					</NotEqual>
				</Compare>
				<Compare>
					<Lower>
						<Value1>UploadSingleAccess.BitSize</Value1>
						<Value2>8</Value2>
						<GotoStep>ConvertToByte</GotoStep>
					</Lower>
				</Compare>
			</TestStep>
			<TestStep Name="incrementProgress1">
				<SetVariable Target="UploadSingleAccess.ExecutedSICount">UploadSingleAccess.ExecutedSICount+1</SetVariable>
			</TestStep>
			<TestStep Name="CopyEntryData">
				<CopyArray>
					<SourceArray>UploadSingleAccess.EntryData</SourceArray>
					<DestinationArray>UploadSingleAccess.Data</DestinationArray>
					<SourceIndex>0</SourceIndex>
					<DestinationIndex>UploadSingleAccess.BitOffset/8</DestinationIndex>
					<Length>(UploadSingleAccess.BitSize+7)/8</Length>
				</CopyArray>
				<Compare>
					<Equal>
						<Value1>0</Value1>
						<Value2>0</Value2>
						<GotoStep>incrementEntryIndex</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="ConvertToByte">
				<SizeOf UInt32Var="UploadSingleAccess.EntryDataLength">UploadSingleAccess.EntryData</SizeOf>
				<Compare>
					<NotEqual>
						<Value1>UploadSingleAccess.EntryDataLength</Value1>
						<Value2>1</Value2>
						<RaiseError Id="16" Param0="UploadSingleAccess.Index" Param1="UploadSingleAccess.SubIndex" Param2="UploadSingleAccess.EntryDataLength" Param3="UploadSingleAccess.EntryData">TestFunction 'UploadSingleAccess': 0x{0:X4}: {1:X} Unexpected data length received ({2}) bytes); expected 1 byte {3}</RaiseError>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="incrementProgress2">
				<SetVariable Target="UploadSingleAccess.ExecutedSICount">UploadSingleAccess.ExecutedSICount+1</SetVariable>
			</TestStep>
			<TestStep Name="SetBitwise">
				<GetArrayItem Index="0" SourceArray="UploadSingleAccess.EntryData" Target="UploadSingleAccess.EntryByteData"></GetArrayItem>
			</TestStep>
			<TestStep Name="CopyDataBitwise">
				<SetBits Target="UploadSingleAccess.Data">
					<Offset>UploadSingleAccess.BitOffset</Offset>
					<Length>UploadSingleAccess.BitSize</Length>
					<Value>UploadSingleAccess.EntryByteData</Value>
				</SetBits>
			</TestStep>
			<TestStep Name="incrementEntryIndex">
				<SetVariable Target="UploadSingleAccess.ListIndex">UploadSingleAccess.ListIndex+1</SetVariable>
				<Compare>
					<Lower>
						<Value1>UploadSingleAccess.SubIndex</Value1>
						<Value2>UploadSingleAccess.SI0Data</Value2>
						<GotoStep>GetEntryDescription</GotoStep>
					</Lower>
				</Compare>
			</TestStep>
			<TestStep Name="end">
				<WriteLine Id="17" Level="Output" Param0="UploadSingleAccess.ExecutedSICount" Param1="UploadSingleAccess.Index" Param2="UploadSingleAccess.Name" Param3="UploadSingleAccess.Data">TestFunction 'UploadSingleAccess': 0x{1:X4} '{2}': {0} entries uploaded : {3}</WriteLine>
			</TestStep>
		</TestFunction>
		<TestFunction Name="VerifyUploadedSi0Data" FunctionId="1001">
			<?MAX_OUTPUT_ID 2?>
			<Parameter>
				<Name>VerifyUploadedSi0Data.Index</Name>
				<Type>UInt16</Type>
				<Comment>Index of the object</Comment>
			</Parameter>
			<Parameter>
				<Name>VerifyUploadedSi0Data.Name</Name>
				<Type>String</Type>
				<Comment>Name of the object description</Comment>
			</Parameter>
			<Parameter>
				<Name>VerifyUploadedSi0Data.Data</Name>
				<Type>ArrayOfBytes</Type>
				<Comment>Complete object CA SI0 data</Comment>
			</Parameter>
			<Parameter>
				<Name>VerifyUploadedSi0Data.SI0Data</Name>
				<Type>Byte</Type>
				<Comment>Uploaded value of SubIndex 0</Comment>
			</Parameter>
			<LocalVariables>
				<Name>VerifyUploadedSi0Data.Data0</Name>
				<Type>Byte</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>VerifyUploadedSi0Data.DataLength</Name>
				<Type>Int32</Type>
				<Comment>Complete object CA SI0 data length</Comment>
			</LocalVariables>
			<OutParameter>
				<Name>VerifyUploadedSi0Data.Valid</Name>
				<Type>Bool</Type>
			</OutParameter>
			<TestStep Name="initReturnValue">
				<SetVariable Target="VerifyUploadedSi0Data.Valid">True</SetVariable>
			</TestStep>
			<TestStep Name="getDataLength">
				<SizeOf UInt32Var="VerifyUploadedSi0Data.DataLength">VerifyUploadedSi0Data.Data</SizeOf>
			</TestStep>
			<TestStep Name="getSi0Fragment">
				<GetArrayItem Index="0" SourceArray="VerifyUploadedSi0Data.Data" Target="VerifyUploadedSi0Data.Data0"></GetArrayItem>
			</TestStep>
			<TestStep Name="checkDatalengthAndSI0Data">
				<Compare>
					<Greater>
						<Value1>VerifyUploadedSi0Data.Data0</Value1>
						<Value2>0</Value2>
						<Return Id="0"></Return>
					</Greater>
				</Compare>
				<Compare>
					<LowerOrEqual>
						<Value1>VerifyUploadedSi0Data.DataLength</Value1>
						<Value2>2</Value2>
						<Return Id="1"></Return>
					</LowerOrEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>True</Value1>
						<Value2>True</Value2>
						<RaiseWarning Id="2" Param0="VerifyUploadedSi0Data.Index" Param1="VerifyUploadedSi0Data.Name" Param2="VerifyUploadedSi0Data.Data">TestFunction: 'VerifyUploadedSi0Data': 0x{0:X4} '{1}': Invalid Complete Access data fragment detected. Data[0] cannot be '00' if the responded Complete Access data length is greater than 2. Responded SI0 Complete Access data: {2}</RaiseWarning>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>True</Value1>
						<Value2>True</Value2>
						<SetVariable Target="VerifyUploadedSi0Data.Valid">False</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
		</TestFunction>
	</TestFunctions>
	<TestGroups>
		<TestGroup Name="SDO Complete Access Upload SI0 and SI1 offline dictionary" GroupId="1">
			<Comment>This test group includes test cases which check the SDO Complete Access upload of objects which are described in the offline dictionary. The test cases are grouped by their EtherCAT state specific  SDO Access Rights. 
Therefore all objects which provide the Complete Access are read by Complete Access starting at Subindex 0 and Subindex 1.
The resulting data streams are compared for each entry that provides default data. If no default data is given by the entry description, the value of the entry may change between two successive SDO transfers and cannot be tested. (Different data streams leads to a Warning instead of an Error)
That means the data comparison is done for each entry description starting on the given bit offset and for the length of the bit size.</Comment>
			<TestCase Name="Objects with read Access in PreOp (offline dictionary)" CaseId="1">
				<?MAX_OUTPUT_ID 13?>
				<Description>
					<Purpose>This test case determines the correct DuT behaviour in case of a SDO Complete Access.</Purpose>
					<PreCondition>1.DuT supports the mailbox CoE protocol
2.DuT provides a ESI offline Dictionary</PreCondition>
					<Action>1. State transition to PreOp
2. Checking ESI for an offline dictionary
3. Filtering offline dictionary for read in PreOp objects
4. The following steps are done for each read in PreOp object:
4.1 Uploading the Complete Access object data starting from SubIndex 0
4.2 Comparing possible object BitSizes of the object dictionary with the received Complete Access data
4.3 Uploading the Complete Access object data starting from SubIndex 1
4.4 Comparing possible object BitSizes of the object dictionary with the received Complete Access data
4.5 Comparing of 'Complete Access data SubIndex 0' with 'Complete Access data SubIndex 1'. The comparison is masked by entries which provide default data.
4.6 The following steps are done for each SubIndex whose description provides default data
4.6.1 Uploading each entry data via a single SDO upload to map the received data bit wise in a byte stream which is used for a comparison against the Complete Access data 
4.6.2 (Only for SI1) Checking BitOffset of offline entry description.
</Action>
					<PostCondition>1. DuT reaches PreOp
2. Test case is skipped if the DuT does not provide an offline dictionary
3. Test case is skipped if the offline dictionary does not contain a RO object
4. If the current object does not support the Complete Access the DuT shall respond the Abort Code 0x06010000 or 0x06010004. Objects with SI count =1 are skipped. If the objects data cannot accessed because of local control the DuT may respond the Abort Code 0x08000021.
4.1 The DuT shall respond the Complete Access SI0 data of the current object.
4.2 The DuT shall respond the data length that is either given by the current max SubIndex or the BitSize of the object description.
4.3 The DuT shall respond the Complete Access SI1 data of the current object.
4.4 The DuT shall respond 16 Bit less than the data length that is either given by the current max SubIndex or the BitSize of the object description.
4.5 The data of Complete Access SI1 shall be equal to the SI0 data starting at BitOffset 16. Depending on if the entry provides default data either an error or warning is thrown if the data segments are different.
4.6 SubIndexes that respond the abortcode 0x06090011 (SubIndex does not exist), 0x08000021 (Data cannot be transferred or stored to the application because of local control) and 0x06010001 (Attempt to read to a write only object) are skipped for collecting Single Access data.
4.6.1 The DuT shall respond the same data corresponding to the data segment of the Complete Access data
4.6.2 The BitOffset shall be 16
</PostCondition>
					<References>
						<Reference Specification="ETG.1020" Chapter="21 SDO Complete Access"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="CheckForCompleteAccess">
					<Description Id="0" Level="Output">Checking for CoE mailbox support...</Description>
					<CallTestFunction Name="CheckCoECompleteAccess"></CallTestFunction>
				</TestStep>
				<TestStep Name="CheckForOfflineDictionary">
					<Description Id="1" Level="Output">Checking for offline dictionary...</Description>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Dictionary</Value1>
							<Value2>false</Value2>
							<SkipCase Id="2">Test case has been skipped because no offline dictionary was found at the ESI file</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CallInitMailbox">
					<Description Id="3" Level="Output">Initializing Mailbox...</Description>
					<CallTestFunction Name="InitMailbox"></CallTestFunction>
				</TestStep>
				<TestStep Name="GoToPreOp">
					<Description Id="4" Level="Output">Requesting PreOp...</Description>
					<RunToState Timeout="r.preOPTimeout">
						<State>PREOP</State>
					</RunToState>
					<RaiseErrorOnFailure Id="5">Failed to go to PreOp</RaiseErrorOnFailure>
				</TestStep>
				<TestStep Name="SetCurrentDictionaryType">
					<SetVariable Target="stringCurrentDictionaryType">offline</SetVariable>
				</TestStep>
				<TestStep Name="GetOfflineDictionary">
					<Description Id="6" Level="Output">Requesting offline dictionary...</Description>
					<GetObjectDictionary Target="sourceDictionary">
						<DictionaryType>Offline</DictionaryType>
					</GetObjectDictionary>
					<RaiseErrorOnFailure Id="7">Failed to get offline dictionary</RaiseErrorOnFailure>
				</TestStep>
				<TestStep Name="CheckForReadO">
					<Description Id="8" Level="Output">Filtering for read in PreOp objects...</Description>
					<GetObjectList Target="object.list" Count="object.count" SourceDict="sourceDictionary">
						<SubIdx>-1</SubIdx>
						<Flags>
							<Access ReadInPreOP="true"></Access>
						</Flags>
					</GetObjectList>
					<RaiseErrorOnFailure Id="9">Faiiled get object list</RaiseErrorOnFailure>
					<Compare>
						<Equal>
							<Value1>object.count</Value1>
							<Value2>0</Value2>
							<SkipCase Id="10">The offline object dictionary does not contain a read in PreOp object.</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>0</Value1>
							<Value2>0</Value2>
							<WriteLine Id="11" Level="Output" Param0="object.count">The offline object dictionary contains {0} read in PreOp object descriptions.</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="InitListIndex">
					<Description Id="12" Level="Output" Param0="object.count">Testing {0} read in PreOp objects...</Description>
					<SetVariable Target="object.listIndex">0</SetVariable>
				</TestStep>
				<TestStep Name="TestEachObject">
					<CallTestFunction Name="CheckROObject">
						<Parameter>object.list</Parameter>
						<Parameter>object.listIndex</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="IncrementListIndex">
					<SetVariable Target="object.listIndex">object.listIndex+1</SetVariable>
					<Compare>
						<Lower>
							<Value1>object.listIndex</Value1>
							<Value2>object.count</Value2>
							<GotoStep>TestEachObject</GotoStep>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep Name="WriteSuccess">
					<WriteLine Id="13" Level="Success">Complete Access was tested successfully.</WriteLine>
				</TestStep>
			</TestCase>
			<TestCase Name="Objects with read Access in SafeOp (offline dictionary)" CaseId="2">
				<?MAX_OUTPUT_ID 13?>
				<Description>
					<Purpose>This test case determines the correct DuT behaviour in case of a SDO Complete Access.</Purpose>
					<PreCondition>1.DuT supports the mailbox CoE protocol
2.DuT provides a ESI offline Dictionary</PreCondition>
					<Action>1. State transition to SafeOp
2. Checking ESI for an offline dictionary
3. Filtering offline dictionary for read in PreOp objects
4. The following steps are done for each read in PreOp object:
4.1 Uploading the Complete Access object data starting from SubIndex 0
4.2 Comparing possible object BitSizes of the object dictionary with the received Complete Access data
4.3 Uploading the Complete Access object data starting from SubIndex 1
4.4 Comparing possible object BitSizes of the object dictionary with the received Complete Access data
4.5 Comparing of 'Complete Access data SubIndex 0' with 'Complete Access data SubIndex 1'. The comparison is masked by entries which provide default data.
4.6 The following steps are done for each SubIndex whose description provides default data
4.6.1 Uploading each entry data via a single SDO upload to map the received data bit wise in a byte stream which is used for a comparison against the Complete Access data 
4.6.2 (Only for SI1) Checking BitOffset of offline entry description.
</Action>
					<PostCondition>1. DuT reaches SafeOp
2. Test case is skipped if the DuT does not provide an offline dictionary
3. Test case is skipped if the offline dictionary does not contain a RO object
4. If the current object does not support the Complete Access the DuT shall respond the Abort Code 0x06010000 or 0x06010004. Objects with SI count =1 are skipped. If the objects data cannot accessed because of local control the DuT may respond the Abort Code 0x08000021.
4.1 The DuT shall respond the Complete Access SI0 data of the current object.
4.2 The DuT shall respond a lower or equal data length than the given length by the object description of the offline dictionary.
4.3 The DuT shall respond the Complete Access SI1 data of the current object.
4.4 The DuT shall respond 16 Bit less than the BitSize of the object description.
4.5 The data of Complete Access SI1 shall be equal to the SI0 data starting at BitOffset 16. Depending on if the entry provides default data either an error or warning is thrown if the data segments are different.
4.6 SubIndexes that respond the abortcode 0x06090011 (SubIndex does not exist), 0x08000021 (Data cannot be transferred or stored to the application because of local control) and 0x06010001 (Attempt to read to a write only object) are skipped for collecting Single Access data.
4.6.1 The DuT shall respond the same data corresponding to the data segment of the Complete Access data
4.6.2 The BitOffset shall be 16</PostCondition>
					<References>
						<Reference Specification="ETG.1020" Chapter="21 SDO Complete Access"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="CheckForCompleteAccess">
					<Description Id="0" Level="Output">Checking for CoE mailbox support...</Description>
					<CallTestFunction Name="CheckCoECompleteAccess"></CallTestFunction>
				</TestStep>
				<TestStep Name="CheckForOfflineDictionary">
					<Description Id="1" Level="Output">Checking for offline dictionary...</Description>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Dictionary</Value1>
							<Value2>false</Value2>
							<SkipCase Id="2">Test case has been skipped because no offline dictionary was found at the ESI file</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CallInitMailbox">
					<Description Id="3" Level="Output">Initializing Mailbox...</Description>
					<CallTestFunction Name="InitMailbox"></CallTestFunction>
				</TestStep>
				<TestStep Name="GoToSafeOp">
					<Description Id="4" Level="Output">Requesting SafeOp...</Description>
					<RunToState Timeout="r.safeOPTimeout">
						<State>SAFEOP</State>
					</RunToState>
					<RaiseErrorOnFailure Id="5">Failed to go to SafeOP</RaiseErrorOnFailure>
				</TestStep>
				<TestStep Name="SetCurrentDictionaryType">
					<SetVariable Target="stringCurrentDictionaryType">offline</SetVariable>
				</TestStep>
				<TestStep Name="GetOfflineDictionary">
					<Description Id="6" Level="Output">Requesting offline dictionary...</Description>
					<GetObjectDictionary Target="sourceDictionary">
						<DictionaryType>Offline</DictionaryType>
					</GetObjectDictionary>
					<RaiseErrorOnFailure Id="7">Failed to get offline dictionary</RaiseErrorOnFailure>
				</TestStep>
				<TestStep Name="CheckForReadO">
					<Description Id="8" Level="Output">Filtering for read in SafeOP objects...</Description>
					<GetObjectList Target="object.list" Count="object.count" SourceDict="sourceDictionary">
						<SubIdx>-1</SubIdx>
						<Flags>
							<Access ReadInSafeOP="true"></Access>
						</Flags>
					</GetObjectList>
					<RaiseErrorOnFailure Id="9">Faiiled get object list</RaiseErrorOnFailure>
					<Compare>
						<Equal>
							<Value1>object.count</Value1>
							<Value2>0</Value2>
							<SkipCase Id="10">The offline object dictionary does not contain a read in SafeOP object.</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>0</Value1>
							<Value2>0</Value2>
							<WriteLine Id="11" Level="Output" Param0="object.count">The offline object dictionary contains {0} read in SafeOP object descriptions.</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="InitListIndex">
					<Description Id="12" Level="Output" Param0="object.count">Testing {0} read in SafeOP objects...</Description>
					<SetVariable Target="object.listIndex">0</SetVariable>
				</TestStep>
				<TestStep Name="TestEachObject">
					<CallTestFunction Name="CheckROObject">
						<Parameter>object.list</Parameter>
						<Parameter>object.listIndex</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="IncrementListIndex">
					<SetVariable Target="object.listIndex">object.listIndex+1</SetVariable>
					<Compare>
						<Lower>
							<Value1>object.listIndex</Value1>
							<Value2>object.count</Value2>
							<GotoStep>TestEachObject</GotoStep>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep Name="WriteSuccess">
					<WriteLine Id="13" Level="Success">Complete Access was tested successfully.</WriteLine>
				</TestStep>
			</TestCase>
			<TestCase Name="Objects with read Access in Op (offline dictionary)" CaseId="3">
				<?MAX_OUTPUT_ID 13?>
				<Description>
					<Purpose>This test case determines the correct DuT behaviour in case of a SDO Complete Access.</Purpose>
					<PreCondition>1.DuT supports the mailbox CoE protocol
2.DuT provides a ESI offline Dictionary
3.DuT provides an freerun mode (StartToSafeOpNoSync attribute = false)</PreCondition>
					<Action>1. State transition to Op
2. Checking ESI for an offline dictionary
3. Filtering offline dictionary for read in PreOp objects
4. The following steps are done for each read in PreOp object:
4.1 Uploading the Complete Access object data starting from SubIndex 0
4.2 Comparing possible object BitSizes of the object dictionary with the received Complete Access data
4.3 Uploading the Complete Access object data starting from SubIndex 1
4.4 Comparing possible object BitSizes of the object dictionary with the received Complete Access data
4.5 Comparing of 'Complete Access data SubIndex 0' with 'Complete Access data SubIndex 1'. The comparison is masked by entries which provide default data.
4.6 The following steps are done for each SubIndex whose description provides default data
4.6.1 Uploading each entry data via a single SDO upload to map the received data bit wise in a byte stream which is used for a comparison against the Complete Access data 
4.6.2 (Only for SI1) Checking BitOffset of offline entry description.
</Action>
					<PostCondition>1. DuT reaches Op
2. Test case is skipped if the DuT does not provide an offline dictionary
3. Test case is skipped if the offline dictionary does not contain a RO object
4. If the current object does not support the Complete Access the DuT shall respond the Abort Code 0x06010000 or 0x06010004. Objects with SI count =1 are skipped. If the objects data cannot accessed because of local control the DuT may respond the Abort Code 0x08000021.
4.1 The DuT shall respond the Complete Access SI0 data of the current object.
4.2 The DuT shall respond a lower or equal data length than the given length by the object description of the offline dictionary.
4.3 The DuT shall respond the Complete Access SI1 data of the current object.
4.4 The DuT shall respond 16 Bit less than the BitSize of the object description.
4.5 The data of Complete Access SI1 shall be equal to the SI0 data starting at BitOffset 16. Depending on if the entry provides default data either an error or warning is thrown if the data segments are different.
4.6 SubIndexes that respond the abortcode 0x06090011 (SubIndex does not exist), 0x08000021 (Data cannot be transferred or stored to the application because of local control) and 0x06010001 (Attempt to read to a write only object) are skipped for collecting Single Access data.
4.6.1 The DuT shall respond the same data corresponding to the data segment of the Complete Access data
4.6.2 The BitOffset shall be 16</PostCondition>
					<References>
						<Reference Specification="ETG.1020" Chapter="21 SDO Complete Access"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="CheckForCompleteAccess">
					<Description Id="0" Level="Output">Checking for CoE mailbox support...</Description>
					<CallTestFunction Name="CheckCoECompleteAccess"></CallTestFunction>
				</TestStep>
				<TestStep Name="CheckForOfflineDictionary">
					<Description Id="1" Level="Output">Checking for offline dictionary...</Description>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Dictionary</Value1>
							<Value2>false</Value2>
							<SkipCase Id="2">Test case has been skipped because no offline dictionary was found at the ESI file</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CallInitMailbox">
					<Description Id="3" Level="Output">Initializing Mailbox...</Description>
					<CallTestFunction Name="InitMailbox"></CallTestFunction>
				</TestStep>
				<TestStep Name="CheckIfRtExtensionRequired">
					<CallTestFunction Name="CheckIfCurrentConfigRequiresCu2508"></CallTestFunction>
				</TestStep>
				<TestStep Name="GoToOp">
					<Description Id="4" Level="Output">Requesting Op...</Description>
					<RunToState Timeout="r.safeOPTimeout">
						<State>OP</State>
					</RunToState>
					<RaiseErrorOnFailure Id="5">Failed to go to OP</RaiseErrorOnFailure>
				</TestStep>
				<TestStep Name="SetCurrentDictionaryType">
					<SetVariable Target="stringCurrentDictionaryType">offline</SetVariable>
				</TestStep>
				<TestStep Name="GetOfflineDictionary">
					<Description Id="6" Level="Output">Requesting offline dictionary...</Description>
					<GetObjectDictionary Target="sourceDictionary">
						<DictionaryType>Offline</DictionaryType>
					</GetObjectDictionary>
					<RaiseErrorOnFailure Id="7">Failed to get offline dictionary</RaiseErrorOnFailure>
				</TestStep>
				<TestStep Name="CheckForReadO">
					<Description Id="8" Level="Output">Filtering for read in OP objects...</Description>
					<GetObjectList Target="object.list" Count="object.count" SourceDict="sourceDictionary">
						<SubIdx>-1</SubIdx>
						<Flags>
							<Access ReadInOP="true"></Access>
						</Flags>
					</GetObjectList>
					<RaiseErrorOnFailure Id="9">Faiiled get object list</RaiseErrorOnFailure>
					<Compare>
						<Equal>
							<Value1>object.count</Value1>
							<Value2>0</Value2>
							<SkipCase Id="10">The offline object dictionary does not contain a read in OP object.</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>0</Value1>
							<Value2>0</Value2>
							<WriteLine Id="11" Level="Output" Param0="object.count">The offline object dictionary contains {0} read in OP object descriptions.</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="InitListIndex">
					<Description Id="12" Level="Output" Param0="object.count">Testing {0} read in OP objects...</Description>
					<SetVariable Target="object.listIndex">0</SetVariable>
				</TestStep>
				<TestStep Name="TestEachObject">
					<CallTestFunction Name="CheckROObject">
						<Parameter>object.list</Parameter>
						<Parameter>object.listIndex</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="IncrementListIndex">
					<SetVariable Target="object.listIndex">object.listIndex+1</SetVariable>
					<Compare>
						<Lower>
							<Value1>object.listIndex</Value1>
							<Value2>object.count</Value2>
							<GotoStep>TestEachObject</GotoStep>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep Name="WriteSuccess">
					<WriteLine Id="13" Level="Success">Complete Access was tested successfully.</WriteLine>
				</TestStep>
			</TestCase>
		</TestGroup>
		<TestGroup Name="SDO Complete Access Download SI0 and SI1 offline dictionary" GroupId="2">
			<Comment>This test group includes test cases which check the SDO Complete Access download of objects which are described in the offline dictionary.
</Comment>
			<TestCase Name="Object Access RW in PreOp (offline dictionary)" CaseId="1">
				<?MAX_OUTPUT_ID 14?>
				<Description>
					<PreCondition>1.DuT supports the mailbox CoE protocol
2.DuT provides a ESI offline Dictionary</PreCondition>
					<Action>1. State transition to PreOp
2. Checking ESI for an offline dictionary
3. Filtering offline dictionary for RW in PreOp objects
4. The following steps are done for each RW in PreOp object:
4.1 Uploading the Complete Access data to determine the Complete Access data length
4.2 Comparing possible object BitSizes of the object dictionary with the received Complete Access data
4.3 Uploading the single access data 1 of the complete object
4.4 Downloading data 1 via a complete access SI0 
4.5 Uploading the single access data 2 of the complete object
4.6 Comparing single access data 1 with single access data 2
4.7 Downloading data 1 via a complete access SI1
4.8 Uploading the single access data 3 of the complete object
4.9 Comparing single access data 1 with single access data 3
</Action>
					<PostCondition>1. DuT reaches PreOp
2. Test case is skipped if the DuT does not provide an offline dictionary
3. Test case is skipped if the offline dictionary does not contain a RW in PreOp object
4.1 If the current object does not support the Complete Access Upload the DuT shall respond the Abort Code 0x06010000. Objects with SI count =1 are skipped.  If the access of one of the entries depends on local control the Abort Code 0x08000021 shall be responded.
4.2 The DuT shall respond the data length that is either given by the current max SubIndex or the BitSize of the object description.
4.3 The DuT shall respond the data for each RW in PreOp or RO subIndex .  If the access of one of the entries depends on local control the Abort Code 0x08000021 shall be responded.
4.4 If the current object does not support the Complete Access Download the DuT shall respond the Abort Code 0x06010000. Objects with SI count =1 are skipped. If the access of one of the entries depends on local control the Abort Code 0x08000021 shall be responded.
If SI0 is RO the DuT may return the Abort Code 0x06010002 (Attempt to write a read only object)
4.5 The DuT shall respond the data for each RW in PreOp or RO subIndex
4.6 Data 1 and data 2 shall be equal for RO entries
4.7 The Complete Access SI1 shall be successful
4.8 The DuT shall respond the data for each RW in PreOp or RO subIndex
4.9 Data 1 and data 3 shall be equal for RO entries
</PostCondition>
					<References>
						<Reference Specification="ETG.1020" Chapter="21 SDO Complete Access"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="CheckForCompleteAccess">
					<Description Id="0" Level="Output">Checking for CoE mailbox support...</Description>
					<CallTestFunction Name="CheckCoECompleteAccess"></CallTestFunction>
				</TestStep>
				<TestStep Name="CheckForOfflineDictionary">
					<Description Id="1" Level="Output">Checking for offline dictionary...</Description>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Dictionary</Value1>
							<Value2>false</Value2>
							<SkipCase Id="2">Test case has been skipped because no offline dictionary was found at the ESI file</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CallInitMailbox">
					<Description Id="3" Level="Output">Initializing Mailbox...</Description>
					<CallTestFunction Name="InitMailbox"></CallTestFunction>
				</TestStep>
				<TestStep Name="GoToPreOp">
					<Description Id="4" Level="Output">Requesting PreOp...</Description>
					<RunToState Timeout="r.preOPTimeout">
						<State>PREOP</State>
					</RunToState>
					<RaiseErrorOnFailure Id="5">Failed to go to PreOp</RaiseErrorOnFailure>
				</TestStep>
				<TestStep Name="SetCurrentDictionaryType">
					<SetVariable Target="stringCurrentDictionaryType">offline</SetVariable>
				</TestStep>
				<TestStep Name="GetOfflineDictionary">
					<Description Id="6" Level="Output">Requesting offline dictionary...</Description>
					<GetObjectDictionary Target="sourceDictionary">
						<DictionaryType>Offline</DictionaryType>
					</GetObjectDictionary>
					<RaiseErrorOnFailure Id="7">Failed to get offline dictionary</RaiseErrorOnFailure>
					<WriteLine Id="8" Level="Output">The offline object dictionary contains {0} RW in PreOp object descriptions.</WriteLine>
				</TestStep>
				<TestStep Name="CheckForRW">
					<Description Id="9" Level="Output">Filtering for RW in PreOp objects...</Description>
					<GetObjectList Target="object.list" Count="object.count" SourceDict="sourceDictionary">
						<SubIdx>-1</SubIdx>
						<Flags>
							<Access ReadInPreOP="true" WriteInPreOP="true"></Access>
						</Flags>
					</GetObjectList>
					<RaiseErrorOnFailure Id="10">Faiiled get object list</RaiseErrorOnFailure>
					<Compare>
						<Equal>
							<Value1>object.count</Value1>
							<Value2>0</Value2>
							<SkipCase Id="11">The offline object dictionary does not contain a RW in PreOp object.</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>0</Value1>
							<Value2>0</Value2>
							<WriteLine Id="12" Level="Output" Param0="object.count">The offline object dictionary contains {0} RW in PreOp object descriptions.</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="InitListIndex">
					<Description Id="13" Level="Output" Param0="object.count">Testing {0} RW in PreOp objects...</Description>
					<SetVariable Target="object.listIndex">0</SetVariable>
				</TestStep>
				<TestStep Name="TestEachObject">
					<CallTestFunction Name="CheckRWObject">
						<Parameter>object.list</Parameter>
						<Parameter>object.listIndex</Parameter>
						<Parameter>"PreOp"</Parameter>
						<Parameter>False</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="IncrementListIndex">
					<SetVariable Target="object.listIndex">object.listIndex+1</SetVariable>
					<Compare>
						<Lower>
							<Value1>object.listIndex</Value1>
							<Value2>object.count</Value2>
							<GotoStep>TestEachObject</GotoStep>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep Name="WriteSuccess">
					<WriteLine Id="14" Level="Success">Complete Access was tested successfully.</WriteLine>
				</TestStep>
			</TestCase>
			<TestCase Name="Object Access RW in SafeOp (offline dictionary)" CaseId="2">
				<?MAX_OUTPUT_ID 14?>
				<Description>
					<PreCondition>1.DuT supports the mailbox CoE protocol
2.DuT provides a ESI offline Dictionary</PreCondition>
					<Action>1. State transition to SafeOp
2. Checking ESI for an offline dictionary
3. Filtering offline dictionary for RW in SafeOp objects
4. The following steps are done for each RW in SafeOp object:
4.1 Uploading the Complete Access data to determine the Complete Access data length
4.2 Comparing possible object BitSizes of the object dictionary with the received Complete Access data
4.3 Uploading the single access data 1 of the complete object
4.4 Downloading data 1 via a complete access SI0 
4.5 Uploading the single access data 2 of the complete object
4.6 Comparing single access data 1 with single access data 2
4.7 Downloading data 1 via a complete access SI1
4.8 Uploading the single access data 3 of the complete object
4.9 Comparing single access data 1 with single access data 3
</Action>
					<PostCondition>1. DuT reaches SafeOp
2. Test case is skipped if the DuT does not provide an offline dictionary
3. Test case is skipped if the offline dictionary does not contain a RW in SafeOp object
4.1 If the current object does not support the Complete Access Upload the DuT shall respond the Abort Code 0x06010000. Objects with SI count =1 are skipped.  If the access of one of the entries depends on local control the Abort Code 0x08000021 shall be responded.
4.2 The DuT shall respond the data length that is either given by the current max SubIndex or the BitSize of the object description.
4.3 The DuT shall respond the data for each RW in SafeOp or RO subIndex .  If the access of one of the entries depends on local control the Abort Code 0x08000021 shall be responded.
4.4 If the current object does not support the Complete Access Download the DuT shall respond the Abort Code 0x06010000. Objects with SI count =1 are skipped. If the access of one of the entries depends on local control the Abort Code 0x08000021 shall be responded.
If SI0 is RO the DuT may return the Abort Code 0x06010002 (Attempt to write a read only object)
4.5 The DuT shall respond the data for each RW in SafeOp or RO subIndex
4.6 Data 1 and data 2 shall be equal for RO entries
4.7 The Complete Access SI1 shall be successful
4.8 The DuT shall respond the data for each RW in SafeOp or RO subIndex
4.9 Data 1 and data 3 shall be equal for RO entries</PostCondition>
					<References>
						<Reference Specification="ETG.1020" Chapter="21 SDO Complete Access"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="CheckForCompleteAccess">
					<Description Id="0" Level="Output">Checking for CoE mailbox support...</Description>
					<CallTestFunction Name="CheckCoECompleteAccess"></CallTestFunction>
				</TestStep>
				<TestStep Name="CheckForOfflineDictionary">
					<Description Id="1" Level="Output">Checking for offline dictionary...</Description>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Dictionary</Value1>
							<Value2>false</Value2>
							<SkipCase Id="2">Test case has been skipped because no offline dictionary was found at the ESI file</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CallInitMailbox">
					<Description Id="3" Level="Output">Initializing Mailbox...</Description>
					<CallTestFunction Name="InitMailbox"></CallTestFunction>
				</TestStep>
				<TestStep Name="GoToSafeOp">
					<Description Id="4" Level="Output">Requesting SafeOp...</Description>
					<RunToState Timeout="r.safeOPTimeout">
						<State>SAFEOP</State>
					</RunToState>
					<RaiseErrorOnFailure Id="5">Failed to go to SafeOp</RaiseErrorOnFailure>
				</TestStep>
				<TestStep Name="SetCurrentDictionaryType">
					<SetVariable Target="stringCurrentDictionaryType">offline</SetVariable>
				</TestStep>
				<TestStep Name="GetOfflineDictionary">
					<Description Id="6" Level="Output">Requesting offline dictionary...</Description>
					<GetObjectDictionary Target="sourceDictionary">
						<DictionaryType>Offline</DictionaryType>
					</GetObjectDictionary>
					<RaiseErrorOnFailure Id="7">Failed to get offline dictionary</RaiseErrorOnFailure>
					<WriteLine Id="8" Level="Output">The offline object dictionary contains {0} RW in SafeOp object descriptions.</WriteLine>
				</TestStep>
				<TestStep Name="CheckForRW">
					<Description Id="9" Level="Output">Filtering for RW in SafeOp objects...</Description>
					<GetObjectList Target="object.list" Count="object.count" SourceDict="sourceDictionary">
						<SubIdx>-1</SubIdx>
						<Flags>
							<Access ReadInSafeOP="true" WriteInSafeOP="true"></Access>
						</Flags>
					</GetObjectList>
					<RaiseErrorOnFailure Id="10">Faiiled get object list</RaiseErrorOnFailure>
					<Compare>
						<Equal>
							<Value1>object.count</Value1>
							<Value2>0</Value2>
							<SkipCase Id="11">The offline object dictionary does not contain a RW in SafeOp object.</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>0</Value1>
							<Value2>0</Value2>
							<WriteLine Id="12" Level="Output" Param0="object.count">The offline object dictionary contains {0} RW in SafeOp object descriptions.</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="InitListIndex">
					<Description Id="13" Level="Output" Param0="object.count">Testing {0} RW in SafeOp objects...</Description>
					<SetVariable Target="object.listIndex">0</SetVariable>
				</TestStep>
				<TestStep Name="TestEachObject">
					<CallTestFunction Name="CheckRWObject">
						<Parameter>object.list</Parameter>
						<Parameter>object.listIndex</Parameter>
						<Parameter>"SafeOp"</Parameter>
						<Parameter>False</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="IncrementListIndex">
					<SetVariable Target="object.listIndex">object.listIndex+1</SetVariable>
					<Compare>
						<Lower>
							<Value1>object.listIndex</Value1>
							<Value2>object.count</Value2>
							<GotoStep>TestEachObject</GotoStep>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep Name="WriteSuccess">
					<WriteLine Id="14" Level="Success">Complete Access was tested successfully.</WriteLine>
				</TestStep>
			</TestCase>
			<TestCase Name="Object Access RW in Op (offline dictionary)" CaseId="3">
				<?MAX_OUTPUT_ID 14?>
				<Description>
					<PreCondition>1.DuT supports the mailbox CoE protocol
2.DuT provides a ESI offline Dictionary
3.DuT provides an freerun mode (StartToSafeOpNoSync attribute = false)</PreCondition>
					<Action>1. State transition to Op
2. Checking ESI for an offline dictionary
3. Filtering offline dictionary for RW in Op objects
4. The following steps are done for each RW in Op object:
4.1 Uploading the Complete Access data to determine the Complete Access data length
4.2 Comparing possible object BitSizes of the object dictionary with the received Complete Access data
4.3 Uploading the single access data 1 of the complete object
4.4 Downloading data 1 via a complete access SI0 
4.5 Uploading the single access data 2 of the complete object
4.6 Comparing single access data 1 with single access data 2
4.7 Downloading data 1 via a complete access SI1
4.8 Uploading the single access data 3 of the complete object
4.9 Comparing single access data 1 with single access data 3
</Action>
					<PostCondition>1. DuT reaches Op
2. Test case is skipped if the DuT does not provide an offline dictionary
3. Test case is skipped if the offline dictionary does not contain a RW in Op object
4.1 If the current object does not support the Complete Access Upload the DuT shall respond the Abort Code 0x06010000. Objects with SI count =1 are skipped.  If the access of one of the entries depends on local control the Abort Code 0x08000021 shall be responded.
4.2 The DuT shall respond the data length that is either given by the current max SubIndex or the BitSize of the object description.
4.3 The DuT shall respond the data for each RW in Op or RO subIndex .  If the access of one of the entries depends on local control the Abort Code 0x08000021 shall be responded.
4.4 If the current object does not support the Complete Access Download the DuT shall respond the Abort Code 0x06010000. Objects with SI count =1 are skipped. If the access of one of the entries depends on local control the Abort Code 0x08000021 shall be responded.
If SI0 is RO the DuT may return the Abort Code 0x06010002 (Attempt to write a read only object)
4.5 The DuT shall respond the data for each RW in Op or RO subIndex
4.6 Data 1 and data 2 shall be equal for RO entries
4.7 The Complete Access SI1 shall be successful
4.8 The DuT shall respond the data for each RW in Op or RO subIndex
4.9 Data 1 and data 3 shall be equal for RO entries
</PostCondition>
					<References>
						<Reference Specification="ETG.1020" Chapter="21 SDO Complete Access"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="CheckForCompleteAccess">
					<Description Id="0" Level="Output">Checking for CoE mailbox support...</Description>
					<CallTestFunction Name="CheckCoECompleteAccess"></CallTestFunction>
				</TestStep>
				<TestStep Name="CheckForOfflineDictionary">
					<Description Id="1" Level="Output">Checking for offline dictionary...</Description>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Dictionary</Value1>
							<Value2>false</Value2>
							<SkipCase Id="2">Test case has been skipped because no offline dictionary was found at the ESI file</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CallInitMailbox">
					<Description Id="3" Level="Output">Initializing Mailbox...</Description>
					<CallTestFunction Name="InitMailbox"></CallTestFunction>
				</TestStep>
				<TestStep Name="CheckIfRtExtensionRequired">
					<CallTestFunction Name="CheckIfCurrentConfigRequiresCu2508"></CallTestFunction>
				</TestStep>
				<TestStep Name="GoToOp">
					<Description Id="4" Level="Output">Requesting Op...</Description>
					<RunToState Timeout="r.safeOPTimeout">
						<State>OP</State>
					</RunToState>
					<RaiseErrorOnFailure Id="5">Failed to go to Op</RaiseErrorOnFailure>
				</TestStep>
				<TestStep Name="SetCurrentDictionaryType">
					<SetVariable Target="stringCurrentDictionaryType">offline</SetVariable>
				</TestStep>
				<TestStep Name="GetOfflineDictionary">
					<Description Id="6" Level="Output">Requesting offline dictionary...</Description>
					<GetObjectDictionary Target="sourceDictionary">
						<DictionaryType>Offline</DictionaryType>
					</GetObjectDictionary>
					<RaiseErrorOnFailure Id="7">Failed to get offline dictionary</RaiseErrorOnFailure>
					<WriteLine Id="8" Level="Output">The offline object dictionary contains {0} RW in Op object descriptions.</WriteLine>
				</TestStep>
				<TestStep Name="CheckForRW">
					<Description Id="9" Level="Output">Filtering for RW in Op objects...</Description>
					<GetObjectList Target="object.list" Count="object.count" SourceDict="sourceDictionary">
						<SubIdx>-1</SubIdx>
						<Flags>
							<Access ReadInOP="true" WriteInOP="true"></Access>
						</Flags>
					</GetObjectList>
					<RaiseErrorOnFailure Id="10">Faiiled get object list</RaiseErrorOnFailure>
					<Compare>
						<Equal>
							<Value1>object.count</Value1>
							<Value2>0</Value2>
							<SkipCase Id="11">The offline object dictionary does not contain a RW in Op object.</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>0</Value1>
							<Value2>0</Value2>
							<WriteLine Id="12" Level="Output" Param0="object.count">The offline object dictionary contains {0} RW in Op object descriptions.</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="InitListIndex">
					<Description Id="13" Level="Output" Param0="object.count">Testing {0} RW in Op objects...</Description>
					<SetVariable Target="object.listIndex">0</SetVariable>
				</TestStep>
				<TestStep Name="TestEachObject">
					<CallTestFunction Name="CheckRWObject">
						<Parameter>object.list</Parameter>
						<Parameter>object.listIndex</Parameter>
						<Parameter>"Op"</Parameter>
						<Parameter>True</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="IncrementListIndex">
					<SetVariable Target="object.listIndex">object.listIndex+1</SetVariable>
					<Compare>
						<Lower>
							<Value1>object.listIndex</Value1>
							<Value2>object.count</Value2>
							<GotoStep>TestEachObject</GotoStep>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep Name="WriteSuccess">
					<WriteLine Id="14" Level="Success">Complete Access was tested successfully.</WriteLine>
				</TestStep>
			</TestCase>
		</TestGroup>
		<TestGroup Name="SDO Complete Access Upload SI0 and SI1 online dictionary" GroupId="3">
			<Comment>This test group includes test cases which check the SDO Complete Access upload of objects which are described in the online dictionary. The test cases are grouped by their EtherCAT state specific  SDO Access Rights. 
Therefore all objects which provide the Complete Access are read by Complete Access starting at Subindex 0 and Subindex 1.
The resulting data streams are compared for each entry that provides default data. If no default data is given by the entry description, the value of the entry may change between two successive SDO transfers and cannot be tested. (Different data streams leads to a Warning instead of an Error)
That means the data comparison is done for each entry description starting on the given bit offset and for the length of the bit size.</Comment>
			<TestCase Name="Objects with read Access in PreOp (online dictionary)" CaseId="1">
				<?MAX_OUTPUT_ID 13?>
				<Description>
					<Purpose>This test case determines the correct DuT behaviour in case of a SDO Complete Access.
Therefore all RO objects which provide the Complete Access are read by Complete Access starting at Subindex 0 and Subindex 1.
The resulting data streams are compared for each entry that provides default data. If no default data is given by the entry description, the value of the entry may change between two successive SDO transfers and cannot be tested. (Different data streams leads to a Warning instead of an Error)
That means the data comparison is done for each entry description starting on the given bit offset and for the length of the bit size.</Purpose>
					<PreCondition>1.DuT supports the mailbox CoE protocol
2.DuT provides an online Dictionary (SDO Info)</PreCondition>
					<Action>1. State transition to PreOp
2. Checking ESI for an online dictionary
3. Filtering online dictionary for read in PreOp objects
4. The following steps are done for each read in PreOp object:
4.1 Uploading the Complete Access object data starting from SubIndex 0
4.2 Comparing object BitSize with the received Complete Access data
4.3 Uploading the Complete Access object data starting from SubIndex 1
4.4 Comparing object BitSize with the received Complete Access data
4.5 Comparision of 'Complete Access data SubIndex 0' with 'Complete Access data SubIndex 1'. The comparison is masked by the entries which provide default data.
4.6 The following steps are done for each SubIndex whose description provides default data
4.6.1 Uploading each entry data via a single SDO upload to map the received data bit wise in a byte stream which is used for a comparison against the Complete Access data 
4.6.2 (Only for SI1) Checking BitOffset of online entry description.
</Action>
					<PostCondition>1. DuT reaches PreOp
2. Test case is skipped if the DuT does not provide an online dictionary
3. Test case is skipped if the online dictionary does not contain a read in PreOp object
4. If the current object does not support the Complete Access the DuT shall respond the Abort Code 0x06010000 or 0x06010004. Objects with SI count =1 are skipped.
4.1 The DuT shall respond the Complete Access SI0 data of the current object.
4.2 The DuT shall respond a lower or equal data length than the given length by the object description of the online dictionary.
4.3 The DuT shall respond the Complete Access SI1 data of the current object.
4.4 The DuT shall respond 16 Bit less than the BitSize of the object description.
4.5 The data of Complete Access SI1 shall be equal to the SI0 data starting at BitOffset 16. Depending on if the entry provides default data either an error or warning is thrown if the data segments are different.
4.6 SubIndexes that respond the abortcode 0x06090011 (SubIndex does not exist), 0x08000021 (Data cannot be transferred or stored to the application because of local control) and 0x06010001 (Attempt to read to a write only object) are skipped for collecting Single Access data.
4.6.1 The DuT shall respond the same data corresponding to the data segment of the Complete Access data
4.6.2 The BitOffset shall be 16</PostCondition>
					<References>
						<Reference Specification="ETG.1020" Chapter="21 SDO Complete Access"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="CheckForCompleteAccess">
					<Description Id="0" Level="Output">Checking for CoE mailbox support...</Description>
					<CallTestFunction Name="CheckCoECompleteAccess"></CallTestFunction>
				</TestStep>
				<TestStep Name="CheckForOnlineDictionary">
					<Description Id="1" Level="Output">Checking for online dictionary...</Description>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Mailbox.CoE.SdoInfo</Value1>
							<Value2>false</Value2>
							<SkipCase Id="2">Test case has been skipped because no online dictionary support was found at the ESI file</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CallInitMailbox">
					<Description Id="3" Level="Output">Initializing Mailbox...</Description>
					<CallTestFunction Name="InitMailbox"></CallTestFunction>
				</TestStep>
				<TestStep Name="GoToPreOp">
					<Description Id="4" Level="Output">Requesting PreOp...</Description>
					<RunToState Timeout="r.preOPTimeout">
						<State>PREOP</State>
					</RunToState>
					<RaiseErrorOnFailure Id="5">Failed to go to PreOp</RaiseErrorOnFailure>
				</TestStep>
				<TestStep Name="SetCurrentDictionaryType">
					<SetVariable Target="stringCurrentDictionaryType">"online"</SetVariable>
				</TestStep>
				<TestStep Name="GetOnlineDictionary">
					<Description Id="6" Level="Output">Requesting online dictionary...</Description>
					<GetObjectDictionary Target="sourceDictionary">
						<DictionaryType>Online</DictionaryType>
					</GetObjectDictionary>
					<RaiseErrorOnFailure Id="7">Failed to get online dictionary</RaiseErrorOnFailure>
				</TestStep>
				<TestStep Name="CheckForReadO">
					<Description Id="8" Level="Output">Filtering for read in objects...</Description>
					<GetObjectList Target="object.list" Count="object.count" SourceDict="sourceDictionary">
						<SubIdx>-1</SubIdx>
						<Flags>
							<Access ReadInPreOP="true"></Access>
						</Flags>
					</GetObjectList>
					<RaiseErrorOnFailure Id="9">Faiiled get object list</RaiseErrorOnFailure>
					<Compare>
						<Equal>
							<Value1>object.count</Value1>
							<Value2>0</Value2>
							<SkipCase Id="10">The online object dictionary does not contain a RW object.</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>0</Value1>
							<Value2>0</Value2>
							<WriteLine Id="11" Level="Output" Param0="object.count">The online object dictionary contains {0} read in PreOp object descriptions.</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="InitListIndex">
					<Description Id="12" Level="Output" Param0="object.count">Testing {0} read in PreOp objects...</Description>
					<SetVariable Target="object.listIndex">0</SetVariable>
				</TestStep>
				<TestStep Name="TestEachObject">
					<CallTestFunction Name="CheckROObject">
						<Parameter>object.list</Parameter>
						<Parameter>object.listIndex</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="IncrementListIndex">
					<SetVariable Target="object.listIndex">object.listIndex+1</SetVariable>
					<Compare>
						<Lower>
							<Value1>object.listIndex</Value1>
							<Value2>object.count</Value2>
							<GotoStep>TestEachObject</GotoStep>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep Name="WriteSuccess">
					<WriteLine Id="13" Level="Success">Complete Access was tested successfully.</WriteLine>
				</TestStep>
			</TestCase>
			<TestCase Name="Objects with read Access in SafeOp (online dictionary)" CaseId="2">
				<?MAX_OUTPUT_ID 13?>
				<Description>
					<Purpose>This test case determines the correct DuT behaviour in case of a SDO Complete Access.
Therefore all read in SafeOp objects which provide the Complete Access are read by Complete Access starting at Subindex 0 and Subindex 1.
The resulting data streams are compared for each entry that provides default data. If no default data is given by the entry description, the value of the entry may change between two successive SDO transfers and cannot be tested. (Different data streams leads to a Warning instead of an Error)
That means the data comparison is done for each entry description starting on the given bit offset and for the length of the bit size.</Purpose>
					<PreCondition>1.DuT supports the mailbox CoE protocol
2.DuT provides an online Dictionary (SDO Info)</PreCondition>
					<Action>1. State transition to SafeOp
2. Checking ESI for an online dictionary
3. Filtering online dictionary for read in SafeOp objects
4. The following steps are done for each read in SafeOp object:
4.1 Uploading the Complete Access object data starting from SubIndex 0
4.2 Comparing object BitSize with the received Complete Access data
4.3 Uploading the Complete Access object data starting from SubIndex 1
4.4 Comparing object BitSize with the received Complete Access data
4.5 Comparision of 'Complete Access data SubIndex 0' with 'Complete Access data SubIndex 1'. The comparison is masked by the entries which provide default data.
4.6 The following steps are done for each SubIndex whose description provides default data
4.6.1 Uploading each entry data via a single SDO upload to map the received data bit wise in a byte stream which is used for a comparison against the Complete Access data 
4.6.2 (Only for SI1) Checking BitOffset of online entry description.
</Action>
					<PostCondition>1. DuT reaches SafeOp
2. Test case is skipped if the DuT does not provide an online dictionary (SDO Info not supported)
3. Test case is skipped if the online dictionary does not contain a read in SafeOp object
4. If the current object does not support the Complete Access the DuT shall respond the Abort Code 0x06010000 or 0x06010004. Objects with SI count =1 are skipped.
4.1 The DuT shall respond the Complete Access SI0 data of the current object.
4.2 The DuT shall respond a lower or equal data length than the given length by the object description of the online dictionary.
4.3 The DuT shall respond the Complete Access SI1 data of the current object.
4.4 The DuT shall respond 16 Bit less than the BitSize of the object description.
4.5 The data of Complete Access SI1 shall be equal to the SI0 data starting at BitOffset 16. Depending on if the entry provides default data either an error or warning is thrown if the data segments are different.
4.6 SubIndexes that respond the abortcode 0x06090011 (SubIndex does not exist), 0x08000021 (Data cannot be transferred or stored to the application because of local control) and 0x06010001 (Attempt to read to a write only object) are skipped for collecting Single Access data.
4.6.1 The DuT shall respond the same data corresponding to the data segment of the Complete Access data
4.6.2 The BitOffset shall be 16</PostCondition>
					<References>
						<Reference Specification="ETG.1020" Chapter="21 SDO Complete Access"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="CheckForCompleteAccess">
					<Description Id="0" Level="Output">Checking for CoE mailbox support...</Description>
					<CallTestFunction Name="CheckCoECompleteAccess"></CallTestFunction>
				</TestStep>
				<TestStep Name="CheckForOnlineDictionary">
					<Description Id="1" Level="Output">Checking for online dictionary...</Description>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Mailbox.CoE.SdoInfo</Value1>
							<Value2>false</Value2>
							<SkipCase Id="2">Test case has been skipped because no online dictionary support was found at the ESI file</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CallInitMailbox">
					<Description Id="3" Level="Output">Initializing Mailbox...</Description>
					<CallTestFunction Name="InitMailbox"></CallTestFunction>
				</TestStep>
				<TestStep Name="GoToSafeOp">
					<Description Id="4" Level="Output">Requesting SafeOp...</Description>
					<RunToState Timeout="r.safeOPTimeout">
						<State>SAFEOP</State>
					</RunToState>
					<RaiseErrorOnFailure Id="5">Failed to go to SafeOP</RaiseErrorOnFailure>
				</TestStep>
				<TestStep Name="SetCurrentDictionaryType">
					<SetVariable Target="stringCurrentDictionaryType">"online"</SetVariable>
				</TestStep>
				<TestStep Name="GetOnlineDictionary">
					<Description Id="6" Level="Output">Requesting online dictionary...</Description>
					<GetObjectDictionary Target="sourceDictionary">
						<DictionaryType>Online</DictionaryType>
					</GetObjectDictionary>
					<RaiseErrorOnFailure Id="7">Failed to get online dictionary</RaiseErrorOnFailure>
				</TestStep>
				<TestStep Name="CheckForReadO">
					<Description Id="8" Level="Output">Filtering for read in SafeOp objects...</Description>
					<GetObjectList Target="object.list" Count="object.count" SourceDict="sourceDictionary">
						<SubIdx>-1</SubIdx>
						<Flags>
							<Access ReadInSafeOP="true"></Access>
						</Flags>
					</GetObjectList>
					<RaiseErrorOnFailure Id="9">Faiiled get object list</RaiseErrorOnFailure>
					<Compare>
						<Equal>
							<Value1>object.count</Value1>
							<Value2>0</Value2>
							<SkipCase Id="10">The online object dictionary does not contain a read in SafeOp object.</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>0</Value1>
							<Value2>0</Value2>
							<WriteLine Id="11" Level="Output" Param0="object.count">The online object dictionary contains {0} read in SafeOp object descriptions.</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="InitListIndex">
					<Description Id="12" Level="Output" Param0="object.count">Testing {0} read in SafeOp objects...</Description>
					<SetVariable Target="object.listIndex">0</SetVariable>
				</TestStep>
				<TestStep Name="TestEachObject">
					<CallTestFunction Name="CheckROObject">
						<Parameter>object.list</Parameter>
						<Parameter>object.listIndex</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="IncrementListIndex">
					<SetVariable Target="object.listIndex">object.listIndex+1</SetVariable>
					<Compare>
						<Lower>
							<Value1>object.listIndex</Value1>
							<Value2>object.count</Value2>
							<GotoStep>TestEachObject</GotoStep>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep Name="WriteSuccess">
					<WriteLine Id="13" Level="Success">Complete Access was tested successfully.</WriteLine>
				</TestStep>
			</TestCase>
			<TestCase Name="Objects with read Access in Op (online dictionary)" CaseId="3">
				<?MAX_OUTPUT_ID 13?>
				<Description>
					<Purpose>This test case determines the correct DuT behaviour in case of a SDO Complete Access.
Therefore all read in Op objects which provide the Complete Access are read by Complete Access starting at Subindex 0 and Subindex 1.
The resulting data streams are compared for each entry that provides default data. If no default data is given by the entry description, the value of the entry may change between two successive SDO transfers and cannot be tested. (Different data streams leads to a Warning instead of an Error)
That means the data comparison is done for each entry description starting on the given bit offset and for the length of the bit size.</Purpose>
					<PreCondition>1.DuT supports the mailbox CoE protocol
2.DuT provides an online Dictionary (SDO Info)
3.DuT provides an freerun mode (StartToSafeOpNoSync attribute = false)</PreCondition>
					<Action>1. State transition to Op
2. Checking ESI for an online dictionary
3. Filtering online dictionary for read in Op objects
4. The following steps are done for each read in Op object:
4.1 Uploading the Complete Access object data starting from SubIndex 0
4.2 Comparing object BitSize with the received Complete Access data
4.3 Uploading the Complete Access object data starting from SubIndex 1
4.4 Comparing object BitSize with the received Complete Access data
4.5 Comparision of 'Complete Access data SubIndex 0' with 'Complete Access data SubIndex 1'. The comparison is masked by the entries which provide default data.
4.6 The following steps are done for each SubIndex whose description provides default data
4.6.1 Uploading each entry data via a single SDO upload to map the received data bit wise in a byte stream which is used for a comparison against the Complete Access data 
4.6.2 (Only for SI1) Checking BitOffset of online entry description.
</Action>
					<PostCondition>1. DuT reaches Op
2. Test case is skipped if the DuT does not provide an online dictionary
3. Test case is skipped if the online dictionary does not contain a read in Op object
4. If the current object does not support the Complete Access the DuT shall respond the Abort Code 0x06010000 or 0x06010004. Objects with SI count =1 are skipped.
4.1 The DuT shall respond the Complete Access SI0 data of the current object.
4.2 The DuT shall respond a lower or equal data length than the given length by the object description of the online dictionary.
4.3 The DuT shall respond the Complete Access SI1 data of the current object.
4.4 The DuT shall respond 16 Bit less than the BitSize of the object description.
4.5 The data of Complete Access SI1 shall be equal to the SI0 data starting at BitOffset 16. Depending on if the entry provides default data either an error or warning is thrown if the data segments are different.
4.6 SubIndexes that respond the abortcode 0x06090011 (SubIndex does not exist), 0x08000021 (Data cannot be transferred or stored to the application because of local control) and 0x06010001 (Attempt to read to a write only object) are skipped for collecting Single Access data.
4.6.1 The DuT shall respond the same data corresponding to the data segment of the Complete Access data
4.6.2 The BitOffset shall be 16</PostCondition>
					<References>
						<Reference Specification="ETG.1020" Chapter="21 SDO Complete Access"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="CheckForCompleteAccess">
					<Description Id="0" Level="Output">Checking for CoE mailbox support...</Description>
					<CallTestFunction Name="CheckCoECompleteAccess"></CallTestFunction>
				</TestStep>
				<TestStep Name="CheckForOfflineDictionary">
					<Description Id="1" Level="Output">Checking for online dictionary...</Description>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Mailbox.CoE.SdoInfo</Value1>
							<Value2>false</Value2>
							<SkipCase Id="2">Test case has been skipped because no online dictionary support was found at the ESI file</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CallInitMailbox">
					<Description Id="3" Level="Output">Initializing Mailbox...</Description>
					<CallTestFunction Name="InitMailbox"></CallTestFunction>
				</TestStep>
				<TestStep Name="CheckIfRtExtensionRequired">
					<CallTestFunction Name="CheckIfCurrentConfigRequiresCu2508"></CallTestFunction>
				</TestStep>
				<TestStep Name="GoToOp">
					<Description Id="4" Level="Output">Requesting Op...</Description>
					<RunToState Timeout="r.safeOPTimeout">
						<State>OP</State>
					</RunToState>
					<RaiseErrorOnFailure Id="5">Failed to go to OP</RaiseErrorOnFailure>
				</TestStep>
				<TestStep Name="SetCurrentDictionaryType">
					<SetVariable Target="stringCurrentDictionaryType">"online"</SetVariable>
				</TestStep>
				<TestStep Name="GetOnlineDictionary">
					<Description Id="6" Level="Output">Requesting online dictionary...</Description>
					<GetObjectDictionary Target="sourceDictionary">
						<DictionaryType>Online</DictionaryType>
					</GetObjectDictionary>
					<RaiseErrorOnFailure Id="7">Failed to get online dictionary</RaiseErrorOnFailure>
				</TestStep>
				<TestStep Name="CheckForReadO">
					<Description Id="8" Level="Output">Filtering for read in Op objects...</Description>
					<GetObjectList Target="object.list" Count="object.count" SourceDict="sourceDictionary">
						<SubIdx>-1</SubIdx>
						<Flags>
							<Access ReadInOP="true" WriteInOP="false"></Access>
						</Flags>
					</GetObjectList>
					<RaiseErrorOnFailure Id="9">Faiiled get object list</RaiseErrorOnFailure>
					<Compare>
						<Equal>
							<Value1>object.count</Value1>
							<Value2>0</Value2>
							<SkipCase Id="10">The online object dictionary does not contain a read in Op object.</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>0</Value1>
							<Value2>0</Value2>
							<WriteLine Id="11" Level="Output" Param0="object.count">The online object dictionary contains {0} read in Op object descriptions.</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="InitListIndex">
					<Description Id="12" Level="Output" Param0="object.count">Testing {0} read in Op objects...</Description>
					<SetVariable Target="object.listIndex">0</SetVariable>
				</TestStep>
				<TestStep Name="TestEachObject">
					<CallTestFunction Name="CheckROObject">
						<Parameter>object.list</Parameter>
						<Parameter>object.listIndex</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="IncrementListIndex">
					<SetVariable Target="object.listIndex">object.listIndex+1</SetVariable>
					<Compare>
						<Lower>
							<Value1>object.listIndex</Value1>
							<Value2>object.count</Value2>
							<GotoStep>TestEachObject</GotoStep>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep Name="WriteSuccess">
					<WriteLine Id="13" Level="Success">Complete Access was tested successfully.</WriteLine>
				</TestStep>
			</TestCase>
		</TestGroup>
		<TestGroup Name="SDO Complete Access Download SI0 and SI1 online dictionary" GroupId="4">
			<Comment>This test group includes test cases which check the SDO Complete Access download of objects which are described in the online dictionary. The online dictionary is represented by the optional SDO Info protocol.</Comment>
			<TestCase Name="Object Access RW in PreOp (online dictionary)" CaseId="1">
				<?MAX_OUTPUT_ID 14?>
				<Description>
					<PreCondition>1.DuT supports the mailbox CoE protocol
2.DuT provides an online Dictionary (SDO Info)</PreCondition>
					<Action>1. State transition to PreOp
2. Checking ESI for an online dictionary
3. Filtering online dictionary for RW in PreOp objects
4. The following steps are done for each RW in PreOp object:
4.1 Uploading the Complete Access data to determine the Complete Access data length
4.2 Comparing possible object BitSizes of the object dictionary with the received Complete Access data
4.3 Uploading the single access data 1 of the complete object
4.4 Downloading data 1 via a complete access SI0 
4.5 Uploading the single access data 2 of the complete object
4.6 Comparing single access data 1 with single access data 2
4.7 Downloading data 1 via a complete access SI1
4.8 Uploading the single access data 3 of the complete object
4.9 Comparing single access data 1 with single access data 3</Action>
					<PostCondition>1. DuT reaches PreOp
2. Test case is skipped if the DuT does not provide an online dictionary
3. Test case is skipped if the online dictionary does not contain a RW in PreOp object
4.1 If the current object does not support the Complete Access Upload the DuT shall respond the Abort Code 0x06010000 or 0x06010004. Objects with SI count =1 are skipped.  If the access of one of the entries depends on local control the Abort Code 0x08000021 shall be responded.
4.2 The DuT shall respond the data length that is either given by the current max SubIndex or the BitSize of the object description.
4.3 The DuT shall respond the data for each RW in PreOp or RO subIndex .  If the access of one of the entries depends on local control the Abort Code 0x08000021 shall be responded.
4.4 If the current object does not support the Complete Access Download the DuT shall respond the Abort Code 0x06010000 or 0x06010004. Objects with SI count =1 are skipped. If the access of one of the entries depends on local control the Abort Code 0x08000021 shall be responded.
If SI0 is RO the DuT may return the Abort Code 0x06010002 (Attempt to write a read only object)
4.5 The DuT shall respond the data for each RW in PreOp or RO subIndex
4.6 Data 1 and data 2 shall be equal for RO entries
4.7 The Complete Access SI1 shall be successful
4.8 The DuT shall respond the data for each RW in PreOp or RO subIndex
4.9 Data 1 and data 3 shall be equal for RO entries
</PostCondition>
					<References>
						<Reference Specification="ETG.1020" Chapter="21 SDO Complete Access"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="CheckForCompleteAccess">
					<Description Id="0" Level="Output">Checking for CoE mailbox support...</Description>
					<CallTestFunction Name="CheckCoECompleteAccess"></CallTestFunction>
				</TestStep>
				<TestStep Name="CheckForOnlineDictionary">
					<Description Id="1" Level="Output">Checking for online dictionary...</Description>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Mailbox.CoE.SdoInfo</Value1>
							<Value2>false</Value2>
							<SkipCase Id="2">Test case has been skipped because no online dictionary supprt found at the ESI file (DeviceType:Mailbox:CoE:SdoInfo)</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CallInitMailbox">
					<Description Id="3" Level="Output">Initializing Mailbox...</Description>
					<CallTestFunction Name="InitMailbox"></CallTestFunction>
				</TestStep>
				<TestStep Name="GoToPreOp">
					<Description Id="4" Level="Output">Requesting PreOp...</Description>
					<RunToState Timeout="r.preOPTimeout">
						<State>PREOP</State>
					</RunToState>
					<RaiseErrorOnFailure Id="5">Failed to go to PreOp</RaiseErrorOnFailure>
				</TestStep>
				<TestStep Name="SetCurrentDictionaryType">
					<SetVariable Target="stringCurrentDictionaryType">"online"</SetVariable>
				</TestStep>
				<TestStep Name="GetOnlineDictionary">
					<Description Id="6" Level="Output">Requesting online dictionary...</Description>
					<GetObjectDictionary Target="sourceDictionary">
						<DictionaryType>Online</DictionaryType>
					</GetObjectDictionary>
					<RaiseErrorOnFailure Id="7">Failed to get online dictionary</RaiseErrorOnFailure>
					<WriteLine Id="8" Level="Output">The online object dictionary contains {0} RW object descriptions.</WriteLine>
				</TestStep>
				<TestStep Name="CheckForRW">
					<Description Id="9" Level="Output">Filtering for RW objects...</Description>
					<GetObjectList Target="object.list" Count="object.count" SourceDict="sourceDictionary">
						<SubIdx>-1</SubIdx>
						<Flags>
							<Access ReadInPreOP="true" WriteInPreOP="true"></Access>
						</Flags>
					</GetObjectList>
					<RaiseErrorOnFailure Id="10">Faiiled get object list</RaiseErrorOnFailure>
					<Compare>
						<Equal>
							<Value1>object.count</Value1>
							<Value2>0</Value2>
							<SkipCase Id="11">The online object dictionary does not contain a RW object.</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>0</Value1>
							<Value2>0</Value2>
							<WriteLine Id="12" Level="Output" Param0="object.count">The online object dictionary contains {0} RW object descriptions.</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="InitListIndex">
					<Description Id="13" Level="Output" Param0="object.count">Testing {0} RW objects...</Description>
					<SetVariable Target="object.listIndex">0</SetVariable>
				</TestStep>
				<TestStep Name="TestEachObject">
					<CallTestFunction Name="CheckRWObject">
						<Parameter>object.list</Parameter>
						<Parameter>object.listIndex</Parameter>
						<Parameter>"PreOp"</Parameter>
						<Parameter>False</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="IncrementListIndex">
					<SetVariable Target="object.listIndex">object.listIndex+1</SetVariable>
					<Compare>
						<Lower>
							<Value1>object.listIndex</Value1>
							<Value2>object.count</Value2>
							<GotoStep>TestEachObject</GotoStep>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep Name="WriteSuccess">
					<WriteLine Id="14" Level="Success">Complete Access was tested successfully.</WriteLine>
				</TestStep>
			</TestCase>
			<TestCase Name="Object Access RW in SafeOp (online dictionary)" CaseId="2">
				<?MAX_OUTPUT_ID 14?>
				<Description>
					<PreCondition>1.DuT supports the mailbox CoE protocol
2.DuT provides an online Dictionary (SDO Info)</PreCondition>
					<Action>1. State transition to SafeOp
2. Checking ESI for an online dictionary
3. Filtering online dictionary for RW in SafeOp objects
4. The following steps are done for each RW in SafeOp object:
4.1 Uploading the Complete Access data to determine the Complete Access data length
4.2 Comparing possible object BitSizes of the object dictionary with the received Complete Access data
4.3 Uploading the single access data 1 of the complete object
4.4 Downloading data 1 via a complete access SI0 
4.5 Uploading the single access data 2 of the complete object
4.6 Comparing single access data 1 with single access data 2
4.7 Downloading data 1 via a complete access SI1
4.8 Uploading the single access data 3 of the complete object
4.9 Comparing single access data 1 with single access data 3</Action>
					<PostCondition>1. DuT reaches SafeOp
2. Test case is skipped if the DuT does not provide an online dictionary
3. Test case is skipped if the online dictionary does not contain a RW in SafeOp object
4.1 If the current object does not support the Complete Access Upload the DuT shall respond the Abort Code 0x06010000 or 0x06010004. Objects with SI count =1 are skipped.  If the access of one of the entries depends on local control the Abort Code 0x08000021 shall be responded.
4.2 The DuT shall respond the data length that is either given by the current max SubIndex or the BitSize of the object description.
4.3 The DuT shall respond the data for each RW in SafeOp or RO subIndex .  If the access of one of the entries depends on local control the Abort Code 0x08000021 shall be responded.
4.4 If the current object does not support the Complete Access Download the DuT shall respond the Abort Code 0x06010000 or 0x06010004. Objects with SI count =1 are skipped. If the access of one of the entries depends on local control the Abort Code 0x08000021 shall be responded.
If SI0 is RO the DuT may return the Abort Code 0x06010002 (Attempt to write a read only object)
4.5 The DuT shall respond the data for each RW in SafeOp or RO subIndex
4.6 Data 1 and data 2 shall be equal for RO entries
4.7 The Complete Access SI1 shall be successful
4.8 The DuT shall respond the data for each RW in SafeOp or RO subIndex
4.9 Data 1 and data 3 shall be equal for RO entries
</PostCondition>
					<References>
						<Reference Specification="ETG.1020" Chapter="21 SDO Complete Access"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="CheckForCompleteAccess">
					<Description Id="0" Level="Output">Checking for CoE mailbox support...</Description>
					<CallTestFunction Name="CheckCoECompleteAccess"></CallTestFunction>
				</TestStep>
				<TestStep Name="CheckForOnlineDictionary">
					<Description Id="1" Level="Output">Checking for online dictionary...</Description>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Mailbox.CoE.SdoInfo</Value1>
							<Value2>false</Value2>
							<SkipCase Id="2">Test case has been skipped because no online dictionary supprt found at the ESI file (DeviceType:Mailbox:CoE:SdoInfo)</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CallInitMailbox">
					<Description Id="3" Level="Output">Initializing Mailbox...</Description>
					<CallTestFunction Name="InitMailbox"></CallTestFunction>
				</TestStep>
				<TestStep Name="GoToSafeOp">
					<Description Id="4" Level="Output">Requesting SafeOp...</Description>
					<RunToState Timeout="r.safeOPTimeout">
						<State>SAFEOP</State>
					</RunToState>
					<RaiseErrorOnFailure Id="5">Failed to go to SafeOp</RaiseErrorOnFailure>
				</TestStep>
				<TestStep Name="SetCurrentDictionaryType">
					<SetVariable Target="stringCurrentDictionaryType">"online"</SetVariable>
				</TestStep>
				<TestStep Name="GetOnlineDictionary">
					<Description Id="6" Level="Output">Requesting online dictionary...</Description>
					<GetObjectDictionary Target="sourceDictionary">
						<DictionaryType>Online</DictionaryType>
					</GetObjectDictionary>
					<RaiseErrorOnFailure Id="7">Failed to get online dictionary</RaiseErrorOnFailure>
					<WriteLine Id="8" Level="Output">The online object dictionary contains {0} RW object descriptions.</WriteLine>
				</TestStep>
				<TestStep Name="CheckForRW">
					<Description Id="9" Level="Output">Filtering for RW objects...</Description>
					<GetObjectList Target="object.list" Count="object.count" SourceDict="sourceDictionary">
						<SubIdx>-1</SubIdx>
						<Flags>
							<Access ReadInSafeOP="true" WriteInSafeOP="true"></Access>
						</Flags>
					</GetObjectList>
					<RaiseErrorOnFailure Id="10">Faiiled get object list</RaiseErrorOnFailure>
					<Compare>
						<Equal>
							<Value1>object.count</Value1>
							<Value2>0</Value2>
							<SkipCase Id="11">The online object dictionary does not contain a RW object.</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>0</Value1>
							<Value2>0</Value2>
							<WriteLine Id="12" Level="Output" Param0="object.count">The online object dictionary contains {0} RW object descriptions.</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="InitListIndex">
					<Description Id="13" Level="Output" Param0="object.count">Testing {0} RW objects...</Description>
					<SetVariable Target="object.listIndex">0</SetVariable>
				</TestStep>
				<TestStep Name="TestEachObject">
					<CallTestFunction Name="CheckRWObject">
						<Parameter>object.list</Parameter>
						<Parameter>object.listIndex</Parameter>
						<Parameter>"SafeOp"</Parameter>
						<Parameter>False</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="IncrementListIndex">
					<SetVariable Target="object.listIndex">object.listIndex+1</SetVariable>
					<Compare>
						<Lower>
							<Value1>object.listIndex</Value1>
							<Value2>object.count</Value2>
							<GotoStep>TestEachObject</GotoStep>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep Name="WriteSuccess">
					<WriteLine Id="14" Level="Success">Complete Access was tested successfully.</WriteLine>
				</TestStep>
			</TestCase>
			<TestCase Name="Object Access RW in Op (online dictionary)" CaseId="3">
				<?MAX_OUTPUT_ID 14?>
				<Description>
					<PreCondition>1.DuT supports the mailbox CoE protocol
2.DuT provides an online Dictionary (SDO Info)
3.DuT provides an freerun mode (StartToSafeOpNoSync attribute = false)</PreCondition>
					<Action>1. State transition to Op
2. Checking ESI for an online dictionary
3. Filtering online dictionary for RW in Op objects
4. The following steps are done for each RW in Op object:
4.1 Uploading the Complete Access data to determine the Complete Access data length
4.2 Comparing possible object BitSizes of the object dictionary with the received Complete Access data
4.3 Uploading the single access data 1 of the complete object
4.4 Downloading data 1 via a complete access SI0 
4.5 Uploading the single access data 2 of the complete object
4.6 Comparing single access data 1 with single access data 2
4.7 Downloading data 1 via a complete access SI1
4.8 Uploading the single access data 3 of the complete object
4.9 Comparing single access data 1 with single access data 3</Action>
					<PostCondition>1. DuT reaches SafeOp
2. Test case is skipped if the DuT does not provide an online dictionary
3. Test case is skipped if the online dictionary does not contain a RW in Op object
4.1 If the current object does not support the Complete Access Upload the DuT shall respond the Abort Code 0x06010000 or 0x06010004. Objects with SI count =1 are skipped.  If the access of one of the entries depends on local control the Abort Code 0x08000021 shall be responded.
4.2 The DuT shall respond the data length that is either given by the current max SubIndex or the BitSize of the object description.
4.3 The DuT shall respond the data for each RW in Op or RO subIndex .  If the access of one of the entries depends on local control the Abort Code 0x08000021 shall be responded.
4.4 If the current object does not support the Complete Access Download the DuT shall respond the Abort Code 0x06010000 or 0x06010004. Objects with SI count =1 are skipped. If the access of one of the entries depends on local control the Abort Code 0x08000021 shall be responded.
If SI0 is RO the DuT may return the Abort Code 0x06010002 (Attempt to write a read only object)
4.5 The DuT shall respond the data for each RW in Op or RO subIndex
4.6 Data 1 and data 2 shall be equal for RO entries
4.7 The Complete Access SI1 shall be successful
4.8 The DuT shall respond the data for each RW in Op or RO subIndex
4.9 Data 1 and data 3 shall be equal for RO entries
</PostCondition>
					<References>
						<Reference Specification="ETG.1020" Chapter="21 SDO Complete Access"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="CheckForCompleteAccess">
					<Description Id="0" Level="Output">Checking for CoE mailbox support...</Description>
					<CallTestFunction Name="CheckCoECompleteAccess"></CallTestFunction>
				</TestStep>
				<TestStep Name="CheckForOnlineDictionary">
					<Description Id="1" Level="Output">Checking for online dictionary...</Description>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Mailbox.CoE.SdoInfo</Value1>
							<Value2>false</Value2>
							<SkipCase Id="2">Test case has been skipped because no online dictionary supprt found at the ESI file (DeviceType:Mailbox:CoE:SdoInfo)</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CallInitMailbox">
					<Description Id="3" Level="Output">Initializing Mailbox...</Description>
					<CallTestFunction Name="InitMailbox"></CallTestFunction>
				</TestStep>
				<TestStep Name="CheckIfRtExtensionRequired">
					<CallTestFunction Name="CheckIfCurrentConfigRequiresCu2508"></CallTestFunction>
				</TestStep>
				<TestStep Name="GoToOp">
					<Description Id="4" Level="Output">Requesting Op...</Description>
					<RunToState Timeout="r.safeOPTimeout">
						<State>OP</State>
					</RunToState>
					<RaiseErrorOnFailure Id="5">Failed to go to Op</RaiseErrorOnFailure>
				</TestStep>
				<TestStep Name="SetCurrentDictionaryType">
					<SetVariable Target="stringCurrentDictionaryType">"online"</SetVariable>
				</TestStep>
				<TestStep Name="GetOnlineDictionary">
					<Description Id="6" Level="Output">Requesting offline dictionary...</Description>
					<GetObjectDictionary Target="sourceDictionary">
						<DictionaryType>Online</DictionaryType>
					</GetObjectDictionary>
					<RaiseErrorOnFailure Id="7">Failed to get offline dictionary</RaiseErrorOnFailure>
					<WriteLine Id="8" Level="Output">The offline object dictionary contains {0} RW object descriptions.</WriteLine>
				</TestStep>
				<TestStep Name="CheckForRW">
					<Description Id="9" Level="Output">Filtering for RW objects...</Description>
					<GetObjectList Target="object.list" Count="object.count" SourceDict="sourceDictionary">
						<SubIdx>-1</SubIdx>
						<Flags>
							<Access ReadInOP="true" WriteInOP="true"></Access>
						</Flags>
					</GetObjectList>
					<RaiseErrorOnFailure Id="10">Faiiled get object list</RaiseErrorOnFailure>
					<Compare>
						<Equal>
							<Value1>object.count</Value1>
							<Value2>0</Value2>
							<SkipCase Id="11">The offline object dictionary does not contain a RW object.</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>0</Value1>
							<Value2>0</Value2>
							<WriteLine Id="12" Level="Output" Param0="object.count">The offline object dictionary contains {0} RW object descriptions.</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="InitListIndex">
					<Description Id="13" Level="Output" Param0="object.count">Testing {0} RW objects...</Description>
					<SetVariable Target="object.listIndex">0</SetVariable>
				</TestStep>
				<TestStep Name="TestEachObject">
					<CallTestFunction Name="CheckRWObject">
						<Parameter>object.list</Parameter>
						<Parameter>object.listIndex</Parameter>
						<Parameter>"Op"</Parameter>
						<Parameter>True</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="IncrementListIndex">
					<SetVariable Target="object.listIndex">object.listIndex+1</SetVariable>
					<Compare>
						<Lower>
							<Value1>object.listIndex</Value1>
							<Value2>object.count</Value2>
							<GotoStep>TestEachObject</GotoStep>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep Name="WriteSuccess">
					<WriteLine Id="14" Level="Success">Complete Access was tested successfully.</WriteLine>
				</TestStep>
			</TestCase>
		</TestGroup>
	</TestGroups>
</EtherCATTest>