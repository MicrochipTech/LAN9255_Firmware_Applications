<?xml version="1.0" encoding="UTF-8" standalone="yes"?><EtherCATTest Name="EtherCAT State Machine Base Test Functions" SchemaVersion="1.0.31" xsi:noNamespaceSchemaLocation="EtherCATTest.xsd" RealeaseState="Released" TestId="0012" TestVendorId="1" TestVersion="1.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
	<Comment>This file includes basic test functions, mainly for EtherCAT State Machine related tests. The test functions are necessary for TF-12xx test files. They can also be included in other test files. It is not intended to run this file independently.</Comment>
	<History>
		<HistoryEntry Editor="F.H." TestVersion="0.0.1" Date="2013-03-01">file created</HistoryEntry>
		<HistoryEntry Editor="F.H." TestVersion="0.0.2" Date="2014-01-30">Add VerifyAlStatusAndStatusCode (before AlStatus.Code)</HistoryEntry>
		<HistoryEntry Editor="F.H." TestVersion="0.0.2" Date="2014-01-30">Add VerifyAlStatusCode (before AlStatusCode)</HistoryEntry>
		<HistoryEntry Editor="F.H." TestVersion="0.0.2" Date="2014-01-30">Deleted "reset of expectedAlStatusCode2/3 since they are now handed over with the parameters and then are 0x0000 as necessary</HistoryEntry>
		<HistoryEntry Editor="F.H." TestVersion="0.0.2" Date="2014-01-30">Change name of VerifyAlStatusAndAlStatusCode to GetAndVerifyAlStatusAndAlStatusCode </HistoryEntry>
		<HistoryEntry Editor="F.H." TestVersion="0.0.2" Date="2014-01-30">Add VerifyAlStatusAndStatusCode (before CheckAlStatus.Code)</HistoryEntry>
		<HistoryEntry Editor="F.H." TestVersion="0.0.2" Date="2014-01-31">Add SkipTestIfDcOnly (before CheckForNonDcMode)</HistoryEntry>
		<HistoryEntry Editor="F.H." TestVersion="0.0.2" Date="2014-01-31">Add GetListOfAllInputOrOutputSm (before GetAllInputSm/GetAllOutputSm are now one with parameter Outputs/Inputs)</HistoryEntry>
		<HistoryEntry Editor="F.H." TestVersion="0.0.2" Date="2014-01-31">Add GetListOfAllPdSm(before GetAllPdSm)</HistoryEntry>
		<HistoryEntry Editor="F.H." TestVersion="0.0.2" Date="2014-01-31">Add CheckIfThisSmEnabled (before CheckIfSmEnabled)</HistoryEntry>
		<HistoryEntry Editor="F.H." TestVersion="0.0.2" Date="2014-02-02">Add ExtractEnabledSmFromList (before GetAllEnabledSm)</HistoryEntry>
		<HistoryEntry Editor="F.H." TestVersion="0.0.2" Date="2014-02-02">Add GetListOfEnabledInputOrOutputSm (before GetAllEnabledOutputSm)</HistoryEntry>
		<HistoryEntry Editor="F.H." TestVersion="0.0.2" Date="2014-02-03">Add GetListOfAllEnabledSm (before GetAllEnabledPdSm)</HistoryEntry>
		<HistoryEntry Editor="F.H." TestVersion="0.0.2" Date="2014-02-03">Add CheckIfInputAndOutputHandlerStopped (before InOutputHandlerStopped)</HistoryEntry>
		<HistoryEntry Editor="F.H." TestVersion="0.0.2" Date="2014-02-03">Add LocalOutputHandlerStartedInfo (before LocalOutputHandlerStarted)</HistoryEntry>
		<HistoryEntry Editor="F.H." TestVersion="0.0.2" Date="2014-02-04">Add LocalOutputHandlerStoppedInfo (before LocalOutputHandlerStopped)</HistoryEntry>
		<HistoryEntry Editor="F.H." TestVersion="0.0.2" Date="2014-02-04">Add CheckIfMbxHandlerStarted (before MbxHandlerStarted)</HistoryEntry>
		<HistoryEntry Editor="F.H." TestVersion="0.0.2" Date="2014-02-04">Add CheckIfMbxHandlerStopped (before MbxHandlerStopped)</HistoryEntry>
		<HistoryEntry Editor="F.H." TestVersion="0.0.2" Date="2014-02-28">Add test functions SetPreOpTimeout, SetSafeOpTimeout, SetBackSafeOpTimeout, SetBackInitTimeout</HistoryEntry>
		<HistoryEntry Editor="FH" TestVersion="0.0.2" Date="2014-06-23" Id="EN_BF_12xx_140623_1" Type="Bug">_Where: TestFunction "VerifyAlStatusCode"
_Description: In the logger output the value of the "Read AL Status Code" was the fexpectedAlStatusCode2
_Solution: use Param2=VerifyAlStatusCode.uint16ActualAlStatusCode</HistoryEntry>
		<HistoryEntry Editor="FH" TestVersion="0.0.2" Date="2014-06-23" Id="EN_BF_12xx_140623_2" Type="Bug">_Where: TestFunction "VerifyAlStatusAndAlStatusCode"
_Description: In the logger output the value of the "Read AL Status Code" was the fexpectedAlStatusCode2
_Solution: use Param2=VerifyAlStatusCode.uint16ActualAlStatusCode</HistoryEntry>
		<HistoryEntry Editor="FH" TestVersion="0.0.2" Date="2014-06-23" Id="EN_BF_12xx_140623_3" Type="Enhancement">_Where: TestFunction "VerifyAlStatusCode"
_Description: Added ActualAlStatus and ExpectedAlStatus to parameters</HistoryEntry>
		<HistoryEntry Editor="FH" TestVersion="0.0.2" Date="2014-06-27" Id="EN_BF_12xx_140627_1" Type="Enhancement">_Where: TestFunction "SkipTestIfDeviceEmulationActive"
_Description: Using CTT variable Esc.DeviceEmulation rather than reading register 0x0141 again.</HistoryEntry>
		<HistoryEntry TestVersion="0.0.3" Date="2014-11-20" Type="Enhancement" Editor="F.H.">Added GetAndVerifyAlStatusAndXStatusCodes which tests unlimited number of AL Status Codes (for #49)</HistoryEntry>
		<HistoryEntry Editor="F.H." TestVersion="0.0.3" Date="2014-11-24" Type="Enhancement">Added SkipTestIfCurrentConfigRequiresDcAndNoCu</HistoryEntry>
		<HistoryEntry Editor="F.H." TestVersion="0.0.3" Date="2015-02-13" Type="Enhancement">Added SkipTestIfPreOpSafeOpStartUpCmdsRequired and CheckIfPreOpSafeOpStartUpCmdsRequired</HistoryEntry>
		<HistoryEntry Editor="F.H." TestVersion="0.0.3" Date="2015-02-19" Type="Enhancement">Add SetBootstrapMbxSyncManSettings (previously SetSm01Boot)</HistoryEntry>
		<HistoryEntry Editor="F.H." TestVersion="0.0.3" Date="2015-02-19" Type="Enhancement">Add SetMailboxSyncManSettings (previously SetSmSettings01)</HistoryEntry>
		<HistoryEntry Editor="F.H." TestVersion="0.0.3" Date="2015-02-20" Type="Enhancement">Add GetAllOutputSyncMan (previously GetAllOutputSm)</HistoryEntry>
		<HistoryEntry Editor="F.H." TestVersion="0.0.3" Date="2015-02-23" Type="Enhancement">Add GetAllInputSyncMan (previously GetAllInputSm)</HistoryEntry>
		<HistoryEntry Editor="F.H." TestVersion="0.0.3" Date="2015-02-24" Type="Enhancement">Add GetAllEnabledInputSyncMan (previously GetAllEnabledInputSm)</HistoryEntry>
		<HistoryEntry Editor="F.H." TestVersion="0.0.3" Date="2015-02-24" Type="Enhancement">Add GetAllEnabledSyncMan (previously GetAllEnabledSm)</HistoryEntry>
		<HistoryEntry Editor="F.H." TestVersion="0.0.3" Date="2015-02-24" Type="Enhancement">Add CheckIfSyncManEnabled (previously CheckIfSmenabled)</HistoryEntry>
		<HistoryEntry Editor="F.H." TestVersion="0.0.3" Date="2015-02-24" Type="Enhancement">Added LocalOutputHandlerStarted (previously same name)</HistoryEntry>
		<HistoryEntry Editor="F.H." TestVersion="0.0.3" Date="2015-03-02" Type="Enhancement">Added LocalOutputHandlerStoppedInInit (previously LocalOutputHandlerStoppedInit)</HistoryEntry>
		<HistoryEntry Editor="F.H." TestVersion="0.0.3" Date="2015-03-03" Type="Enhancement">Added ExtractAllEnabledSm (previously GetAllEnabledSm)</HistoryEntry>
		<HistoryEntry Editor="F.H." TestVersion="0.0.3" Date="2015-03-05" Type="Enhancement">_Where: SkipTestIfPreOpSafeOpStartUpCmdsRequired
_Description: verify that ESI element Mailbox:Coe supported and return if not</HistoryEntry>
		<HistoryEntry Editor="F.H." TestVersion="0.0.3" Date="2015-03-05" Type="Enhancement">Added VerifyInOutputHandlerStarted (previously InOutputHandlerStarted)</HistoryEntry>
		<HistoryEntry Editor="F.H." TestVersion="0.0.3" Date="2015-03-05" Type="Enhancement">Added VerifyInOutputHandlerStopped (previously InOutputHandlerStopped)</HistoryEntry>
		<HistoryEntry Editor="F.H." TestVersion="0.0.3" Date="2015-03-05" Type="Enhancement">Delete VerifyInOutputHandlerStopped and VerifyInOutputHandlerStoppedInit (Functionality of (GetListOfAllEnabledSm+CheckIfInputAndOutputHandlerStopped)</HistoryEntry>
		<HistoryEntry Editor="F.H." TestVersion="0.0.3" Date="2015-03-05" Type="Enhancement">Added SetSyncManSettingsAccToPdoLength</HistoryEntry>
		<HistoryEntry Editor="F.H." TestVersion="0.0.3" Date="2015-03-05" Type="Enhancement">Added SetWrongSyncManSettings</HistoryEntry>
		<HistoryEntry Editor="F.H." TestVersion="0.0.3" Date="2015-03-05" Type="Enhancement">Added VerifySyncManChannelDisabled</HistoryEntry>
		<HistoryEntry Editor="F.H." TestVersion="0.0.3" Date="2015-03-09" Type="Enhancement">Added SkipIfNotTf1201OrReg134NotSupported</HistoryEntry>
		<HistoryEntry Editor="F.H." TestVersion="0.0.3" Date="2015-03-09" Type="Enhancement">_Where: CheckIfPreOpSafeOpStartUpCmdsRequired
Description: Add missing check for root elements of PdoAssign
</HistoryEntry>
		<HistoryEntry Editor="F.H." TestVersion="0.0.3" Date="2015-03-13" Type="Enhancement">Added ReturnErrorIfCurrentConfigRequiresDcAndNoCu</HistoryEntry>
		<HistoryEntry Editor="F.H." TestVersion="0.0.3" Date="2015-03-24" Type="Enhancement">VerifyAlStatusCode: If test is performed as TF-1201 then skip warning that ErrofFlag = 0 and AL StatusCode unequal 0</HistoryEntry>
		<HistoryEntry Editor="F.H." TestVersion="0.0.4" Date="2015-09-02" Type="Enhancement">Update Schema version to 1.0.23</HistoryEntry>
		<HistoryEntry Editor="F.H." TestVersion="0.0.5" Date="2015-11-05" Type="Bug">GetAndVerifyAlStatusAndXStatusCodes: undefined variable used in Info-Message in case an invalid AL Status was returned. . Info Message was redundant. For this reason it was removed.</HistoryEntry>
		<HistoryEntry Editor="B.L." TestVersion="0.0.6" Date="2016-02-17" Id="EN_BF_12xx_160217" Type="Enhancement">Update to Schema version 1.0.24</HistoryEntry>
		<HistoryEntry Editor="F.H." TestVersion="0.0.9" Date="2016-05-24" Type="Enhancement">Add support for complex slaves which do not have mailbox SyncManagers:
- add function SetSmStartAdd0x0AndLength0x2 and call it in SetWrongSyncManSettings
- add ReturnIfNoMailboxSupported to function CheckIfMbxHandlerStopped</HistoryEntry>
		<HistoryEntry Editor="F.H." TestVersion="0.0.10" Date="2016-05-30" Type="Bug">Where: CheckIfMbxHandlerStopped
Description: Missing CHECKENABLE jump mark added</HistoryEntry>
		<HistoryEntry Editor="F.H." TestVersion="0.0.11" Date="2017-01-25" Type="Enhancement">Where: VerifySyncManChannelDisabled
Description: Checking of PD-SyncManager was fixed to SyncManager2 and SyncManager3. For slaves which do not have a Mailbox but DevEmu = FALSE a serious error occured
Solution: Check for first and second Process Data SycnManager</HistoryEntry>
		<HistoryEntry Editor="F.E." TestVersion="0.0.12" Date="2017-03-23" Type="Enhancement">Where: SetSyncManSettingsAccToPdoLength (used in TF-1200 #17)
Description: If the SyncManager Start Address is changed due to a specific configuraiton (e.g. PD length of a SyncManager would exceed the current maximum length) the test might fail because the SyncManager start address is taken from the ESI file rather than from the current configuration (e.g. imported slave description)
Solution: Use SyncManager Start Address of current config (CurrentConfig.SM[i].StartAddress). Also add CurrentConfig.SM[i].ControlByte</HistoryEntry>
		<HistoryEntry Editor="F.E." TestVersion="0.0.13" Date="2017-03-24" Type="Enhancement">Where: SetSmStartAdd0x0AndLength0x2
Description: To set invalid SyncManager start address in case only one SyncManager is supported, it is not possible to use the SynManager start address of another enabled SyncManager - nor can register address 0x0000 be used
Solution: Use reserved address 0x0018:0x0019; manipulate correct SyncManager (sm+1 was manipulated)</HistoryEntry>
		<HistoryEntry Editor="F.E." TestVersion="0.0.14" Date="2017-04-06" Type="Bug">Where: SetSyncManSettingsAccToPdoLength (used in TF-1200 #17)
Description: Fix Typo (SM&gt;Sm): CurrentConfig.Sm[i].StartAddress; CurrentConfig.Sm[i].ControlByte</HistoryEntry>
		<HistoryEntry Editor="F.E." TestVersion="0.0.15" Date="2017-04-21" Type="Enhancement">- Adopt EtherCATTest:Name = EtherCAT State Machine Base Test Functions
- Remove Development Writeline in SetSyncManSettingsAccToPdoLength </HistoryEntry>
		<HistoryEntry Editor="F.E." TestVersion="0.0.16" Date="2017-05-03" Type="Enhancement">Where: GetAndVerifyAlStatusAndStatusCode
Description: Updated Outputs to indicate where the information for the expected IAL Status Code (0x1D for Outputs, 0x1E for Inputs) comes from (ESI Sm:ControlByte)</HistoryEntry>
		<HistoryEntry Editor="F.E." TestVersion="0.0.17" Date="2017-07-04" Type="Enhancement">Where: SkipTestIfCurrentConfigRequiresDcAndNoCu, ReturnErrorIfCurrentConfigRequiresDcAndNoCu
Description: Add Verbose Level to message that test can be performed when Cu is available</HistoryEntry>
		<HistoryEntry Editor="F.E." TestVersion="0.0.17" Date="2017-07-13" Type="Enhancement">Where: ReturnErrorIfCurrentConfigRequiresDcAndNoCu
Description: Fix check of CU to generate Error if non available</HistoryEntry>
		<HistoryEntry Editor="F.E." TestVersion="0.0.19" Date="2017-07-24" Type="Enhancement">_Description: Added ReadDcSysTime to Read 0x0910 and 0x0990 and prompt in in the Test Log</HistoryEntry>
		<HistoryEntry Editor="F.E." TestVersion="0.0.21" Date="2017-08-31" Type="Bug">_Where: SetBackInitTimeout/ SetBackSafeOpTimeout/ SetSafeOpTimeout
_Description: correct default value from 3000ms to 500/ 200/ 10000ms</HistoryEntry>
		<HistoryEntry TestVersion="0.0.22" Date="2017-09-06" Type="Bug" Editor="F.E.">_Where: VerifySyncManChannelDisabled
_Description: Fix syntac for parameter call (replace [ by {)</HistoryEntry>
		<HistoryEntry Editor="F.E." TestVersion="0.0.23" Date="2017-10-16" Type="Enhancement">_Where :ReturnErrorIfCurrentConfigRequiresDcAndNoCu
_Description: Add check if CurrentConfig.DcOpMode and CurrentConfig.DcAssignActivate are available and return or generate error if not. Skip test if not a DC device.</HistoryEntry>
		<HistoryEntry Editor="F.E." TestVersion="0.0.24" Date="2017-10-19" Type="Enhancement">_Where: ReadDcSysTime
_Description: ns-time outputs (activation via settings dialog) also printed in ms</HistoryEntry>
		<HistoryEntry Editor="F.E." TestVersion="0.0.25" Date="2017-10-28" Type="Bug">_Where :ReturnErrorIfCurrentConfigRequiresDcAndNoCu
_Description: Add DcSpecificTest check</HistoryEntry>
		<HistoryEntry Editor="F.E." TestVersion="0.0.27" Date="2017-10-30" Type="Enhancement">_Where :ReturnErrorIfCurrentConfigRequiresDcAndNoCu
_Description: Remove "PerformTestAnyways" check</HistoryEntry>
		<HistoryEntry Editor="B.L." TestVersion="0.0.28" Date="2018-09-14">Add output IDs and update Schema version to 1.0.31</HistoryEntry>
		<HistoryEntry Editor="F.E." TestVersion="0.0.29" Date="2017-11-09" Type="Enhancement">_Where: SetSyncManSettingsAccToPdoLength
_Desc: Read SyncMan-registers of currently set SyncMan before and after configuration (for debugging)</HistoryEntry>
		<HistoryEntry TestVersion="0.0.30" Date="2018-11-12" Editor="F.L." Type="Enhancement">TestFunction 401, Error 12: Changed Param2 to Param1. TestFunction 401, Error 16: Removed unused Param3. TestFunction 908, Error 4 and 5: Changed Param1 to Param0.</HistoryEntry>
		<HistoryEntry TestVersion="0.0.31" Date="2018-12-14" Editor="F.E." Type="Enhancement">Added Test Function IsSmKnown</HistoryEntry>
		<HistoryEntry TestVersion="0.0.32" Date="2019-01-22" Editor="G.E." Type="Bug">TestFunction 1203, Error 4: Corrected Param1 from VerifyInOutputHandlerStarted.byte_VerifySyncManChannelDisabled.uint16_smAdo to VerifyInOutputHandlerStarted.uint16_VerifySyncManChannelDisabled.uint16_smAdo.</HistoryEntry>
		<HistoryEntry TestVersion="0.0.32" Date="2019-05-02" Editor="F.E." Type="Enhancement">For release with CTT V2.2 set version to 1.0.0</HistoryEntry>
	</History>
	<TestFunctions>
		<TestFunction FunctionId="101" Name="CheckIfInputAndOutputHandlerStopped">
			<?MAX_OUTPUT_ID 6?>
			<Description>
				<Purpose>Checks for the list of SyncManager provided if they have been stopped

(previously InOutputHandlerStoppedInit and InOutputHandlerStopped. Now, the list of SyncManager have to be provided)
Function returns if no PdSm available</Purpose>
				<PreCondition>- length of provided SyncManager list greater 0: otherwise check is skipped</PreCondition>
				<Action></Action>
				<PostCondition>Generate Error if the SyncManager is supposed to be stopped but is not stopped</PostCondition>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>CheckIfInputAndOutputHandlerStopped.b_DebugMsg</Name>
				<Type>Bool</Type>
				<Comment>Write debug message to logger</Comment>
			</Parameter>
			<Parameter>
				<Name>CheckIfInputAndOutputHandlerStopped.ArrayOfBytes_listOfEnabledSms</Name>
				<Type>ArrayOfBytes</Type>
				<Comment>List of SyncManagers (input and output) that shall be checked by this function</Comment>
			</Parameter>
			<LocalVariables>
				<Name>CheckIfInputAndOutputHandlerStopped.uint32_lengthOfList</Name>
				<Type>UInt32</Type>
				<DefaultValue>#x00</DefaultValue>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckIfInputAndOutputHandlerStopped.uint32_smIndex</Name>
				<Type>UInt32</Type>
				<DefaultValue>#x00</DefaultValue>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckIfInputAndOutputHandlerStopped.byte_smNumber</Name>
				<Type>Byte</Type>
				<DefaultValue>#x00</DefaultValue>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckIfInputAndOutputHandlerStopped.uint16_VerifySyncManChannelDisabled.uint16_smAdo</Name>
				<Type>UInt16</Type>
				<DefaultValue>#x00</DefaultValue>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckIfInputAndOutputHandlerStopped.byte_smControl</Name>
				<Type>Byte</Type>
				<DefaultValue>#x00</DefaultValue>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckIfInputAndOutputHandlerStopped.b_smDeactivate</Name>
				<Type>Bool</Type>
				<DefaultValue>true</DefaultValue>
			</LocalVariables>
			<TestStep Name="DebugOutputThatFunctionStarted">
				<Compare>
					<Equal>
						<Value1>CheckIfInputAndOutputHandlerStopped.b_DebugMsg</Value1>
						<Value2>true</Value2>
						<WriteLine Id="0">  "CheckIfInputAndOutputHandlerStopped" started</WriteLine>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="ReturnIfNoEnabledSmSupported">
				<SizeOf UInt32Var="CheckIfInputAndOutputHandlerStopped.uint32_lengthOfList">CheckIfInputAndOutputHandlerStopped.ArrayOfBytes_listOfEnabledSms</SizeOf>
			</TestStep>
			<TestStep>
				<Compare>
					<Equal>
						<Value1>CheckIfInputAndOutputHandlerStopped.uint32_lengthOfList</Value1>
						<Value2>0</Value2>
						<Return Id="1">No enabled process data SyncManager available. Checking if Input and/ or Output handler are stopped not necessary.</Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="GET_SM_NUMBER_FROM_LIST">
				<GetArrayItem Index="CheckIfInputAndOutputHandlerStopped.uint32_smIndex" SourceArray="CheckIfInputAndOutputHandlerStopped.ArrayOfBytes_listOfEnabledSms" Target="CheckIfInputAndOutputHandlerStopped.byte_smNumber"></GetArrayItem>
			</TestStep>
			<TestStep Name="ReadPdiSmControlRegisterOffset0x07FromEsc">
				<SetVariable Target="CheckIfInputAndOutputHandlerStopped.uint16_VerifySyncManChannelDisabled.uint16_smAdo">#x807+8*CheckIfInputAndOutputHandlerStopped.byte_smNumber</SetVariable>
				<WriteLine Id="2" Level="Verbose" Param0="CheckIfInputAndOutputHandlerStopped.uint16_VerifySyncManChannelDisabled.uint16_smAdo" Param1="CheckIfInputAndOutputHandlerStopped.byte_smNumber">Read PDI Control Register 0x{0:x2} of SyncManager{1}</WriteLine>
			</TestStep>
			<TestStep Name="ReturnErrorIfRegisterAccessWasNotPossible">
				<ReadEscData Target="CheckIfInputAndOutputHandlerStopped.byte_smControl">
					<Address>CheckIfInputAndOutputHandlerStopped.uint16_VerifySyncManChannelDisabled.uint16_smAdo</Address>
				</ReadEscData>
				<RaiseErrorOnFailure Id="3" Param0="CheckIfInputAndOutputHandlerStopped.uint16_VerifySyncManChannelDisabled.uint16_smAdo">Failed to read Syncmanager PDI Control Register 0x{0:x4}!</RaiseErrorOnFailure>
			</TestStep>
			<TestStep Name="ReturnErrorIfSmHandlerWasNotStopped">
				<GetBits Source="CheckIfInputAndOutputHandlerStopped.byte_smControl" Target="CheckIfInputAndOutputHandlerStopped.b_smDeactivate">
					<Offset>0</Offset>
					<Length>1</Length>
				</GetBits>
				<Compare>
					<NotEqual>
						<Value1>CheckIfInputAndOutputHandlerStopped.b_smDeactivate</Value1>
						<Value2>true</Value2>
						<RaiseError Id="4" Param0="CheckIfInputAndOutputHandlerStopped.uint16_VerifySyncManChannelDisabled.uint16_smAdo" Param1="CheckIfInputAndOutputHandlerStopped.b_smDeactivate">Handler was not stopped || Register 0x{0:x4}:00:  Expected = true, Read = {1}.</RaiseError>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="WriteSuccessInfoToLogger">
				<WriteLine Id="5" Level="Verbose" Param0="CheckIfInputAndOutputHandlerStopped.byte_smNumber" Param1="CheckIfInputAndOutputHandlerStopped.uint16_VerifySyncManChannelDisabled.uint16_smAdo" Param2="CheckIfInputAndOutputHandlerStopped.b_smDeactivate">SM{0} handler stopped successfully || Value read from 0x{1:x4}:00 = {2}.</WriteLine>
			</TestStep>
			<TestStep Name="INCREMENT_SM_INDEX_AND_CHECK_IF_DONE">
				<SetVariable Target="CheckIfInputAndOutputHandlerStopped.uint32_smIndex">CheckIfInputAndOutputHandlerStopped.uint32_smIndex+1</SetVariable>
				<Compare>
					<Lower>
						<Value1>CheckIfInputAndOutputHandlerStopped.uint32_smIndex</Value1>
						<Value2>CheckIfInputAndOutputHandlerStopped.uint32_lengthOfList</Value2>
						<GotoStep>GET_SM_NUMBER_FROM_LIST</GotoStep>
					</Lower>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckIfInputAndOutputHandlerStopped.uint32_lengthOfList</Value1>
						<Value2>0</Value2>
						<WriteLine Id="6">  "CheckIfInputAndOutputHandlerStopped" done</WriteLine>
					</Equal>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="102" Name="CheckIfMbxHandlerStarted">
			<?MAX_OUTPUT_ID 12?>
			<Description>
				<Purpose>Check if Mailbox Handler was started, i.e. the "Deactivate SyncManger" bit of Register PDI Control SyncManager (+0x07.0) has to be false for SM0 and SM1.

If no Mailbox SMs are configured in the ESI file, the Enable attribute is false or the DefaultLength is 0 the MailboxHandlerStarted is not checked

If SyncManager0 AND SyncManager1 have the ESI element Sm@Enable = false then the MbxHandlerStarted is not checked

(previously MbxHandlerStarted)</Purpose>
				<Action></Action>
				<PostCondition></PostCondition>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>CheckIfMbxHandlerStarted.b_DebugMsg</Name>
				<Type>Bool</Type>
				<Comment>Write debug message to logger</Comment>
			</Parameter>
			<LocalVariables>
				<Name>CheckIfMbxHandlerStarted.byte_pdiControlSm0</Name>
				<Type>Byte</Type>
				<DefaultValue>#x00</DefaultValue>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckIfMbxHandlerStarted.byte_pdiControlSm1</Name>
				<Type>Byte</Type>
				<DefaultValue>#x00</DefaultValue>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckIfMbxHandlerStarted.b_sm0Deactivated</Name>
				<Type>Bool</Type>
				<DefaultValue>false</DefaultValue>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckIfMbxHandlerStarted.b_sm1Deactivated</Name>
				<Type>Bool</Type>
				<DefaultValue>false</DefaultValue>
			</LocalVariables>
			<TestStep Name="DebugOutputThatFunctionStarted">
				<Compare>
					<Equal>
						<Value1>CheckIfMbxHandlerStarted.b_DebugMsg</Value1>
						<Value2>true</Value2>
						<WriteLine Id="0">FUNCTION | Test function  "CheckIfMbxHandlerStarted" started</WriteLine>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="ReturnIfNoMailboxSupported">
				<Compare>
					<Equal>
						<Value1>DeviceDescr.SM[0]</Value1>
						<Value2>MBoxOut</Value2>
						<GotoStep>CHECKENABLE</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>DeviceDescr.SM[0]</Value1>
						<Value2>MBoxOut</Value2>
						<Return Id="1">No MailboxOut SyncManager configured in ESI file, i .e. device does not support Mailboxes and the check if Mailbox handler was started is skipped</Return>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.SM[0].Enable</Value1>
						<Value2>null</Value2>
						<RaiseError Id="2">ESI element DeviceDescr.SM[0].Enable is missing!</RaiseError>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.SM[1].Enable</Value1>
						<Value2>null</Value2>
						<RaiseError Id="3">ESI element DeviceDescr.SM[1].Enable is missing!</RaiseError>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>DeviceDescr.SM[0].EnableANDDeviceDescr.SM[1].Enable</Value1>
						<Value2>1</Value2>
						<Return Id="4" Param0="DeviceDescr.SM[0].Enable" Param1="DeviceDescr.SM[1].Enable">Mailbox SyncManagers 0 and 1 are disabled  | INFO: ESI element DeviceDescr.SM[0].Enable = {0}, DeviceDescr.SM[0].Enable = {1}</Return>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="CHECKENABLE">
				<!--If SM01 Enable element equal 0 skip MbxHandlerStarted-->
				<Compare>
					<Equal>
						<Value1>DeviceDescr.SM[0].Enable</Value1>
						<Value2>null</Value2>
						<Return Id="5">Mailbox SyncManagers are disabled (DeviceDescr.SM[0].Enable not available)  | Checking if Mailbox Handler was started is skipped</Return>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.SM[0].Enable</Value1>
						<Value2>false</Value2>
						<Return Id="6" Param0="DeviceDescr.SM[0].Enable">Mailbox SyncManagers are disabled (DeviceDescr.SM[0].Enable = {0}) | Checking if Mailbox Handler was started is skipped</Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CHECKIFSTARTED">
				<Description Id="7">Read Deactivate Bit of MbxOut SyncManager (Sm0) PDI Control register 0x0807.0 and check if false (= Handler Started)</Description>
				<!--0x0807 = ?-->
				<ReadEscData Target="CheckIfMbxHandlerStarted.byte_pdiControlSm0">
					<Address>#x807</Address>
				</ReadEscData>
				<RaiseErrorOnFailure Id="8">Failed to read PDI Control Register 0x0807!</RaiseErrorOnFailure>
			</TestStep>
			<TestStep Name="CheckIf0x0807Bit0Isfalse">
				<GetBits Source="CheckIfMbxHandlerStarted.byte_pdiControlSm0" Target="CheckIfMbxHandlerStarted.b_sm0Deactivated">
					<Offset>0</Offset>
					<Length>1</Length>
				</GetBits>
				<Compare>
					<NotEqual>
						<Value1>CheckIfMbxHandlerStarted.b_sm0Deactivated</Value1>
						<Value2>false</Value2>
						<RaiseError Id="9" Param0="CheckIfMbxHandlerStarted.b_sm0Deactivated">MbxOutputHandler not started || Register 0x0807:00: Expected = false, Read = {0}.</RaiseError>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="Read0x080FFromEsc">
				<Description Id="10">Read Deactivate Bit of MbxIn SyncManager (Sm1) PDI Control register 0x080F.0 and check if false (= Handler Started)</Description>
				<ReadEscData Target="CheckIfMbxHandlerStarted.byte_pdiControlSm1">
					<Address>#x80F</Address>
				</ReadEscData>
				<RaiseErrorOnFailure Id="11">Failed to read PDI Control Register 0x0807!</RaiseErrorOnFailure>
			</TestStep>
			<TestStep Name="CheckIf0x080FBit0Isfalse">
				<GetBits Source="CheckIfMbxHandlerStarted.byte_pdiControlSm1" Target="CheckIfMbxHandlerStarted.b_sm1Deactivated">
					<Offset>0</Offset>
					<Length>1</Length>
				</GetBits>
				<Compare>
					<NotEqual>
						<Value1>CheckIfMbxHandlerStarted.b_sm1Deactivated</Value1>
						<Value2>false</Value2>
						<RaiseError Id="12" Param0="CheckIfMbxHandlerStarted.b_sm1Deactivated">MbxInputHandler not started || Register 0x080F:00: Expected = false, Read = {0}.</RaiseError>
					</NotEqual>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="103" Name="CheckIfMbxHandlerStopped">
			<?MAX_OUTPUT_ID 12?>
			<Description>
				<Purpose>Reads the Deactivate SyncManager Bit in the PDI Control SyncManager register (+0x07.0). If Deactivate Bit is not true (sm deactivated) then an Error is raised

(previously MbxHandlerStopped)</Purpose>
				<Action></Action>
				<PostCondition></PostCondition>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>CheckIfMbxHandlerStopped.b_DebugMsg</Name>
				<Type>Bool</Type>
				<Comment>Write debug message to logger</Comment>
			</Parameter>
			<LocalVariables>
				<Name>CheckIfMbxHandlerStopped.byte_pdiControlSm0</Name>
				<Type>Byte</Type>
				<DefaultValue>#x00</DefaultValue>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckIfMbxHandlerStopped.byte_pdiControlSm1</Name>
				<Type>Byte</Type>
				<DefaultValue>#x00</DefaultValue>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckIfMbxHandlerStopped.b_pdiCntrlSmActivation0</Name>
				<Type>Bool</Type>
				<DefaultValue>true</DefaultValue>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckIfMbxHandlerStopped.b_pdiCntrlSmActivation1</Name>
				<Type>Bool</Type>
				<DefaultValue>true</DefaultValue>
			</LocalVariables>
			<TestStep Name="DebugOutputThatFunctionStopped">
				<Compare>
					<Equal>
						<Value1>CheckIfMbxHandlerStopped.b_DebugMsg</Value1>
						<Value2>true</Value2>
						<WriteLine Id="0">FUNCTION | Test function  "CheckIfMbxHandlerStopped" started</WriteLine>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="ReturnIfNoMailboxSupported">
				<Compare>
					<Equal>
						<Value1>DeviceDescr.SM[0]</Value1>
						<Value2>MBoxOut</Value2>
						<GotoStep>CHECKENABLE</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>DeviceDescr.SM[0]</Value1>
						<Value2>MBoxOut</Value2>
						<Return Id="1">No MailboxOut SyncManager configured in ESI file, i .e. device does not support Mailboxes and the check if Mailbox handler was started is skipped</Return>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.SM[0].Enable</Value1>
						<Value2>null</Value2>
						<RaiseError Id="2">ESI element DeviceDescr.SM[0].Enable is missing!</RaiseError>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.SM[1].Enable</Value1>
						<Value2>null</Value2>
						<RaiseError Id="3">ESI element DeviceDescr.SM[1].Enable is missing!</RaiseError>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>DeviceDescr.SM[0].EnableANDDeviceDescr.SM[1].Enable</Value1>
						<Value2>1</Value2>
						<Return Id="4" Param0="DeviceDescr.SM[0].Enable" Param1="DeviceDescr.SM[1].Enable">Mailbox SyncManagers 0 and 1 are disabled  | INFO: ESI element DeviceDescr.SM[0].Enable = {0}, DeviceDescr.SM[0].Enable = {1}</Return>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="CHECKENABLE">
				<!--MBX_Handler stopped ?:  Check Deactivation Bit for SM0-->
				<Description Id="5" Param0="">Read SyncManager0 PDI Control register 0x807 from ESC</Description>
				<ReadEscData Target="CheckIfMbxHandlerStopped.byte_pdiControlSm0">
					<Address>#x0807</Address>
				</ReadEscData>
				<RaiseErrorOnFailure Id="6">Failed to read register 0x0807 when checking if mailbox handler was stopped.</RaiseErrorOnFailure>
			</TestStep>
			<TestStep>
				<!--    -->
				<Description Id="7">Check if SyncManager0 was disabled by host controller, i.e. 0x0807.0 = true (= MbxOutHandler stopped)</Description>
				<GetBits Source="CheckIfMbxHandlerStopped.byte_pdiControlSm0" Target="CheckIfMbxHandlerStopped.b_pdiCntrlSmActivation0">
					<Offset>0</Offset>
					<Length>1</Length>
				</GetBits>
				<Compare>
					<NotEqual>
						<Value1>CheckIfMbxHandlerStopped.b_pdiCntrlSmActivation0</Value1>
						<Value2>true</Value2>
						<RaiseError Id="8" Param0="CheckIfMbxHandlerStopped.b_pdiCntrlSmActivation0">Output Mailbox Handler not stopped || Register 0x0807:00: Expected = true, Read = {0}</RaiseError>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep>
				<!--MBX_Handler stopped ?:  Check Deactivation Bit for SM1-->
				<Description Id="9">Read SyncManager0 PDI Control register 0x80E from ESC</Description>
				<ReadEscData Target="CheckIfMbxHandlerStopped.byte_pdiControlSm1">
					<Address>#x080F</Address>
				</ReadEscData>
				<RaiseErrorOnFailure Id="10">Failed to read register 0x080F when checking if mailbox handler was stopped.</RaiseErrorOnFailure>
			</TestStep>
			<TestStep>
				<!--    -->
				<Description Id="11">Check if SyncManager1 was disabled by host controller, i.e. 0x080F.0 = true (= MbxInHandler stopped)</Description>
				<GetBits Source="CheckIfMbxHandlerStopped.byte_pdiControlSm1" Target="CheckIfMbxHandlerStopped.b_pdiCntrlSmActivation1">
					<Offset>0</Offset>
					<Length>1</Length>
				</GetBits>
				<Compare>
					<NotEqual>
						<Value1>CheckIfMbxHandlerStopped.b_pdiCntrlSmActivation1</Value1>
						<Value2>true</Value2>
						<RaiseError Id="12" Param0="CheckIfMbxHandlerStopped.b_pdiCntrlSmActivation1">Input Maiblox Handler not stopped || Register 0x080F:00): Expected = true, Read = {0}</RaiseError>
					</NotEqual>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="104" Name="CheckIfPreOpSafeOpStartUpCmdsRequired">
			<?MAX_OUTPUT_ID 2?>
			<Description>
				<Purpose>Test goes from ErrPreOp to SafeOp.Therefore, start-up commands from PreOp to SafeOp cannot be sent.</Purpose>
				<PreCondition>ESI attributes PdoConfig, PdoAssign, Coe:InitCmds are used</PreCondition>
				<Action></Action>
				<PostCondition>Return bRequired = true if such start-up commands are required</PostCondition>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<OutParameter>
				<Name>CheckIfPreOpSafeOpStartUpCmdsRequired_bRequired</Name>
				<Type>Bool</Type>
				<Comment></Comment>
			</OutParameter>
			<TestStep>
				<SetVariable Target="CheckIfPreOpSafeOpStartUpCmdsRequired_bRequired">false</SetVariable>
			</TestStep>
			<TestStep>
				<Description Id="0" Level="Verbose">Test goes from ErrPreOp to SafeOp.Therefore, start-up commands from PreOp to SafeOp cannot be sent. Check if this part of the test needs to be skipped in such a case.</Description>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Mailbox</Value1>
						<Value2>false</Value2>
						<Return Id="1"></Return>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Mailbox.CoE</Value1>
						<Value2>false</Value2>
						<Return Id="2"></Return>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Mailbox.CoE.PdoAssign</Value1>
						<Value2>true</Value2>
						<SetVariable Target="CheckIfPreOpSafeOpStartUpCmdsRequired_bRequired">true</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Mailbox.CoE.PdoConfig</Value1>
						<Value2>true</Value2>
						<SetVariable Target="CheckIfPreOpSafeOpStartUpCmdsRequired_bRequired">true</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>DeviceDescr.Mailbox.CoE.InitCmd.Count</Value1>
						<Value2>0</Value2>
						<SetVariable Target="CheckIfPreOpSafeOpStartUpCmdsRequired_bRequired">true</SetVariable>
					</NotEqual>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="105" Name="CheckIfSyncManEnabled">
			<?MAX_OUTPUT_ID 7?>
			<Description>
				<Purpose>(Previously CheckifSmEnabled)
- Check if SyncManager specified by smNumber is described in ESI file</Purpose>
				<PreCondition>- Slave must support mailbox communication if Esi:PdoUpload = true
- SyncManager provided to the function described in ESI file</PreCondition>
				<Action>- Check if PdoUpload in ESI file is true. In this case upload PDO configuration from slave
- If PdoUpload is false use PdoConfiguration from ESI file
- Check if PDO length of this SyncManager is greater 0</Action>
				<PostCondition>Return smDisabled: if true = PDO length is unequal 0</PostCondition>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>CheckIfSyncManEnabled_byteSyncManNumber</Name>
				<Type>Byte</Type>
				<Comment>Check if this SyncManager shall be enabled</Comment>
			</Parameter>
			<LocalVariables>
				<Name>CheckIfSyncManEnabled_uint32DefaultPdLength</Name>
				<Type>UInt32</Type>
			</LocalVariables>
			<OutParameter>
				<Name>CheckIfSyncManEnabled_bSyncManDisabled</Name>
				<Type>Bool</Type>
				<Comment>- smDisabled (if 1: pdoLength = 0)</Comment>
			</OutParameter>
			<TestStep Name="InitSyncManDisabled">
				<Description Id="0" Level="Verbose">TEST FUNCTION "CheckIfSyncManEnabled" start</Description>
				<SetVariable Target="CheckIfSyncManEnabled_bSyncManDisabled">true</SetVariable>
			</TestStep>
			<TestStep Name="LoggerInfo_WhichSyncManIsTested">
				<WriteLine Id="1" Param0="smNumber" Level="Verbose">TEST FUNCTION "CheckIfSyncManEnabled" |  Check if SyncManager{0} is enabled (according to PDO length)</WriteLine>
			</TestStep>
			<TestStep Name="CheckIfPdoUploadSetInEsi">
				<Description Id="2" Level="Verbose">Check if ESI element Mailbox:Coe@PdoUpload is available and if true</Description>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Mailbox</Value1>
						<Value2>false</Value2>
						<GotoStep>PDOUPLOADfalse</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Mailbox.CoE</Value1>
						<Value2>false</Value2>
						<GotoStep>PDOUPLOADfalse</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Mailbox.CoE.PdoUpload</Value1>
						<Value2>false</Value2>
						<GotoStep>PDOUPLOADfalse</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="PDOUPLOADtrue_GetDefaultPdoLengthFromOnlineOd">
				<GetMaxPdoLength SyncMan="CheckIfSyncManEnabled_byteSyncManNumber" Int32Var="CheckIfSyncManEnabled_uint32DefaultPdLength" Source="OD"></GetMaxPdoLength>
			</TestStep>
			<TestStep Name="LengthOfSmNumberUnequal0">
				<Description Id="3" Param0="defaultPdLength" Level="Verbose">Since PDO length is {0}...</Description>
				<Compare>
					<Equal>
						<Value1>CheckIfSyncManEnabled_uint32DefaultPdLength</Value1>
						<Value2>0</Value2>
						<Return Id="4" Param0="CheckIfSyncManEnabled_byteSyncManNumber" Param1="CheckIfSyncManEnabled_bSyncManDisabled" Param2="CheckIfSyncManEnabled_uint32DefaultPdLength">SyncManager{0}: According to PDO length ({2} byte) Disable = {1}</Return>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>SMENABLED</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="PDOUPLOADfalse">
				<Description Id="5" Param0="CheckIfSyncManEnabled_byteSyncManNumber" Level="Verbose">Check in ESI file if SyncMan{0} enabeld</Description>
				<GetMaxPdoLength SyncMan="CheckIfSyncManEnabled_byteSyncManNumber" Int32Var="CheckIfSyncManEnabled_uint32DefaultPdLength" Source="CurrentConfig"></GetMaxPdoLength>
				<Compare>
					<Greater>
						<Value1>CheckIfSyncManEnabled_uint32DefaultPdLength</Value1>
						<Value2>0</Value2>
						<GotoStep>SMENABLED</GotoStep>
					</Greater>
				</Compare>
			</TestStep>
			<TestStep Name="Logger_SmDisabled">
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<Return Id="6" Param0="CheckIfSyncManEnabled_byteSyncManNumber" Param1="CheckIfSyncManEnabled_bSyncManDisabled" Param2="CheckIfSyncManEnabled_uint32DefaultPdLength">SyncManager{0}: According to PDO length ({2} byte) Disable = {1}</Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="SMENABLED">
				<SetVariable Target="CheckIfSyncManEnabled_bSyncManDisabled">false</SetVariable>
				<WriteLine Id="7" Param0="CheckIfSyncManEnabled_byteSyncManNumber" Param1="CheckIfSyncManEnabled_bSyncManDisabled" Param2="CheckIfSyncManEnabled_uint32DefaultPdLength" Level="Verbose">TEST FUNCTION "CheckIfSmEnabled" |  SyncManager{0}: According to PDO length ({2} byte) Disable = {1}</WriteLine>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="106" Name="CheckIfThisSmEnabled">
			<?MAX_OUTPUT_ID 4?>
			<Description>
				<Purpose>- Check if SyncManager specified by smNumber is described in ESI file
- Check if SyncManager length &gt; 0: if PdoUpload = false. check ESI file, if PdoUpload = true check process data configuration for this SyncManager online</Purpose>
				<Action></Action>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>CheckIfThisSmEnabled.b_DebugMsg</Name>
				<Type>Bool</Type>
				<Comment>Write debug message to logger</Comment>
			</Parameter>
			<Parameter>
				<Name>CheckIfThisSmEnabled.byte_smNumber</Name>
				<Type>Byte</Type>
				<Comment>smNumber</Comment>
			</Parameter>
			<LocalVariables>
				<Name>CheckIfThisSmEnabled.uint32_defaultPdLength</Name>
				<Type>UInt32</Type>
				<DefaultValue>#x00</DefaultValue>
				<Comment>defaultPdLength</Comment>
			</LocalVariables>
			<OutParameter>
				<Name>CheckIfThisSmEnabled.b_smDisabled</Name>
				<Type>Bool</Type>
				<DefaultValue>false</DefaultValue>
				<Comment>smDisabled
1: pdoLength = 0</Comment>
			</OutParameter>
			<TestStep Name="DebugLoggerOutputThatFunctionStarted">
				<Compare>
					<Equal>
						<Value1>CheckIfThisSmEnabled.b_DebugMsg</Value1>
						<Value2>true</Value2>
						<WriteLine Id="0">  "CheckIfThisSmEnabled" started</WriteLine>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CheckIfEsiElementPdoUploadIstrue">
				<Compare>
					<Equal>
						<Value1>CheckIfThisSmEnabled.b_DebugMsg</Value1>
						<Value2>true</Value2>
						<WriteLine Id="1">  "CheckIfThisSmEnabled"  | Check if ESI element Mailbox:Coe@PdoUpload available and if true</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Mailbox</Value1>
						<Value2>false</Value2>
						<GotoStep>PDOUPLOADfalse</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Mailbox.CoE</Value1>
						<Value2>false</Value2>
						<GotoStep>PDOUPLOADfalse</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Mailbox.CoE.PdoUpload</Value1>
						<Value2>false</Value2>
						<GotoStep>PDOUPLOADfalse</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="PDOUPLOADtrue">
				<!--CheckPdoLengthForThisSynchManagerOnline-->
				<GetMaxPdoLength SyncMan="CheckIfThisSmEnabled.byte_smNumber" Int32Var="CheckIfThisSmEnabled.uint32_defaultPdLength" Source="OD"></GetMaxPdoLength>
				<Compare>
					<Equal>
						<Value1>CheckIfThisSmEnabled.b_DebugMsg</Value1>
						<Value2>true</Value2>
						<WriteLine Id="2">  "CheckIfThisSmEnabled" | Mailbox@PdoUpload = true</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckIfThisSmEnabled.uint32_defaultPdLength</Value1>
						<Value2>0</Value2>
						<SetVariable Target="CheckIfThisSmEnabled.b_smDisabled">true</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckIfThisSmEnabled.uint32_defaultPdLength</Value1>
						<Value2>0</Value2>
						<GotoStep>LOGGER_OUTPUT</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckIfThisSmEnabled.uint32_defaultPdLength</Value1>
						<Value2>0</Value2>
						<SetVariable Target="CheckIfThisSmEnabled.b_smDisabled">false</SetVariable>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckIfThisSmEnabled.uint32_defaultPdLength</Value1>
						<Value2>0</Value2>
						<GotoStep>LOGGER_OUTPUT</GotoStep>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="PDOUPLOADfalse">
				<!--Check in ESI if Sm Enabled-->
				<GetMaxPdoLength SyncMan="CheckIfThisSmEnabled.byte_smNumber" Int32Var="CheckIfThisSmEnabled.uint32_defaultPdLength" Source="CurrentConfig"></GetMaxPdoLength>
				<Compare>
					<Equal>
						<Value1>CheckIfThisSmEnabled.b_DebugMsg</Value1>
						<Value2>true</Value2>
						<WriteLine Id="3">  "CheckIfThisSmEnabled" | Mailbox@PdoUpload = false</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckIfThisSmEnabled.uint32_defaultPdLength</Value1>
						<Value2>0</Value2>
						<SetVariable Target="CheckIfThisSmEnabled.b_smDisabled">true</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckIfThisSmEnabled.uint32_defaultPdLength</Value1>
						<Value2>0</Value2>
						<GotoStep>LOGGER_OUTPUT</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckIfThisSmEnabled.uint32_defaultPdLength</Value1>
						<Value2>0</Value2>
						<SetVariable Target="CheckIfThisSmEnabled.b_smDisabled">false</SetVariable>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckIfThisSmEnabled.uint32_defaultPdLength</Value1>
						<Value2>0</Value2>
						<GotoStep>LOGGER_OUTPUT</GotoStep>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="LOGGER_OUTPUT">
				<WriteLine Id="4" Param0="CheckIfThisSmEnabled.byte_smNumber" Param1="CheckIfThisSmEnabled.b_smDisabled" Param2="CheckIfThisSmEnabled.uint32_defaultPdLength" Level="Verbose">SyncManager{0}: According to PDO length ({2} byte) Disable = {1}</WriteLine>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="201" Name="ExtractAllEnabledSm">
			<?MAX_OUTPUT_ID 2?>
			<Description>
				<Purpose>Receives a list of SyncManagers and extracts those which shall be enabled according to their SyncManager/ PDO length. Return value is a list of enabled process data SyncManagersMakes.

#### Previous function GetAllEnabledSm
Parameter:
- allSm (all SM which shall be checked if enabled)
- smCount (number of SMs in the array) ## deleted

Return values:
- allEnabledSm
- noEnabledSm ## deleted
- enabledSmCount  ## deleted

#######</Purpose>
				<PreCondition>- Slave must support mailbox communication if Esi:PdoUpload = true (function CheckIfSyncManEnabled)
- Parameter: List of SyncManagers</PreCondition>
				<Action>- Check if received list is longer than 0
- Get one SyncManager from the received list at a time 
- Check if this SyncManager is enabled acc. to its PDO length</Action>
				<PostCondition>- If SyncManager length is greater 0 it is added to the list of allEnabledSm</PostCondition>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>GetListOfAllEnabledSm_Settings.bAll_debugMsg</Name>
				<Type>Bool</Type>
			</Parameter>
			<Parameter>
				<Name>ExtractAllEnabledSm.ArrayOfBytes_allSm</Name>
				<Type>ArrayOfBytes</Type>
				<Comment>List of (enabled and not enabled )SyncManagers</Comment>
			</Parameter>
			<LocalVariables>
				<Name>ExtractAllEnabledSm.uint32_index32</Name>
				<Type>UInt32</Type>
				<DefaultValue>0</DefaultValue>
			</LocalVariables>
			<LocalVariables>
				<Name>ExtractAllEnabledSm.byte_smNumber</Name>
				<Type>Byte</Type>
				<DefaultValue>0</DefaultValue>
			</LocalVariables>
			<LocalVariables>
				<Name>ExtractAllEnabledSm.uint32_lengthOfList</Name>
				<Type>UInt32</Type>
				<DefaultValue>0</DefaultValue>
			</LocalVariables>
			<LocalVariables>
				<Name>ExtractAllEnabledSm.b_smDisabled</Name>
				<Type>Bool</Type>
				<DefaultValue>false</DefaultValue>
			</LocalVariables>
			<OutParameter>
				<Name>ExtractAllEnabledSm.ArrayOfBytes_allEnabledSm</Name>
				<Type>ArrayOfBytes</Type>
				<Comment>Extract of enabled SyncManagers</Comment>
			</OutParameter>
			<TestStep Name="InitSyncManArrayIndex">
				<SetVariable Target="ExtractAllEnabledSm.uint32_index32">0</SetVariable>
			</TestStep>
			<TestStep Name="Init_allEnabledSm">
				<InitArray Length="0" TargetArray="ExtractAllEnabledSm.ArrayOfBytes_allEnabledSm"></InitArray>
			</TestStep>
			<TestStep Name="CheckIfReceivedListOfSyncManagerIsUnequal0">
				<SizeOf UInt32Var="ExtractAllEnabledSm.uint32_lengthOfList">ExtractAllEnabledSm.ArrayOfBytes_allSm</SizeOf>
				<Compare>
					<Equal>
						<Value1>ExtractAllEnabledSm.uint32_lengthOfList</Value1>
						<Value2>0</Value2>
						<Return Id="0"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="GET_NUMBER_OF_NEXT_SYNCMAN">
				<GetArrayItem Index="ExtractAllEnabledSm.uint32_index32" SourceArray="ExtractAllEnabledSm.ArrayOfBytes_allSm" Target="ExtractAllEnabledSm.byte_smNumber"></GetArrayItem>
			</TestStep>
			<TestStep Name="CheckIfSyncManEnabled">
				<CallTestFunction Name="CheckIfSyncManEnabled">
					<Parameter>ExtractAllEnabledSm.byte_smNumber</Parameter>
					<OutParameter>ExtractAllEnabledSm.b_smDisabled</OutParameter>
				</CallTestFunction>
			</TestStep>
			<TestStep Name="CheckIfSyncManMustBeAddedToList">
				<Compare>
					<Equal>
						<Value1>ExtractAllEnabledSm.b_smDisabled</Value1>
						<Value2>true</Value2>
						<GotoStep>INCREMENT_SM_INDEX_AND_CHECK_IF_DONE_WITH_SM_NUMBER</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="AddSmNumberToListOfAllEnabledSm">
				<AddArrayItem TargetArray="ExtractAllEnabledSm.ArrayOfBytes_allEnabledSm">ExtractAllEnabledSm.byte_smNumber</AddArrayItem>
				<Compare>
					<Equal>
						<Value1>GetListOfAllEnabledSm_Settings.bAll_debugMsg</Value1>
						<Value2>true</Value2>
						<WriteLine Id="1" Param0="ExtractAllEnabledSm.ArrayOfBytes_allEnabledSm">  TEST FUNCTION "ExtractAllEnabledSm" | allEnabledSm = {0}</WriteLine>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="INCREMENT_SM_INDEX_AND_CHECK_IF_DONE_WITH_SM_NUMBER">
				<SetVariable Target="ExtractAllEnabledSm.uint32_index32">ExtractAllEnabledSm.uint32_index32+1</SetVariable>
				<Compare>
					<Lower>
						<Value1>ExtractAllEnabledSm.uint32_index32</Value1>
						<Value2>ExtractAllEnabledSm.uint32_lengthOfList</Value2>
						<GotoStep>GET_NUMBER_OF_NEXT_SYNCMAN</GotoStep>
					</Lower>
				</Compare>
			</TestStep>
			<TestStep Name="WriteListOfAllEnabledSmToLogger">
				<Compare>
					<Equal>
						<Value1>GetListOfAllEnabledSm_Settings.bAll_debugMsg</Value1>
						<Value2>true</Value2>
						<WriteLine Id="2" Param0="ExtractAllEnabledSm.ArrayOfBytes_allEnabledSm">  TEST FUNCTION "ExtractAllEnabledSm" | allEnabledSm = {0}</WriteLine>
					</Equal>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="202" Name="ExtractEnabledSmFromList">
			<?MAX_OUTPUT_ID 4?>
			<Description>
				<Purpose>From a list of process data SycnManagers this function extracts those which shall be enable according to their process data length
(Previous Name = GetAllEnabledSm)</Purpose>
				<PreCondition>Slave has to be at least in PreOp state</PreCondition>
				<Action>Check SyncManager if need to be enabled according to ESI length or if PdoUpload= true to online configuration</Action>
				<PostCondition>List with all SyncManagers which shall be enabled according to the PDO length / SyncManager length</PostCondition>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>ExtractEnabledSmFromList.b_DebugMsg</Name>
				<Type>Bool</Type>
				<Comment>Write debug message to logger</Comment>
			</Parameter>
			<Parameter>
				<Name>ExtractEnabledSmFromList.ArrayOfBytes_smSourceList</Name>
				<Type>ArrayOfBytes</Type>
				<Comment>allSm (all SM which shall be checked if enabled)</Comment>
			</Parameter>
			<LocalVariables>
				<Name>ExtractEnabledSmFromList.uint32_smIndex</Name>
				<Type>UInt32</Type>
				<DefaultValue>#x00</DefaultValue>
				<Comment>index32</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>ExtractEnabledSmFromList.byte_smNumber</Name>
				<Type>Byte</Type>
				<DefaultValue>#x00</DefaultValue>
			</LocalVariables>
			<LocalVariables>
				<Name>ExtractEnabledSmFromList.uint32_lengthOfList</Name>
				<Type>UInt32</Type>
				<DefaultValue>#x00</DefaultValue>
			</LocalVariables>
			<LocalVariables>
				<Name>ExtractEnabledSmFromList.b_smDisabeld</Name>
				<Type>Bool</Type>
				<DefaultValue>false</DefaultValue>
			</LocalVariables>
			<OutParameter>
				<Name>ExtractEnabledSmFromList.ArrayOfBytes_listOfEnabledSm</Name>
				<Type>ArrayOfBytes</Type>
				<Comment></Comment>
			</OutParameter>
			<TestStep Name="DebugOutputThatFunctionStarted">
				<Compare>
					<Equal>
						<Value1>ExtractEnabledSmFromList.b_DebugMsg</Value1>
						<Value2>true</Value2>
						<WriteLine Id="0">  "ExtractEnabledSmFromList" started</WriteLine>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="ReturnIfSourceArrayEmpty">
				<SizeOf UInt32Var="ExtractEnabledSmFromList.uint32_lengthOfList">ExtractEnabledSmFromList.ArrayOfBytes_smSourceList</SizeOf>
				<Compare>
					<Equal>
						<Value1>ExtractEnabledSmFromList.uint32_lengthOfList</Value1>
						<Value2>#x00</Value2>
						<Return Id="1"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="ResetListOfEnabledSm">
				<InitArray Length="0" TargetArray="ExtractEnabledSmFromList.ArrayOfBytes_listOfEnabledSm"></InitArray>
				<Compare>
					<Equal>
						<Value1>ExtractEnabledSmFromList.b_DebugMsg</Value1>
						<Value2>true</Value2>
						<WriteLine Id="2" Param0="ExtractEnabledSmFromList.ArrayOfBytes_listOfEnabledSm" Param1="ExtractEnabledSmFromList.uint32_lengthOfList" Param2="ExtractEnabledSmFromList.ArrayOfBytes_smSourceList" Param3="ExtractEnabledSmFromList.byte_smNumber">  "ExtractEnabledSmFromList" | listOfEnabledSm = [{0}] after initialization | smNumber = {3}  ||| smSourceList = {2}  | lengthOfList = {1} </WriteLine>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CHECK_IF_SM_ENABLED">
				<!--Add Sm to ExtractEnabledSmFromList.ArrayOfBytes_listOfEnabledSm-->
				<GetArrayItem Index="ExtractEnabledSmFromList.uint32_smIndex" SourceArray="ExtractEnabledSmFromList.ArrayOfBytes_smSourceList" Target="ExtractEnabledSmFromList.byte_smNumber"></GetArrayItem>
			</TestStep>
			<TestStep Name="CheckIfThisSmEnabled">
				<CallTestFunction Name="CheckIfThisSmEnabled">
					<Parameter>ExtractEnabledSmFromList.b_DebugMsg</Parameter>
					<Parameter>ExtractEnabledSmFromList.byte_smNumber</Parameter>
					<OutParameter>ExtractEnabledSmFromList.b_smDisabeld</OutParameter>
				</CallTestFunction>
			</TestStep>
			<TestStep Name="IfDisabledGoToCheckIfDone">
				<Compare>
					<Equal>
						<Value1>ExtractEnabledSmFromList.b_smDisabeld</Value1>
						<Value2>true</Value2>
						<GotoStep>CHECK_IF_DONE</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="IfEnabledAddSmNumberToArray">
				<AddArrayItem TargetArray="ExtractEnabledSmFromList.ArrayOfBytes_listOfEnabledSm">ExtractEnabledSmFromList.byte_smNumber</AddArrayItem>
				<Compare>
					<Equal>
						<Value1>ExtractEnabledSmFromList.b_DebugMsg</Value1>
						<Value2>true</Value2>
						<WriteLine Id="3" Param0="ExtractEnabledSmFromList.ArrayOfBytes_listOfEnabledSm">  "ExtractEnabledSmFromList" | listOfEnabledSm = {0}</WriteLine>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CHECK_IF_DONE">
				<!--Increment SyncManager index and check if done with smNumber-->
				<SetVariable Target="ExtractEnabledSmFromList.uint32_smIndex">ExtractEnabledSmFromList.uint32_smIndex+1</SetVariable>
				<Compare>
					<Lower>
						<Value1>ExtractEnabledSmFromList.uint32_smIndex</Value1>
						<Value2>ExtractEnabledSmFromList.uint32_lengthOfList</Value2>
						<GotoStep>CHECK_IF_SM_ENABLED</GotoStep>
					</Lower>
				</Compare>
			</TestStep>
			<TestStep Name="WriteTestFunctionResultToLogger">
				<WriteLine Id="4" Level="Verbose" Param0="ExtractEnabledSmFromList.ArrayOfBytes_listOfEnabledSm">List of SyncManagers that shall be enabled according to PDO length = [{0}]</WriteLine>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="301" Name="GetAllEnabledInputSyncMan">
			<?MAX_OUTPUT_ID 2?>
			<Description>
				<Purpose>Gets a list with all enabled input process data SyncManagers (PDO length greater 0)</Purpose>
				<PreCondition></PreCondition>
				<Action></Action>
				<PostCondition></PostCondition>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>GetAllEnabledInputSyncMan_bDebugMsg</Name>
				<Type>Bool</Type>
			</Parameter>
			<LocalVariables>
				<Name>GetAllEnabledInputSyncMan_ArrayOfBytesAllInputSyncMan</Name>
				<Type>ArrayOfBytes</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>GetAllEnabledInputSyncMan_uint32LengthOfList</Name>
				<Type>UInt32</Type>
			</LocalVariables>
			<OutParameter>
				<Name>GetAllEnabledInputSyncMan_ArrayOfBytesAllInputSyncMan</Name>
				<Type>ArrayOfBytes</Type>
				<Comment>Array of Bytes with all enabled Input SyncManager</Comment>
			</OutParameter>
			<TestStep Name="GetAllInputSyncMan">
				<Description Id="0" Level="Verbose">Get a list with all input SyncManagers</Description>
				<CallTestFunction Name="GetAllInputSyncMan">
					<OutParameter>GetAllEnabledInputSyncMan_ArrayOfBytesAllInputSyncMan</OutParameter>
				</CallTestFunction>
			</TestStep>
			<TestStep Name="ReturnIfNoInputSm">
				<SizeOf UInt32Var="GetAllEnabledInputSyncMan_uint32LengthOfList">GetAllEnabledInputSyncMan_ArrayOfBytesAllInputSyncMan</SizeOf>
				<Compare>
					<Equal>
						<Value1>Settings.bAll_debugMsg</Value1>
						<Value2>true</Value2>
						<WriteLine Id="1" Param0="GetAllEnabledInputSyncMan_uint32LengthOfList">  List of Input SM | GetAllEnabledInputSyncMan_uint32LengthOfList = {0}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>GetAllEnabledInputSyncMan_uint32LengthOfList</Value1>
						<Value2>0</Value2>
						<Return Id="2"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="GetAllEnabledSyncMan">
				<CallTestFunction Name="GetAllEnabledSyncMan">
					<Parameter>GetAllEnabledInputSyncMan_bDebugMsg</Parameter>
					<Parameter>GetAllEnabledInputSyncMan_ArrayOfBytesAllInputSyncMan</Parameter>
					<OutParameter>GetAllEnabledInputSyncMan_ArrayOfBytesAllInputSyncMan</OutParameter>
				</CallTestFunction>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="302" Name="GetAllEnabledSyncMan">
			<?MAX_OUTPUT_ID 2?>
			<Description>
				<Purpose>Takes an array of SyncManagers and checks which are enabled acc. to their length.</Purpose>
				<PreCondition></PreCondition>
				<Action></Action>
				<PostCondition></PostCondition>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>GetAllEnabledSyncMan_bDebugMsg</Name>
				<Type>Bool</Type>
			</Parameter>
			<Parameter>
				<Name>GetAllEnabledSyncMan_ArrayOfBytesSyncMan</Name>
				<Type>Bool</Type>
				<Comment>List of SyncManager which shall be filtered for enabled SyncManagers</Comment>
			</Parameter>
			<LocalVariables>
				<Name>GetAllEnabledSyncMan_uint32Index</Name>
				<Type>UInt32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>GetAllEnabledSyncMan_uint32LengthOfList</Name>
				<Type>UInt32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>GetAllEnabledSyncMan_byteSyncManNumber</Name>
				<Type>Byte</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>GetAllEnabledSyncMan_bSyncManDisabled</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<OutParameter>
				<Name>GetAllEnabledSyncMan_ArrayOfBytesAllEnabledSyncMan</Name>
				<Type>ArrayOfBytes</Type>
				<Comment></Comment>
			</OutParameter>
			<TestStep Name="InitIndex32">
				<SetVariable Target="GetAllEnabledSyncMan_uint32Index">0</SetVariable>
			</TestStep>
			<TestStep Name="InitAllEnabledSyncMan">
				<InitArray Length="0" TargetArray="GetAllEnabledSyncMan_ArrayOfBytesAllEnabledSyncMan"></InitArray>
			</TestStep>
			<TestStep Name="RetrunIfArrayIs0">
				<SizeOf UInt32Var="GetAllEnabledSyncMan_uint32LengthOfList">GetAllEnabledSyncMan_ArrayOfBytesSyncMan</SizeOf>
				<Compare>
					<Equal>
						<Value1>GetAllEnabledSyncMan_uint32LengthOfList</Value1>
						<Value2>0</Value2>
						<Return Id="0"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="GET_SM_TO_BE_CHECKED">
				<GetArrayItem Index="GetAllEnabledSyncMan_uint32Index" SourceArray="GetAllEnabledSyncMan_ArrayOfBytesSyncMan" Target="GetAllEnabledSyncMan_byteSyncManNumber"></GetArrayItem>
			</TestStep>
			<TestStep Name="CheckifSyncManEnabled">
				<CallTestFunction Name="CheckIfSyncManEnabled">
					<Parameter>GetAllEnabledSyncMan_byteSyncManNumber</Parameter>
					<OutParameter>GetAllEnabledSyncMan_bSyncManDisabled</OutParameter>
				</CallTestFunction>
			</TestStep>
			<TestStep Name="GoToCheckNextSyncManIfThisOneIsNotEnabled">
				<Compare>
					<Equal>
						<Value1>GetAllEnabledSyncMan_bSyncManDisabled</Value1>
						<Value2>true</Value2>
						<GotoStep>INC_SYNCMAN_IDX_AND_CHECK_IF_DONE</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="ADDTOARRAY">
				<AddArrayItem TargetArray="GetAllEnabledSyncMan_ArrayOfBytesAllEnabledSyncMan">GetAllEnabledSyncMan_byteSyncManNumber</AddArrayItem>
				<Compare>
					<Equal>
						<Value1>Settings.bAll_debugMsg</Value1>
						<Value2>true</Value2>
						<WriteLine Id="1" Param0="GetAllEnabledSyncMan_ArrayOfBytesAllEnabledSyncMan">  TEST FUNCTION "GetAllEnabledSyncMan" | GetAllEnabledSyncMan_ArrayOfBytesAllEnabledSyncMan = {0}</WriteLine>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="INC_SYNCMAN_IDX_AND_CHECK_IF_DONE">
				<SetVariable Target="GetAllEnabledSyncMan_uint32Index">GetAllEnabledSyncMan_uint32Index+1</SetVariable>
				<Compare>
					<Lower>
						<Value1>GetAllEnabledSyncMan_uint32Index</Value1>
						<Value2>GetAllEnabledSyncMan_uint32LengthOfList</Value2>
						<GotoStep>GET_SM_TO_BE_CHECKED</GotoStep>
					</Lower>
				</Compare>
			</TestStep>
			<TestStep Name="DebugLoggerOutput">
				<Compare>
					<Equal>
						<Value1>Settings.bAll_debugMsg</Value1>
						<Value2>true</Value2>
						<WriteLine Id="2" Param0="GetAllEnabledSyncMan_ArrayOfBytesAllEnabledSyncMan">  TEST FUNCTION "GetAllEnabledSyncMan" | GetAllEnabledSyncMan_ArrayOfBytesAllEnabledSyncMan = {0}</WriteLine>
					</Equal>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="303" Name="GetAllInputSyncMan">
			<?MAX_OUTPUT_ID 2?>
			<Description>
				<Purpose>Get input process datat SyncManager from ESI file element Sm (possible are 16 SyncManagers)</Purpose>
				<PreCondition>SyncManager in ESi file element Sm defined at all</PreCondition>
				<Action>- Check ESI element Sm for type = "Input" and attribute Virtual = false</Action>
				<PostCondition>- Raise error if no SyncManager in element Sm defined
- Return ArrayOfBytes with list of Input SyncManager</PostCondition>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<LocalVariables>
				<Name>GetAllInputSyncMan_strSmType</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>GetAllInputSyncMan_byteIndex8</Name>
				<Type>Byte</Type>
			</LocalVariables>
			<OutParameter>
				<Name>GetAllInputSyncMan_ArrayOfBytesAllInputSm</Name>
				<Type>ArrayOfBytes</Type>
				<Comment></Comment>
			</OutParameter>
			<TestStep Name="InitAllInputSmArray">
				<InitArray Length="0" TargetArray="GetAllInputSyncMan_ArrayOfBytesAllInputSm"></InitArray>
			</TestStep>
			<TestStep Name="SetSmTypeToInput">
				<SetVariable Target="GetAllInputSyncMan_strSmType">Inputs</SetVariable>
			</TestStep>
			<TestStep Name="InitIndex">
				<SetVariable Target="GetAllInputSyncMan_byteIndex8">0</SetVariable>
			</TestStep>
			<TestStep Name="CheckIfAnySmInEsiFileDefined">
				<Compare>
					<Equal>
						<Value1>DeviceDescr.SM.Count</Value1>
						<Value2>0</Value2>
						<RaiseError Id="0">INFO | No Sm Element in ESI defined!</RaiseError>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="INPUT">
				<!--ESI Sm:Text Available?-->
				<Compare>
					<Equal>
						<Value1>DeviceDescr.SM[GetAllInputSyncMan_byteIndex8]</Value1>
						<Value2>null</Value2>
						<RaiseError Id="1" Param0="GetAllInputSyncMan_byteIndex8">INFO: No Sm:Text defined in ESI for SyncManager{0}</RaiseError>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CheckIfSmIsInputAndNotVirtual">
				<Compare>
					<NotEqual>
						<Value1>DeviceDescr.SM[GetAllInputSyncMan_byteIndex8]</Value1>
						<Value2>Inputs</Value2>
						<GotoStep>NEXT</GotoStep>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>DeviceDescr.SM[GetAllInputSyncMan_byteIndex8].Virtual</Value1>
						<Value2>false</Value2>
						<GotoStep>NEXT</GotoStep>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="ADD">
				<!--update GetAllInputSyncMan_ArrayOfBytesAllInputSm-->
				<AddArrayItem TargetArray="GetAllInputSyncMan_ArrayOfBytesAllInputSm">GetAllInputSyncMan_byteIndex8</AddArrayItem>
			</TestStep>
			<TestStep Name="NEXT">
				<!--Done? otherwise check next Sm-->
				<SetVariable Target="GetAllInputSyncMan_byteIndex8">GetAllInputSyncMan_byteIndex8+1</SetVariable>
				<Compare>
					<Lower>
						<Value1>GetAllInputSyncMan_byteIndex8</Value1>
						<Value2>DeviceDescr.SM.Count</Value2>
						<GotoStep>INPUT</GotoStep>
					</Lower>
				</Compare>
			</TestStep>
			<TestStep Name="WriteInputSmCountArrayToLogger">
				<Compare>
					<Equal>
						<Value1>Settings.bAll_debugMsg</Value1>
						<Value2>true</Value2>
						<WriteLine Id="2" Param0="GetAllInputSyncMan_ArrayOfBytesAllInputSm">  TEST FUNCTION "GetAllInputSyncMan" | GetAllInputSyncMan_ArrayOfBytesAllInputSm = {0}</WriteLine>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep></TestStep>
		</TestFunction>
		<TestFunction FunctionId="304" Name="GetAllOutputSyncMan">
			<?MAX_OUTPUT_ID 2?>
			<Description>
				<Purpose>Get output process datat SyncManager from ESI file element Sm (possible are 16 SyncManagers)</Purpose>
				<PreCondition>SyncManager in ESi file element Sm defined at all</PreCondition>
				<Action>- Check ESI element Sm for type = "Output" and attribute Virtual = false</Action>
				<PostCondition>- Raise error if no SyncManager in element Sm defined
- Return ArrayOfBytes with list of Output SyncManager</PostCondition>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<LocalVariables>
				<Name>GetAllOutputSyncMan_strSmType</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>GetAllOutputSyncMan_byteIndex8</Name>
				<Type>Byte</Type>
			</LocalVariables>
			<OutParameter>
				<Name>GetAllOutputSyncMan_ArrayOfBytesAllOutputSm</Name>
				<Type>ArrayOfBytes</Type>
				<Comment></Comment>
			</OutParameter>
			<TestStep Name="InitAllOutputSmArray">
				<InitArray Length="0" TargetArray="GetAllOutputSyncMan_ArrayOfBytesAllOutputSm"></InitArray>
			</TestStep>
			<TestStep Name="SetSmTypeToOutput">
				<SetVariable Target="GetAllOutputSyncMan_strSmType">Outputs</SetVariable>
			</TestStep>
			<TestStep Name="InitIndex">
				<SetVariable Target="GetAllOutputSyncMan_byteIndex8">0</SetVariable>
			</TestStep>
			<TestStep Name="CheckIfAnySmInEsiFileDefined">
				<Compare>
					<Equal>
						<Value1>DeviceDescr.SM.Count</Value1>
						<Value2>0</Value2>
						<RaiseError Id="0">INFO | No Sm Element in ESI defined!</RaiseError>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="OUTPUT">
				<!--ESI Sm:Text Available?-->
				<Compare>
					<Equal>
						<Value1>DeviceDescr.SM[GetAllOutputSyncMan_byteIndex8]</Value1>
						<Value2>null</Value2>
						<RaiseError Id="1" Param0="GetAllOutputSyncMan_byteIndex8">INFO: No Sm:Text defined in ESI for SyncManager{0}</RaiseError>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CheckIfSmIsOutputAndNotVirtual">
				<Compare>
					<NotEqual>
						<Value1>DeviceDescr.SM[GetAllOutputSyncMan_byteIndex8]</Value1>
						<Value2>Outputs</Value2>
						<GotoStep>NEXT</GotoStep>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>DeviceDescr.SM[GetAllOutputSyncMan_byteIndex8].Virtual</Value1>
						<Value2>false</Value2>
						<GotoStep>NEXT</GotoStep>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="ADD">
				<!--update GetAllOutputSyncMan_ArrayOfBytesAllOutputSm-->
				<AddArrayItem TargetArray="GetAllOutputSyncMan_ArrayOfBytesAllOutputSm">GetAllOutputSyncMan_byteIndex8</AddArrayItem>
			</TestStep>
			<TestStep Name="NEXT">
				<!--Done? otherwise check next Sm-->
				<SetVariable Target="GetAllOutputSyncMan_byteIndex8">GetAllOutputSyncMan_byteIndex8+1</SetVariable>
				<Compare>
					<Lower>
						<Value1>GetAllOutputSyncMan_byteIndex8</Value1>
						<Value2>DeviceDescr.SM.Count</Value2>
						<GotoStep>OUTPUT</GotoStep>
					</Lower>
				</Compare>
			</TestStep>
			<TestStep Name="WriteOutputSmCountArrayToLogger">
				<Compare>
					<Equal>
						<Value1>Settings.bAll_debugMsg</Value1>
						<Value2>true</Value2>
						<WriteLine Id="2" Param0="GetAllOutputSyncMan_ArrayOfBytesAllOutputSm">  TEST FUNCTION "GetAllOutputSyncMan" | GetAllOutputSyncMan_ArrayOfBytesAllOutputSm = {0}</WriteLine>
					</Equal>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="401" Name="GetAndVerifyAlStatusAndStatusCode">
			<?MAX_OUTPUT_ID 16?>
			<Description>
				<Purpose>Validates AL Status and AL Status Code (3 different Status Codes can be possible) against expected values</Purpose>
				<PreCondition></PreCondition>
				<Action>Read AL Status cand AL Status Code with 6 byte continues read access from ESC.</Action>
				<PostCondition>Generate Error if read values unequal expected values.
If ErrFlag equal 0 and AlStatusCode unequal 0 then raise warning</PostCondition>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>GetAndVerifyAlStatusAndStatusCode.uint16StateValueNext</Name>
				<Type>UInt16</Type>
				<!--stateValueNext-->
			</Parameter>
			<Parameter>
				<Name>GetAndVerifyAlStatusAndStatusCode.uint16ExpectedAlStatusCode</Name>
				<Type>UInt16</Type>
				<!--Status Code which is expected after the state transition-->
			</Parameter>
			<Parameter>
				<Name>GetAndVerifyAlStatusAndStatusCode.uint16ExpectedAlStatusCode2</Name>
				<Type>UInt16</Type>
				<!--If a second AL Status Code is possible -->
			</Parameter>
			<Parameter>
				<Name>GetAndVerifyAlStatusAndStatusCode.uint16ExpectedAlStatusCode3</Name>
				<Type>UInt16</Type>
				<!--If a third AL Status Code is possible -->
			</Parameter>
			<Parameter>
				<Name>GetAndVerifyAlStatusAndStatusCode.bWarning</Name>
				<Type>Bool</Type>
				<!--true = if the AL Status is not the expected al Status only a Warning and not an Error is generated-->
			</Parameter>
			<LocalVariables>
				<Name>GetAndVerifyAlStatusAndStatusCode.ArrayOfUint16AlStatusAndStatusCode</Name>
				<Type>ArrayOfUInt16</Type>
				<!--6Byte Array to read the AL Status and Al Status with one datagram so that it is consistent-->
			</LocalVariables>
			<LocalVariables>
				<Name>GetAndVerifyAlStatusAndStatusCode.uint16AlStatus</Name>
				<Type>UInt16</Type>
				<!--Al Status extracted from AlStatusAndStatusCodeArray-->
			</LocalVariables>
			<LocalVariables>
				<Name>GetAndVerifyAlStatusAndStatusCode.uint16AlStatusCode</Name>
				<Type>UInt16</Type>
				<!--Al Status Code extracted from AlStatusAndStatusCodeArray-->
			</LocalVariables>
			<TestStep Name="InitAlStatusAndStatusCodeArray">
				<!--Build alStatus.Code-->
				<SetVariable Target="GetAndVerifyAlStatusAndStatusCode.ArrayOfUint16AlStatusAndStatusCode">000000000000</SetVariable>
			</TestStep>
			<TestStep Name="ReadAlStatusAndStatusCodeFromEsc">
				<!--0x0135:0x0130 ?-->
				<Description Id="0">Read AL Status and AL Status Code from device</Description>
				<ReadEscData Target="GetAndVerifyAlStatusAndStatusCode.ArrayOfUint16AlStatusAndStatusCode">
					<Address>#x130</Address>
				</ReadEscData>
				<RaiseErrorOnFailure Id="1">Failed to read register 0x0135:0x0130</RaiseErrorOnFailure>
			</TestStep>
			<TestStep Name="ExtractAlStatus">
				<!--GetAndVerifyAlStatusAndStatusCode.uint16AlStatus-->
				<GetArrayItem SourceArray="GetAndVerifyAlStatusAndStatusCode.ArrayOfUint16AlStatusAndStatusCode" Index="0" Target="GetAndVerifyAlStatusAndStatusCode.uint16AlStatus"></GetArrayItem>
			</TestStep>
			<TestStep Name="ExtractAlStatusCode">
				<!--GetAndVerifyAlStatusAndStatusCode.uint16AlStatusCode-->
				<GetArrayItem SourceArray="GetAndVerifyAlStatusAndStatusCode.ArrayOfUint16AlStatusAndStatusCode" Index="2" Target="GetAndVerifyAlStatusAndStatusCode.uint16AlStatusCode"></GetArrayItem>
				<WriteLine Id="2" Param0="GetAndVerifyAlStatusAndStatusCode.uint16StateValueNext" Param1="GetAndVerifyAlStatusAndStatusCode.uint16AlStatus" Param2="GetAndVerifyAlStatusAndStatusCode.uint16ExpectedAlStatusCode" Param3="GetAndVerifyAlStatusAndStatusCode.uint16AlStatusCode" Level="Output">Expected AL Status = 0x{0:x2}, Read = 0x{1:x2}  || Info: Expected AL Status Code = 0x{2:x2}, Read = 0x{3:x2}</WriteLine>
			</TestStep>
			<TestStep Name="ALSTATUSERROR">
				<!--alStatus = stateValueNext ?-->
				<Compare>
					<Equal>
						<Value1>GetAndVerifyAlStatusAndStatusCode.bWarning</Value1>
						<Value2>true</Value2>
						<GotoStep>ALSTATUSWARNING</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>GetAndVerifyAlStatusAndStatusCode.uint16AlStatus</Value1>
						<Value2>GetAndVerifyAlStatusAndStatusCode.uint16StateValueNext</Value2>
						<RaiseError Id="3" Param0="GetAndVerifyAlStatusAndStatusCode.uint16StateValueNext" Param1="GetAndVerifyAlStatusAndStatusCode.uint16AlStatus" Param2="GetAndVerifyAlStatusAndStatusCode.uint16ExpectedAlStatusCode" Param3="GetAndVerifyAlStatusAndStatusCode.uint16AlStatusCode">Invalid AL Status || Expected AL Status = 0x{0:x2}, Read = 0x{1:x2}  || Info: Expected AL Status Code = 0x{2:x2}, Read = 0x{3:x2}</RaiseError>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>GetAndVerifyAlStatusAndStatusCode.bWarning</Value1>
						<Value2>false</Value2>
						<GotoStep>EXPECTEDALSTATUSCODE3</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="ALSTATUSWARNING">
				<!--alStatus = stateValueNext ?-->
				<Compare>
					<NotEqual>
						<Value1>GetAndVerifyAlStatusAndStatusCode.uint16AlStatus</Value1>
						<Value2>GetAndVerifyAlStatusAndStatusCode.uint16StateValueNext</Value2>
						<RaiseWarning Id="4" Param0="GetAndVerifyAlStatusAndStatusCode.uint16StateValueNext" Param1="GetAndVerifyAlStatusAndStatusCode.uint16AlStatus" Param2="GetAndVerifyAlStatusAndStatusCode.uint16ExpectedAlStatusCode" Param3="GetAndVerifyAlStatusAndStatusCode.uint16AlStatusCode">Invalid AL Status || Expected AL Status = 0x{0:x2}, Read = 0x{1:x2}  || Info: Expected AL Status Code = 0x{2:x2} (ESI element Sm:ControlByte indicates this SyncManager direction), Read = 0x{3:x2} </RaiseWarning>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>GetAndVerifyAlStatusAndStatusCode.bWarning</Value1>
						<Value2>true</Value2>
						<Return Id="5">INFO | AL Status Codes are not verified when Settings.Warning = true</Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="EXPECTEDALSTATUSCODE3">
				<!--AlStatusCode <> Main Al Status Code (alStatusCode)  > Warning-->
				<Compare>
					<Equal>
						<Value1>GetAndVerifyAlStatusAndStatusCode.uint16AlStatusCode</Value1>
						<Value2>0</Value2>
						<GotoStep>CHECK</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>GetAndVerifyAlStatusAndStatusCode.uint16AlStatusCode</Value1>
						<Value2>GetAndVerifyAlStatusAndStatusCode.uint16ExpectedAlStatusCode</Value2>
						<RaiseWarning Id="6" Param0="GetAndVerifyAlStatusAndStatusCode.uint16AlStatusCode" Param1="GetAndVerifyAlStatusAndStatusCode.uint16ExpectedAlStatusCode">Recommended AL Status Code 0x{1:x4} should be used! || Read AL Status Code = 0x{0:x4}</RaiseWarning>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="CHECK">
				<!--expectedAlStatusCode3  ?-->
				<Compare>
					<NotEqual>
						<Value1>GetAndVerifyAlStatusAndStatusCode.uint16ExpectedAlStatusCode3</Value1>
						<Value2>0</Value2>
						<GotoStep>STATCODE3</GotoStep>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="CheckIf2ndAlStatusCodePossible">
				<!--expectedAlStatusCode2  ?-->
				<Compare>
					<NotEqual>
						<Value1>GetAndVerifyAlStatusAndStatusCode.uint16ExpectedAlStatusCode2</Value1>
						<Value2>0</Value2>
						<GotoStep>STATCODE2</GotoStep>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="WarningIfMainAlStatusCodeNotUsed">
				<!--expectedAlStatusCode = 0 -> if not, only warning, no error-->
				<Compare>
					<NotEqual>
						<Value1>GetAndVerifyAlStatusAndStatusCode.uint16ExpectedAlStatusCode</Value1>
						<Value2>0</Value2>
						<GotoStep>STATCODE1ERROR</GotoStep>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>GetAndVerifyAlStatusAndStatusCode.uint16AlStatusCode</Value1>
						<Value2>GetAndVerifyAlStatusAndStatusCode.uint16ExpectedAlStatusCode</Value2>
						<RaiseWarning Id="7" Param0="GetAndVerifyAlStatusAndStatusCode.uint16ExpectedAlStatusCode" Param1="GetAndVerifyAlStatusAndStatusCode.uint16AlStatusCode" Param2="GetAndVerifyAlStatusAndStatusCode.uint16StateValueNext" Param3="GetAndVerifyAlStatusAndStatusCode.uint16AlStatus">AL Status Code should be 0 when ErrorFlag of AL Status reigster is false || INFO: Expected AL Status Code = 0x{0:x4}, Read = 0x{1:x4}, Expected AL Status = 0x{2:x4}, Read = 0x{3:x4}</RaiseWarning>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<Return Id="8"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="STATCODE1ERROR">
				<!--AlStatusCode = expectedAlStatusCode  ?-->
				<Compare>
					<NotEqual>
						<Value1>GetAndVerifyAlStatusAndStatusCode.uint16AlStatusCode</Value1>
						<Value2>GetAndVerifyAlStatusAndStatusCode.uint16ExpectedAlStatusCode</Value2>
						<RaiseError Id="9" Param0="GetAndVerifyAlStatusAndStatusCode.uint16ExpectedAlStatusCode" Param1="GetAndVerifyAlStatusAndStatusCode.uint16AlStatusCode" Param2="GetAndVerifyAlStatusAndStatusCode.uint16StateValueNext" Param3="GetAndVerifyAlStatusAndStatusCode.uint16AlStatus">Invalid AL Status Code || Expected AL Status Code = 0x{0:x4}, Read = 0x{1:x4}  || Info: Expected AL Status = 0x{2:x4}, Read = 0x{3:x4}</RaiseError>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="RETURN">
				<!--Return-->
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<Return Id="10"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="STATCODE2">
				<!--AlStatusCode = expectedAlStatusCode  ?-->
				<Compare>
					<Equal>
						<Value1>GetAndVerifyAlStatusAndStatusCode.uint16AlStatusCode</Value1>
						<Value2>GetAndVerifyAlStatusAndStatusCode.uint16ExpectedAlStatusCode</Value2>
						<Return Id="11"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="VerifyAlStatusCodeAgainstAlStatusCode2">
				<!--AlStatusCode = fexpectedAlStatusCode2  ?-->
				<Compare>
					<NotEqual>
						<Value1>GetAndVerifyAlStatusAndStatusCode.uint16AlStatusCode</Value1>
						<Value2>GetAndVerifyAlStatusAndStatusCode.uint16ExpectedAlStatusCode2</Value2>
						<RaiseError Id="12" Param0="GetAndVerifyAlStatusAndStatusCode.uint16ExpectedAlStatusCode" Param1="GetAndVerifyAlStatusAndStatusCode.uint16AlStatusCode" Param2="GetAndVerifyAlStatusAndStatusCode.uint16AlStatus">Invalid AL Status Code || Expected AL Status Code = 0x{0:x4}, Read = 0x{1:x4}  || Info: AL Status = 0x{2:x4}</RaiseError>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="Return">
				<!--Return-->
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<Return Id="13"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="STATCODE3">
				<!--AlStatusCode = expectedAlStatusCode  ?-->
				<Compare>
					<Equal>
						<Value1>GetAndVerifyAlStatusAndStatusCode.uint16AlStatusCode</Value1>
						<Value2>GetAndVerifyAlStatusAndStatusCode.uint16ExpectedAlStatusCode</Value2>
						<Return Id="14"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="AlStatusCode_Equals_fexpectedAlStatusCode2">
				<Compare>
					<Equal>
						<Value1>GetAndVerifyAlStatusAndStatusCode.uint16AlStatusCode</Value1>
						<Value2>GetAndVerifyAlStatusAndStatusCode.uint16ExpectedAlStatusCode2</Value2>
						<Return Id="15"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="VerifyAlStatusCodeAgainstAlStatusCode3">
				<!--AlStatusCode = fexpectedAlStatusCode3  ?-->
				<Compare>
					<NotEqual>
						<Value1>GetAndVerifyAlStatusAndStatusCode.uint16AlStatusCode</Value1>
						<Value2>GetAndVerifyAlStatusAndStatusCode.uint16ExpectedAlStatusCode3</Value2>
						<RaiseError Id="16" Param0="GetAndVerifyAlStatusAndStatusCode.uint16ExpectedAlStatusCode">Invalid AL Status Code || Expected AL Status Code = 0x{0:x4}</RaiseError>
					</NotEqual>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="402" Name="GetAndVerifyAlStatusAndXStatusCodes">
			<?MAX_OUTPUT_ID 10?>
			<Description>
				<Purpose>Validates AL Status and AL Status Code (an unlimited list of AL Status Codes can be provided) against expected values</Purpose>
				<PreCondition></PreCondition>
				<Action>Read AL Status cand AL Status Code with 6 byte continues read access from ESC.</Action>
				<PostCondition>Generate Error if read values unequal expected values.
If ErrFlag equal 0 and AlStatusCode unequal 0 then raise warning</PostCondition>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>GetAndVerifyAlStatusAndXStatusCodes.uint16StateValueNext</Name>
				<Type>UInt16</Type>
				<!--stateValueNext-->
			</Parameter>
			<Parameter>
				<Name>GetAndVerifyAlStatusAndXStatusCodes.uint16ArrayExpectedAlStatusCodes</Name>
				<Type>ArrayOfUInt16</Type>
				<!--ARRAY of allowed AL Status Codes-->
			</Parameter>
			<Parameter>
				<Name>GetAndVerifyAlStatusAndXStatusCodes.bWarning</Name>
				<Type>Bool</Type>
				<!--true = if the AL Status is not the expected al Status only a Warning and not an Error is generated-->
			</Parameter>
			<Parameter>
				<Name>GetAndVerifyAlStatusAndXStatusCodes.b_DebugMsg</Name>
				<Type>Bool</Type>
				<!--true: DebugMessages are written to looger-->
			</Parameter>
			<LocalVariables>
				<Name>GetAndVerifyAlStatusAndXStatusCodes.ArrayOfUint16AlStatusAndStatusCode</Name>
				<Type>ArrayOfUInt16</Type>
				<!--6Byte Array to read the AL Status and Al Status with one datagram so that it is consistent-->
			</LocalVariables>
			<LocalVariables>
				<Name>GetAndVerifyAlStatusAndXStatusCodes.uint16AlStatus</Name>
				<Type>UInt16</Type>
				<!--Al Status extracted from AlStatusAndStatusCodeArray-->
			</LocalVariables>
			<LocalVariables>
				<Name>GetAndVerifyAlStatusAndXStatusCodes.uint16AlStatusCode</Name>
				<Type>UInt16</Type>
				<!--Al Status Code extracted from AlStatusAndStatusCodeArray-->
			</LocalVariables>
			<LocalVariables>
				<Name>GetAndVerifyAlStatusAndXStatusCodes.uint16AllowedAlStatusCode</Name>
				<Type>UInt16</Type>
				<!--Allowed AL StatusCode from AlStatusCodeArray-->
			</LocalVariables>
			<LocalVariables>
				<Name>GetAndVerifyAlStatusAndXStatusCodes.byteIndex</Name>
				<Type>Byte</Type>
				<!--Index for AlStatusCodes-Array-->
			</LocalVariables>
			<LocalVariables>
				<Name>GetAndVerifyAlStatusAndXStatusCodes.byteMaxIndex</Name>
				<Type>Byte</Type>
				<!--Maximum number of allowed AL Status Codes (0-based)-->
			</LocalVariables>
			<TestStep Name="DebugMsgFunctionStarted">
				<Compare>
					<Equal>
						<Value1>GetAndVerifyAlStatusAndXStatusCodes.b_DebugMsg</Value1>
						<Value2>true</Value2>
						<WriteLine Id="0">  DEBUG MSG | Test Function "GetAndVerifyAlStatusAndXStatusCodes" started</WriteLine>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="InitAlStatusAndStatusCodeArray">
				<InitArray Length="6" TargetArray="GetAndVerifyAlStatusAndXStatusCodes.ArrayOfUint16AlStatusAndStatusCode"></InitArray>
			</TestStep>
			<TestStep Name="InitbyteIndex">
				<SetVariable Target="GetAndVerifyAlStatusAndXStatusCodes.byteIndex">#x00</SetVariable>
			</TestStep>
			<TestStep Name="ReadAlStatusAndStatusCodeFromEsc">
				<!--0x0135:0x0130 ?-->
				<Description Id="1">Read AL Status and AL Status Code from device</Description>
				<ReadEscData Target="GetAndVerifyAlStatusAndXStatusCodes.ArrayOfUint16AlStatusAndStatusCode">
					<Address>#x130</Address>
				</ReadEscData>
				<RaiseErrorOnFailure Id="2">Failed to read register 0x0135:0x0130</RaiseErrorOnFailure>
			</TestStep>
			<TestStep Name="ExtractAlStatus">
				<!--GetAndVerifyAlStatusAndXStatusCodes.uint16AlStatus-->
				<GetArrayItem SourceArray="GetAndVerifyAlStatusAndXStatusCodes.ArrayOfUint16AlStatusAndStatusCode" Index="0" Target="GetAndVerifyAlStatusAndXStatusCodes.uint16AlStatus"></GetArrayItem>
			</TestStep>
			<TestStep Name="ExtractAlStatusCode">
				<!--GetAndVerifyAlStatusAndXStatusCodes.uint16AlStatusCode-->
				<GetArrayItem SourceArray="GetAndVerifyAlStatusAndXStatusCodes.ArrayOfUint16AlStatusAndStatusCode" Index="2" Target="GetAndVerifyAlStatusAndXStatusCodes.uint16AlStatusCode"></GetArrayItem>
				<WriteLine Id="3" Param0="GetAndVerifyAlStatusAndXStatusCodes.uint16StateValueNext" Param1="GetAndVerifyAlStatusAndXStatusCodes.uint16AlStatus" Param2="GetAndVerifyAlStatusAndXStatusCodes.uint16ArrayExpectedAlStatusCodes" Param3="GetAndVerifyAlStatusAndXStatusCodes.uint16AlStatusCode" Level="Output">Expected AL Status = 0x{0:x2}, Read = 0x{1:x2}  || Info: Expected AL Status Code List = 0x{2:x}, Read = 0x{3:x2}</WriteLine>
			</TestStep>
			<TestStep Name="ALSTATUSERROR">
				<!--alStatus = stateValueNext ?-->
				<Compare>
					<Equal>
						<Value1>GetAndVerifyAlStatusAndXStatusCodes.bWarning</Value1>
						<Value2>true</Value2>
						<GotoStep>ALSTATUSWARNING</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>GetAndVerifyAlStatusAndXStatusCodes.uint16AlStatus</Value1>
						<Value2>GetAndVerifyAlStatusAndXStatusCodes.uint16StateValueNext</Value2>
						<RaiseError Id="4" Param0="GetAndVerifyAlStatusAndXStatusCodes.uint16StateValueNext" Param1="GetAndVerifyAlStatusAndXStatusCodes.uint16AlStatus">Invalid AL Status || Expected AL Status = 0x{0:x2}, Read = 0x{1:x2}</RaiseError>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>GetAndVerifyAlStatusAndXStatusCodes.bWarning</Value1>
						<Value2>false</Value2>
						<GotoStep>ATLEASTONEALSTATUSCODEALLOWED</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="ALSTATUSWARNING">
				<!--alStatus = stateValueNext ?-->
				<Compare>
					<NotEqual>
						<Value1>GetAndVerifyAlStatusAndXStatusCodes.uint16AlStatus</Value1>
						<Value2>GetAndVerifyAlStatusAndXStatusCodes.uint16StateValueNext</Value2>
						<RaiseWarning Id="5" Param0="GetAndVerifyAlStatusAndXStatusCodes.uint16StateValueNext" Param1="GetAndVerifyAlStatusAndXStatusCodes.uint16AlStatus">Invalid AL Status || Expected AL Status = 0x{0:x2}, Read = 0x{1:x2}</RaiseWarning>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>GetAndVerifyAlStatusAndXStatusCodes.bWarning</Value1>
						<Value2>true</Value2>
						<Return Id="6">INFO | AL Status Codes are not verified when Settings.Warning = true</Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="ATLEASTONEALSTATUSCODEALLOWED">
				<GetArrayItem Index="0" SourceArray="GetAndVerifyAlStatusAndXStatusCodes.uint16ArrayExpectedAlStatusCodes" Target="GetAndVerifyAlStatusAndXStatusCodes.uint16AllowedAlStatusCode"></GetArrayItem>
			</TestStep>
			<TestStep Name="FirstStatusCodeUnequal0">
				<Compare>
					<Equal>
						<Value1>GetAndVerifyAlStatusAndXStatusCodes.uint16AllowedAlStatusCode</Value1>
						<Value2>0000</Value2>
						<Return Id="7">Exception | No allowed AL Status Code defined by test.</Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="GetNumberOfAllowedAlStatusCodes">
				<SizeOf UInt32Var="GetAndVerifyAlStatusAndXStatusCodes.byteMaxIndex">GetAndVerifyAlStatusAndXStatusCodes.uint16ArrayExpectedAlStatusCodes</SizeOf>
			</TestStep>
			<TestStep Name="GETALLOWEDALSTATUSCODE">
				<GetArrayItem Index="GetAndVerifyAlStatusAndXStatusCodes.byteIndex" SourceArray="GetAndVerifyAlStatusAndXStatusCodes.uint16ArrayExpectedAlStatusCodes" Target="GetAndVerifyAlStatusAndXStatusCodes.uint16AllowedAlStatusCode"></GetArrayItem>
			</TestStep>
			<TestStep Name="DebugMsgCheckAgainstAlStatusCode">
				<Compare>
					<Equal>
						<Value1>GetAndVerifyAlStatusAndXStatusCodes.b_DebugMsg</Value1>
						<Value2>true</Value2>
						<WriteLine Id="8" Param0="GetAndVerifyAlStatusAndXStatusCodes.uint16AllowedAlStatusCode">  DEBUG MSG | Current Check vs. allowed AL Status Code = 0x{0:x0}</WriteLine>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CheckIfAlStatusCodeAllowed">
				<Compare>
					<Equal>
						<Value1>GetAndVerifyAlStatusAndXStatusCodes.uint16AllowedAlStatusCode</Value1>
						<Value2>GetAndVerifyAlStatusAndXStatusCodes.uint16AlStatusCode</Value2>
						<Return Id="9" Param0="GetAndVerifyAlStatusAndXStatusCodes.uint16AlStatusCode">AL Status Code 0x{0:x2} is valid</Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="IncrementAlStatusArrayIndex">
				<SetVariable Target="GetAndVerifyAlStatusAndXStatusCodes.byteIndex">GetAndVerifyAlStatusAndXStatusCodes.byteIndex+1</SetVariable>
			</TestStep>
			<TestStep Name="CheckNextOrErrorIfNoAllowedCodeFound">
				<Compare>
					<GreaterOrEqual>
						<Value1>GetAndVerifyAlStatusAndXStatusCodes.byteIndex</Value1>
						<Value2>GetAndVerifyAlStatusAndXStatusCodes.byteMaxIndex</Value2>
						<RaiseError Id="10" Param0="GetAndVerifyAlStatusAndXStatusCodes.uint16AlStatusCode" Param1="GetAndVerifyAlStatusAndXStatusCodes.uint16ArrayExpectedAlStatusCodes">Invalid AL Status Code 0x{0:x4} || expected  AL Status Codes Array = {1} </RaiseError>
					</GreaterOrEqual>
				</Compare>
				<Compare>
					<Lower>
						<Value1>GetAndVerifyAlStatusAndXStatusCodes.byteIndex</Value1>
						<Value2>GetAndVerifyAlStatusAndXStatusCodes.byteMaxIndex</Value2>
						<GotoStep>GETALLOWEDALSTATUSCODE</GotoStep>
					</Lower>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="501" Name="GetListOfAllEnabledSm">
			<?MAX_OUTPUT_ID 1?>
			<Description>
				<Purpose>Makes a list with all SyncManagers which shall be enabled according to the PDO length / SyncManager length

(previously GetAllEnabledPdSm, Parameter:
- allSm (all SM which shall be checked if enabled)
- smCount (number of SMs in the array)
Return values:
- allEnabledSm
- noEnabledSm
- enabledSmCount
)</Purpose>
				<PreCondition>Slave has to be at least in PreOp state (since function ExtractEnabledSmFromList is called)</PreCondition>
				<Action>Gets all enabled Input-Sm and all enabeld Output-Sm with function GetListOfEnabledInputOrOutputSm and adds them to one single list</Action>
				<PostCondition>Return list with all enabled Input and Output SyncManagers</PostCondition>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>GetListOfAllEnabledSm.b_DebugMsg</Name>
				<Type>Bool</Type>
				<Comment>Write debug message to logger</Comment>
			</Parameter>
			<LocalVariables>
				<Name>GetListOfAllEnabledSm.ArrayOfByte_ListOfAllEnabledSmIntermediateContainer</Name>
				<Type>ArrayOfBytes</Type>
				<DefaultValue></DefaultValue>
				<Comment></Comment>
			</LocalVariables>
			<OutParameter>
				<Name>GetListOfAllEnabledSm.ArrayOfByte_ListOfAllEnabledSm</Name>
				<Type>ArrayOfBytes</Type>
				<Comment></Comment>
			</OutParameter>
			<TestStep Name="DebugOutputThatFunctionStarted">
				<Compare>
					<Equal>
						<Value1>GetListOfAllEnabledSm.b_DebugMsg</Value1>
						<Value2>true</Value2>
						<WriteLine Id="0">  "GetListOfAllEnabledSm" started</WriteLine>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="GetEnabledOutputSms">
				<CallTestFunction Name="GetListOfEnabledInputOrOutputSm">
					<Parameter>GetListOfAllEnabledSm.b_DebugMsg</Parameter>
					<Parameter>Outputs</Parameter>
					<OutParameter>GetListOfAllEnabledSm.ArrayOfByte_ListOfAllEnabledSm</OutParameter>
				</CallTestFunction>
			</TestStep>
			<TestStep Name="GetEnabledInputSms">
				<CallTestFunction Name="GetListOfEnabledInputOrOutputSm">
					<Parameter>GetListOfAllEnabledSm.b_DebugMsg</Parameter>
					<Parameter>Inputs</Parameter>
					<OutParameter>GetListOfAllEnabledSm.ArrayOfByte_ListOfAllEnabledSmIntermediateContainer</OutParameter>
				</CallTestFunction>
			</TestStep>
			<TestStep Name="UpdateArray">
				<AddArrayItem TargetArray="GetListOfAllEnabledSm.ArrayOfByte_ListOfAllEnabledSm">GetListOfAllEnabledSm.ArrayOfByte_ListOfAllEnabledSmIntermediateContainer</AddArrayItem>
			</TestStep>
			<TestStep Name="WriteTestFunctionResultToLogger">
				<WriteLine Id="1" Level="Verbose" Param0="GetListOfAllEnabledSm.ArrayOfByte_ListOfAllEnabledSm">List of all enabled SyncManagers that shall be enabled according to PDO length = [{0}]</WriteLine>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="502" Name="GetListOfAllInputOrOutputSm">
			<?MAX_OUTPUT_ID 4?>
			<Description>
				<Purpose>Finds all either input and output SyncManagers (ESI based, i.e. offline) (possible are 16 entities).
Only adds SyncManagers with Virtual = false

previous return values (not supported any more) : noInputSm
inputSmCount
firstInputSm

Previous Name: GetAllInputSm, GetallOutputSm</Purpose>
				<PreCondition>Slave can be in any ESM state</PreCondition>
				<Action></Action>
				<PostCondition>Disable = 0: Pdo length for this SyncManager is &gt;0: 
Disable = 1: PDO length for this SyncManager is = 0</PostCondition>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>GetListOfAllInputOrOutputSm.b_DebugMsg</Name>
				<Type>Bool</Type>
				<Comment>Write debug message to logger</Comment>
			</Parameter>
			<Parameter>
				<Name>GetListOfAllInputOrOutputSm.str_smType</Name>
				<Type>String</Type>
				<Comment>smType: allowed values: 
Inputs
Outputs</Comment>
			</Parameter>
			<LocalVariables>
				<Name>GetListOfAllInputOrOutputSm.byte_smIndex</Name>
				<Type>Byte</Type>
				<DefaultValue>#x00</DefaultValue>
				<Comment>index8</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>GetListOfAllInputOrOutputSm.b_localDebugMsg</Name>
				<Type>Bool</Type>
				<DefaultValue>false</DefaultValue>
				<Comment>Logger ouputs are written only for debugging of this test function</Comment>
			</LocalVariables>
			<OutParameter>
				<Name>GetListOfAllInputOrOutputSm.ArrayOfBytes_AllInputOrOutputSm</Name>
				<Type>ArrayOfBytes</Type>
				<Comment>Depending on the type (outputs or Inputs) a list of this type is returned</Comment>
			</OutParameter>
			<TestStep Name="DebugOutputThatFunctionStarted">
				<Compare>
					<Equal>
						<Value1>GetListOfAllInputOrOutputSm.b_DebugMsg</Value1>
						<Value2>true</Value2>
						<WriteLine Id="0">  "GetListOfAllInputOrOutputSm" started</WriteLine>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="ClearAllEitherInputOrOutputSmList">
				<InitArray Length="0" TargetArray="GetListOfAllInputOrOutputSm.ArrayOfBytes_AllInputOrOutputSm"></InitArray>
			</TestStep>
			<TestStep Name="SmElementInEsiAvailable">
				<Compare>
					<Equal>
						<Value1>DeviceDescr.SM.Count</Value1>
						<Value2>0</Value2>
						<RaiseError Id="1">INFO | No Sm Element in ESI defined!</RaiseError>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="FIND_SM_TYPE_IN_ESI">
				<Compare>
					<Equal>
						<Value1>DeviceDescr.SM[GetListOfAllInputOrOutputSm.byte_smIndex]</Value1>
						<Value2>null</Value2>
						<RaiseError Id="2" Param0="GetListOfAllInputOrOutputSm.byte_smIndex">INFO: No Sm:Text element defined in ESI for SyncManager{0}</RaiseError>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CheckIfThisSmHasTypeAndNoVirtualFlag">
				<Compare>
					<NotEqual>
						<Value1>DeviceDescr.SM[GetListOfAllInputOrOutputSm.byte_smIndex]</Value1>
						<Value2>GetListOfAllInputOrOutputSm.str_smType</Value2>
						<GotoStep>NEXT</GotoStep>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>DeviceDescr.SM[GetListOfAllInputOrOutputSm.byte_smIndex].Virtual</Value1>
						<Value2>false</Value2>
						<GotoStep>NEXT</GotoStep>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="UPDATE_SM_LIST">
				<AddArrayItem TargetArray="GetListOfAllInputOrOutputSm.ArrayOfBytes_AllInputOrOutputSm">GetListOfAllInputOrOutputSm.byte_smIndex</AddArrayItem>
			</TestStep>
			<TestStep Name="DebugLoggerOutputLocal">
				<Compare>
					<Equal>
						<Value1>GetListOfAllInputOrOutputSm.b_localDebugMsg</Value1>
						<Value2>true</Value2>
						<WriteLine Id="3" Param0="GetListOfAllInputOrOutputSm.str_smType" Param1="GetListOfAllInputOrOutputSm.ArrayOfBytes_AllInputOrOutputSm" Param2="GetListOfAllInputOrOutputSm.byte_smIndex">  "GetListOfAllInputOrOutputSm" | GetListOfAllInputOrOutputSm.str_smType = {0} | AllInputOrOutputSm = {1} | SmIndex = {2} </WriteLine>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="NEXT">
				<SetVariable Target="GetListOfAllInputOrOutputSm.byte_smIndex">GetListOfAllInputOrOutputSm.byte_smIndex+1</SetVariable>
				<Compare>
					<Lower>
						<Value1>GetListOfAllInputOrOutputSm.byte_smIndex</Value1>
						<Value2>DeviceDescr.SM.Count</Value2>
						<GotoStep>FIND_SM_TYPE_IN_ESI</GotoStep>
					</Lower>
				</Compare>
			</TestStep>
			<TestStep Name="END"></TestStep>
			<TestStep Name="LoggerOutput">
				<WriteLine Id="4" Param0="GetListOfAllInputOrOutputSm.str_smType" Param1="GetListOfAllInputOrOutputSm.ArrayOfBytes_AllInputOrOutputSm" Level="Verbose">List of all {0} SyncManagers = {1}</WriteLine>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="503" Name="GetListOfAllPdSm">
			<?MAX_OUTPUT_ID 2?>
			<Description>
				<Purpose>Based on the ESI file it merges arrays of allOutputSm and all allInputSm

Previously GetAllPdSm

Return values deleted frp, original function:
- noPdSm
- pdSmCount</Purpose>
				<PreCondition>Slave can be in any ESM state</PreCondition>
				<Action></Action>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>GetListOfAllPdSm.b_DebugMsg</Name>
				<Type>Bool</Type>
				<Comment>Write debug message to logger</Comment>
			</Parameter>
			<LocalVariables>
				<Name>GetListOfAllPdSm.byte_inputSmCount</Name>
				<Type>Byte</Type>
				<DefaultValue>#x00</DefaultValue>
				<Comment>inputSmCount</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>GetListOfAllPdSm.byte_SmIndex</Name>
				<Type>Byte</Type>
				<DefaultValue>#x00</DefaultValue>
				<Comment>index8</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>GetListOfAllPdSm.ArrayOfByte_allPdSmIntermediateContainer</Name>
				<Type>ArrayOfBytes</Type>
				<Comment>intermediate container</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>GetListOfAllPdSm.b_localDebugMsg</Name>
				<Type>Bool</Type>
				<DefaultValue>false</DefaultValue>
				<Comment>Logger ouputs are written only for debugging of this test function</Comment>
			</LocalVariables>
			<OutParameter>
				<Name>GetListOfAllPdSm.ArrayOfByte_allPdSm</Name>
				<Type>ArrayOfBytes</Type>
				<Comment>allPdSm</Comment>
			</OutParameter>
			<TestStep Name="ClearAllPdSmList">
				<InitArray Length="0" TargetArray="GetListOfAllPdSm.ArrayOfByte_allPdSm"></InitArray>
			</TestStep>
			<TestStep Name="ClearAllPdSmIntermediateContainer">
				<InitArray Length="0" TargetArray="GetListOfAllPdSm.ArrayOfByte_allPdSmIntermediateContainer"></InitArray>
			</TestStep>
			<TestStep Name="GetListOfAllOutputSmAndUpdateArray">
				<CallTestFunction Name="GetListOfAllInputOrOutputSm">
					<Parameter>GetListOfAllPdSm.b_DebugMsg</Parameter>
					<Parameter>Outputs</Parameter>
					<OutParameter>GetListOfAllPdSm.ArrayOfByte_allPdSm</OutParameter>
				</CallTestFunction>
				<Compare>
					<Equal>
						<Value1>GetListOfAllPdSm.b_DebugMsg</Value1>
						<Value2>true</Value2>
						<WriteLine Id="0" Param0="GetListOfAllPdSm.ArrayOfByte_allPdSm">  "GetListOfAllPdSm" | After Getting all Output SyncManager | GetListOfAllPdSm.ArrayOfByte_allPdSm = {0}</WriteLine>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="GetListOfAllInputSm">
				<CallTestFunction Name="GetListOfAllInputOrOutputSm">
					<Parameter>GetListOfAllPdSm.b_DebugMsg</Parameter>
					<Parameter>Inputs</Parameter>
					<OutParameter>GetListOfAllPdSm.ArrayOfByte_allPdSmIntermediateContainer</OutParameter>
				</CallTestFunction>
				<Compare>
					<Equal>
						<Value1>GetListOfAllPdSm.b_DebugMsg</Value1>
						<Value2>true</Value2>
						<WriteLine Id="1" Param0="GetListOfAllPdSm.ArrayOfByte_allPdSmIntermediateContainer">  "GetListOfAllPdSm" | After Getting all Input SyncManager | GetListOfAllPdSm.ArrayOfByte_allPdSmIntermediateContainer = {0}</WriteLine>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="UpdateArray">
				<AddArrayItem TargetArray="GetListOfAllPdSm.ArrayOfByte_allPdSm">GetListOfAllPdSm.ArrayOfByte_allPdSmIntermediateContainer</AddArrayItem>
			</TestStep>
			<TestStep Name="WriteResultToLoggerAsDebugMessage">
				<Compare>
					<Equal>
						<Value1>GetListOfAllPdSm.b_DebugMsg</Value1>
						<Value2>true</Value2>
						<WriteLine Id="2" Param0="GetListOfAllPdSm.ArrayOfByte_allPdSm">  "GetListOfAllPdSm" | GetListOfAllPdSm.ArrayOfByte_allPdSm = {0}</WriteLine>
					</Equal>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="504" Name="GetListOfEnabledInputOrOutputSm">
			<?MAX_OUTPUT_ID 4?>
			<Description>
				<Purpose>Gets a list with all enabled output or input  process data SyncManagers (PDO length greater 0).

Return values:
- allEnabledOutputSm
- noEnabledOutputSm
- enabledOutputSmCount

Previously "GetAllEnabledOutputSm"</Purpose>
				<PreCondition>Slave has to be at least in PreOp state (since function ExtractEnabledSmFromList is called)</PreCondition>
				<Action>Gets a list with all Input or Output SyncManagers and extracts a list with the enabled SyncManagers</Action>
				<PostCondition>Return list with enabled Input or Output SyncManagers</PostCondition>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>GetListOfEnabledInputOrOutputSm.b_DebugMsg</Name>
				<Type>Bool</Type>
				<Comment>Write debug message to logger</Comment>
			</Parameter>
			<Parameter>
				<Name>GetListOfEnabledInputOrOutputSm.str_smType</Name>
				<Type>String</Type>
				<Comment>smType: allowed values: 
Inputs
Outputs</Comment>
			</Parameter>
			<LocalVariables>
				<Name>GetListOfEnabledInputOrOutputSm.ArrayOfByte_AllInputOrOutputSm</Name>
				<Type>ArrayOfBytes</Type>
				<DefaultValue></DefaultValue>
				<Comment></Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>GetListOfEnabledInputOrOutputSm.uint32_lengthOfList</Name>
				<Type>UInt32</Type>
				<DefaultValue></DefaultValue>
				<Comment></Comment>
			</LocalVariables>
			<OutParameter>
				<Name>GetListOfEnabledInputOrOutputSm.ArrayOfByte_ListOfEnabledInputOrOutputSm</Name>
				<Type>ArrayOfBytes</Type>
				<Comment></Comment>
			</OutParameter>
			<TestStep Name="DebugOutputThatFunctionStarted">
				<Compare>
					<Equal>
						<Value1>GetListOfEnabledInputOrOutputSm.b_DebugMsg</Value1>
						<Value2>true</Value2>
						<WriteLine Id="0">  "GetListOfEnabledInputOrOutputSm" started</WriteLine>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="GetListOfDesiredSmType">
				<CallTestFunction Name="GetListOfAllInputOrOutputSm">
					<Parameter>GetListOfEnabledInputOrOutputSm.b_DebugMsg</Parameter>
					<Parameter>GetListOfEnabledInputOrOutputSm.str_smType</Parameter>
					<OutParameter>GetListOfEnabledInputOrOutputSm.ArrayOfByte_AllInputOrOutputSm</OutParameter>
				</CallTestFunction>
			</TestStep>
			<TestStep Name="ReturnIfDesiredSmTypeNotAvailable">
				<SizeOf UInt32Var="GetListOfEnabledInputOrOutputSm.uint32_lengthOfList">GetListOfEnabledInputOrOutputSm.ArrayOfByte_AllInputOrOutputSm</SizeOf>
				<Compare>
					<Equal>
						<Value1>GetListOfEnabledInputOrOutputSm.b_DebugMsg</Value1>
						<Value2>true</Value2>
						<WriteLine Id="1" Param0="GetListOfEnabledInputOrOutputSm.uint32_lengthOfList">  "GetListOfEnabledInputOrOutputSm" | lengthOfList = {0}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>GetListOfEnabledInputOrOutputSm.uint32_lengthOfList</Value1>
						<Value2>0</Value2>
						<WriteLine Id="2" Level="Verbose" Param0="GetListOfEnabledInputOrOutputSm.str_smType">No {0}-SyncManager supported</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>GetListOfEnabledInputOrOutputSm.uint32_lengthOfList</Value1>
						<Value2>0</Value2>
						<Return Id="3"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="ResetReturnArrayOfthisFunction">
				<InitArray Length="0" TargetArray="GetListOfEnabledInputOrOutputSm.ArrayOfByte_ListOfEnabledInputOrOutputSm"></InitArray>
			</TestStep>
			<TestStep Name="ExtractEnabledSm">
				<CallTestFunction Name="ExtractEnabledSmFromList">
					<Parameter>GetListOfEnabledInputOrOutputSm.b_DebugMsg</Parameter>
					<Parameter>GetListOfEnabledInputOrOutputSm.ArrayOfByte_AllInputOrOutputSm</Parameter>
					<OutParameter>GetListOfEnabledInputOrOutputSm.ArrayOfByte_ListOfEnabledInputOrOutputSm</OutParameter>
				</CallTestFunction>
			</TestStep>
			<TestStep Name="WriteTestFunctionResultToLogger">
				<Compare>
					<Equal>
						<Value1>GetListOfEnabledInputOrOutputSm.b_DebugMsg</Value1>
						<Value2>true</Value2>
						<WriteLine Id="4" Param0="GetListOfEnabledInputOrOutputSm.str_smType" Param1="GetListOfEnabledInputOrOutputSm.ArrayOfByte_ListOfEnabledInputOrOutputSm">  List of enabled {0}-SyncManagers that shall be enabled according to PDO length = [{1}]</WriteLine>
					</Equal>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="601" Name="LocalOutputHandlerStartedInfo">
			<?MAX_OUTPUT_ID 2?>
			<Description>
				<Purpose>Makes a logger Output that Output SyncManger shall be set to received process values

(previously LocalOutputHandlerStarted)</Purpose>
				<PreCondition>Slave has to be at least in PreOp state (since GetListOfEnabledInputOrOutputSm is called) </PreCondition>
				<Action></Action>
				<PostCondition></PostCondition>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>LocalOutputHandlerStartedInfo.b_DebugMsg</Name>
				<Type>Bool</Type>
				<Comment>Write debug message to logger</Comment>
			</Parameter>
			<LocalVariables>
				<Name>LocalOutputHandlerStartedInfo.uint32_lengthOfList</Name>
				<Type>UInt32</Type>
				<DefaultValue>#x00</DefaultValue>
			</LocalVariables>
			<LocalVariables>
				<Name>LocalOutputHandlerStartedInfo.ArrayOfByte_ListOfEnabledOutputSm</Name>
				<Type>ArrayOfBytes</Type>
			</LocalVariables>
			<TestStep Name="DebugOutputThatFunctionStarted">
				<Compare>
					<Equal>
						<Value1>LocalOutputHandlerStartedInfo.b_DebugMsg</Value1>
						<Value2>true</Value2>
						<WriteLine Id="0">  "LocalOutputHandlerStartedInfo" started</WriteLine>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="ResetListOfEnabledOutputSm">
				<InitArray Length="0" TargetArray="LocalOutputHandlerStartedInfo.ArrayOfByte_ListOfEnabledOutputSm"></InitArray>
			</TestStep>
			<TestStep Name="GetEnabledOutputSm">
				<CallTestFunction Name="GetListOfEnabledInputOrOutputSm">
					<Parameter>Settings.bAll_debugMsg</Parameter>
					<Parameter>Outputs</Parameter>
					<OutParameter>LocalOutputHandlerStartedInfo.ArrayOfByte_ListOfEnabledOutputSm</OutParameter>
				</CallTestFunction>
			</TestStep>
			<TestStep Name="CheckIfEnabledOutputSmSupported">
				<SizeOf UInt32Var="LocalOutputHandlerStartedInfo.uint32_lengthOfList">LocalOutputHandlerStartedInfo.ArrayOfByte_ListOfEnabledOutputSm</SizeOf>
				<Compare>
					<Equal>
						<Value1>LocalOutputHandlerStartedInfo.uint32_lengthOfList</Value1>
						<Value2>0</Value2>
						<Return Id="1"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="LoggerInfoOutputShallBeInSafeState">
				<WriteLine Id="2" Level="Output">INFO | Outputs shall be set to received process values!</WriteLine>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="602" Name="LocalOutputHandlerStoppedInfo">
			<?MAX_OUTPUT_ID 2?>
			<Description>
				<Purpose>Makes a logger Output that Output SyncManger shall be set to safe values.

(previously LocalOutputHandlerStopped)</Purpose>
				<PreCondition>Slave is at least in PreOp state</PreCondition>
				<Action>Gets a list of all enabled output SyncManager and checks if this list is longer than 0</Action>
				<PostCondition>Make logger output that output values shall be set to safe value</PostCondition>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>LocalOutputHandlerStoppedInfo.b_DebugMsg</Name>
				<Type>Bool</Type>
				<Comment>Write debug message to logger</Comment>
			</Parameter>
			<LocalVariables>
				<Name>LocalOutputHandlerStoppedInfo.uint32_lengthOfList</Name>
				<Type>UInt32</Type>
				<DefaultValue>#x00</DefaultValue>
			</LocalVariables>
			<LocalVariables>
				<Name>LocalOutputHandlerStoppedInfo.ArrayOfByte_ListOfEnabledOutputSm</Name>
				<Type>ArrayOfBytes</Type>
			</LocalVariables>
			<TestStep Name="DebugOutputThatFunctionStarted">
				<Compare>
					<Equal>
						<Value1>LocalOutputHandlerStoppedInfo.b_DebugMsg</Value1>
						<Value2>true</Value2>
						<WriteLine Id="0">  "LocalOutputHandlerStoppedInfo" started</WriteLine>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="ResetListOfEnabledOutputSm">
				<InitArray Length="0" TargetArray="LocalOutputHandlerStoppedInfo.ArrayOfByte_ListOfEnabledOutputSm"></InitArray>
			</TestStep>
			<TestStep Name="GetEnabledOutputSm">
				<CallTestFunction Name="GetListOfEnabledInputOrOutputSm">
					<Parameter>Settings.bAll_debugMsg</Parameter>
					<Parameter>Outputs</Parameter>
					<OutParameter>LocalOutputHandlerStoppedInfo.ArrayOfByte_ListOfEnabledOutputSm</OutParameter>
				</CallTestFunction>
			</TestStep>
			<TestStep Name="CheckIfEnabledOutputSmSupported">
				<SizeOf UInt32Var="LocalOutputHandlerStoppedInfo.uint32_lengthOfList">LocalOutputHandlerStoppedInfo.ArrayOfByte_ListOfEnabledOutputSm</SizeOf>
				<Compare>
					<Equal>
						<Value1>LocalOutputHandlerStoppedInfo.uint32_lengthOfList</Value1>
						<Value2>0</Value2>
						<Return Id="1"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="LoggerInfoOutputShallBeInSafeState">
				<WriteLine Id="2" Level="Output">INFO | Outputs shall be set to safe values!</WriteLine>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="603" Name="LocalOutputHandlerStoppedInInit">
			<?MAX_OUTPUT_ID 1?>
			<Description>
				<Purpose>Makes a logger Output that Output SyncManger shall be set to safe values.
Use GetListOfEnabledInputOrOutputSm ("Outputs") in state when mbx communicatino supported


(previously LocalOutputHandlerStoppedInit)</Purpose>
				<PreCondition>List of enabled output SyncManager is unequal 0.</PreCondition>
				<Action>Checks the paramter "ListOfEnabledOutputSm" has at least one item.
If list is 0 the function returns</Action>
				<PostCondition>Make logger output that local outputs shall be set to safe value</PostCondition>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>LocalOutputHandlerStoppedInInit.ArrayOfBytes_ListOfEnabledOutputSm</Name>
				<Type>ArrayOfBytes</Type>
			</Parameter>
			<LocalVariables>
				<Name>LocalOutputHandlerStoppedInInit.uint32_lengthOfList</Name>
				<Type>UInt32</Type>
				<DefaultValue>#x00</DefaultValue>
			</LocalVariables>
			<TestStep Name="CheckIfEnabledOutputSmAvailable">
				<SizeOf UInt32Var="LocalOutputHandlerStoppedInInit.uint32_lengthOfList">LocalOutputHandlerStoppedInInit.ArrayOfBytes_ListOfEnabledOutputSm</SizeOf>
				<Compare>
					<Equal>
						<Value1>LocalOutputHandlerStoppedInInit.uint32_lengthOfList</Value1>
						<Value2>0</Value2>
						<Return Id="0"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="LoggerOutput">
				<WriteLine Id="1" Level="Output">Outputs shall be set to safe values!</WriteLine>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="701" Name="ReturnErrorIfCurrentConfigRequiresDcAndNoCu">
			<?MAX_OUTPUT_ID 11?>
			<Description>
				<Purpose>Check if CurrentConfig has a DC element, a DC:OpMode element, a Dc:OpMode:AssignActivate element and if AssignActivate activates a Sync-Signal. </Purpose>
				<Action>If yes check if Cu2508 available, otherwise generate error
If not, skip test</Action>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>ReturnErrorIfCurrentConfigRequiresDcAndNoCu.bDcSpecificTest</Name>
				<Type>Bool</Type>
				<Comment>True: Test must be performed for DC slaves. And must be skipped for non-DC slaves
False: Skip if non-Dc slave</Comment>
			</Parameter>
			<LocalVariables>
				<Name>ReturnErrorIfCurrentConfigRequiresDcAndNoCu.uint32OpModeCounter</Name>
				<Type>UInt32</Type>
			</LocalVariables>
			<TestStep Name="LOGGER_INFO_ABOUT_TEST_EVENT">
				<Description Id="0" Level="Verbose">Check if current configuration of DuT has AssignAcitvate == 0x0000 or realtime-enabling hardware connected.</Description>
			</TestStep>
			<TestStep Name="CheckIfDcSpecificTest">
				<Compare>
					<Equal>
						<Value1>ReturnErrorIfCurrentConfigRequiresDcAndNoCu.bDcSpecificTest</Value1>
						<Value2>True</Value2>
						<GotoStep>DCSPECIFIC_SkipIfEsiElementDeviceDcNotAvailableOr0</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="NOTDCSPECIFIC_ReturnIfEsiElementDeviceDcNotAvailableOr0">
				<Compare>
					<Equal>
						<Value1>CurrentConfig.Dc</Value1>
						<Value2>false</Value2>
						<Return Id="1"></Return>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CurrentConfig.DcOpMode</Value1>
						<Value2>null</Value2>
						<Return Id="2"></Return>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CurrentConfig.DcAssignActivate</Value1>
						<Value2>null</Value2>
						<RaiseError Id="3">Mandatory element AssignActivate of Dc:OpMode not available</RaiseError>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CurrentConfig.DcAssignActivate</Value1>
						<Value2>0</Value2>
						<Return Id="4"></Return>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CurrentConfig.DcAssignActivate</Value1>
						<Value2>0</Value2>
						<GotoStep>CheckifCuAvailable</GotoStep>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="DCSPECIFIC_SkipIfEsiElementDeviceDcNotAvailableOr0">
				<Compare>
					<Equal>
						<Value1>CurrentConfig.Dc</Value1>
						<Value2>false</Value2>
						<SkipCase Id="5">DC-specific test and DC not supported (ESI element Dc in current config not available)</SkipCase>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CurrentConfig.DcOpMode</Value1>
						<Value2>null</Value2>
						<SkipCase Id="6">DC-specific test and DC not supported (ESI element Dc:OpMode in current config not available)</SkipCase>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CurrentConfig.DcAssignActivate</Value1>
						<Value2>null</Value2>
						<RaiseError Id="7">Mandatory element AssignActivate of Dc:OpMode not available</RaiseError>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CurrentConfig.DcAssignActivate</Value1>
						<Value2>0</Value2>
						<SkipCase Id="8">DC-specific test and DC not supported (ESI element Dc:OpMode:AssignActivate = 0x0000)</SkipCase>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CheckifCuAvailable">
				<Compare>
					<Equal>
						<Value1>Master.Realtime</Value1>
						<Value2>true</Value2>
						<WriteLine Id="9" Level="Verbose">Realtime enabling hardware connected. Slave can be tested with its DC modes.</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>Master.Realtime</Value1>
						<Value2>true</Value2>
						<Return Id="10"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="ReturnError">
				<Compare>
					<Equal>
						<Value1>Master.Realtime</Value1>
						<Value2>false</Value2>
						<RaiseError Id="11">DcOpMode of current DuT configuration requires realtime-enabling hardware to perform this test. Connect CU2508.</RaiseError>
					</Equal>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="801" Name="ReadDcSysTime">
			<?MAX_OUTPUT_ID 7?>
			<Description>
				<Purpose>Read DC System Time 0x0910 from ESC and write to logger if Parameter is set. Checks if SysTime is 32 o 64 bit wide</Purpose>
				<Action></Action>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>ReadDcSysTime.b_DebugMsg</Name>
				<Type>Bool</Type>
			</Parameter>
			<LocalVariables>
				<Name>ReadDcSysTime.uint32DcSysTime</Name>
				<Type>Int32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>ReadDcSysTime.uint32DcSysTimeInMs</Name>
				<Type>Int32</Type>
				<Comment>in ms</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>ReadDcSysTime.uint64DcSysTime</Name>
				<Type>UInt64</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>ReadDcSysTime.uint32NextSync0EventTime</Name>
				<Type>UInt32</Type>
				<Comment>0x0990</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>ReadDcSysTime.uint32NextSync0EventTimeInMs</Name>
				<Type>UInt32</Type>
				<Comment>0x0990 in ms</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>ReadDcSysTime.uint64NextSync0EventTime</Name>
				<Type>UInt64</Type>
				<Comment>0x0990</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>ReadDcSysTime.uint64NextSync0EventTimeInMs</Name>
				<Type>UInt64</Type>
				<Comment>0x0990 in ms</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>ReadDcSysTime.bDcSysTimeLength</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>ReadDcSysTime.uint32EscFeaturesSupported</Name>
				<Type>UInt32</Type>
				<Comment>0x0009-0x0009</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>ReadDcSysTime.uint64DcSysTimeInMs</Name>
				<Type>UInt64</Type>
				<Comment>0x0990 in ms</Comment>
			</LocalVariables>
			<OutParameter>
				<Name>ReadDcSysTime.bDcSysTimeLength</Name>
				<Type>Bool</Type>
			</OutParameter>
			<TestStep Name="ReturnIfDebugIsFalse">
				<Compare>
					<Equal>
						<Value1>ReadDcSysTime.b_DebugMsg</Value1>
						<Value2>false</Value2>
						<Return Id="0"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="GetDcLength">
				<ReadEscData Target="ReadDcSysTime.uint32EscFeaturesSupported">
					<Address>#x0008</Address>
				</ReadEscData>
			</TestStep>
			<TestStep>
				<GetBits Target="ReadDcSysTime.bDcSysTimeLength" Source="ReadDcSysTime.uint32EscFeaturesSupported">
					<Offset>3</Offset>
					<Length>1</Length>
				</GetBits>
				<Compare>
					<Equal>
						<Value1>ReadDcSysTime.bDcSysTimeLength</Value1>
						<Value2>false</Value2>
						<WriteLine Id="1" Level="Verbose" Param0="ReadDcSysTime.bDcSysTimeLength">   32 bit DC supported (register 0x0008:3 = {0})</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>ReadDcSysTime.bDcSysTimeLength</Value1>
						<Value2>true</Value2>
						<WriteLine Id="2" Level="Verbose" Param0="ReadDcSysTime.bDcSysTimeLength">   64bit DC supported (register 0x0008:3 = {0})</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>ReadDcSysTime.bDcSysTimeLength</Value1>
						<Value2>true</Value2>
						<GotoStep>GET64DCSYSTIME</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="Get32DcSysTime">
				<ReadEscData Target="ReadDcSysTime.uint32DcSysTime">
					<Address>#x910</Address>
				</ReadEscData>
			</TestStep>
			<TestStep>
				<SetVariable Target="ReadDcSysTime.uint32DcSysTimeInMs">ReadDcSysTime.uint32DcSysTime/1000000UL</SetVariable>
				<WriteLine Id="3" Level="Verbose" Param0="ReadDcSysTime.uint32DcSysTime" Param1="ReadDcSysTime.uint32DcSysTimeInMs">   0x0910 = {0}ns = {1}ms (DcSysTime32)</WriteLine>
			</TestStep>
			<TestStep Name="GetNextSyncEventTime32">
				<ReadEscData Target="ReadDcSysTime.uint32NextSync0EventTime">
					<Address>#x990</Address>
				</ReadEscData>
			</TestStep>
			<TestStep>
				<SetVariable Target="ReadDcSysTime.uint32NextSync0EventTimeInMs">ReadDcSysTime.uint32NextSync0EventTime/1000000UL</SetVariable>
				<WriteLine Id="4" Level="Verbose" Param0="ReadDcSysTime.uint32NextSync0EventTime" Param1="ReadDcSysTime.uint32NextSync0EventTimeInMs">   0x0990 = {0}ns = {1}ms ( NextDcEventTime32)</WriteLine>
				<Compare>
					<Equal>
						<Value1>ReadDcSysTime.bDcSysTimeLength</Value1>
						<Value2>false</Value2>
						<Return Id="5"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="GET64DCSYSTIME">
				<ReadEscData Target="ReadDcSysTime.uint64DcSysTime">
					<Address>#x910</Address>
				</ReadEscData>
			</TestStep>
			<TestStep>
				<SetVariable Target="ReadDcSysTime.uint64DcSysTimeInMs">ReadDcSysTime.uint64DcSysTime/1000000UL</SetVariable>
				<WriteLine Id="6" Level="Verbose" Param0="ReadDcSysTime.uint64DcSysTime" Param1="ReadDcSysTime.uint64DcSysTimeInMs">   0x0910 = {0}ns = {1}ms (DcSysTime64)</WriteLine>
			</TestStep>
			<TestStep Name="GetNextSyncEventTime64">
				<ReadEscData Target="ReadDcSysTime.uint64NextSync0EventTime">
					<Address>#x990</Address>
				</ReadEscData>
			</TestStep>
			<TestStep>
				<SetVariable Target="ReadDcSysTime.uint64NextSync0EventTimeInMs">ReadDcSysTime.uint64NextSync0EventTime/1000000UL</SetVariable>
				<WriteLine Id="7" Level="Verbose" Param0="ReadDcSysTime.uint64NextSync0EventTime" Param1="ReadDcSysTime.uint64NextSync0EventTimeInMs">   0x0990 = {0}ns  = {1}ms (NextDcEventTime64)</WriteLine>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="901" Name="SetBackInitTimeout">
			<?MAX_OUTPUT_ID 2?>
			<Description>
				<Purpose>Set ESM safeOPTimeout to default value. If value defined in ESI file set to this value.
Timeout time for state transition from OP/SAFEOP/PREOP/BOOT → INIT SAFEOP → PREOP. Default value: 5000ms</Purpose>
				<Action></Action>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>SetBackInitTimeout.b_DebugMsg</Name>
				<Type>Bool</Type>
			</Parameter>
			<OutParameter>
				<Name>SetBackInitTimeout.int32_backInitTimeout</Name>
				<Type>Int32</Type>
				<Comment></Comment>
			</OutParameter>
			<TestStep Name="SetDefaultValue">
				<SetVariable Target="SetBackInitTimeout.int32_backInitTimeout">5000</SetVariable>
			</TestStep>
			<TestStep Name="CheckIfTimeoutsDefinedInEsiFile">
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Info</Value1>
						<Value2>false</Value2>
						<Return Id="0"></Return>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Info.StateMachine.Timeout</Value1>
						<Value2>false</Value2>
						<Return Id="1"></Return>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Info.StateMachine.Timeout.BackToInitTimeout</Value1>
						<Value2>null</Value2>
						<Return Id="2"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="SetEsiTimeoutValue">
				<!--Init-> PreOp and Boot->Init-->
				<SetVariable Target="SetBackInitTimeout.int32_backInitTimeout">DeviceDescr.Info.StateMachine.Timeout.BackToInitTimeout</SetVariable>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="902" Name="SetBackSafeOpTimeout">
			<?MAX_OUTPUT_ID 2?>
			<Description>
				<Purpose>Set ESM safeOPTimeout (Op &gt; Safetp) to default value. If value defined in ESI file set to this value.
Timeout time for state transition from OP → SAFEOP. Default value: 200ms</Purpose>
				<Action></Action>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>SetBackSafeOpTimeout.b_DebugMsg</Name>
				<Type>Bool</Type>
			</Parameter>
			<OutParameter>
				<Name>SetBackSafeOpTimeout.int32_safeOPTimeout</Name>
				<Type>Int32</Type>
				<Comment></Comment>
			</OutParameter>
			<TestStep Name="SetDefaultValue">
				<SetVariable Target="SetBackSafeOpTimeout.int32_safeOPTimeout">200</SetVariable>
			</TestStep>
			<TestStep Name="CheckIfTimeoutsDefinedInEsiFile">
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Info</Value1>
						<Value2>false</Value2>
						<Return Id="0"></Return>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Info.StateMachine.Timeout</Value1>
						<Value2>false</Value2>
						<Return Id="1"></Return>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Info.StateMachine.Timeout.BackToSafeopTimeout</Value1>
						<Value2>null</Value2>
						<Return Id="2"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="SetEsiTimeoutValue">
				<!--Init-> PreOp and Boot->Init-->
				<SetVariable Target="SetBackSafeOpTimeout.int32_safeOPTimeout">DeviceDescr.Info.StateMachine.Timeout.BackToSafeopTimeout</SetVariable>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="903" Name="SetBootstrapMbxSyncManSettings">
			<?MAX_OUTPUT_ID 10?>
			<Description>
				<Purpose>Sets Bootstrap Mailbox settings (previously SetSm01Boot)</Purpose>
				<PreCondition>ESI file has Maibox SyncManageres in ESI element Sm</PreCondition>
				<Action>- Get Bootstrap SyncManager Settings from ESI element Eeeprom:Bootstrap
- Deactiviate MailboxSyncManagers to ensure access
- Set Bootstrap SyncManager setttings</Action>
				<PostCondition>Send logger info if deactivation or setting of Mbx SyncManagers not possible</PostCondition>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<LocalVariables>
				<Name>SetBootstrapMbxSyncManSettings.byteNullByte</Name>
				<Type>Byte</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>SetBootstrapMbxSyncManSettings_uint16Sm0StartAddress</Name>
				<Type>UInt16</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>SetBootstrapMbxSyncManSettings_uint16Sm0Length</Name>
				<Type>UInt16</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>SetBootstrapMbxSyncManSettings_uint16Sm1StartAddress</Name>
				<Type>UInt16</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>SetBootstrapMbxSyncManSettings_uint16Sm1Length</Name>
				<Type>UInt16</Type>
			</LocalVariables>
			<TestStep Name="CheckIfMailboxSyncManagerSupported">
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Mailbox</Value1>
						<Value2>false</Value2>
						<Return Id="0"></Return>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.SM[0].DefaultSize</Value1>
						<Value2>null</Value2>
						<Return Id="1">Device description does not contain an element for Sm[0]:DefaultSize</Return>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.SM[1].DefaultSize</Value1>
						<Value2>null</Value2>
						<Return Id="2">Device description does not contain an element for Sm[1]:DefaultSize</Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="SetBootSm0Add">
				<GetArrayItem Index="0" SourceArray="DeviceDescr.Eeprom.BootStrap" Target="SetBootstrapMbxSyncManSettings_uint16Sm0StartAddress"></GetArrayItem>
			</TestStep>
			<TestStep Name="SetBootSm0Length">
				<GetArrayItem Index="1" SourceArray="DeviceDescr.Eeprom.BootStrap" Target="SetBootstrapMbxSyncManSettings_uint16Sm0Length"></GetArrayItem>
			</TestStep>
			<TestStep Name="SetBootSm1Add">
				<GetArrayItem Index="2" SourceArray="DeviceDescr.Eeprom.BootStrap" Target="SetBootstrapMbxSyncManSettings_uint16Sm1StartAddress"></GetArrayItem>
			</TestStep>
			<TestStep Name="SetBootSm1Length">
				<GetArrayItem Index="3" SourceArray="DeviceDescr.Eeprom.BootStrap" Target="SetBootstrapMbxSyncManSettings_uint16Sm1Length"></GetArrayItem>
			</TestStep>
			<TestStep>
				<SetVariable Target="SetBootstrapMbxSyncManSettings.byteNullByte">0</SetVariable>
			</TestStep>
			<TestStep Name="DisableSm0">
				<Description Id="3" Level="Verbose">Disable SyncManager 0 to ensure access to SyncManager Settings Registers</Description>
				<WriteEscData Source="SetBootstrapMbxSyncManSettings.byteNullByte">
					<Address>#x806</Address>
				</WriteEscData>
				<RaiseErrorOnFailure Id="4">Failed to disable SyncManager 0 for Bootstrap</RaiseErrorOnFailure>
			</TestStep>
			<TestStep Name="SetSm0WithBootstrapSettings">
				<Description Id="5" Level="Verbose">Set SyncManager 0 with Bootstrap Settings</Description>
				<SetSyncManagerSettings>
					<Number>0</Number>
					<Start>SetBootstrapMbxSyncManSettings_uint16Sm0StartAddress</Start>
					<Length>SetBootstrapMbxSyncManSettings_uint16Sm0Length</Length>
					<ControlByte>DeviceDescr.SM[0].ControlByte</ControlByte>
					<Enable>DeviceDescr.SM[0].Enable</Enable>
				</SetSyncManagerSettings>
				<RaiseErrorOnFailure Id="6">Failed to set  boot sync manager settings of SyncManager 0 for Bootstrap</RaiseErrorOnFailure>
			</TestStep>
			<TestStep Name="DisableSm1">
				<Description Id="7" Level="Verbose">Disable SyncManager 1 to ensure access to SyncManager Settings Registers</Description>
				<WriteEscData Source="SetBootstrapMbxSyncManSettings.byteNullByte">
					<Address>#x80E</Address>
				</WriteEscData>
				<RaiseErrorOnFailure Id="8">Failed to disable SyncManager 1 for Bootstrap</RaiseErrorOnFailure>
			</TestStep>
			<TestStep Name="SetSm1WithBootstrapSettings">
				<Description Id="9" Level="Verbose">Set SyncManager 1 with Bootstrap Settings</Description>
				<SetSyncManagerSettings>
					<Number>1</Number>
					<Start>SetBootstrapMbxSyncManSettings_uint16Sm1StartAddress</Start>
					<Length>SetBootstrapMbxSyncManSettings_uint16Sm1Length</Length>
					<ControlByte>DeviceDescr.SM[1].ControlByte</ControlByte>
					<Enable>DeviceDescr.SM[1].Enable</Enable>
				</SetSyncManagerSettings>
				<RaiseErrorOnFailure Id="10">Failed to set boot sync manager settings of SyncManager 1 for Bootstrap</RaiseErrorOnFailure>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="904" Name="SetMailboxSyncManSettings">
			<?MAX_OUTPUT_ID 6?>
			<Description>
				<Purpose>Set mailbox SyncManager settings</Purpose>
				<PreCondition>- ESI element SyncManager available
- Check if first Sm is an Output Mailbox SyncManager. If not check if Input Mbx SyncManager available</PreCondition>
				<Action>- Get Bootstrap SyncManager Settings from ESI element Sm
- Set Bootstrap SyncManager setttings</Action>
				<PostCondition>Raise error in logger if setting  Mbx SyncManagers not possible</PostCondition>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<TestStep Name="EsiElementSmAvailable">
				<Compare>
					<Equal>
						<Value1>DeviceDescr.SM.Count</Value1>
						<Value2>0</Value2>
						<RaiseError Id="0">INFO | No Sm Element in ESI defined!</RaiseError>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="EsiElementSmTestDefined">
				<Compare>
					<Equal>
						<Value1>DeviceDescr.SM[0]</Value1>
						<Value2>null</Value2>
						<RaiseError Id="1">INFO: No Sm:Text element defined in ESI for SyncManager0</RaiseError>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="MBoxOutSmAvailable">
				<Compare>
					<NotEqual>
						<Value1>DeviceDescr.SM[0]</Value1>
						<Value2>MBoxOut</Value2>
						<GotoStep>MBXIN</GotoStep>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="SetSm0">
				<Description Id="2">Set SyncManager 0 settings according to ESI</Description>
				<SetSyncManagerSettings>
					<Number>0</Number>
					<Start>DeviceDescr.SM[0].StartAddress</Start>
					<Length>DeviceDescr.SM[0].DefaultSize</Length>
					<ControlByte>DeviceDescr.SM[0].ControlByte</ControlByte>
					<Enable>DeviceDescr.SM[0].Enable</Enable>
				</SetSyncManagerSettings>
				<RaiseErrorOnFailure Id="3">Failed to set SyncManager settings of SyncManager 0</RaiseErrorOnFailure>
			</TestStep>
			<TestStep Name="MBXIN">
				<Compare>
					<NotEqual>
						<Value1>DeviceDescr.SM[1]</Value1>
						<Value2>MBoxIn</Value2>
						<Return Id="4"></Return>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="SetSm1">
				<Description Id="5">Set SyncManager 1 settings according to ESI</Description>
				<SetSyncManagerSettings>
					<Number>1</Number>
					<Start>DeviceDescr.SM[1].StartAddress</Start>
					<Length>DeviceDescr.SM[1].DefaultSize</Length>
					<ControlByte>DeviceDescr.SM[1].ControlByte</ControlByte>
					<Enable>DeviceDescr.SM[1].Enable</Enable>
				</SetSyncManagerSettings>
				<RaiseErrorOnFailure Id="6">Failed to set SyncManager settings of SyncManager 1</RaiseErrorOnFailure>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="905" Name="SetPreOpTimeout">
			<?MAX_OUTPUT_ID 2?>
			<Description>
				<Purpose>Set ESM preOPTimeout to default value. If value defined in ESI file set to this value.
Timeout time for state transition from INIT → PREOP/BOOT. Default value: 3000ms</Purpose>
				<Action></Action>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>SetPreOpTimeout.b_DebugMsg</Name>
				<Type>Bool</Type>
			</Parameter>
			<OutParameter>
				<Name>SetPreOpTimeout.int32_preOPTimeout</Name>
				<Type>Int32</Type>
				<Comment></Comment>
			</OutParameter>
			<TestStep Name="SetDefaultValue">
				<SetVariable Target="SetPreOpTimeout.int32_preOPTimeout">3000</SetVariable>
			</TestStep>
			<TestStep Name="CheckIfTimeoutsDefinedInEsiFile">
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Info</Value1>
						<Value2>false</Value2>
						<Return Id="0"></Return>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Info.StateMachine.Timeout</Value1>
						<Value2>false</Value2>
						<Return Id="1"></Return>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Info.StateMachine.Timeout.PreopTimeout</Value1>
						<Value2>null</Value2>
						<Return Id="2"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="SetEsiTimeoutValue">
				<!--Init-> PreOp and Boot->Init-->
				<SetVariable Target="SetPreOpTimeout.int32_preOPTimeout">DeviceDescr.Info.StateMachine.Timeout.PreopTimeout</SetVariable>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="906" Name="SetSafeOpTimeout">
			<?MAX_OUTPUT_ID 2?>
			<Description>
				<Purpose>Set ESM safeOPTimeout (SafeOp &gt; Op)  to default value. If value defined in ESI file set to this value.
Timeout time for state transition from SAFEOP → OP, PREOP → SAFEOP, Default value: 10000ms</Purpose>
				<Action></Action>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>SetSafeOpTimeout.b_DebugMsg</Name>
				<Type>Bool</Type>
			</Parameter>
			<OutParameter>
				<Name>SetSafeOpTimeout.int32_safeOPTimeout</Name>
				<Type>Int32</Type>
				<Comment></Comment>
			</OutParameter>
			<TestStep Name="SetDefaultValue">
				<SetVariable Target="SetSafeOpTimeout.int32_safeOPTimeout">10000</SetVariable>
			</TestStep>
			<TestStep Name="CheckIfTimeoutsDefinedInEsiFile">
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Info</Value1>
						<Value2>false</Value2>
						<Return Id="0"></Return>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Info.StateMachine.Timeout</Value1>
						<Value2>false</Value2>
						<Return Id="1"></Return>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Info.StateMachine.Timeout.SafeopOpTimeout</Value1>
						<Value2>null</Value2>
						<Return Id="2"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="SetEsiTimeoutValue">
				<!--Init-> PreOp and Boot->Init-->
				<SetVariable Target="SetSafeOpTimeout.int32_safeOPTimeout">DeviceDescr.Info.StateMachine.Timeout.SafeopOpTimeout</SetVariable>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="907" Name="SetSyncManSettingsAccToPdoLength">
			<?MAX_OUTPUT_ID 8?>
			<Description>
				<Purpose>Sets all available process data SyncManagers according to PdoLength

This functions
- sets all Input/Output-SmSettings according to PDO configuration:
+ when PdoUpload=1, then SM-Objects from online-OD are read and Sm-Settings calculated
+ when PdoUpload = 0, then PDOs assigned to Sm by default are used to calculate SM-Settings

- when ESI:Mailbox:CoE:PdoUpload is not set the ESI-SyncManagerSettings are set

NOTE: This function makes only sense when device supports Mbx since SDO services are used and when device is at least in PreOp State</Purpose>
				<PreCondition></PreCondition>
				<Action></Action>
				<PostCondition></PostCondition>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>SetSyncManSettingsAccToPdoLength_Settings.bAll_debugMsg</Name>
				<Type>Bool</Type>
			</Parameter>
			<LocalVariables>
				<Name>SetSyncManSettingsAccToPdoLength.uint32_sizeOfAllPdSm</Name>
				<Type>UInt32</Type>
				<DefaultValue>0</DefaultValue>
			</LocalVariables>
			<LocalVariables>
				<Name>SetSyncManSettingsAccToPdoLength.ArrayOBytes_allPdSm</Name>
				<Type>ArrayOfBytes</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>SetSyncManSettingsAccToPdoLength.uint32_index</Name>
				<Type>UInt32</Type>
				<DefaultValue>0</DefaultValue>
			</LocalVariables>
			<LocalVariables>
				<Name>SetSyncManSettingsAccToPdoLength.byte_pdSm</Name>
				<Type>Byte</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>SetSyncManSettingsAccToPdoLength.uint32_defaultPdLength</Name>
				<Type>UInt32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>SetSyncManSettingsAccToPdoLength.bool_smEnable</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>SetSyncManSettingsAccToPdoLength.ArrayOfBytes_smSetting</Name>
				<Type>ArrayOfBytes</Type>
				<DefaultValue>0000000000000000</DefaultValue>
			</LocalVariables>
			<LocalVariables>
				<Name>SetSyncManSettingsAccToPdoLength.uint16_smAdo</Name>
				<Type>UInt16</Type>
			</LocalVariables>
			<TestStep Name="ANYPDSM">
				<Description Id="0" Level="Output">Get a list with all Process Data SyncManagers</Description>
				<CallTestFunction Name="GetListOfAllPdSm">
					<Parameter>Settings.bAll_debugMsg</Parameter>
					<OutParameter>SetSyncManSettingsAccToPdoLength.ArrayOBytes_allPdSm</OutParameter>
				</CallTestFunction>
			</TestStep>
			<TestStep Name="GetNumberOfallPdSm">
				<SizeOf UInt32Var="SetSyncManSettingsAccToPdoLength.uint32_sizeOfAllPdSm">SetSyncManSettingsAccToPdoLength.ArrayOBytes_allPdSm</SizeOf>
				<Compare>
					<Equal>
						<Value1>SetSyncManSettingsAccToPdoLength.uint32_sizeOfAllPdSm</Value1>
						<Value2>0</Value2>
						<Return Id="1" Param0="No process data SyncManager"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="GET_COUNT_OF_PD_SM">
				<GetArrayItem Index="SetSyncManSettingsAccToPdoLength.uint32_index" SourceArray="SetSyncManSettingsAccToPdoLength.ArrayOBytes_allPdSm" Target="SetSyncManSettingsAccToPdoLength.byte_pdSm"></GetArrayItem>
				<WriteLine Id="2" Param0="SetSyncManSettingsAccToPdoLength.byte_pdSm" Param1="SetSyncManSettingsAccToPdoLength.uint32_index" Level="Verbose">Start to get SyncManager{0} length || index32 = {1}</WriteLine>
			</TestStep>
			<TestStep Name="SetSmReadAdo">
				<SetVariable Target="SetSyncManSettingsAccToPdoLength.uint16_smAdo">#x0800+SetSyncManSettingsAccToPdoLength.byte_pdSm*8</SetVariable>
			</TestStep>
			<TestStep Name="DeubgSetting_GetPdSmSettings0x08xxBefore">
				<ReadEscData Target="SetSyncManSettingsAccToPdoLength.ArrayOfBytes_smSetting">
					<Address>SetSyncManSettingsAccToPdoLength.uint16_smAdo</Address>
				</ReadEscData>
				<Compare>
					<Equal>
						<Value1>SetSyncManSettingsAccToPdoLength_Settings.bAll_debugMsg</Value1>
						<Value2>true</Value2>
						<WriteLine Param0="SetSyncManSettingsAccToPdoLength.uint16_smAdo" Param1="SetSyncManSettingsAccToPdoLength.ArrayOfBytes_smSetting" Level="Verbose">INFO || SyncManager settings for 0x{0:x2} before writing valid settings = 0x{1:x8}</WriteLine>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CheckIfPdoUploadIsTrueInEsi">
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Mailbox</Value1>
						<Value2>false</Value2>
						<GotoStep>PDOUPLOADFALSE_SET_ESI_PD_SM</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Mailbox.CoE</Value1>
						<Value2>false</Value2>
						<GotoStep>PDOUPLOADFALSE_SET_ESI_PD_SM</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Mailbox.CoE.PdoUpload</Value1>
						<Value2>null</Value2>
						<GotoStep>PDOUPLOADFALSE_SET_ESI_PD_SM</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Mailbox.CoE.PdoUpload</Value1>
						<Value2>TRUE</Value2>
						<GotoStep>PDOUPLOADTRUE_GET_DEFAULT_LENGTH_FROM_ONLINE_OD</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="PDOUPLOADFALSE_SET_ESI_PD_SM">
				<Description Id="3" Param0="SetSyncManSettingsAccToPdoLength.byte_pdSm">Set SyncManager{0} according to ESI description, while Sm@Enable attribute is set according to default PDO length of ESI file</Description>
				<GetMaxPdoLength SyncMan="SetSyncManSettingsAccToPdoLength.byte_pdSm" Int32Var="SetSyncManSettingsAccToPdoLength.uint32_defaultPdLength" Source="CurrentConfig"></GetMaxPdoLength>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>ENABLESETTING_GET_LENGTH_OF_SM</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="PDOUPLOADTRUE_GET_DEFAULT_LENGTH_FROM_ONLINE_OD">
				<Description Id="4" Param0="SetSyncManSettingsAccToPdoLength.byte_pdSm">Set SyncManager{0} according to PdoLength read from online object dictionary (ESI element PdoUpload = TRUE)</Description>
				<GetMaxPdoLength SyncMan="SetSyncManSettingsAccToPdoLength.byte_pdSm" Int32Var="SetSyncManSettingsAccToPdoLength.uint32_defaultPdLength" Source="OD"></GetMaxPdoLength>
			</TestStep>
			<TestStep Name="ENABLESETTING_GET_LENGTH_OF_SM">
				<Description Id="5" Param0="SetSyncManSettingsAccToPdoLength.uint32_defaultPdLength">Since PDO length is {0}...</Description>
				<Compare>
					<Equal>
						<Value1>SetSyncManSettingsAccToPdoLength.uint32_defaultPdLength</Value1>
						<Value2>0</Value2>
						<GotoStep>ELSE_SET_ENABLE_FALSE</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="SetEnableToTrue">
				<Description Id="6">...enable SyncManager</Description>
				<SetVariable Target="SetSyncManSettingsAccToPdoLength.bool_smEnable">TRUE</SetVariable>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>MAKESMINPUTSETTINGS</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="ELSE_SET_ENABLE_FALSE">
				<Description Id="7">...disable SyncManager</Description>
				<SetVariable Target="SetSyncManSettingsAccToPdoLength.bool_smEnable">FALSE</SetVariable>
			</TestStep>
			<TestStep Name="MAKESMINPUTSETTINGS">
				<Description Id="8" Param0="SetSyncManSettingsAccToPdoLength.byte_pdSm" Param1="CurrentConfig.Sm[SetSyncManSettingsAccToPdoLength.byte_pdSm].StartAddress" Param2="CurrentConfig.Sm[SetSyncManSettingsAccToPdoLength.byte_pdSm].ControlByte" Param3="SetSyncManSettingsAccToPdoLength.bool_smEnable">Write SyncManager{0} registers | StartAddress = {1:x} | ControlByte = {2:x} | Enable = {3}</Description>
				<SetSyncManagerSettings>
					<Number>SetSyncManSettingsAccToPdoLength.byte_pdSm</Number>
					<Start>CurrentConfig.Sm[SetSyncManSettingsAccToPdoLength.byte_pdSm].StartAddress</Start>
					<Length>SetSyncManSettingsAccToPdoLength.uint32_defaultPdLength</Length>
					<ControlByte>CurrentConfig.Sm[SetSyncManSettingsAccToPdoLength.byte_pdSm].ControlByte</ControlByte>
					<Enable>SetSyncManSettingsAccToPdoLength.bool_smEnable</Enable>
				</SetSyncManagerSettings>
			</TestStep>
			<TestStep Name="DeubgSetting_GetPdSmSettings0x08xxAfter">
				<ReadEscData Target="SetSyncManSettingsAccToPdoLength.ArrayOfBytes_smSetting">
					<Address>SetSyncManSettingsAccToPdoLength.uint16_smAdo</Address>
				</ReadEscData>
				<Compare>
					<Equal>
						<Value1>SetSyncManSettingsAccToPdoLength_Settings.bAll_debugMsg</Value1>
						<Value2>true</Value2>
						<WriteLine Param0="SetSyncManSettingsAccToPdoLength.uint16_smAdo" Param1="SetSyncManSettingsAccToPdoLength.ArrayOfBytes_smSetting" Level="Verbose">INFO || SyncManager settings for 0x{0:x2} after writing valid settings = 0x{1:x8}</WriteLine>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="IncrmeentPdSmIndexAndCheckifDone">
				<SetVariable Target="SetSyncManSettingsAccToPdoLength.uint32_index">SetSyncManSettingsAccToPdoLength.uint32_index+1</SetVariable>
				<Compare>
					<Lower>
						<Value1>SetSyncManSettingsAccToPdoLength.uint32_index</Value1>
						<Value2>SetSyncManSettingsAccToPdoLength.uint32_sizeOfAllPdSm</Value2>
						<GotoStep>GET_COUNT_OF_PD_SM</GotoStep>
					</Lower>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="908" Name="SetSmStartAdd0x0AndLength0x2">
			<?MAX_OUTPUT_ID 6?>
			<Description>
				<Purpose>Sets invalid SyncManager settings.
Only used when no other enabled SM available from which the Sm Settings could be used.

Writes invalid SM-length (0x0002) and invalid SM-Start addres 0x0018:0x0019 (reserved) to the SyncManager in question</Purpose>
				<PreCondition></PreCondition>
				<Action></Action>
				<PostCondition></PostCondition>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>SetSmStartAdd0x0AndLength0x2.bAll_debugMsg</Name>
				<Type>Bool</Type>
			</Parameter>
			<Parameter>
				<Name>SetSmStartAdd0x0AndLength0x2.byte_smNo</Name>
				<Type>Byte</Type>
			</Parameter>
			<LocalVariables>
				<Name>SetSmStartAdd0x0AndLength0x2.uint16_smAdo</Name>
				<Type>UInt16</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>SetSmStartAdd0x0AndLength0x2.uint16_invalidSmStartAddress</Name>
				<Type>UInt16</Type>
				<DefaultValue>#x0018</DefaultValue>
			</LocalVariables>
			<LocalVariables>
				<Name>SetSmStartAdd0x0AndLength0x2.uint16_invalidSmLength</Name>
				<Type>UInt16</Type>
				<DefaultValue>#x0002</DefaultValue>
			</LocalVariables>
			<LocalVariables>
				<Name>SetSmStartAdd0x0AndLength0x2.byte_smControl</Name>
				<Type>Byte</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>SetSmStartAdd0x0AndLength0x2.byte_smActivate</Name>
				<Type>Byte</Type>
				<DefaultValue>#x01</DefaultValue>
			</LocalVariables>
			<TestStep Name="DebugMessageFunctionStart">
				<Compare>
					<Equal>
						<Value1>SetSmStartAdd0x0AndLength0x2.bAll_debugMsg</Value1>
						<Value2>True</Value2>
						<WriteLine Id="0">TEST FUNCTION START | SetSmStartAddAndLengthTo0x900</WriteLine>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="LoadEscRegisterAddressToWriteStartAddress">
				<SetVariable Target="SetSmStartAdd0x0AndLength0x2.uint16_smAdo">#x800+8*SetSmStartAdd0x0AndLength0x2.byte_smNo</SetVariable>
			</TestStep>
			<TestStep Name="WriteInvalidSmStartAddress">
				<WriteEscData Source="SetSmStartAdd0x0AndLength0x2.uint16_invalidSmStartAddress">
					<Address>SetSmStartAdd0x0AndLength0x2.uint16_smAdo</Address>
				</WriteEscData>
				<RaiseErrorOnFailure Id="1" Param0="SetSmStartAdd0x0AndLength0x2.uint16_invalidSmStartAddress" Param1="SetSmStartAdd0x0AndLength0x2.byte_smNo">Failed to write invalid SM start address (0x{0:x2}) to SyncManager{1}</RaiseErrorOnFailure>
				<WriteLine Id="2" Param0="SetSmStartAdd0x0AndLength0x2.byte_smNo" Param1="SetSmStartAdd0x0AndLength0x2.uint16_invalidSmStartAddress" Level="Verbose">Wrong SM start address written to SM{0}, Start Address written = 0x{1:x2}</WriteLine>
			</TestStep>
			<TestStep Name="LoadEscRegisterAddressToWriteLength">
				<SetVariable Target="SetSmStartAdd0x0AndLength0x2.uint16_smAdo">#x802+8*SetSmStartAdd0x0AndLength0x2.byte_smNo</SetVariable>
			</TestStep>
			<TestStep Name="WriteInvalidSmLength">
				<WriteEscData Source="SetSmStartAdd0x0AndLength0x2.uint16_invalidSmLength">
					<Address>SetSmStartAdd0x0AndLength0x2.uint16_smAdo</Address>
				</WriteEscData>
				<RaiseErrorOnFailure Id="3" Param0="SetSmStartAdd0x0AndLength0x2.uint16_invalidSmLength" Param1="SetSmStartAdd0x0AndLength0x2.byte_smNo">Failed to write invalid SM length (0x{0:x2}) to SyncManager{1}</RaiseErrorOnFailure>
				<WriteLine Id="4" Param0="SetSmStartAdd0x0AndLength0x2.byte_smNo" Param1="SetSmStartAdd0x0AndLength0x2.uint16_invalidSmLength" Level="Verbose">Wrong length written to SM{0}, Length written = 0x{1:x2} bytes</WriteLine>
			</TestStep>
			<TestStep Name="LoadEscRegisterAddressToWriteEnable">
				<SetVariable Target="SetSmStartAdd0x0AndLength0x2.uint16_smAdo">#x806+8*SetSmStartAdd0x0AndLength0x2.byte_smNo</SetVariable>
			</TestStep>
			<TestStep Name="WriteSmEnable">
				<WriteEscData Source="SetSmStartAdd0x0AndLength0x2.byte_smActivate">
					<Address>SetSmStartAdd0x0AndLength0x2.uint16_smAdo</Address>
				</WriteEscData>
				<WriteLine Id="5" Param0="SetSmStartAdd0x0AndLength0x2.byte_smNo" Level="Verbose">Enable Sm{0} to activate wrong start address settings</WriteLine>
			</TestStep>
			<TestStep Name="DebugMessageFunctionEnd">
				<Compare>
					<Equal>
						<Value1>SetSmStartAdd0x0AndLength0x2.bAll_debugMsg</Value1>
						<Value2>True</Value2>
						<WriteLine Id="6">TEST FUNCTION END | SetSmStartAddAndLengthTo0x900</WriteLine>
					</Equal>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="909" Name="SetWrongSyncManSettings">
			<?MAX_OUTPUT_ID 11?>
			<Description>
				<Purpose>Sets wrong SmSettings for specified SyncManager:
- if SM enabled: disable
- if disabled: Write start address and length of other enabled SM

Parameter:
- smNo (SyncManager for which wrong SmSettings shall be written)

Return Values:
- smType (Inputs 0, MbxInput 2, Outputs 4, MbxOutputs 6)
if Sm enabled -&gt; disable
if Sm disabled -&gt; write startAdress of the first enabled Sm found and enable

Used Variables:
- nullByte
- VerifySyncManChannelDisabled.uint16_smAdo
- smNo
- otherSm</Purpose>
				<PreCondition></PreCondition>
				<Action></Action>
				<PostCondition></PostCondition>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>SetWrongSyncManSettings_Settings.bAll_debugMsg</Name>
				<Type>Bool</Type>
			</Parameter>
			<Parameter>
				<Name>SetWrongSyncManSettings.byte_smNo</Name>
				<Type>Byte</Type>
			</Parameter>
			<LocalVariables>
				<Name>SetWrongSyncManSettings.byte_otherSm</Name>
				<Type>Byte</Type>
				<DefaultValue>0</DefaultValue>
			</LocalVariables>
			<LocalVariables>
				<Name>SetWrongSyncManSettings.byte_nullByte</Name>
				<Type>Byte</Type>
				<DefaultValue>0</DefaultValue>
			</LocalVariables>
			<LocalVariables>
				<Name>SetWrongSyncManSettings.uint16_VerifySyncManChannelDisabled.uint16_smAdo</Name>
				<Type>UInt16</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>SetWrongSyncManSettings.byte_smControl</Name>
				<Type>Byte</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>SetWrongSyncManSettings.bool_smEnable</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>SetWrongSyncManSettings.byte_smActivate</Name>
				<Type>Byte</Type>
			</LocalVariables>
			<TestStep Name="LoadSmActivateRegisterAddress">
				<SetVariable Target="SetWrongSyncManSettings.uint16_VerifySyncManChannelDisabled.uint16_smAdo">#x0806+8*SetWrongSyncManSettings.byte_smNo</SetVariable>
			</TestStep>
			<TestStep Name="ReadActivateRegisterFromEsc">
				<ReadEscData Target="SetWrongSyncManSettings.byte_smControl">
					<Address>SetWrongSyncManSettings.uint16_VerifySyncManChannelDisabled.uint16_smAdo</Address>
				</ReadEscData>
				<RaiseErrorOnFailure Id="0" Param0="SetWrongSyncManSettings.uint16_VerifySyncManChannelDisabled.uint16_smAdo">Failed to read SmControl Byte of SyncManager{0}</RaiseErrorOnFailure>
			</TestStep>
			<TestStep Name="GetSmEnableBit">
				<GetBits Target="SetWrongSyncManSettings.bool_smEnable" Source="SetWrongSyncManSettings.byte_smControl">
					<Offset>0</Offset>
					<Length>1</Length>
				</GetBits>
				<Compare>
					<Equal>
						<Value1>SetWrongSyncManSettings.bool_smEnable</Value1>
						<Value2>FALSE</Value2>
						<GotoStep>IF_DISABLED_THEN_GET_START_ADD_OF_OTHER_ENABLED_SM</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="IfSyncManagerIsEnabledThenDisableNow_WithSmControlEq0_andReturn">
				<WriteEscData Source="SetWrongSyncManSettings.byte_nullByte">
					<Address>SetWrongSyncManSettings.uint16_VerifySyncManChannelDisabled.uint16_smAdo</Address>
				</WriteEscData>
				<RaiseErrorOnFailure Id="1" Param0="SetWrongSyncManSettings.byte_smNo">Failed to disable SyncManager{0}</RaiseErrorOnFailure>
				<WriteLine Id="2" Param0="SetWrongSyncManSettings.byte_smNo" Level="Verbose">Info | Disable Sm{0} to enforce wrong SyncManager settings </WriteLine>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<Return Id="3"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="IF_DISABLED_THEN_GET_START_ADD_OF_OTHER_ENABLED_SM">
				<Compare>
					<Equal>
						<Value1>SetWrongSyncManSettings.byte_smNo</Value1>
						<Value2>SetWrongSyncManSettings.byte_otherSm</Value2>
						<GotoStep>NEXT</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="IfSmEnabledInEsiFile_ThenGoTo_WriteWrongStartAddress">
				<Compare>
					<Equal>
						<Value1>DeviceDescr.SM[SetWrongSyncManSettings.byte_otherSm]</Value1>
						<Value2>null</Value2>
						<RaiseError Id="4" Param0="SetWrongSyncManSettings.byte_otherSm">No ESI element Device:Sm[{0}] available while Bootstrap is supported which needs SM0 and SM1</RaiseError>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.SM[SetWrongSyncManSettings.byte_otherSm].Enable</Value1>
						<Value2>null</Value2>
						<RaiseError Id="5" Param0="SetWrongSyncManSettings.byte_otherSm">No ESI element Device:Sm[{0}].Enable available while Bootstrap is supported which needs SM0 and SM1</RaiseError>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.SM[SetWrongSyncManSettings.byte_otherSm].Enable</Value1>
						<Value2>true</Value2>
						<GotoStep>WRITEWRONGSTART</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="NEXT">
				<!--If no other enable Sm then use memory in register area-->
				<SetVariable Target="SetWrongSyncManSettings.byte_otherSm">SetWrongSyncManSettings.byte_otherSm+1</SetVariable>
				<Compare>
					<GreaterOrEqual>
						<Value1>SetWrongSyncManSettings.byte_otherSm</Value1>
						<Value2>DeviceDescr.SM.Count</Value2>
						<CallTestFunction Name="SetSmStartAdd0x0AndLength0x2">
							<Parameter>SetWrongSyncManSettings_Settings.bAll_debugMsg</Parameter>
							<Parameter>SetWrongSyncManSettings.byte_smNo</Parameter>
						</CallTestFunction>
					</GreaterOrEqual>
				</Compare>
				<Compare>
					<GreaterOrEqual>
						<Value1>SetWrongSyncManSettings.byte_otherSm</Value1>
						<Value2>DeviceDescr.SM.Count</Value2>
						<Return Id="6"></Return>
					</GreaterOrEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>IF_DISABLED_THEN_GET_START_ADD_OF_OTHER_ENABLED_SM</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="WRITEWRONGSTART">
				<SetVariable Target="SetWrongSyncManSettings.uint16_VerifySyncManChannelDisabled.uint16_smAdo">#x800+8*SetWrongSyncManSettings.byte_smNo</SetVariable>
			</TestStep>
			<TestStep Name="WriteStartAddressOfOtherSm">
				<WriteEscData Source="DeviceDescr.SM[SetWrongSyncManSettings.byte_otherSm].StartAddress">
					<Address>SetWrongSyncManSettings.uint16_VerifySyncManChannelDisabled.uint16_smAdo</Address>
				</WriteEscData>
				<RaiseErrorOnFailure Id="7" Param0="SetWrongSyncManSettings.byte_otherSm" Param1="SetWrongSyncManSettings.byte_smNo">Failed to write start address of SyncManager{0} to SyncManager{1}</RaiseErrorOnFailure>
				<WriteLine Id="8" Param0="SetWrongSyncManSettings.byte_smNo" Param1="SetWrongSyncManSettings.byte_otherSm" Level="Verbose">Wrong Start Address written to SM (SetWrongSyncManSettings.byte_smNo) = {0}, Start Address taken from Sm (otherSm) = {1}</WriteLine>
			</TestStep>
			<TestStep Name="LoadEscRegisterAddressToWriteLength">
				<SetVariable Target="SetWrongSyncManSettings.uint16_VerifySyncManChannelDisabled.uint16_smAdo">#x802+8*SetWrongSyncManSettings.byte_smNo</SetVariable>
			</TestStep>
			<TestStep Name="WriteLenghtOfOtherSm">
				<WriteEscData Source="DeviceDescr.SM[SetWrongSyncManSettings.byte_otherSm].DefaultSize">
					<Address>SetWrongSyncManSettings.uint16_VerifySyncManChannelDisabled.uint16_smAdo</Address>
				</WriteEscData>
				<RaiseErrorOnFailure Id="9" Param0="SetWrongSyncManSettings.byte_otherSm" Param1="SetWrongSyncManSettings.byte_smNo">Failed to write start address of SyncManager{0} to SyncManager{1}</RaiseErrorOnFailure>
				<WriteLine Id="10" Param0="SetWrongSyncManSettings.byte_smNo" Param1="SetWrongSyncManSettings.byte_otherSm" Level="Verbose">Wrong length written to SM (SetWrongSyncManSettings.byte_smNo) = {0}, Length taken from Sm (otherSm) = {1}</WriteLine>
			</TestStep>
			<TestStep Name="LoadEscRegisterAddressToWriteEnable">
				<SetVariable Target="SetWrongSyncManSettings.uint16_VerifySyncManChannelDisabled.uint16_smAdo">#x806+8*SetWrongSyncManSettings.byte_smNo</SetVariable>
			</TestStep>
			<TestStep Name="LoadSmActivateValue">
				<SetVariable Target="SetWrongSyncManSettings.byte_smActivate">#x01</SetVariable>
			</TestStep>
			<TestStep Name="WriteSmEnable">
				<WriteEscData Source="SetWrongSyncManSettings.byte_smActivate">
					<Address>SetWrongSyncManSettings.uint16_VerifySyncManChannelDisabled.uint16_smAdo</Address>
				</WriteEscData>
				<WriteLine Id="11" Param0="SetWrongSyncManSettings.byte_smNo" Level="Verbose">Enable Sm{0} to activate wrong start address settings</WriteLine>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="1001" Name="SkipIfNotTf1201OrReg134NotSupported">
			<?MAX_OUTPUT_ID 3?>
			<Description>
				<Purpose>Skips test case if ESI element IdentificationReg134 = false or if parameter "isTf-1201TestFile" is false</Purpose>
				<PreCondition>- This function is only executed if the parameter reg134Supported is true</PreCondition>
				<Action>- Check root of IdentificationReg134 and the  value itsel if true.</Action>
				<PostCondition>- If true: return
- if false: skip test</PostCondition>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>SkipIfNotTf1201OrReg134NotSupported.bool_isTf1201TestFile</Name>
				<Type>Bool</Type>
			</Parameter>
			<TestStep>
				<Compare>
					<Equal>
						<Value1>SkipIfNotTf1201OrReg134NotSupported.bool_isTf1201TestFile</Value1>
						<Value2>false</Value2>
						<Return Id="0"></Return>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Info</Value1>
						<Value2>FALSE</Value2>
						<SkipCase Id="1">Explcit Device Identification with register 0x0134 not supported -&gt; skip case | INFO: ESI element DeviceDescr.Info not available</SkipCase>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Info.IdentificationReg134</Value1>
						<Value2>null</Value2>
						<SkipCase Id="2">Explcit Device Identification with register 0x0134 not supported -&gt; skip case | INFO: ESI element DeviceDescr.Info.IdentificationReg134 not available</SkipCase>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Info.IdentificationReg134</Value1>
						<Value2>false</Value2>
						<SkipCase Id="3" Param0="DeviceDescr.Info.IdentificationReg134">Explcit Device Identification with register 0x0134 not supported -&gt; skip case | INFO: ESI element DeviceDescr.Info.IdentificationReg134 = {0}</SkipCase>
					</Equal>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="1101" Name="SkipTestIfCurrentConfigRequiresDcAndNoCu">
			<?MAX_OUTPUT_ID 9?>
			<Parameter>
				<Name>SkipTestIfDcOnly.bPerfomeAnyways</Name>
				<Type>Bool</Type>
				<Comment>debug_opTestsAlsoIfDcOnly</Comment>
			</Parameter>
			<LocalVariables>
				<Name>SkipTestIfDcOnly.uint32OpModeCounter</Name>
				<Type>UInt32</Type>
			</LocalVariables>
			<TestStep Name="ReturnIfPerformTestAnywaysIstrue">
				<Compare>
					<Equal>
						<Value1>SkipTestIfDcOnly.bPerfomeAnyways</Value1>
						<Value2>true</Value2>
						<Return Id="0">performTestAnyways = true</Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="LOGGER_INFO_ABOUT_TEST_EVENT">
				<Description Id="1" Level="Verbose">Check if current configuration of DuT has AssignAcitvate == 0x0000 or realtime-enabling hardware connected.</Description>
			</TestStep>
			<TestStep Name="ReturnIfEsiElementDeviceDcNotAvailableOr0">
				<Compare>
					<Equal>
						<Value1>CurrentConfig.Dc</Value1>
						<Value2>false</Value2>
						<WriteLine Id="2" Level="Verbose">DC not supported (ESI element Dc not available)</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CurrentConfig.Dc</Value1>
						<Value2>false</Value2>
						<Return Id="3"></Return>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CurrentConfig.DcAssignActivate</Value1>
						<Value2>0</Value2>
						<WriteLine Id="4" Level="Verbose">DC not supported (Dc:OpMode:AssignActivate = 0x0000)</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CurrentConfig.DcAssignActivate</Value1>
						<Value2>0</Value2>
						<Return Id="5"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="DoNotSkipIfCuAvailable">
				<Compare>
					<Equal>
						<Value1>Master.Realtime</Value1>
						<Value2>true</Value2>
						<WriteLine Id="6" Level="Verbose">Realtime enabling hardware connected. Slave can be tested with its DC modes.</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<Return Id="7"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="SKIP">
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<RaiseWarning Id="8">DcOpMode of current DuT configuration requires realtime-enabling hardware or shall pass the test according to ETG.7000 EtherCAT Conformance Test Speciffication Amendment for DC Devices.</RaiseWarning>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<SkipCase Id="9">Test is skipped. Test shall be performed manually according to ETG.7000!</SkipCase>
					</Equal>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="1102" Name="SkipTestIfDeviceEmulationActive">
			<?MAX_OUTPUT_ID 0?>
			<Description>
				<Purpose>Checks if device emulatoin bit in register 0x0141 Bit 0 is set and skips test with putting a message to the logger</Purpose>
				<PreCondition></PreCondition>
				<Action>get Device Emulation bit (0x0141) via CTT tool variable</Action>
				<PostCondition>Skip Test if true and write message to looger</PostCondition>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<TestStep Name="SkipTestIfDeviceEmulationActiveAndWriteLogger">
				<Compare>
					<Equal>
						<Value1>Esc.DeviceEmulation </Value1>
						<Value2>True</Value2>
						<SkipCase Id="0">Device Emulation active. Test Case does not apply to Simple Devices -&gt; Skip Test Case.</SkipCase>
					</Equal>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="1103" Name="SkipTestIfPreOpSafeOpStartUpCmdsRequired">
			<?MAX_OUTPUT_ID 5?>
			<Description>
				<Purpose>Test goes from ErrPreOp to SafeOp.Therefore, start-up commands from PreOp to SafeOp cannot be sent.</Purpose>
				<PreCondition>ESI attributes PdoConfig, PdoAssign, Coe:InitCmds are used</PreCondition>
				<Action></Action>
				<PostCondition>Skip test if such start-up commands are required</PostCondition>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<TestStep>
				<!--SkipTestIfPreOpSafeOpStartUpCmdsRequired-->
				<Description Id="0" Level="Verbose">Test goes from ErrPreOp to SafeOp.Therefore, start-up commands from PreOp to SafeOp cannot be sent. Check if test needs to be skipped in such a case.</Description>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Mailbox</Value1>
						<Value2>false</Value2>
						<Return Id="1"></Return>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Mailbox.CoE</Value1>
						<Value2>false</Value2>
						<Return Id="2"></Return>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Mailbox.CoE.PdoAssign</Value1>
						<Value2>true</Value2>
						<SkipCase Id="3">Skip | Slave requires PreOp-SafeOp start-up commands.</SkipCase>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Mailbox.CoE.PdoConfig</Value1>
						<Value2>true</Value2>
						<SkipCase Id="4">Skip | Slave requires PreOp-SafeOp start-up commands.</SkipCase>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>DeviceDescr.Mailbox.CoE.InitCmd.Count</Value1>
						<Value2>0</Value2>
						<SkipCase Id="5">Skip | Slave requires PreOp-SafeOp start-up commands.</SkipCase>
					</NotEqual>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="1201" Name="VerifyAlStatusAndAlStatusCode">
			<?MAX_OUTPUT_ID 4?>
			<Description>
				<Purpose>Validates AL Status and AL Status Code(1,2) and, if necessary raises an error. It does not read registers.</Purpose>
				<PreCondition></PreCondition>
				<Action>compare the provides AL Status and the AL Status Codes . No Register are read</Action>
				<PostCondition></PostCondition>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>VerifyAlStatusAndAlStatusCode.uint16ActualAlStatus</Name>
				<Type>UInt16</Type>
				<!--alStatus-->
			</Parameter>
			<Parameter>
				<Name>VerifyAlStatusAndAlStatusCode.uint16ActualAlStatusCode</Name>
				<Type>UInt16</Type>
				<!--alStatusCode-->
			</Parameter>
			<Parameter>
				<Name>VerifyAlStatusAndAlStatusCode.uint16StateValueNext</Name>
				<Type>UInt16</Type>
				<!--stateValueNext-->
			</Parameter>
			<Parameter>
				<Name>VerifyAlStatusAndAlStatusCode.uint16ExpectedAlStatusCode</Name>
				<Type>UInt16</Type>
				<!--expectedAlStatusCode-->
			</Parameter>
			<Parameter>
				<Name>VerifyAlStatusAndAlStatusCode.uint16ExpectedAlStatusCode2</Name>
				<Type>UInt16</Type>
				<!--expectedAlStatusCode2-->
			</Parameter>
			<TestStep>
				<!--AlStatus = stateValueNext ?-->
				<Compare>
					<NotEqual>
						<Value1>VerifyAlStatusAndAlStatusCode.uint16ActualAlStatus</Value1>
						<Value2>VerifyAlStatusAndAlStatusCode.uint16StateValueNext</Value2>
						<RaiseError Id="0" Param0="VerifyAlStatusAndAlStatusCode.uint16StateValueNext" Param1="VerifyAlStatusAndAlStatusCode.uint16ActualAlStatus" Param2="VerifyAlStatusAndAlStatusCode.uint16ExpectedAlStatusCode" Param3="VerifyAlStatusAndAlStatusCode.uint16ActualAlStatusCode">Invalid AL Status || Expected AL Status = 0x{0:x2}, Read = 0x{1:x2}  || Info: Expected AL Status Code = 0x{2:x2}, Read = 0x{3:x2}</RaiseError>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep>
				<!--expectedAlStatusCode2  ?-->
				<Compare>
					<NotEqual>
						<Value1>VerifyAlStatusAndAlStatusCode.uint16ExpectedAlStatusCode2</Value1>
						<Value2>0</Value2>
						<GotoStep>STATCODE2</GotoStep>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep>
				<!--AlStatusCode = expectedAlStatusCode  ?-->
				<Compare>
					<NotEqual>
						<Value1>VerifyAlStatusAndAlStatusCode.uint16ActualAlStatusCode</Value1>
						<Value2>VerifyAlStatusAndAlStatusCode.uint16ExpectedAlStatusCode</Value2>
						<RaiseError Id="1" Param0="VerifyAlStatusAndAlStatusCode.uint16ExpectedAlStatusCode" Param1="VerifyAlStatusAndAlStatusCode.uint16ActualAlStatusCode" Param2="VerifyAlStatusAndAlStatusCode.uint16StateValueNext" Param3="VerifyAlStatusAndAlStatusCode.uint16ActualAlStatus">Invalid AL Status Code || Expected AL Status Code = 0x{0:x4}, Read = 0x{1:x4}  || Info: Expected AL Status = 0x{2:x2}, Read = 0x{3:x2}</RaiseError>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Return-->
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<Return Id="2"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="STATCODE2">
				<!--AlStatusCode = expectedAlStatusCode  ?-->
				<Compare>
					<Equal>
						<Value1>VerifyAlStatusAndAlStatusCode.uint16ActualAlStatusCode</Value1>
						<Value2>VerifyAlStatusAndAlStatusCode.uint16ExpectedAlStatusCode</Value2>
						<Return Id="3"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--AlStatusCode = fexpectedAlStatusCode2  ?-->
				<Compare>
					<NotEqual>
						<Value1>VerifyAlStatusAndAlStatusCode.uint16ActualAlStatusCode</Value1>
						<Value2>VerifyAlStatusAndAlStatusCode.uint16ExpectedAlStatusCode2</Value2>
						<RaiseError Id="4" Param0="VerifyAlStatusAndAlStatusCode.uint16ExpectedAlStatusCode" Param1="VerifyAlStatusAndAlStatusCode.uint16ExpectedAlStatusCode2" Param2="VerifyAlStatusAndAlStatusCode.uint16ActualAlStatusCode" Param3="VerifyAlStatusAndAlStatusCode.uint16ActualAlStatus">Invalid AL Status Code || Expected AL Status Code = 0x{0:x4} or 0x{1:x4}, Read = 0x{2:x2}  || Info: AL Status = 0x{3:x2}</RaiseError>
					</NotEqual>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="1202" Name="VerifyAlStatusCode">
			<?MAX_OUTPUT_ID 6?>
			<Description>
				<Purpose>Validates the actual AL Status Code against two possible AL Status Codes and, if necessary raises an error.</Purpose>
				<PreCondition></PreCondition>
				<Action>compare the provides AL Status Code. No Register are read</Action>
				<PostCondition>If ErrFlag = 0 and AlStatusCode unequal 0 then raise warning, if run for TF-1200. Skip Warning if test is run as TF-1201</PostCondition>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>VerifyAlStatusCode.uint16ActualAlStatusCode</Name>
				<Type>UInt16</Type>
				<!--The current Al Status Code possibly read from register 0x134-->
			</Parameter>
			<Parameter>
				<Name>VerifyAlStatusCode.uint16ExpectedAlStatusCode</Name>
				<Type>UInt16</Type>
				<!--Status Code which is expected after the state transition-->
			</Parameter>
			<Parameter>
				<Name>VerifyAlStatusCode.uint16ExpectedAlStatusCode2</Name>
				<Type>UInt16</Type>
				<!--If a second AL Status Code is possible -->
			</Parameter>
			<Parameter>
				<Name>VerifyAlStatusCode.uint16ActualAlStatus</Name>
				<Type>UInt16</Type>
				<!--alStatus-->
			</Parameter>
			<Parameter>
				<Name>VerifyAlStatusCode.uint16StateValueNext</Name>
				<Type>UInt16</Type>
				<!--stateValueNext-->
			</Parameter>
			<Parameter>
				<Name>VerifyAlStatusCode.bool_tf1201</Name>
				<Type>Bool</Type>
				<!--bool_tf1201-->
			</Parameter>
			<TestStep>
				<!--fexpectedAlStatusCode2  ?-->
				<Compare>
					<NotEqual>
						<Value1>VerifyAlStatusCode.uint16ExpectedAlStatusCode2</Value1>
						<Value2>0</Value2>
						<GotoStep>STATCODE2</GotoStep>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep>
				<!--expectedAlStatusCode = 0 -> if not, only warning, no error-->
				<Compare>
					<NotEqual>
						<Value1>VerifyAlStatusCode.uint16ExpectedAlStatusCode</Value1>
						<Value2>0</Value2>
						<GotoStep>STATCODE1</GotoStep>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyAlStatusCode.bool_tf1201</Value1>
						<Value2>true</Value2>
						<Return Id="0"></Return>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>VerifyAlStatusCode.uint16ActualAlStatusCode</Value1>
						<Value2>VerifyAlStatusCode.uint16ExpectedAlStatusCode</Value2>
						<RaiseWarning Id="1" Param0="VerifyAlStatusCode.uint16ExpectedAlStatusCode" Param1="VerifyAlStatusCode.uint16ActualAlStatusCode" Param2="VerifyAlStatusCode.uint16StateValueNext" Param3="VerifyAlStatusCode.uint16ActualAlStatus">AL Status Code should be 0 when ErrorFlag of AL Status reigster is false || INFO: Expected AL Status Code = 0x{0:x4}, Read = 0x{1:x4}, Expected AL Status = 0x{2:x4}, Read = 0x{3:x4}</RaiseWarning>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<Return Id="2"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="STATCODE1">
				<!--AlStatusCode = expectedAlStatusCode  ?-->
				<Compare>
					<NotEqual>
						<Value1>VerifyAlStatusCode.uint16ActualAlStatusCode</Value1>
						<Value2>VerifyAlStatusCode.uint16ExpectedAlStatusCode</Value2>
						<RaiseError Id="3" Param0="VerifyAlStatusCode.uint16ExpectedAlStatusCode" Param1="VerifyAlStatusCode.uint16ActualAlStatusCode" Param2="VerifyAlStatusCode.uint16StateValueNext" Param3="VerifyAlStatusCode.uint16ActualAlStatus">Invalid AL Status Code || Expected AL Status Code = 0x{0:x4}, Read = 0x{1:x4}  || Info: Expected AL Status = 0x{2:x2}, Read = 0x{3:x2}</RaiseError>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Return-->
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<Return Id="4"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="STATCODE2">
				<!--AlStatusCode = expectedAlStatusCode  ?-->
				<Compare>
					<Equal>
						<Value1>VerifyAlStatusCode.uint16ActualAlStatusCode</Value1>
						<Value2>VerifyAlStatusCode.uint16ExpectedAlStatusCode</Value2>
						<Return Id="5"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--AlStatusCode = fexpectedAlStatusCode2  ?-->
				<Compare>
					<NotEqual>
						<Value1>VerifyAlStatusCode.uint16ActualAlStatusCode</Value1>
						<Value2>VerifyAlStatusCode.uint16ExpectedAlStatusCode2</Value2>
						<RaiseError Id="6" Param0="VerifyAlStatusCode.uint16ExpectedAlStatusCode" Param1="VerifyAlStatusCode.uint16ExpectedAlStatusCode2" Param2="VerifyAlStatusCode.uint16ActualAlStatusCode" Param3="VerifyAlStatusCode.uint16ActualAlStatus">Invalid AL Status Code || Expected AL Status Code = 0x{0:x4} or 0x{1:x4}, Read = 0x{2:x2}  || Info: AL Status = 0x{3:x2}</RaiseError>
					</NotEqual>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="1203" Name="VerifyInOutputHandlerStarted">
			<?MAX_OUTPUT_ID 5?>
			<Description>
				<Purpose>Checks for all Process Data Input and Output SyncManager if handler was started and generates a logger output if successfull or not</Purpose>
				<PreCondition>- At least on enabled PD Sm available 
- Slave has to be at least in PreOp state (since function GetListOfAllEnabledSm -&gt;ExtractEnabledSmFromList is called)</PreCondition>
				<Action>Read PD SM Control register (+0x07.0) and check if false
</Action>
				<PostCondition>- If false: success logger output
- If true: Error logger output</PostCondition>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>VerifyInOutputHandlerStarted_Settings.bAll_debugMsg</Name>
				<Type>Bool</Type>
			</Parameter>
			<LocalVariables>
				<Name>VerifyInOutputHandlerStarted.ArrayOfBytes_allEnabledPdSm</Name>
				<Type>ArrayOfBytes</Type>
				<DefaultValue>0</DefaultValue>
			</LocalVariables>
			<LocalVariables>
				<Name>VerifyInOutputHandlerStarted.uint32_enabledPdSmCount</Name>
				<Type>UInt32</Type>
				<DefaultValue>0</DefaultValue>
			</LocalVariables>
			<LocalVariables>
				<Name>VerifyInOutputHandlerStarted.uint32_index</Name>
				<Type>UInt32</Type>
				<DefaultValue>0</DefaultValue>
			</LocalVariables>
			<LocalVariables>
				<Name>VerifyInOutputHandlerStarted.byte_pdSm</Name>
				<Type>Byte</Type>
				<DefaultValue>0</DefaultValue>
			</LocalVariables>
			<LocalVariables>
				<Name>VerifyInOutputHandlerStarted.uint16_VerifySyncManChannelDisabled.uint16_smAdo</Name>
				<Type>UInt16</Type>
				<DefaultValue>0</DefaultValue>
			</LocalVariables>
			<LocalVariables>
				<Name>VerifyInOutputHandlerStarted.byte_smControl</Name>
				<Type>Byte</Type>
				<DefaultValue>0</DefaultValue>
			</LocalVariables>
			<LocalVariables>
				<Name>VerifyInOutputHandlerStarted.uint16_smDeactivate</Name>
				<Type>Bool</Type>
				<DefaultValue>0</DefaultValue>
			</LocalVariables>
			<TestStep Name="GetListOfAllEnabledSm">
				<CallTestFunction Name="GetListOfAllEnabledSm">
					<Parameter>Settings.bAll_debugMsg</Parameter>
					<OutParameter>VerifyInOutputHandlerStarted.ArrayOfBytes_allEnabledPdSm</OutParameter>
				</CallTestFunction>
			</TestStep>
			<TestStep Name="ReturnIfNoEnabledPdSmSupported">
				<SizeOf UInt32Var="VerifyInOutputHandlerStarted.uint32_enabledPdSmCount">VerifyInOutputHandlerStarted.ArrayOfBytes_allEnabledPdSm</SizeOf>
				<Compare>
					<Equal>
						<Value1>VerifyInOutputHandlerStarted.uint32_enabledPdSmCount</Value1>
						<Value2>0</Value2>
						<Return Id="0">No enabled process data SyncManager available. Checking if Input and/ or Output handler are stopped not necessary.</Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="GET_PD_SM_NUMBER_TO_CHECK_IF_ENABLED">
				<GetArrayItem Index="VerifyInOutputHandlerStarted.uint32_index" SourceArray="VerifyInOutputHandlerStarted.ArrayOfBytes_allEnabledPdSm" Target="VerifyInOutputHandlerStarted.byte_pdSm"></GetArrayItem>
				<WriteLine Id="1" Level="Verbose" Param0="VerifyInOutputHandlerStarted.byte_pdSm">Start to check  if Handler for SyncManager{0} was started</WriteLine>
			</TestStep>
			<TestStep Name="ReadPdiSmControlRegister_0x07">
				<SetVariable Target="VerifyInOutputHandlerStarted.uint16_VerifySyncManChannelDisabled.uint16_smAdo">#x807+8*VerifyInOutputHandlerStarted.byte_pdSm</SetVariable>
				<WriteLine Id="2" Level="Verbose" Param0="VerifyInOutputHandlerStarted.byte_pdSm">Read PDI Control Register of SyncManager{0}</WriteLine>
			</TestStep>
			<TestStep>
				<ReadEscData Target="VerifyInOutputHandlerStarted.byte_smControl">
					<Address>VerifyInOutputHandlerStarted.uint16_VerifySyncManChannelDisabled.uint16_smAdo</Address>
				</ReadEscData>
				<RaiseErrorOnFailure Id="3" Param0="VerifyInOutputHandlerStarted.uint16_VerifySyncManChannelDisabled.uint16_smAdo">Failed to read Syncmanager PDI Control Register 0x{0:x4}!</RaiseErrorOnFailure>
			</TestStep>
			<TestStep Name="CheckIf0x07isFalse">
				<GetBits Source="VerifyInOutputHandlerStarted.byte_smControl" Target="VerifyInOutputHandlerStarted.uint16_smDeactivate">
					<Offset>0</Offset>
					<Length>1</Length>
				</GetBits>
				<Compare>
					<NotEqual>
						<Value1>VerifyInOutputHandlerStarted.uint16_smDeactivate</Value1>
						<Value2>false</Value2>
						<RaiseError Id="4" Param0="VerifyInOutputHandlerStarted.uint16_smDeactivate" Param1="VerifyInOutputHandlerStarted.uint16_VerifySyncManChannelDisabled.uint16_smAdo">Handler was not started|| Register 0x{1:x4}:00:  Expected = false, Read = {0}.</RaiseError>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="LoggerOutput_partSuccessfull">
				<WriteLine Id="5" Level="Verbose" Param0="VerifyInOutputHandlerStarted.byte_pdSm">SM{0} handler start successfull</WriteLine>
			</TestStep>
			<TestStep Name="IncrementSmIndexAndCheckIfDone">
				<SetVariable Target="VerifyInOutputHandlerStarted.uint32_index">VerifyInOutputHandlerStarted.uint32_index+1</SetVariable>
				<Compare>
					<Lower>
						<Value1>VerifyInOutputHandlerStarted.uint32_index</Value1>
						<Value2>VerifyInOutputHandlerStarted.uint32_enabledPdSmCount</Value2>
						<GotoStep>GET_PD_SM_NUMBER_TO_CHECK_IF_ENABLED</GotoStep>
					</Lower>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="1204" Name="VerifySyncManChannelDisabled">
			<?MAX_OUTPUT_ID 39?>
			<Description>
				<Purpose>Spec: "..SyncManager 2 shall be disabled. Only if there is no Output SyncManager or an input error occurs the Input SyncManager shall be disabled while SyncManager 2 remains enabled." 
- If no PdSm &gt; Skip
- If no enabled PdSm &gt; Skip
- If one enabled PdSm &gt; first (enabled or disabled) PdSm = "Sm2" and Sm2+1 = "Sm3 (there must be no Mailbox-Sm in between)
</Purpose>
				<PreCondition>- Slave at least in PreOp </PreCondition>
				<Action></Action>
				<PostCondition></PostCondition>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>VerifySyncManChannelDisabled_Settings.bAll_debugMsg</Name>
				<Type>Bool</Type>
			</Parameter>
			<LocalVariables>
				<Name>VerifySyncManChannelDisabled.ArrayOfBytes_allEnabledPdSm</Name>
				<Type>ArrayOfBytes</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>VerifySyncManChannelDisabled.ArrayOfBytes_allPdSm</Name>
				<Type>ArrayOfBytes</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>VerifySyncManChannelDisabled.uint32_enabledPdSmCount</Name>
				<Type>UInt32</Type>
				<DefaultValue>0</DefaultValue>
			</LocalVariables>
			<LocalVariables>
				<Name>VerifySyncManChannelDisabled.uint16_sm2Ado</Name>
				<Type>UInt32</Type>
				<DefaultValue>0</DefaultValue>
			</LocalVariables>
			<LocalVariables>
				<Name>VerifySyncManChannelDisabled.uint16_sm3Ado</Name>
				<Type>UInt32</Type>
				<DefaultValue>0</DefaultValue>
			</LocalVariables>
			<LocalVariables>
				<Name>VerifySyncManChannelDisabled.byte_sm2Control</Name>
				<Type>Byte</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>VerifySyncManChannelDisabled.bool_sm2Deactivate</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>VerifySyncManChannelDisabled.byte_sm3Control</Name>
				<Type>Byte</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>VerifySyncManChannelDisabled.bool_sm3Deactivate</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>VerifySyncManChannelDisabled.bool_sm2Disabled</Name>
				<Type>Bool</Type>
				<!--TRUE = SM disabled-->
			</LocalVariables>
			<LocalVariables>
				<Name>VerifySyncManChannelDisabled.bool_sm3Disabled</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>VerifySyncManChannelDisabled.byte_sm2</Name>
				<Type>Byte</Type>
				<DefaultValue>255</DefaultValue>
			</LocalVariables>
			<LocalVariables>
				<Name>VerifySyncManChannelDisabled.byte_sm3</Name>
				<Type>Byte</Type>
				<DefaultValue>255</DefaultValue>
			</LocalVariables>
			<TestStep Name="GetListOfAllEnabledSm">
				<CallTestFunction Name="GetListOfAllEnabledSm">
					<Parameter>VerifySyncManChannelDisabled_Settings.bAll_debugMsg</Parameter>
					<OutParameter>VerifySyncManChannelDisabled.ArrayOfBytes_allEnabledPdSm</OutParameter>
				</CallTestFunction>
			</TestStep>
			<TestStep Name="ReturnIfNoEnabledPdSmSupported">
				<Description Id="0" Level="Verbose">Only check if SmChannelDisabled when at least one enabled process data SyncManager available</Description>
				<SizeOf UInt32Var="VerifySyncManChannelDisabled.uint32_enabledPdSmCount">VerifySyncManChannelDisabled.ArrayOfBytes_allEnabledPdSm</SizeOf>
				<Compare>
					<Equal>
						<Value1>VerifySyncManChannelDisabled.uint32_enabledPdSmCount</Value1>
						<Value2>0</Value2>
						<Return Id="1">No enabled process data SyncManager found. Checking if SyncManager was disable by host controller not necessary.</Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="GetListOfAllPdSm">
				<CallTestFunction Name="GetListOfAllPdSm">
					<Parameter>VerifySyncManChannelDisabled_Settings.bAll_debugMsg</Parameter>
					<OutParameter>VerifySyncManChannelDisabled.ArrayOfBytes_allPdSm</OutParameter>
				</CallTestFunction>
			</TestStep>
			<TestStep Name="GetFirstPdSmFromListOfAllPdSm">
				<GetArrayItem Index="0" SourceArray="VerifySyncManChannelDisabled.ArrayOfBytes_allPdSm" Target="VerifySyncManChannelDisabled.byte_sm2"></GetArrayItem>
			</TestStep>
			<TestStep Name="GetSmNumberForSmY_ThisMayNotBeEnabled">
				<SetVariable Target="VerifySyncManChannelDisabled.byte_sm3">VerifySyncManChannelDisabled.byte_sm2+1</SetVariable>
				<WriteLine Id="2" Level="Output" Param0="VerifySyncManChannelDisabled.byte_sm2" Param1="VerifySyncManChannelDisabled.byte_sm3">First Process Data SyncManaager = {0} (usually SyncManager2) | Following Process Data SyncManager = {1} (usually SyncManager3)</WriteLine>
			</TestStep>
			<TestStep Name="GetSmX_PdiControlReg">
				<Description Id="3" Level="Verbose" Param0="VerifySyncManChannelDisabled.byte_sm2">At least one enabled process data SyncManager found (SyncMan{0}), i.e. it needs to be checked if one PD SyncManager was deactivated by host controller.</Description>
				<SetVariable Target="VerifySyncManChannelDisabled.uint16_sm2Ado">#x0807+8*VerifySyncManChannelDisabled.byte_sm2</SetVariable>
			</TestStep>
			<TestStep>
				<ReadEscData Target="VerifySyncManChannelDisabled.byte_sm2Control">
					<Address>VerifySyncManChannelDisabled.uint16_sm2Ado</Address>
				</ReadEscData>
				<RaiseErrorOnFailure Id="4" Param0="VerifySyncManChannelDisabled.uint16_sm2Ado">Failed to read Syncmanager PDI Control Register 0x{0:x4}!</RaiseErrorOnFailure>
			</TestStep>
			<TestStep Name="GetSmX_DeactivatedBit">
				<GetBits Source="VerifySyncManChannelDisabled.byte_sm2Control" Target="VerifySyncManChannelDisabled.bool_sm2Deactivate">
					<Offset>0</Offset>
					<Length>1</Length>
				</GetBits>
				<WriteLine Id="5" Level="Output" Param0="VerifySyncManChannelDisabled.uint16_sm2Ado" Param1="VerifySyncManChannelDisabled.byte_sm2Control" Param2="VerifySyncManChannelDisabled.bool_sm2Deactivate">Read PDI Control Register from 0x{0:x4} = 0x{1:x4} | Bit 0 (Deactivate SyncManager by PDI) = {2}</WriteLine>
				<Compare>
					<Equal>
						<Value1>VerifySyncManChannelDisabled_Settings.bAll_debugMsg</Value1>
						<Value2>true</Value2>
						<WriteLine Id="6">  DEBUG_VerifySyncManChannelDisabled | GetSmX_DeactivatedBit</WriteLine>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="GetSmY_PdiControlReg">
				<SetVariable Target="VerifySyncManChannelDisabled.uint16_sm3Ado">#x0807+8*VerifySyncManChannelDisabled.byte_sm3</SetVariable>
				<Compare>
					<Equal>
						<Value1>VerifySyncManChannelDisabled_Settings.bAll_debugMsg</Value1>
						<Value2>true</Value2>
						<WriteLine Id="7">  DEBUG_VerifySyncManChannelDisabled | GetSmY_PdiControlReg</WriteLine>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<ReadEscData Target="VerifySyncManChannelDisabled.byte_sm3Control">
					<Address>VerifySyncManChannelDisabled.uint16_sm3Ado</Address>
				</ReadEscData>
				<RaiseErrorOnFailure Id="8" Param0="VerifySyncManChannelDisabled.uint16_sm3Ado">Failed to read Syncmanager PDI Control Register 0x{0:x4}!</RaiseErrorOnFailure>
			</TestStep>
			<TestStep Name="GetSmY_DeactivateBit">
				<GetBits Source="VerifySyncManChannelDisabled.byte_sm3Control" Target="VerifySyncManChannelDisabled.bool_sm3Deactivate">
					<Offset>0</Offset>
					<Length>1</Length>
				</GetBits>
				<WriteLine Id="9" Level="Output" Param0="VerifySyncManChannelDisabled.uint16_sm3Ado" Param1="VerifySyncManChannelDisabled.byte_sm3Control" Param2="VerifySyncManChannelDisabled.bool_sm3Deactivate">Read PDI Control Register from 0x{0:x4} = 0x{1:x4} | Bit 0 (Deactivate SyncManager by PDI) = {2}</WriteLine>
				<Compare>
					<Equal>
						<Value1>VerifySyncManChannelDisabled_Settings.bAll_debugMsg</Value1>
						<Value2>true</Value2>
						<WriteLine Id="10">  DEBUG_VerifySyncManChannelDisabled | GetSmY_DeactivateBit</WriteLine>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="GetSmX_DisableBit">
				<CallTestFunction Name="CheckIfSyncManEnabled">
					<Parameter>VerifySyncManChannelDisabled.byte_sm2</Parameter>
					<OutParameter>VerifySyncManChannelDisabled.bool_sm2Disabled</OutParameter>
				</CallTestFunction>
				<Compare>
					<Equal>
						<Value1>VerifySyncManChannelDisabled_Settings.bAll_debugMsg</Value1>
						<Value2>true</Value2>
						<WriteLine Id="11" Param0="VerifySyncManChannelDisabled.byte_sm2" Param1="VerifySyncManChannelDisabled.bool_sm2Disabled">     DEBUG_VerifySyncManChannelDisabled | GetSmX_DisableBit | VerifySyncManChannelDisabled.byte_sm2 = {0} | VerifySyncManChannelDisabled.bool_sm2Disabled = {1}</WriteLine>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="GetSmY_DisableBit">
				<CallTestFunction Name="CheckIfSyncManEnabled">
					<Parameter>VerifySyncManChannelDisabled.byte_sm3</Parameter>
					<OutParameter>VerifySyncManChannelDisabled.bool_sm3Disabled</OutParameter>
				</CallTestFunction>
				<Compare>
					<Equal>
						<Value1>VerifySyncManChannelDisabled_Settings.bAll_debugMsg</Value1>
						<Value2>true</Value2>
						<WriteLine Id="12" Param0="VerifySyncManChannelDisabled.byte_sm3" Param1="VerifySyncManChannelDisabled.bool_sm3Disabled">   DEBUG | GetSmY_DisableBit | VerifySyncManChannelDisabled.byte_sm3 = {0} | VerifySyncManChannelDisabled.bool_sm3Disabled = {1}</WriteLine>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="START">
				<Compare>
					<Equal>
						<Value1>VerifySyncManChannelDisabled_Settings.bAll_debugMsg</Value1>
						<Value2>true</Value2>
						<WriteLine Id="13">  DEBUG_VerifySyncManChannelDisabled | START</WriteLine>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="SmXenabled">
				<Compare>
					<Equal>
						<Value1>VerifySyncManChannelDisabled_Settings.bAll_debugMsg</Value1>
						<Value2>true</Value2>
						<WriteLine Id="14">  DEBUG_VerifySyncManChannelDisabled | SmXenabled | yes: Check if SM2 deactivated | no: Check if SM3 deactivated</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifySyncManChannelDisabled.bool_sm2Disabled</Value1>
						<Value2>true</Value2>
						<GotoStep>SM3DEACTIVATED2</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="Sm2Enabledyes__Sm2DeactivatedYes">
				<Compare>
					<Equal>
						<Value1>VerifySyncManChannelDisabled_Settings.bAll_debugMsg</Value1>
						<Value2>true</Value2>
						<WriteLine Id="15">  DEBUG_VerifySyncManChannelDisabled | Sm2Enabledyes__Sm2DeactivatedYes | SM2 deactivated ? | yes: check if SM3 activated</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifySyncManChannelDisabled.bool_sm2Deactivate</Value1>
						<Value2>true</Value2>
						<GotoStep>SM3ACTIVATED</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="Sm2Enabledyes__Sm2DeactivatedNo">
				<Compare>
					<Equal>
						<Value1>VerifySyncManChannelDisabled_Settings.bAll_debugMsg</Value1>
						<Value2>true</Value2>
						<WriteLine Id="16">  DEBUG_VerifySyncManChannelDisabled | Sm2Enabledyes__Sm2DeactivatedNo | SM2 activated  ? | yes: check if SM3 deactivated</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifySyncManChannelDisabled.bool_sm2Deactivate</Value1>
						<Value2>false</Value2>
						<GotoStep>SM3DEACTIVATED1</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="SM3DEACTIVATED1">
				<Compare>
					<Equal>
						<Value1>DeviceDescr.SM.[VerifySyncManChannelDisabled.byte_sm3]</Value1>
						<Value2>null</Value2>
						<Return Id="17" Param0="VerifySyncManChannelDisabled.byte_sm3">No SyncManager{0} described in ESI file (element Sm:Text)  -&gt; no check if SyncManager{0} is deactivated by PDI</Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="Sm2Enabledyes__Sm2DeactivatedNo__Sm3InEsi_Sm3enabledNo">
				<Compare>
					<Equal>
						<Value1>VerifySyncManChannelDisabled_Settings.bAll_debugMsg</Value1>
						<Value2>true</Value2>
						<WriteLine Id="18">  DEBUG_VerifySyncManChannelDisabled | Sm2Enabledyes__Sm2DeactivatedNo__Sm3InEsi_Sm3enabledNo | yes: check if deactivated | no: error</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifySyncManChannelDisabled.bool_sm3Disabled</Value1>
						<Value2>true</Value2>
						<RaiseError Id="19" Param0="VerifySyncManChannelDisabled.byte_sm3" Param1="VerifySyncManChannelDisabled.byte_sm2">One SyncManager has to be deactivated. Since SyncManager{0} is not enabled / not deactivated SyncManager{1} shall be deactivated by PDI side.</RaiseError>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="Sm2Enabledyes__Sm2DeactivatedNo__Sm3InEsi_Sm3enabledYes_Sm3deactivatedNo">
				<Compare>
					<Equal>
						<Value1>VerifySyncManChannelDisabled_Settings.bAll_debugMsg</Value1>
						<Value2>true</Value2>
						<WriteLine Id="20">  DEBUG_VerifySyncManChannelDisabled | Sm2Enabledyes__Sm2DeactivatedNo__Sm3InEsi_Sm3enabledYes_Sm3deactivatedNo | yes: Return | no: Error</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifySyncManChannelDisabled.bool_sm3Deactivate</Value1>
						<Value2>false</Value2>
						<RaiseError Id="21" Param0="VerifySyncManChannelDisabled.bool_sm2" Param1="VerifySyncManChannelDisabled.bool_sm3">One SyncManager has to be deactivated. Since SyncManager{0} is not enabled/ not deactivated SyncManager{1} shall be deactivated by PDI side.</RaiseError>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="Sm2Enabledyes__Sm2DeactivatedNo__Sm3InEsi_Sm3enabledYes_Sm3deactivatedYes">
				<Compare>
					<Equal>
						<Value1>VerifySyncManChannelDisabled_Settings.bAll_debugMsg</Value1>
						<Value2>true</Value2>
						<WriteLine Id="22">  DEBUG_VerifySyncManChannelDisabled | Sm2Enabledyes__Sm2DeactivatedNo__Sm3InEsi_Sm3enabledYes_Sm3deactivatedYes | Return</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<Return Id="23" Param0="VerifySyncManChannelDisabled.bool_sm3">INFO | SyncManager3 was deactivated by host controller</Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="SM3DEACTIVATED2">
				<Compare>
					<Equal>
						<Value1>VerifySyncManChannelDisabled_Settings.bAll_debugMsg</Value1>
						<Value2>true</Value2>
						<WriteLine Id="24">  DEBUG_VerifySyncManChannelDisabled | SM3DEACTIVATED2</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.SM[VerifySyncManChannelDisabled.byte_sm3]</Value1>
						<Value2>null</Value2>
						<Return Id="25" Param0="VerifySyncManChannelDisabled.byte_sm3">No SyncManager{0} described in ESI file (element Sm:Text)  -&gt; no check if SyncManager{0} is deactivated by PDI</Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="Sm2EnabledNo_Sm3InEsi_Sm3EnabledNo">
				<Description Id="26" Level="Verbose">  S18: SM3 enabled ?
yes: check if deactivated
no: return</Description>
				<Compare>
					<Equal>
						<Value1>VerifySyncManChannelDisabled_Settings.bAll_debugMsg</Value1>
						<Value2>true</Value2>
						<WriteLine Id="27">  DEBUG_VerifySyncManChannelDisabled | Sm2EnabledNo_Sm3InEsi_Sm3EnabledNo | yes: check if deactivated | no: return</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifySyncManChannelDisabled.bool_sm3Disabled</Value1>
						<Value2>true</Value2>
						<Return Id="28" Param0="VerifySyncManChannelDisabled.byte_sm2" Param1="VerifySyncManChannelDisabled.byte_sm3">INFO | SyncManager{0} and SyncManager{1} are disabled</Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="Sm2EnabledNo_Sm3InEsi_Sm3EnabledYes_Sm3DeactivatedNo">
				<Compare>
					<Equal>
						<Value1>VerifySyncManChannelDisabled_Settings.bAll_debugMsg</Value1>
						<Value2>true</Value2>
						<WriteLine Id="29">  DEBUG_VerifySyncManChannelDisabled | Sm2EnabledNo_Sm3InEsi_Sm3EnabledYes_Sm3DeactivatedNo | yes: Return | no: error</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>VerifySyncManChannelDisabled.bool_sm3Deactivate</Value1>
						<Value2>true</Value2>
						<RaiseError Id="30" Param0="VerifySyncManChannelDisabled.bool_sm2" Param1="VerifySyncManChannelDisabled.bool_sm3">One SyncManager has to be deactivated. Since SyncManager{0} is not enabled/ not deactivated SyncManager{1} shall be disabled by PDI side.</RaiseError>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="Sm2EnabledNo_Sm3InEsi_Sm3EnabledYes_Sm3DeactivatedYes">
				<Compare>
					<Equal>
						<Value1>VerifySyncManChannelDisabled_Settings.bAll_debugMsg</Value1>
						<Value2>true</Value2>
						<WriteLine Id="31">  DEBUG_VerifySyncManChannelDisabled | Sm2EnabledNo_Sm3InEsi_Sm3EnabledYes_Sm3DeactivatedYes | Return</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<Return Id="32" Param0="VerifySyncManChannelDisabled.byte_sm3">INFO | SyncManager{0} was deactivated by host controller</Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="SM3ACTIVATED">
				<Compare>
					<Equal>
						<Value1>VerifySyncManChannelDisabled_Settings.bAll_debugMsg</Value1>
						<Value2>true</Value2>
						<WriteLine Id="33">  DEBUG_VerifySyncManChannelDisabled | SM3ACTIVATED</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.SM[VerifySyncManChannelDisabled.byte_sm3]</Value1>
						<Value2>null</Value2>
						<Return Id="34" Param0="VerifySyncManChannelDisabled.byte_sm3">No SyncManager{0} described in ESI file (element Sm:Text)  -&gt; no check if SyncManager{0} is deactivated by PDI</Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="Sm2enabledYes_Sm2DeactivatedYes_Sm3InEsi_Sm3enabledNo">
				<Compare>
					<Equal>
						<Value1>VerifySyncManChannelDisabled_Settings.bAll_debugMsg</Value1>
						<Value2>true</Value2>
						<WriteLine Id="35">  DEBUG_VerifySyncManChannelDisabled | Sm2enabledYes_Sm2DeactivatedYes_Sm3InEsi_Sm3enabledNo | yes: Check if activated | no: return</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifySyncManChannelDisabled.bool_sm3Disabled</Value1>
						<Value2>true</Value2>
						<Return Id="36" Param0="VerifySyncManChannelDisabled.byte_sm3">INFO | SyncManager{0} is not enabled</Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="Sm2enabledYes_Sm2DeactivatedYes_Sm3InEsi_Sm3enabledYes_Sm3ActivatedNo">
				<Compare>
					<Equal>
						<Value1>VerifySyncManChannelDisabled_Settings.bAll_debugMsg</Value1>
						<Value2>true</Value2>
						<WriteLine Id="37">  DEBUG_VerifySyncManChannelDisabled | Sm2enabledYes_Sm2DeactivatedYes_Sm3InEsi_Sm3enabledYes_Sm3ActivatedNo | yes: ok | no: error</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifySyncManChannelDisabled.bool_sm3Deactivate</Value1>
						<Value2>true</Value2>
						<RaiseError Id="38" Param0="VerifySyncManChannelDisabled.byte_sm2" Param1="VerifySyncManChannelDisabled.byte_sm3">Only one SyncManager shall be deactivated. Since SyncManager{0} is deactivated SyncManager{1} shall remain enabled.</RaiseError>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="Sm2enabledYes_Sm2DeactivatedYes_Sm3InEsi_Sm3enabledYes_Sm3ActivatedYes">
				<WriteLine Id="39" Level="Output" Param0="VerifySyncManChannelDisabled.uint16_sm3Ado" Param1="VerifySyncManChannelDisabled.byte_sm3Control" Param2="VerifySyncManChannelDisabled.bool_sm3Deactivate" Param3="VerifySyncManChannelDisabled.byte_sm3">INFO | Syncmanager{3} was not deactivated by host controller</WriteLine>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="1205" Name="IsSyncManUnknown">
			<Description>
				<Purpose>Check if the requestes SyncMan has a known text and returns yes/no</Purpose>
				<PreCondition>SyncManager in ESi file element Sm defined at all</PreCondition>
				<Action>- Check ESI element Sm for type = "MBoxOut/MBoxIn/Outputs/Inputs"</Action>
				<PostCondition>- set return value to false if text is known</PostCondition>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>IsSyncManUnknown_byteSmNo</Name>
				<Type>Byte</Type>
			</Parameter>
			<OutParameter>
				<Name>IsSyncManUnknown_SmUnkown</Name>
				<Type>Bool</Type>
				<DefaultValue>TRUE</DefaultValue>
				<Comment></Comment>
			</OutParameter>
			<TestStep Name="CheckIfAnySmInEsiFileDefined">
				<Compare>
					<Equal>
						<Value1>DeviceDescr.SM.Count</Value1>
						<Value2>0</Value2>
						<RaiseError>INFO | No Sm Element in ESI defined!</RaiseError>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="NoSmTextDefinedWriteline">
				<Compare>
					<Equal>
						<Value1>DeviceDescr.SM[IsSyncManUnknown_byteSmNo]</Value1>
						<Value2>null</Value2>
						<RaiseError Param0="IsSyncManUnknown_byteSmNo">INFO: No Sm:Text defined in ESI for SyncManager{0}</RaiseError>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="IsSmTextKnown">
				<Compare>
					<Equal>
						<Value1>DeviceDescr.SM[IsSyncManUnknown_byteSmNo]</Value1>
						<Value2>MBoxOut</Value2>
						<GotoStep>KNOWN</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.SM[IsSyncManUnknown_byteSmNo]</Value1>
						<Value2>MBoxIn</Value2>
						<GotoStep>KNOWN</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.SM[IsSyncManUnknown_byteSmNo]</Value1>
						<Value2>Outputs</Value2>
						<GotoStep>KNOWN</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.SM[IsSyncManUnknown_byteSmNo]</Value1>
						<Value2>Inputs</Value2>
						<Return>DEBUG: SmTextUnkown = TRUE</Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="KNOWN">
				<SetVariable Target="IsSyncManUnknown_SmUnkown">False</SetVariable>
			</TestStep>
		</TestFunction>
	</TestFunctions>
</EtherCATTest>