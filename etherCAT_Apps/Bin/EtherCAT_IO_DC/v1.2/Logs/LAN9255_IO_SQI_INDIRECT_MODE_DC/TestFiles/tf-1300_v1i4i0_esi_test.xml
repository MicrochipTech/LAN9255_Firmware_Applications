<?xml version="1.0" encoding="UTF-8" standalone="yes"?><EtherCATTest Name="TF-1300 EtherCAT Slave Information" TestId="4864" Url="http://www.ethercat.org/en/conformance.html" TestVendorId="1" xsi:noNamespaceSchemaLocation="EtherCATTest.xsd" TestVersion="1.4.0" SchemaVersion="1.0.31" RealeaseState="Released" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
	<Comment>Tests of the EtherCAT Slave Information file. These tests refer to the EtherCAT Slave Information Specification.</Comment>
	<History>
		<HistoryEntry Editor="F.H." TestVersion="1.0.3" Date="2010-01-14">Added test case Device:Sm@Enable</HistoryEntry>
		<HistoryEntry Editor="F.H." TestVersion="1.0.3" Date="2010-01-14">Added test case Secondary Vendor ID</HistoryEntry>
		<HistoryEntry Editor="F.H." TestVersion="1.0.3" Date="2010-02-01">Deleted test case Device:Sm@Enable. Sm@Enable "Don't care" for Process Data SyncManagers according to ESI Spec</HistoryEntry>
		<HistoryEntry Editor="O.H." TestVersion="1.0.5" Date="2010-03-09" Id="EN_100309">Where: Test cases E²PROM TXPDO Categories and E²PROM RXPDO Categories Description: Shall be skipped if an object dictionary is supported.</HistoryEntry>
		<HistoryEntry Editor="O.H." TestVersion="1.0.8" Date="2011-02-25" Id="EN_110225_1">Where: Reset function
Description: When no FMMUs are supported by the ESC (reg 0x04 = 0) the function did still try to reset one FMMU
Solution: skip resetting FMMUs when FMMU count = 0</HistoryEntry>
		<HistoryEntry Editor="O.H." TestVersion="1.0.9" Date="2011-03-15" Id="EN_110315">Schema V1.0.3 assigned</HistoryEntry>
		<HistoryEntry Editor="O.H." TestVersion="1.0.10" Date="2011-05-13" Id="EN_110513">Comparison ESI to ESC Register DpramSize / Invalid compariso of KBit (ESI) and KByte (Register 0x6) values / ESI value converted to KByte</HistoryEntry>
		<HistoryEntry Editor="O.H." TestVersion="1.0.11" Date="2011-07-29" Id="EN_110729">Test function Reset / Invalid reset test function in case of syncmanager count =0 and Fmmu count = 0/ Is corrected in the test function</HistoryEntry>
		<HistoryEntry Editor="J.S.C." TestVersion="1.0.12" Date="2012-01-11" Id="EN_TF-1300_120111_1">Where: Added Device:RevisionNo to TG1
Description: Check if ESI uses DeviceDescr.RevisionNo</HistoryEntry>
		<HistoryEntry Editor="J.S.C." TestVersion="1.0.12" Date="2012-01-11" Id="EN_TF-1300_120111_2">Where: Added ESI Port Type Consistency to TG1
Description: Check port type configuration (MII/LVDS) of the DuT's ESI elements for consistency</HistoryEntry>
		<HistoryEntry Editor="J.S.C." TestVersion="1.0.12" Date="2012-01-11" Id="EN_TF-1300_120111_3">Where: Added Number of Offline Dictionaries to TG1
Description: Check for maximum number of element Device.Profiles (max = 1).</HistoryEntry>
		<HistoryEntry Editor="J.S.C." TestVersion="1.0.12" Date="2012-01-11" Id="EN_TF-1300_120111_4">Where: Added Number of Offline Dictionaries to TG1
Description: Check for maximum number of element Device.Profiles (max = 1).</HistoryEntry>
		<HistoryEntry Editor="J.S.C." TestVersion="1.0.12" Date="2012-01-11" Id="EN_TF-1300_120111_5">Where: Added PDO Upload/Config/Assign to TG1
Description: Check wether the DuT supports PdoUpload or (PdoConfig and/or PdoAssign)</HistoryEntry>
		<HistoryEntry Editor="J.S.C." TestVersion="1.0.12" Date="2012-01-11" Id="EN_TF-1300_120111_6">Where: Added new TG5 for obsolete ESI element tests.
Description: ESI elements which are marked as obsolete in the ETG.2000 ESI specification shall not be used.</HistoryEntry>
		<HistoryEntry Editor="J.S.C." TestVersion="1.0.12" Date="2012-01-11" Id="EN_TF-1300_120111_7">Where:  Added new TG6 for reserved ESI element tests.
Description: ESI elements which are marked as reserved for future use in the ETG.2000 ESI specification shall not be used.</HistoryEntry>
		<HistoryEntry Editor="J.S.C." TestVersion="1.0.12" Date="2012-01-11" Id="EN_TF-1300_120111_8">Where: Added TG4 and test for ESI OD Identity Info
Description: Comparison of the DuT's ESI file and the CoE online dictionary identity object 0x1018.</HistoryEntry>
		<HistoryEntry Editor="J.S.C." TestVersion="1.0.17" Date="2012-01-17" Id="EN_TF-1300_120117">Where: TG4 test for ESI OD Identity Info
Description: If only comparison of object 0x1018:SI4 to Device:Type:SerialNo unequal conclude with warning and successful test instead of error.</HistoryEntry>
		<HistoryEntry Editor="J.S.C." TestVersion="1.0.17" Date="2012-01-17" Id="EN_TF-1300_120118">Where: TC 1300-4-1
Description: If Device:Type:RevisionNo not equal to 0x1018:3 of online OD throw warning instead of error.</HistoryEntry>
		<HistoryEntry Editor="J.S.C." TestVersion="1.0.17" Date="2012-02-08" Id="EN_TF-1300_120208">Where: TC 1300-4-1
Description: Used variable EEPROM.SerialNo instead of DeviceDescr.SerialNo. 
Solution: Use variable DeviceDescr.SerialNo instead of EEPROM.SerialNo. If Device:Type:SerialNo not available in ESI. Skip comparison and show SerialNo from EEPROM as Info.</HistoryEntry>
		<HistoryEntry Editor="J.S.C." TestVersion="1.0.17" Date="2012-02-21" Id="EN_TF-1300_120221" Type="Enhancement">Where: TC 1300-4-1
Description: If Device:Type:SerialNo is not 0 and not equal to 0x1018:4 of online OD throw error.</HistoryEntry>
		<HistoryEntry Editor="F.H." TestVersion="1.1.0" Date="2012-06-22" Id="EN_TF_1300_120622_1" Type="Bug">_Whrere: TC-1300-2-10 E²PROM General Category
_Description: Copy-Past error in description field from Fmmu Category
_Solution: Correct description</HistoryEntry>
		<HistoryEntry Editor="O.H." TestVersion="1.1.1" Date="2012-09-17" Id="EN_TF_1300_120917_1" Type="Enhancement">Whrere: TG-1300-2 and 3 all cases
Description: The test cases of these groups needs online state of the DuT. 
Solution: Online state query added</HistoryEntry>
		<HistoryEntry Editor="O.H." TestVersion="1.1.1" Date="2012-09-17" Id="EN_TF_1300_120917_2" Type="Enhancement">Whrere: TG-1300-4
Description:  A unique reset test function shall be used for all ETG-Tests.
Solution: EcBaseFunctions.xml added to use the Reset test function that is defined in this file.</HistoryEntry>
		<HistoryEntry Editor="R.H." TestVersion="1.1.3" Date="2012-09-19" Id="EN_TF_1300_120919" Type="Enhancement">- Add Function "CheckFmmuElements"
- Add FMMU test case [1][9]</HistoryEntry>
		<HistoryEntry Editor="R.H." TestVersion="1.1.4" Date="2012-10-01" Id="EN_TF_1300_121001" Type="Enhancement">Add Groups for RxPdo Tests (Group 7) and TxPdo Tests (Group 8)
- Include attribute tests
- Index tests
- SyncManager assignment tests</HistoryEntry>
		<HistoryEntry Editor="D.O." TestVersion="1.1.5" Date="2012-10-02" Id="EN_TF_1300_121002" Type="Enhancement">Where: Test Group RxPdo/TxPdo Tests
Add Cases for RxPdo and TxPdo Tests
- Pdo entry data types test
- Pdo default size test</HistoryEntry>
		<HistoryEntry Editor="R.H." TestVersion="1.1.6" Date="2012-10-08" Id="EN_TF_1300_121008" Type="Enhancement">Create seperate Test Group for Fmmu Tests [9]
Move existing Fmmu test from [1][9] -&gt; [9][1]
Update test description for RxPDO Tests (Group [7]), TxPDO Tests(Group [8]) and Fmmu Tests (Group [9])</HistoryEntry>
		<HistoryEntry Editor="R.H." TestVersion="1.1.6" Date="2012-10-12" Id="EN_TF_1300_121012" Type="Enhancement">Add DataType tests for the device offline dictionary (Group 10).</HistoryEntry>
		<HistoryEntry Editor="F.Ha." TestVersion="1.1.7" Date="2012-10-16" Id="EN_TF_1300_121016_1" Type="Enhancement">Add Sm tests for ESI file (group 11)
   - Name of SyncManagers [11][1]
   - Order of SyncManagers [11][2]
Therefor added functions:
   - CheckSmOrder
Therefor added variable:
   - FHa_i    
   - FHa_j
   - FHa_Error
   - FHa_BoolTemp1</HistoryEntry>
		<HistoryEntry Editor="F.Ha." TestVersion="1.1.7" Date="2012-10-16" Id="EN_TF_1300_121016_2" Type="Enhancement">Sorting of Tests
Moved:
   - [1][1] -&gt; [11][3]
   - [1][2] -&gt; [11][4]
To be deleted (moved to [11][100] for review):
  - [1][3] -&gt; is a superset of new Sm order tests [11][2]
Renamed:
  - all remaining tests [1][n] -&gt; [1][n-3]</HistoryEntry>
		<HistoryEntry Editor="R.H" TestVersion="1.1.8" Date="2012-10-18" Id="EN_TF_1300_121018_1" Type="Enhancement">TestGroup "Device Object Tests" add ([11] , the SyncManager group is moved to 12)
CheckDTxxxxENnnDataType : Add check if enum value is less 0
Add Function "InitGlobalVariablesForObjectTests" (init xml file and xPath variables for object element tests)</HistoryEntry>
		<HistoryEntry Editor="D.O." TestVersion="1.1.9" Date="2012-10-19" Id="EN_TF_1300_121019" Type="Enhancement">Where: Test Group RxPdo/TxPdo Tests
Changed RxPdo and TxPdo Tests
- Pdo entry data types test: fixed wrong logger outputs
- Pdo default size test: fixed SM descritpion test - added SM validation for first Tx/Rx Element</HistoryEntry>
		<HistoryEntry Editor="R.H." TestVersion="1.1.10" Date="2012-10-22" Id="EN_TF_1300_121022" Type="Enhancement">Enhancements of DataType.SubItem Tests:
- check overlapping Byte border only if continous Subindices are defined
- check BitOffs only if continous Subindices are defined</HistoryEntry>
		<HistoryEntry Editor="O.H." TestVersion="1.1.12" Date="2012-10-22" Id="EN_TF_1300_121022_1" Type="Enhancement">Test Case: Obsolete ESI Elements.Device:Type@TcSmClass: Attribute is no longer obsolete and therefore the test case has been removed.</HistoryEntry>
		<HistoryEntry Editor="O.H." TestVersion="1.1.13" Date="2012-10-22" Id="EN_TF_1300_121022_2" Type="Enhancement">Test Case: Comparison ESI To SII/E²PROM BootStrap: Length of Bootstrap element is checked.</HistoryEntry>
		<HistoryEntry Editor="O.H." TestVersion="1.1.13" Date="2012-10-23" Id="EN_TF_1300_121023" Type="Enhancement">Test Case: Comparison ESI to SII/Mailbox Protocols: Typing error resolved. Teststep 9 FoE changed to VoE</HistoryEntry>
		<HistoryEntry Editor="R.H." TestVersion="1.1.17" Date="2012-11-05" Id="EN_TF_1300_121105" Type="Enhancement">Add Tests for Object.Info elements</HistoryEntry>
		<HistoryEntry Editor="R.H." TestVersion="1.1.18" Date="2012-11-05" Id="EN_TF_1300_121105_2" Type="Enhancement">Test Function GetSmLength: a virtual SM may not include a ControlByte (SM is running in 1Buffer mode)</HistoryEntry>
		<HistoryEntry Editor="R.H." TestVersion="1.1.19" Date="2012-11-06" Id="EN_TF_1300_121106" Type="Enhancement">Add physics type "H" is valid (Test : [General ESI plausibility][ESI Port Type Consistency]</HistoryEntry>
		<HistoryEntry Editor="D.O." TestVersion="1.1.21" Date="2012-11-06" Id="EN_TF_1300_121106_1" Type="Enhancement">Test case: Check Pdo Default Size: The calculated PDO size is rounded to a byte alignment</HistoryEntry>
		<HistoryEntry Editor="F.Ha." TestVersion="1.1.24" Date="2012-11-14" Id="EN_TF_1300_121114_1" Type="Bug">TestFunction "GetSmLength": CallTestFunction "SetStateMachTimeouts" added after Reset to get correct timeout values</HistoryEntry>
		<HistoryEntry Editor="R.H." TestVersion="1.1.24" Date="2012-11-15" Id="EN_TF_1300_121115_1" Type="Enhancement">"ESI Port Type Consistency" raise an error if the Physics element has trailing whitespaces</HistoryEntry>
		<HistoryEntry Editor="O.H." TestVersion="1.1.25" Date="2012-11-16" Id="EN_TF_1300_121116" Type="Enhancement">EEPROM parameter 'Station Alias' is skipped for comparison of ESI Eeprom:ConfigData element with the first 7 words of the EEPROM data</HistoryEntry>
		<HistoryEntry Editor="D.O." TestVersion="1.1.26" Date="2012-11-19" Id="EN_TF_1300_121119" Type="Enhancement">Test function: Rx/TxCheckPdSmDefaultSize: SM default size of 0 is valid. Throws warning instead of error if SM default size is null.</HistoryEntry>
		<HistoryEntry Editor="D.O." TestVersion="1.1.27" Date="2012-11-20" Id="EN_TF_1300_121120" Type="Enhancement">Comparison ESI to SII: Rx/TxCheckPdSmDefaultSize: E²PROM RX/TX PDO Categories: Compares E²PROM PDO count to ESI PDO count element before testing PDO categories.</HistoryEntry>
		<HistoryEntry Editor="D.O." TestVersion="1.1.28" Date="2012-11-21" Id="EN_TF_1300_121121" Type="Enhancement">Comparison ESI to SII: Description elements added.</HistoryEntry>
		<HistoryEntry Editor="R.H." TestVersion="1.1.29" Date="2012-11-23" Id="EN_TF_1300_121123" Type="Enhancement">New test cases:
ESI Reserved element tests:
 - Device.Profile.Dictionary.DataTypes.DataType.Index
 - Device.InfoType.DeviceFeature
  
SM Tests:
 - Check value of Sm@Enabled
  
General
 - Device.Name shall not be empty
 - Device.HideType shall not be empty
 - Device.GroupType shall not be empty</HistoryEntry>
		<HistoryEntry Editor="D.O." TestVersion="1.1.31" Date="2012-12-04" Id="EN_TF_1300_121204" Type="Enhancement">Pdo Tests: Output logger information changed.</HistoryEntry>
		<HistoryEntry Editor="D.O." TestVersion="1.1.32" Date="2012-12-10" Id="EN_TF_1300_121210" Type="Enhancement">Default size tests: Does not throw a warning if PDOs are assigned by default and no SM@DefaultSize attribute is specified</HistoryEntry>
		<HistoryEntry Editor="O.H." TestVersion="1.1.35" Date="2013-01-15" Id="EN_TF_1300_130115" Type="Enhancement">Comparison of String types: Quotation marks added.</HistoryEntry>
		<HistoryEntry Editor="R.H." TestVersion="1.1.36" Date="2013-01-29" Id="EN_TF_1300_130129" Type="Enhancement">DataType tests : Accept "SunbIndex 000" and "Number of Entries" for Subindex0</HistoryEntry>
		<HistoryEntry Editor="D.O." TestVersion="1.1.38" Date="2013-02-06" Id="EN_TF_1300_130206" Type="Enhancement">"E²PROM General Category": General EEPROM category checked for plausibility</HistoryEntry>
		<HistoryEntry Editor="O.H." TestVersion="1.1.39" Date="2013-02-07" Id="EN_TF_1300_130207" Type="Enhancement">"E²PROM General Category": Warning for non specified "UseLrdLwr" attribute removed.</HistoryEntry>
		<HistoryEntry Editor="D.O." TestVersion="1.1.40" Date="2013-02-13" Id="EN_TF_1300_130213" Type="Enhancement">"E²PROM General Category": Raises detailed error if index to Strings is higher than the max index.</HistoryEntry>
		<HistoryEntry Editor="R.H." TestVersion="1.1.41" Date="2013-02-21" Id="EN_TF_1300_130221" Type="Enhancement">DPRAM test (ESI vs. ESC) Update error text if values don't match.</HistoryEntry>
		<HistoryEntry Editor="O.H." TestVersion="1.1.42" Date="2013-02-25" Id="EN_TF_1300_130225" Type="Enhancement">Test Case: "SyncMan default usage" deleted. Integratet in [11][2]</HistoryEntry>
		<HistoryEntry Editor="D.O." TestVersion="1.1.43" Date="2013-03-08" Id="EN_TF_1300_130308" Type="Enhancement">Test Case: "E²PROM General Category": Validation of EEPROM element "SysmanClass" to ESI element "TcSmClass" deleted.</HistoryEntry>
		<HistoryEntry Editor="R.H." TestVersion="1.1.44" Date="2013-03-11" Id="EN_TF_1300_130311" Type="Bug">FMMU Tests Change 'EmptzString' to 'EmtpyString'</HistoryEntry>
		<HistoryEntry Editor="D.O." TestVersion="1.1.45" Date="2013-03-20" Id="EN_TF_1300_130320" Type="Enhancement">Test Case: "Check Pdo entry Data Types" (Rx/Tx): Entries with size larger than 31 Byte are properly tested.</HistoryEntry>
		<HistoryEntry Editor="R.H." TestVersion="1.1.46" Date="2013-03-21" Id="EN_TF_1300_130321" Type="Enhancement">Handle Empty FMMU and SM elements
Handle SoE Devices in "PDO Index" tests, "Data Type" tests and "Object" tests</HistoryEntry>
		<HistoryEntry Editor="R.H." TestVersion="1.1.47" Date="2013-03-21" Id="EN_TF_1300_130321_1" Type="Enhancement">Enum data type tests : Update error message in case that the bit size doen't match the bit size in the data type name.</HistoryEntry>
		<HistoryEntry Editor="D.O." TestVersion="1.1.48" Date="2013-04-04" Id="EN_TF_1300_130404" Type="Enhancement">Where: Comparison ESI to SII: Test Case "E²PROM General Category": EPROM.CatGeneral.CoEDetails.EnableSDO comparison to DeviceDescr.Mailbox.CoE instead of DeviceDescr.Mailbox.SdoInfo</HistoryEntry>
		<HistoryEntry Editor="R.H." TestVersion="1.1.49" Date="2013-04-12" Id="EN_TF_1300_130412" Type="Enhancement">Array data type tests : allow "ARRAY [0..n] OF XXXX" as base data type for array info elements
Update the Regex pattern for "ARRAY [0.. n] OF XXXX" to detect also invalid names without a "n"</HistoryEntry>
		<HistoryEntry Editor="R.H." TestVersion="1.1.50" Date="2013-04-23" Id="EN_TF_1300_130423" Type="Enhancement">Test Case: "E²PROM General Category" (Compare Group String) access "GroupType" of the DuT</HistoryEntry>
		<HistoryEntry Editor="R.H." TestVersion="1.1.51" Date="2013-04-25" Id="EN_TF_1300_130425" Type="Enhancement">FMMU Test: Detection of continuous SyncManager buffer was not detected if no SM.Default size was set. SM size is now calculated based on assigned PDOs.</HistoryEntry>
		<HistoryEntry Editor="R.H." TestVersion="1.1.52" Date="2013-04-26" Id="EN_TF_1300_130426" Type="Enhancement">DataType Tests: Skip checking of Si0 name.</HistoryEntry>
		<HistoryEntry Editor="R.H." TestVersion="1.1.52" Date="2013-04-26" Id="EN_TF_1300_130426_1" Type="Enhancement">DataType Tests: data type name including an x is also vaild (DTyyyy, y may be the object index or x)</HistoryEntry>
		<HistoryEntry Editor="D.O." TestVersion="1.1.53" Date="2013-04-30" Id="EN_TF_1300_130430" Type="Enhancement">Rx-/Tx-CheckPdSmDefaultSize: Support PDO SM assignment of non continous PDO list.</HistoryEntry>
		<HistoryEntry Editor="R.H." TestVersion="1.1.54" Date="2013-05-07" Id="EN_TF_1300_130507" Type="Enhancement">SII Tests (Check General Category): skip check GroupIdx if no groupIdx is defined.</HistoryEntry>
		<HistoryEntry Editor="D.O." TestVersion="1.1.55" Date="2013-05-08" Id="EN_TF_1300_130508" Type="Enhancement">Added TestFunction "CheckRemainingSm": writes error if SM default size &gt; 0 but no default PDO assignment</HistoryEntry>
		<HistoryEntry Editor="D.O." TestVersion="1.1.56" Date="2013-05-17" Id="EN_TF_1300_130517" Type="Enhancement">Rx-/Tx-Check Pdo entry Data Types: Entry bit length larger than 255 bits are not valid.</HistoryEntry>
		<HistoryEntry Editor="D.O." TestVersion="1.1.57" Date="2013-06-04" Id="EN_TF_1300_130604" Type="Enhancement">Group "Device DataType Tests": enhanced error messages (added XPath) in all associated data type functions</HistoryEntry>
		<HistoryEntry Editor="D.O." TestVersion="1.1.58" Date="2013-06-07" Id="EN_TF_1300_130607" Type="Enhancement">PDO Tests: Improved Error Messages. Output before integrated in Error message</HistoryEntry>
		<HistoryEntry Editor="D.O." TestVersion="1.1.59" Date="2013-06-10" Id="EN_TF_1300_130610" Type="Bug">TxPdo Tests: Check Pdo entry Data Types: Step "GetAndWriteResult": at Compare: Changed WriteLine "Error" to "Output"</HistoryEntry>
		<HistoryEntry Editor="R.H." TestVersion="1.1.60" Date="2013-06-20" Id="EN_TF_1300_130620" Type="Enhancement">Enhance 'EN_TF_1300_130607': The return string of the String(n) Bitlength checking shall be empty and not unequal empty</HistoryEntry>
		<HistoryEntry Editor="R.H." TestVersion="1.1.60" Date="2013-06-28" Id="EN_TF_1300_130628" Type="Enhancement">further enhancement of 'EN_TF_1300_130607'</HistoryEntry>
		<HistoryEntry Editor="R.H." TestVersion="1.1.62" Date="2013-09-09" Id="EN_TF_1300_130909" Type="Enhancement">DataType Tests : Allow 'x' and 'X' in DTyyyyARR datatype name</HistoryEntry>
		<HistoryEntry Editor="R.H." TestVersion="1.1.62" Date="2013-09-09" Id="EN_TF_1300_130909_1" Type="Enhancement">DataType Tests : A bit size of 8 is allowed for an empty (array/record) object.</HistoryEntry>
		<HistoryEntry Editor="R.H." TestVersion="1.1.62" Date="2013-09-09" Id="EN_TF_1300_130909_2" Type="Enhancement">Object Tests : upate entry search function (object element - data type element)</HistoryEntry>
		<HistoryEntry Editor="R.H." TestVersion="1.1.64" Date="2013-09-09" Id="EN_TF_1300_130909_3" Type="Enhancement">EEPROM General category test : do not raise an error if no string category is defined and skip corresponding tests.</HistoryEntry>
		<HistoryEntry Editor="R.H." TestVersion="1.1.64" Date="2013-09-09" Id="EN_TF_1300_130909_4" Type="Enhancement">Data type test : allow 'String(n)' as base type for DTyyyyARR</HistoryEntry>
		<HistoryEntry Editor="R.H." TestVersion="1.1.66" Date="2013-12-16" Id="EN_TF_1300_131216" Type="Enhancement">Skip PDO index tests for simple devices devices.</HistoryEntry>
		<HistoryEntry Editor="O.H." TestVersion="1.1.68" Date="2014-02-17" Id="EN_TF_1300_140217" Type="Enhancement">Unused variables and testfunctions removed.</HistoryEntry>
		<HistoryEntry Editor="O.H." TestVersion="1.1.68" Date="2014-02-17" Id="EN_TF_1300_140217_2" Type="Enhancement">Testfunction ReadEEPROMData: Variables added to local scope</HistoryEntry>
		<HistoryEntry Editor="R.H." TestVersion="1.1.69" Date="2014-02-19" Id="EN_TF_1300_140219" Type="Enhancement">Check for 'PreOp' in ReadResctriction/WriteRestriction (see DataType and Object tests)</HistoryEntry>
		<HistoryEntry Editor="O.H." TestVersion="1.1.70" Date="2014-04-24" Id="EN_TF_1300_140424" Type="Enhancement">Test review: Test variables added, unused variables removed</HistoryEntry>
		<HistoryEntry Editor="O.H." TestVersion="1.1.71" Date="2014-04-24" Id="EN_TF_1300_140424" Type="Enhancement">Test review: double test step names per test case/function corrected</HistoryEntry>
		<HistoryEntry Editor="O.H." TestVersion="1.1.72" Date="2014-05-06" Id="EN_TF_1300_140506" Type="Enhancement">Test review: Test function: 'InitGlobalVariablesForDataTypeTest' There is no need to check the Device:Profile:DataType count if no dictionary is defined. Therefore the last test step has been removed.</HistoryEntry>
		<HistoryEntry Editor="O.H." TestVersion="1.1.74" Date="2014-06-13" Id="EN_TF_1300_140613" Type="Enhancement">Rx and TxPdo Index test cases: The Pdo index verification is skipped for SoE devices</HistoryEntry>
		<HistoryEntry Editor="D.O." TestVersion="1.1.75" Date="2014-06-26" Id="EN_TF_1300_140626" Type="Enhancement">Device DataType Tests Cases All DataType Names and BaseDataTypes (fixed length): Added Base Data Type "GUID"</HistoryEntry>
		<HistoryEntry Editor="D.O." TestVersion="1.1.76" Date="2014-07-01" Id="EN_TF_1300_140701" Type="Bug">TxPdo Tests: Entry Data Type Test: Bugfix if Array Data Type has the right BitLen</HistoryEntry>
		<HistoryEntry Editor="D.O." TestVersion="1.1.77" Date="2014-08-11" Id="EN_TF_1300_140811" Type="Enhancement">General Category Test: Fixed Logger Output and Name Test. White Space difference leads to an Warning.</HistoryEntry>
		<HistoryEntry Editor="O.H." TestVersion="1.1.78" Date="2014-10-10" Id="EN_TF_1300_141010" Type="Enhancement">Reserved ESI Elements.Device:InfoType:DeviceFeature: GetXmlValue throws an error for "Unknown" DuTs. New test step to determine if a ESI is assigned to the DuT </HistoryEntry>
		<HistoryEntry Editor="O.H." TestVersion="1.1.79" Date="2014-10-17" Id="EN_TF_1300_141017" Type="Enhancement">Comparison ESI To SII:VendorId: Missing writeline parameter added in compare result.</HistoryEntry>
		<HistoryEntry Editor="F.H." TestVersion="1.1.80" Date="2014-11-21" Id="EN_TF_1300_141121" Type="Enhancement">Check if attribute Mailobx:DataLinkLayer is TRUE</HistoryEntry>
		<HistoryEntry Editor="F.H." TestVersion="1.1.80" Date="2014-11-24" Id="EN_TF_1300_141124" Type="Enhancement">Check usage of Eeprom:AssignToPdi: If TRUE the DuT should return an AL Status Code if EEPROM access was not assigned to PDI during INIT-PREOP transition</HistoryEntry>
		<HistoryEntry Editor="O.H." TestVersion="1.1.81" Date="2014-11-25" Id="EN_TF_1300_141125" Type="Enhancement">String representation of boolean values changed from 'TRUE' to 'True' and 'FALSE' to 'False'</HistoryEntry>
		<HistoryEntry Editor="F.H." TestVersion="1.1.82" Date="2014-11-28" Id="EN_TF_1300_141128" Type="Bug">Compare DataLinkLayer with False rather than null</HistoryEntry>
		<HistoryEntry Editor="D.O." TestVersion="1.1.83" Date="2014-12-08" Id="EN_TF_1300_141208" Type="Enhancement">EEPROM General Category Test is skipped if Device is not complex</HistoryEntry>
		<HistoryEntry Editor="O.H." TestVersion="1.1.84" Date="2015-03-03" Id="EN_TF_1300_150303" Type="Enhancement">Obsolete ESI Elements.Device:Profile@Channel: Test Case returns a warning although the Channel attribute could not be found. Checking test variable against "Null" instead of "0".</HistoryEntry>
		<HistoryEntry Editor="R.H." TestVersion="1.1.84" Date="2015-03-17" Id="EN_TF_1300_151703" Type="Enhancement">remove double skip check in the EEPROM data vs. ESI.EEPROM.Data test</HistoryEntry>
		<HistoryEntry Editor="D.O." TestVersion="1.1.85" Date="2015-06-01" Id="EN_TF_1300_150106" Type="Enhancement">CheckObjectInfoData: Error if Default Data length is 0</HistoryEntry>
		<HistoryEntry Editor="B.L." TestVersion="1.1.86" Date="2015-06-11" Id="EN_TF_1300_121106" Type="Bug">Move comments out of CallTestFunction Parameter elements, delete whitespace</HistoryEntry>
		<HistoryEntry Editor="O.H." TestVersion="1.1.87" Date="2015-09-02" Id="EN_TF_1300_150902" Type="Enhancement">Test schema version set to 1.0.23</HistoryEntry>
		<HistoryEntry Editor="R.H." TestVersion="1.1.88" Date="2015-09-29" Id="EN_TF_1300_150929" Type="Enhancement">Data type tests: Do no raise an error in case of a single access object and an "even byte offset failure"</HistoryEntry>
		<HistoryEntry Editor="R.H." TestVersion="1.1.89" Date="2015-11-03" Id="EN_TF_1300_151103" Type="Enhancement">Datatype/Object tests : to not use test variables to iterate over the elements.</HistoryEntry>
		<HistoryEntry Editor="F.E." TestVersion="1.1.90" Date="2015-11-16" Id="EN_TF_1300_151116" Type="Bug">1-10 Device:Eeprom:AssignToPdi: AssignToPdi was set rather than not set. ESC Reset function called before start of test
Moved test to TF-1200 and deleted in this test file</HistoryEntry>
		<HistoryEntry Editor="R.H." TestVersion="1.1.90" Date="2015-11-17" Id="EN_TF_1300_151117" Type="Enhancement">Allow trailing whitespaces in physics element</HistoryEntry>
		<HistoryEntry Editor="B.L." TestVersion="1.1.91" Date="2016-01-12" Id="EN_TF_1300_160112" Type="Bug">Don't skip ESI / EEPROM General Category comparison</HistoryEntry>
		<HistoryEntry Editor="B.L." TestVersion="1.1.92" Date="2016-02-17" Id="EN_TF_1300_160217" Type="Enhancement">Update to Schema version 1.0.24</HistoryEntry>
		<HistoryEntry Editor="F.H." TestVersion="1.2.1" Date="2016-07-05">Release version</HistoryEntry>
		<HistoryEntry Editor="G.E." TestVersion="1.3.0" Date="2016-10-25" Type="Enhancement">Add init value for "CheckForValidArrayDataType.BoolComplexType" variable in function "CheckForValidArrayDataType".</HistoryEntry>
		<HistoryEntry Editor="O.H." TestVersion="1.3.1" Date="2018-02-26" Type="Enhancement">Comparison ESI to SII: EEPROM SyncM Categories: Typing error in error message corrected. 'SyncManager' instead of 'FMMU'</HistoryEntry>
		<HistoryEntry Editor="G.E." TestVersion="1.3.2" Date="2018-03-13" Type="Enhancement">Minor corrections: 1. TF-1300[2][1] AssignEEPROMToPdi moved in front of "Success" logger output, 2. TF-1300[2][3] Added missing AssignEEPROMToPdi step.</HistoryEntry>
		<HistoryEntry Editor="G.E." TestVersion="1.3.2" Date="2016-03-13" Type="Enhancement">Comparison ESI to SII: Serial Number: Typing error in warning message corrected. 'SerialNo' instead of 'RevisionNo'</HistoryEntry>
		<HistoryEntry Editor="G.E." TestVersion="1.3.3" Date="2018-03-29" Type="Enhancement">Corrected RegEx for ENUMs in Functions "CheckDTxxxxSubItem" (used by TF-1300[10][6]), "CheckDTxxxxENnnDataType" (used by TF-1300[10][7]), "CheckObjectInfoValue" (used by ValidateObjectInfoType) and Test Cases TF-1300[10][1] "All DataType Names", TF-1300[11][3] "ObjectInfo (Variable)", TF-1300[11][4] "ObjectInfo (Arry/Record)". Second RegEx Group for ENUM was not checking the Name Format ("Bitlength of Enum") correctly.</HistoryEntry>
		<HistoryEntry Editor="B.L." TestVersion="1.3.4" Date="2018-09-14">Add output IDs and update Schema version to 1.0.31.</HistoryEntry>
		<HistoryEntry Editor="B.L." TestVersion="1.3.5" Date="2018-09-27">Skip for offline slaves and missing ESI entry.</HistoryEntry>
		<HistoryEntry Editor="R.H." TestVersion="1.3.6" Date="2018-12-13">add TFX-1300 tests:
Module object, data type and PDO tests
Process data length FMMU test
Allow dynamic Sync Manager names</HistoryEntry>
		<HistoryEntry Editor="R.H." TestVersion="1.3.7" Date="2018-12-14">Add dynamic FMMU Categories</HistoryEntry>
		<HistoryEntry Editor="R.H." TestVersion="1.3.8" Date="2018-12-18">fix invalid ESM timeout handling</HistoryEntry>
		<HistoryEntry Editor="R.H." TestVersion="1.3.9" Date="2019-02-05">allow all Basedatatypes less or equal 32bit for enums
remove redundant error outputs
Remove test "PDO Upload/Config/Assign", it is allowed to support PDOupload and PDOConfig/assign at the same time</HistoryEntry>
	</History>
	<TestVariables>
		<TestVariable>
			<Name>AllAssignedDuTModules.Uint32Array</Name>
			<Type>ArrayOfUInt32</Type>
			<Comment>Global Array of all DuT assigned ModuleIdents</Comment>
		</TestVariable>
		<TestVariable>
			<Name>AllAvailableDuTModules.Uint32Array</Name>
			<Type>ArrayOfUInt32</Type>
			<Comment>Global Array of all DuT available ModuleIdents</Comment>
		</TestVariable>
		<TestVariable>
			<Name>AllExternalModuleIdents.Uint32Array</Name>
			<Type>ArrayOfUInt32</Type>
			<Comment>Global Array of all External ModuleIdents</Comment>
		</TestVariable>
		<TestVariable>
			<Name>AllLocalModuleIdents.Uint32Array</Name>
			<Type>ArrayOfUInt32</Type>
			<Comment>Global Array of all Local ModuleIdents</Comment>
		</TestVariable>
		<TestVariable>
			<Name>bool_tf1201</Name>
			<Type>Bool</Type>
			<DefaultValue>false</DefaultValue>
		</TestVariable>
		<TestVariable>
			<Name>debug_msg</Name>
			<Type>Bool</Type>
			<DefaultValue>false</DefaultValue>
			<Comment>Flag for Debug messages</Comment>
		</TestVariable>
		<TestVariable>
			<Name>ext_ModuleXmlFile</Name>
			<Type>String</Type>
			<Comment>Module OD Tests : Reference to the external modules file</Comment>
		</TestVariable>
		<TestVariable>
			<Name>ext_ModuleXmlFile.Length</Name>
			<Type>Int32</Type>
			<Comment>Number of (external module) files under InfoReference</Comment>
		</TestVariable>
		<TestVariable>
			<Name>ext_ModuleXmlFile.XPath</Name>
			<Type>String</Type>
			<Comment>XPath for first module file</Comment>
		</TestVariable>
		<TestVariable>
			<Name>ext_XPathModuleIdent</Name>
			<Type>String</Type>
			<Comment>Module OD Tests : basic XPath to the external ModuleIdent Element</Comment>
		</TestVariable>
		<TestVariable>
			<Name>loc_ModuleXmlFile</Name>
			<Type>String</Type>
			<Comment>Module OD Tests : Reference to the local modules file</Comment>
		</TestVariable>
		<TestVariable>
			<Name>loc_XPathModuleIdent</Name>
			<Type>String</Type>
			<Comment>Module OD Tests : basic XPath to the local ModuleIdent Element</Comment>
		</TestVariable>
		<TestVariable>
			<Name>Settings.b04_10_WarningAccepted</Name>
			<Type>Bool</Type>
			<DefaultValue>false</DefaultValue>
		</TestVariable>
		<TestVariable>
			<Name>Settings.b04_all_performAnyways</Name>
			<Type>Bool</Type>
			<DefaultValue>false</DefaultValue>
		</TestVariable>
		<TestVariable>
			<Name>Settings.bAll_debugMsg</Name>
			<Type>Bool</Type>
			<DefaultValue>false</DefaultValue>
		</TestVariable>
		<TestVariable>
			<Name>Settings.bAll_esm_overwriteTimeouts</Name>
			<Type>Bool</Type>
			<DefaultValue>false</DefaultValue>
		</TestVariable>
		<TestVariable>
			<Name>Settings.int32_all_esm_backInitTimeout</Name>
			<Type>Int32</Type>
			<DefaultValue>5000</DefaultValue>
		</TestVariable>
		<TestVariable>
			<Name>Settings.int32_all_esm_backSafeOPTimeout</Name>
			<Type>Int32</Type>
			<DefaultValue>200</DefaultValue>
		</TestVariable>
		<TestVariable>
			<Name>Settings.int32_all_esm_preOPTimeout</Name>
			<Type>Int32</Type>
			<DefaultValue>3000</DefaultValue>
		</TestVariable>
		<TestVariable>
			<Name>Settings.int32_all_esm_safeOPTimeout</Name>
			<Type>Int32</Type>
			<DefaultValue>10000</DefaultValue>
		</TestVariable>
		<TestVariable>
			<Name>t_preopTimeout</Name>
			<Type>Int32</Type>
			<DefaultValue>3000</DefaultValue>
		</TestVariable>
		<TestVariable>
			<Name>TestAvailableMdls</Name>
			<Type>Bool</Type>
			<DefaultValue>true</DefaultValue>
			<Comment>Flag to test ALL (non-assigned and assigned modules) - false or ONLY assigned modules - true</Comment>
		</TestVariable>
		<TestVariable>
			<Name>uint32_idValue</Name>
			<Type>UInt32</Type>
			<DefaultValue>5</DefaultValue>
		</TestVariable>
		<TestVariable>
			<Name>XmlFile</Name>
			<Type>String</Type>
			<Comment>DataType/Object Tests : Reference to the external xml file</Comment>
		</TestVariable>
		<TestVariable>
			<Name>XPathDt</Name>
			<Type>String</Type>
			<Comment>DataType/Object Tests : basic XPath to the DatatType Element</Comment>
		</TestVariable>
		<TestVariable>
			<Name>XPathObject</Name>
			<Type>String</Type>
			<Comment>Object Tests : basic XPath to the Object Element</Comment>
		</TestVariable>
	</TestVariables>
	<Variables>
		<Variable>
			<Name>abortMessage</Name>
			<Type>String</Type>
		</Variable>
		<Variable>
			<Name>access</Name>
			<Type>String</Type>
		</Variable>
		<Variable>
			<Name>AllDataTypeNames.LoopCounter</Name>
			<Type>Int32</Type>
		</Variable>
		<Variable>
			<Name>allInputSm</Name>
			<Type>ArrayOfBytes</Type>
		</Variable>
		<Variable>
			<Name>allMboxInSm</Name>
			<Type>ArrayOfBytes</Type>
		</Variable>
		<Variable>
			<Name>AllModuleIdents.LoopCounter</Name>
			<Type>Int32</Type>
			<Comment>Loop counter for looping through available modules with XPath</Comment>
		</Variable>
		<Variable>
			<Name>AllModuleIdents.Uint32</Name>
			<Type>UInt32</Type>
			<Comment>Tmp value to receive array item</Comment>
		</Variable>
		<Variable>
			<Name>AllModuleIdents.Uint32Array</Name>
			<Type>ArrayOfUInt32</Type>
			<Comment>Array to store already tested modules</Comment>
		</Variable>
		<Variable>
			<Name>allOutputSm</Name>
			<Type>ArrayOfBytes</Type>
		</Variable>
		<Variable>
			<Name>allPdSm</Name>
			<Type>ArrayOfBytes</Type>
		</Variable>
		<Variable>
			<Name>alStatus</Name>
			<Type>UInt16</Type>
		</Variable>
		<Variable>
			<Name>alStatusCode</Name>
			<Type>UInt16</Type>
		</Variable>
		<Variable>
			<Name>ArrayModule.Counter</Name>
			<Type>Int32</Type>
			<Comment>Module counter for assigned modules in array</Comment>
		</Variable>
		<Variable>
			<Name>arrayOfUint16_eepromData</Name>
			<Type>ArrayOfUInt16</Type>
		</Variable>
		<Variable>
			<Name>arrStrtEndAddr</Name>
			<Type>ArrayOfUInt16</Type>
		</Variable>
		<Variable>
			<Name>assignedIndex</Name>
			<Type>UInt16</Type>
		</Variable>
		<Variable>
			<Name>assignObjects</Name>
			<Type>ArrayOfUInt16</Type>
		</Variable>
		<Variable>
			<Name>AtLeastOneDtFound</Name>
			<Type>Bool</Type>
			<Comment>DataType Tests : indicates if at least one DT was checked in TestCase</Comment>
		</Variable>
		<Variable>
			<Name>AtLeastOneModuleFound</Name>
			<Type>Bool</Type>
			<DefaultValue>False</DefaultValue>
			<Comment>DataType Tests : indicates if at least one DT was checked in TestCase</Comment>
		</Variable>
		<Variable>
			<Name>backInitTimeout</Name>
			<Type>Int32</Type>
		</Variable>
		<Variable>
			<Name>backSafeOPTimeout</Name>
			<Type>Int32</Type>
		</Variable>
		<Variable>
			<Name>BaseDataTypes.LoopCounter</Name>
			<Type>Int32</Type>
		</Variable>
		<Variable>
			<Name>BaseDataTypesArray.LoopCounter</Name>
			<Type>Int32</Type>
		</Variable>
		<Variable>
			<Name>BaseDataTypesEnum.LoopCounter</Name>
			<Type>Int32</Type>
		</Variable>
		<Variable>
			<Name>BaseDataTypesRecord.LoopCounter</Name>
			<Type>Int32</Type>
		</Variable>
		<Variable>
			<Name>BaseDataTypesString.LoopCounter</Name>
			<Type>Int32</Type>
		</Variable>
		<Variable>
			<Name>BaseType</Name>
			<Type>String</Type>
			<Comment>BaseType of the obejct/entry</Comment>
		</Variable>
		<Variable>
			<Name>bIsMatch</Name>
			<Type>Bool</Type>
		</Variable>
		<Variable>
			<Name>bitSize</Name>
			<Type>Int32</Type>
		</Variable>
		<Variable>
			<Name>boolComplexType</Name>
			<Type>Bool</Type>
		</Variable>
		<Variable>
			<Name>boolVar</Name>
			<Type>Bool</Type>
		</Variable>
		<Variable>
			<Name>byte</Name>
			<Type>Byte</Type>
		</Variable>
		<Variable>
			<Name>byteArr</Name>
			<Type>ArrayOfBytes</Type>
		</Variable>
		<Variable>
			<Name>byteAssignToEcat</Name>
			<Type>Byte</Type>
		</Variable>
		<Variable>
			<Name>byteSize</Name>
			<Type>Int32</Type>
		</Variable>
		<Variable>
			<Name>byteVal</Name>
			<Type>Byte</Type>
		</Variable>
		<Variable>
			<Name>byteVal1</Name>
			<Type>Byte</Type>
		</Variable>
		<Variable>
			<Name>byteVal2</Name>
			<Type>Byte</Type>
		</Variable>
		<Variable>
			<Name>CheckAccessFlag.LoopCounter</Name>
			<Type>Int32</Type>
		</Variable>
		<Variable>
			<Name>CheckAttributes.LoopCounter</Name>
			<Type>Int32</Type>
		</Variable>
		<Variable>
			<Name>CheckIndex.LoopCounter</Name>
			<Type>Int32</Type>
		</Variable>
		<Variable>
			<Name>CheckModuleAlreadyTested.boolAlreadyChecked</Name>
			<Type>Bool</Type>
			<Comment>Bool to indicate if Module already passed the test</Comment>
		</Variable>
		<Variable>
			<Name>CheckModuleInArray.boolAssigned</Name>
			<Type>Bool</Type>
			<Comment>Bool to indicate if current Module is present in the Assigned Array</Comment>
		</Variable>
		<Variable>
			<Name>CheckPdoExclude.LoopCounter</Name>
			<Type>Int32</Type>
		</Variable>
		<Variable>
			<Name>CheckSmAssignment.LoopCounter</Name>
			<Type>Int32</Type>
		</Variable>
		<Variable>
			<Name>clearSMAdo</Name>
			<Type>Register</Type>
		</Variable>
		<Variable>
			<Name>cmpDefString</Name>
			<Type>String</Type>
		</Variable>
		<Variable>
			<Name>cmpEndAddr</Name>
			<Type>UInt16</Type>
		</Variable>
		<Variable>
			<Name>cmpIndex</Name>
			<Type>Int32</Type>
		</Variable>
		<Variable>
			<Name>cmpListIndex</Name>
			<Type>UInt16</Type>
		</Variable>
		<Variable>
			<Name>cmpStrtAddr</Name>
			<Type>UInt16</Type>
		</Variable>
		<Variable>
			<Name>cmpSubIndex</Name>
			<Type>Byte</Type>
		</Variable>
		<Variable>
			<Name>count</Name>
			<Type>UInt32</Type>
		</Variable>
		<Variable>
			<Name>CurrentConfigAllMdlIds.uint32Length</Name>
			<Type>UInt32</Type>
			<Comment>Array length of all DuTs modules</Comment>
		</Variable>
		<Variable>
			<Name>CurrentConfigMdlIds.uint32Length</Name>
			<Type>UInt32</Type>
			<Comment>Array length of assigned modules</Comment>
		</Variable>
		<Variable>
			<Name>CurrentFMMU</Name>
			<Type>UInt16</Type>
		</Variable>
		<Variable>
			<Name>CurrentObjIndex</Name>
			<Type>UInt16</Type>
			<Comment>Index of the current object</Comment>
		</Variable>
		<Variable>
			<Name>data</Name>
			<Type>ArrayOfBytes</Type>
		</Variable>
		<Variable>
			<Name>DataType.Index.LoopCounter</Name>
			<Type>Int32</Type>
		</Variable>
		<Variable>
			<Name>defaultPdoLength</Name>
			<Type>UInt32</Type>
		</Variable>
		<Variable>
			<Name>defData</Name>
			<Type>ArrayOfBytes</Type>
		</Variable>
		<Variable>
			<Name>defDataLen</Name>
			<Type>UInt32</Type>
		</Variable>
		<Variable>
			<Name>Device.HideType.LoopCounter</Name>
			<Type>Int32</Type>
		</Variable>
		<Variable>
			<Name>deviceEmulation</Name>
			<Type>Bool</Type>
		</Variable>
		<Variable>
			<Name>elementName</Name>
			<Type>String</Type>
		</Variable>
		<Variable>
			<Name>endAddr</Name>
			<Type>UInt16</Type>
		</Variable>
		<Variable>
			<Name>entryIdx</Name>
			<Type>Int32</Type>
		</Variable>
		<Variable>
			<Name>errAck</Name>
			<Type>Bool</Type>
		</Variable>
		<Variable>
			<Name>errcount</Name>
			<Type>Int32</Type>
		</Variable>
		<Variable>
			<Name>ESCreg0x0000</Name>
			<Type>Int32</Type>
		</Variable>
		<Variable>
			<Name>EsmTimeout</Name>
			<Type>Int32</Type>
		</Variable>
		<Variable>
			<Name>expectedAlStatusCode</Name>
			<Type>UInt16</Type>
		</Variable>
		<Variable>
			<Name>ext_ModuleXmlFile.FileCounter</Name>
			<Type>Int32</Type>
			<DefaultValue>1</DefaultValue>
			<Comment>Counter for external module files referenced in InfoReference</Comment>
		</Variable>
		<Variable>
			<Name>ext_XPathDtTmp</Name>
			<Type>String</Type>
			<Comment>Temporal XPath string for external modules - DataType tests</Comment>
		</Variable>
		<Variable>
			<Name>FHa_BoolTemp1</Name>
			<Type>Bool</Type>
		</Variable>
		<Variable>
			<Name>FHa_Error</Name>
			<Type>Bool</Type>
		</Variable>
		<Variable>
			<Name>FHa_i</Name>
			<Type>UInt16</Type>
		</Variable>
		<Variable>
			<Name>firstInputSm</Name>
			<Type>Byte</Type>
		</Variable>
		<Variable>
			<Name>firstOutputSm</Name>
			<Type>Byte</Type>
		</Variable>
		<Variable>
			<Name>FmmuIndex</Name>
			<Type>Int32</Type>
		</Variable>
		<Variable>
			<Name>i32TmpEntryIndex</Name>
			<Type>Int32</Type>
			<Comment>Loop Counter (3.level)</Comment>
		</Variable>
		<Variable>
			<Name>i32TmpIndex</Name>
			<Type>Int32</Type>
		</Variable>
		<Variable>
			<Name>i32TmpModuleIndex</Name>
			<Type>Int32</Type>
			<Comment>Loop Counter (2.level)</Comment>
		</Variable>
		<Variable>
			<Name>i32TmpModuleIndexDeep</Name>
			<Type>Int32</Type>
			<Comment>Loop Counter (3.level)</Comment>
		</Variable>
		<Variable>
			<Name>i32TmpRxPdoIndex</Name>
			<Type>Int32</Type>
			<Comment>Loop Counter (2.level)</Comment>
		</Variable>
		<Variable>
			<Name>i32TmpTxPdoIndex</Name>
			<Type>Int32</Type>
			<Comment>Loop Counter (2.level)</Comment>
		</Variable>
		<Variable>
			<Name>i32TmpVar</Name>
			<Type>Int32</Type>
		</Variable>
		<Variable>
			<Name>index</Name>
			<Type>Int32</Type>
		</Variable>
		<Variable>
			<Name>index2</Name>
			<Type>Int32</Type>
		</Variable>
		<Variable>
			<Name>index2max</Name>
			<Type>Int32</Type>
		</Variable>
		<Variable>
			<Name>index3</Name>
			<Type>Int32</Type>
		</Variable>
		<Variable>
			<Name>index32</Name>
			<Type>Int32</Type>
		</Variable>
		<Variable>
			<Name>index3max</Name>
			<Type>Int32</Type>
		</Variable>
		<Variable>
			<Name>index8</Name>
			<Type>Byte</Type>
		</Variable>
		<Variable>
			<Name>indexCount</Name>
			<Type>UInt16</Type>
		</Variable>
		<Variable>
			<Name>indexmax</Name>
			<Type>Int32</Type>
		</Variable>
		<Variable>
			<Name>inputSmCount</Name>
			<Type>Int32</Type>
		</Variable>
		<Variable>
			<Name>Int32</Name>
			<Type>Int32</Type>
		</Variable>
		<Variable>
			<Name>int32CurrIndex</Name>
			<Type>Int32</Type>
		</Variable>
		<Variable>
			<Name>int32CurrSubIndex</Name>
			<Type>Int32</Type>
		</Variable>
		<Variable>
			<Name>int32SavedSubIndex</Name>
			<Type>Int32</Type>
		</Variable>
		<Variable>
			<Name>int32Val</Name>
			<Type>Int32</Type>
		</Variable>
		<Variable>
			<Name>int32XPathValue</Name>
			<Type>Int32</Type>
		</Variable>
		<Variable>
			<Name>IsMatch</Name>
			<Type>Bool</Type>
			<Comment>DataType Tests : tmp variable to indicate if an RegEx match</Comment>
		</Variable>
		<Variable>
			<Name>isPdoObject</Name>
			<Type>Bool</Type>
		</Variable>
		<Variable>
			<Name>isSMPdoAssignObject</Name>
			<Type>Bool</Type>
		</Variable>
		<Variable>
			<Name>listIndex</Name>
			<Type>UInt16</Type>
		</Variable>
		<Variable>
			<Name>listLen</Name>
			<Type>UInt32</Type>
		</Variable>
		<Variable>
			<Name>loc_XPathDtTmp</Name>
			<Type>String</Type>
			<Comment>Temporal XPath string for local modules - DataType tests</Comment>
		</Variable>
		<Variable>
			<Name>LocExt_InitToggle</Name>
			<Type>Bool</Type>
			<Comment>Toggle between Global Variable Initializations</Comment>
		</Variable>
		<Variable>
			<Name>mandatoryDict</Name>
			<Type>ObjectDictionary</Type>
		</Variable>
		<Variable>
			<Name>mappingObjects</Name>
			<Type>ArrayOfBytes</Type>
		</Variable>
		<Variable>
			<Name>maxSubIndex</Name>
			<Type>Byte</Type>
		</Variable>
		<Variable>
			<Name>MboxInSmCount</Name>
			<Type>UInt16</Type>
		</Variable>
		<Variable>
			<Name>mbxReqTimeout</Name>
			<Type>Int32</Type>
		</Variable>
		<Variable>
			<Name>mbxResTimeout</Name>
			<Type>Int32</Type>
		</Variable>
		<Variable>
			<Name>ModuleCounter</Name>
			<Type>Int32</Type>
			<Comment>General Module Counter</Comment>
		</Variable>
		<Variable>
			<Name>ModuleObjectDTBitSize.ObjBitSize</Name>
			<Type>Int32</Type>
			<Comment>BitSize of the Object</Comment>
		</Variable>
		<Variable>
			<Name>ModuleObjectDTBitSize.TypeBitSize</Name>
			<Type>Int32</Type>
			<Comment>BitSize of Object Type</Comment>
		</Variable>
		<Variable>
			<Name>ModuleObjectInfo.ObjFound</Name>
			<Type>Bool</Type>
			<DefaultValue>False</DefaultValue>
			<Comment>Indicates if an object was found</Comment>
		</Variable>
		<Variable>
			<Name>ModuleObjectInfo.strHexObjIndex</Name>
			<Type>String</Type>
			<Comment>String of the index in hex coding</Comment>
		</Variable>
		<Variable>
			<Name>ModuleObjectInfo.strXmlValue</Name>
			<Type>String</Type>
			<Comment>Value of Object/Info</Comment>
		</Variable>
		<Variable>
			<Name>ModuleObjectInfo.Subitem</Name>
			<Type>String</Type>
			<Comment>XPath of Object/Info/Subitem</Comment>
		</Variable>
		<Variable>
			<Name>ModuleObjectInfo.XPathInfo</Name>
			<Type>String</Type>
			<Comment>XPath of Object/Info</Comment>
		</Variable>
		<Variable>
			<Name>ModuleObjectInfo.XPathType</Name>
			<Type>String</Type>
			<Comment>XPath of Object/Type</Comment>
		</Variable>
		<Variable>
			<Name>name</Name>
			<Type>String</Type>
		</Variable>
		<Variable>
			<Name>noInputSm</Name>
			<Type>Bool</Type>
		</Variable>
		<Variable>
			<Name>nonVirtualSmCount</Name>
			<Type>Int32</Type>
		</Variable>
		<Variable>
			<Name>noOutputSm</Name>
			<Type>Bool</Type>
		</Variable>
		<Variable>
			<Name>noPdSm</Name>
			<Type>Bool</Type>
		</Variable>
		<Variable>
			<Name>NumberOfElements</Name>
			<Type>Int32</Type>
		</Variable>
		<Variable>
			<Name>ObjBitSize</Name>
			<Type>Int32</Type>
			<Comment>BitSize of the Object</Comment>
		</Variable>
		<Variable>
			<Name>objctCnt</Name>
			<Type>UInt32</Type>
		</Variable>
		<Variable>
			<Name>ObjectAttributes.LoopCounter</Name>
			<Type>Int32</Type>
		</Variable>
		<Variable>
			<Name>ObjectDataType.LoopCounter</Name>
			<Type>Int32</Type>
		</Variable>
		<Variable>
			<Name>ObjectInfo.LoopCounter</Name>
			<Type>Int32</Type>
		</Variable>
		<Variable>
			<Name>ObjectInfoArrRec.LoopCounter</Name>
			<Type>Int32</Type>
		</Variable>
		<Variable>
			<Name>ObjectInfoVar.LoopCounter</Name>
			<Type>Int32</Type>
		</Variable>
		<Variable>
			<Name>objectList</Name>
			<Type>ObjectList</Type>
		</Variable>
		<Variable>
			<Name>objectResponse</Name>
			<Type>ArrayOfBytes</Type>
		</Variable>
		<Variable>
			<Name>objectResponseLen</Name>
			<Type>UInt32</Type>
		</Variable>
		<Variable>
			<Name>ObjFound</Name>
			<Type>Bool</Type>
			<Comment>indicates if an object was found</Comment>
		</Variable>
		<Variable>
			<Name>ObjIndex</Name>
			<Type>UInt16</Type>
			<Comment>Object index</Comment>
		</Variable>
		<Variable>
			<Name>offlineDict</Name>
			<Type>ObjectDictionary</Type>
		</Variable>
		<Variable>
			<Name>onlineDict</Name>
			<Type>ObjectDictionary</Type>
		</Variable>
		<Variable>
			<Name>outputSmCount</Name>
			<Type>Int32</Type>
		</Variable>
		<Variable>
			<Name>pdSm</Name>
			<Type>Byte</Type>
		</Variable>
		<Variable>
			<Name>pdSmCount</Name>
			<Type>Byte</Type>
		</Variable>
		<Variable>
			<Name>portType</Name>
			<Type>Byte</Type>
		</Variable>
		<Variable>
			<Name>portTypeSize</Name>
			<Type>UInt32</Type>
		</Variable>
		<Variable>
			<Name>preOPTimeout</Name>
			<Type>Int32</Type>
		</Variable>
		<Variable>
			<Name>ramSize</Name>
			<Type>Byte</Type>
		</Variable>
		<Variable>
			<Name>readInOp</Name>
			<Type>Bool</Type>
		</Variable>
		<Variable>
			<Name>readInPreOp</Name>
			<Type>Bool</Type>
		</Variable>
		<Variable>
			<Name>readInSafeOp</Name>
			<Type>Bool</Type>
		</Variable>
		<Variable>
			<Name>result</Name>
			<Type>Bool</Type>
		</Variable>
		<Variable>
			<Name>safeOPTimeout</Name>
			<Type>Int32</Type>
		</Variable>
		<Variable>
			<Name>sdoAbortCode</Name>
			<Type>UInt32</Type>
		</Variable>
		<Variable>
			<Name>smEnable</Name>
			<Type>Bool</Type>
		</Variable>
		<Variable>
			<Name>SmEnable.LoopCounter</Name>
			<Type>Int32</Type>
		</Variable>
		<Variable>
			<Name>SMerror</Name>
			<Type>Int32</Type>
		</Variable>
		<Variable>
			<Name>smLen</Name>
			<Type>UInt16</Type>
		</Variable>
		<Variable>
			<Name>smNo</Name>
			<Type>Byte</Type>
		</Variable>
		<Variable>
			<Name>SMStrtLenArrIndex</Name>
			<Type>Int32</Type>
		</Variable>
		<Variable>
			<Name>smType</Name>
			<Type>String</Type>
		</Variable>
		<Variable>
			<Name>specialListIndex</Name>
			<Type>UInt16</Type>
		</Variable>
		<Variable>
			<Name>specialObject</Name>
			<Type>UInt16</Type>
		</Variable>
		<Variable>
			<Name>specialobjectList</Name>
			<Type>ObjectList</Type>
		</Variable>
		<Variable>
			<Name>stateValue</Name>
			<Type>UInt16</Type>
		</Variable>
		<Variable>
			<Name>stateValueNext</Name>
			<Type>UInt16</Type>
		</Variable>
		<Variable>
			<Name>strHexObjIndex</Name>
			<Type>String</Type>
			<Comment>string of the index in hex coding</Comment>
		</Variable>
		<Variable>
			<Name>StringBaseTypeErrorString</Name>
			<Type>String</Type>
		</Variable>
		<Variable>
			<Name>StringCurrXPathValue</Name>
			<Type>String</Type>
		</Variable>
		<Variable>
			<Name>strtAddr</Name>
			<Type>UInt16</Type>
		</Variable>
		<Variable>
			<Name>strXmlValue</Name>
			<Type>String</Type>
			<Comment>DataType Tests : tmp variable to read a xml value</Comment>
		</Variable>
		<Variable>
			<Name>strXmlValue.BitLen.Uint32</Name>
			<Type>UInt32</Type>
			<Comment>Bit Length for RxPdo Check Entry Data Type test</Comment>
		</Variable>
		<Variable>
			<Name>strXmlValue.EntryBitLenCopy.Uint32</Name>
			<Type>UInt32</Type>
			<Comment>Converted to Uint32</Comment>
		</Variable>
		<Variable>
			<Name>strXmlValue.EntryBitLenCopy2.Uint32</Name>
			<Type>UInt32</Type>
			<Comment>Converted to Uint32</Comment>
		</Variable>
		<Variable>
			<Name>strXmlValue.EntryDT.String</Name>
			<Type>String</Type>
			<Comment>Entry Data Type for RxPdo Check Entry Data Type test</Comment>
		</Variable>
		<Variable>
			<Name>strXmlValue.EntryDTCopy.String</Name>
			<Type>String</Type>
			<Comment>Copied Entry DT</Comment>
		</Variable>
		<Variable>
			<Name>strXmlValue.EntryDTSave.String</Name>
			<Type>String</Type>
			<Comment>Saved String</Comment>
		</Variable>
		<Variable>
			<Name>strXmlValue.EntryIndex.Uint16</Name>
			<Type>UInt16</Type>
			<Comment>Converted to Uint16</Comment>
		</Variable>
		<Variable>
			<Name>strXmlValue.EntryNmmr.String</Name>
			<Type>String</Type>
			<Comment>Copy for "last" Entry.Count</Comment>
		</Variable>
		<Variable>
			<Name>strXmlValue.EntrySubindex.Uint16</Name>
			<Type>UInt16</Type>
			<Comment>Converted to Uint16</Comment>
		</Variable>
		<Variable>
			<Name>strXmlValue.Index.Uint16</Name>
			<Type>UInt16</Type>
			<Comment>Converted String (Index) for RxPdo Check Index test</Comment>
		</Variable>
		<Variable>
			<Name>strXmlValue.Obj.String</Name>
			<Type>String</Type>
			<Comment>String Value of object</Comment>
		</Variable>
		<Variable>
			<Name>strXmlValue.ObjBaseType.String</Name>
			<Type>String</Type>
			<Comment>String Value of object base type</Comment>
		</Variable>
		<Variable>
			<Name>strXmlValue.ObjIndex.Uint16</Name>
			<Type>UInt16</Type>
			<Comment>Object index</Comment>
		</Variable>
		<Variable>
			<Name>strXmlValue.OSFac.Int32</Name>
			<Type>Int32</Type>
			<Comment>Converted String (OSFac) for RxPdo Check Attributes test</Comment>
		</Variable>
		<Variable>
			<Name>strXmlValue.OSIndexInc.Int32</Name>
			<Type>Int32</Type>
			<Comment>Converted String (OSIndexInc) for RxPdo Check Attributes test</Comment>
		</Variable>
		<Variable>
			<Name>strXmlValue.OSMax.Int32</Name>
			<Type>Int32</Type>
			<Comment>Converted String (OSMax) for RxPdo Check Attributes test</Comment>
		</Variable>
		<Variable>
			<Name>strXmlValue.OSMin.Int32</Name>
			<Type>Int32</Type>
			<Comment>Converted String (OSMin) for RxPdo Check Attributes test</Comment>
		</Variable>
		<Variable>
			<Name>strXmlValue.Su.Uint16</Name>
			<Type>UInt16</Type>
			<Comment>Su as Uint16</Comment>
		</Variable>
		<Variable>
			<Name>strXmlValueEntries</Name>
			<Type>String</Type>
			<Comment>Entry Uint16 Value</Comment>
		</Variable>
		<Variable>
			<Name>strXmlValueFixed.Bool</Name>
			<Type>Bool</Type>
			<Comment>Fixed Bool Value</Comment>
		</Variable>
		<Variable>
			<Name>strXmlValueOSFac</Name>
			<Type>String</Type>
			<Comment>OSFac String Value</Comment>
		</Variable>
		<Variable>
			<Name>strXmlValueOSMax</Name>
			<Type>String</Type>
			<Comment>OSMax String Value</Comment>
		</Variable>
		<Variable>
			<Name>strXmlValueOSMin</Name>
			<Type>String</Type>
			<Comment>OSMin String Value</Comment>
		</Variable>
		<Variable>
			<Name>subIdx</Name>
			<Type>Byte</Type>
		</Variable>
		<Variable>
			<Name>subIndex</Name>
			<Type>Byte</Type>
		</Variable>
		<Variable>
			<Name>subindex</Name>
			<Type>UInt32</Type>
		</Variable>
		<Variable>
			<Name>tempListIndex</Name>
			<Type>UInt16</Type>
		</Variable>
		<Variable>
			<Name>tmpByte</Name>
			<Type>Byte</Type>
		</Variable>
		<Variable>
			<Name>tmpData</Name>
			<Type>ArrayOfBytes</Type>
		</Variable>
		<Variable>
			<Name>TmpResult</Name>
			<Type>Bool</Type>
		</Variable>
		<Variable>
			<Name>tmpString</Name>
			<Type>String</Type>
		</Variable>
		<Variable>
			<Name>tmpUInt16</Name>
			<Type>UInt16</Type>
		</Variable>
		<Variable>
			<Name>tmpUInt32</Name>
			<Type>UInt32</Type>
		</Variable>
		<Variable>
			<Name>type</Name>
			<Type>String</Type>
		</Variable>
		<Variable>
			<Name>TypeBitSize</Name>
			<Type>Int32</Type>
			<Comment>BitSize of Object Type</Comment>
		</Variable>
		<Variable>
			<Name>u16ArrFmmu</Name>
			<Type>ArrayOfUInt16</Type>
		</Variable>
		<Variable>
			<Name>u16FmmuArrCount</Name>
			<Type>UInt32</Type>
		</Variable>
		<Variable>
			<Name>u32TmpVal</Name>
			<Type>UInt32</Type>
		</Variable>
		<Variable>
			<Name>u8EscFmmu</Name>
			<Type>Byte</Type>
		</Variable>
		<Variable>
			<Name>uInt16</Name>
			<Type>UInt16</Type>
		</Variable>
		<Variable>
			<Name>uint16_temp_esi_data</Name>
			<Type>UInt16</Type>
			<Comment>Data fragment of ESI config data</Comment>
		</Variable>
		<Variable>
			<Name>uint16_temp_sii_data</Name>
			<Type>UInt16</Type>
			<Comment>Data fragment of SII config data</Comment>
		</Variable>
		<Variable>
			<Name>uint16ErrCount</Name>
			<Type>UInt16</Type>
		</Variable>
		<Variable>
			<Name>uint16Errors</Name>
			<Type>UInt16</Type>
		</Variable>
		<Variable>
			<Name>uint16SuccCount</Name>
			<Type>UInt16</Type>
		</Variable>
		<Variable>
			<Name>uint16TestedValues</Name>
			<Type>UInt16</Type>
		</Variable>
		<Variable>
			<Name>uInt16Val</Name>
			<Type>UInt16</Type>
		</Variable>
		<Variable>
			<Name>uInt16Val2</Name>
			<Type>UInt16</Type>
		</Variable>
		<Variable>
			<Name>uInt32</Name>
			<Type>UInt32</Type>
		</Variable>
		<Variable>
			<Name>Uint32ArrayBitLength</Name>
			<Type>UInt32</Type>
		</Variable>
		<Variable>
			<Name>uInt32Val</Name>
			<Type>UInt32</Type>
		</Variable>
		<Variable>
			<Name>writeInOp</Name>
			<Type>Bool</Type>
		</Variable>
		<Variable>
			<Name>writeInPreOp</Name>
			<Type>Bool</Type>
		</Variable>
		<Variable>
			<Name>writeInSafeOp</Name>
			<Type>Bool</Type>
		</Variable>
		<Variable>
			<Name>XPathDtTmp</Name>
			<Type>String</Type>
			<Comment>DataType/Object Tests : tmp XPath for the DataType Element (required to create function parameters)</Comment>
		</Variable>
		<Variable>
			<Name>XPathInfo</Name>
			<Type>String</Type>
			<Comment>XPath to Info Elements</Comment>
		</Variable>
		<Variable>
			<Name>XPathObjTmp</Name>
			<Type>String</Type>
			<Comment>Object Tests : tmp XPath for the Object Element (required to create function parameters)</Comment>
		</Variable>
		<Variable>
			<Name>XPathTmp</Name>
			<Type>String</Type>
		</Variable>
	</Variables>
	<IncludedTestFunctions>
		<FileName>BF-12xx_V1i0i0_EsmBaseFunctions.xml</FileName>
		<FileName Version="0.0.16">EcBaseFunctions_V1i0i0.xml</FileName>
	</IncludedTestFunctions>
	<TestFunctions>
		<TestFunction Name="AssignedDuTModuleIdents" FunctionId="20201">
			<?MAX_OUTPUT_ID 13?>
			<!--Initiate global array of all DuT assigned ModuleIdents-->
			<Description>
				<Action>Initiate global array of all DuT assigned ModuleIdents</Action>
				<PostCondition>Global array AllAssignedDuTModules.Uint32Array initiated</PostCondition>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<LocalVariables>
				<Name>AssignedDuTModuleIdents.result</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>AssignedDuTModuleIdents.AtLeastOneModuleFound</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>AssignedDuTModuleIdents.int32LoopCounter</Name>
				<Type>Int32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CurrentConfigAllMdlIds.uint32Length</Name>
				<Type>UInt32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CurrentConfigMdlIds.uint32Length</Name>
				<Type>UInt32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>AssignedDuTModuleIdents.FiltAllMdlIds.uint32Length</Name>
				<Type>UInt32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>AssignedDuTModuleIdents.RealModuleIdents.Uint32Array</Name>
				<Type>ArrayOfUInt32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>AssignedDuTModuleIdents.ArrayModule.Counter</Name>
				<Type>Int32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>AssignedDuTModuleIdents.boolAlreadyChecked</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>AssignedDuTModuleIdents.Uint32ModuleIdent</Name>
				<Type>UInt32</Type>
			</LocalVariables>
			<TestStep Name="SkipNoSlots">
				<!--Skip Test if "CurrentConfig.SlotCount" == 0-->
				<Compare>
					<Equal>
						<Value1>CurrentConfig.SlotCount</Value1>
						<Value2>0</Value2>
						<SkipCase Id="0">Test skipped. No slots defined.</SkipCase>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="SkipSoE">
				<!--Skip Test if SoE Device-->
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Mailbox.SoE</Value1>
						<Value2>true</Value2>
						<SkipCase Id="1">Test skipped for SoE Devices.</SkipCase>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="INIT_AssignedDuTModuleIdents.result">
				<!--"AssignedDuTModuleIdents.result" = true-->
				<SetVariable Target="AssignedDuTModuleIdents.result">true</SetVariable>
			</TestStep>
			<TestStep Name="GetLengthOfAssignedModArray">
				<!--ASSIGNED DuT modules-->
				<SizeOf UInt32Var="CurrentConfigMdlIds.uint32Length">CurrentConfig.MdlIds</SizeOf>
				<Compare>
					<NotEqual>
						<Value1>CurrentConfigMdlIds.uint32Length</Value1>
						<Value2>0</Value2>
						<SetVariable Target="AssignedDuTModuleIdents.AtLeastOneModuleFound">true</SetVariable>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="INIT_LOOP_COUNTER">
				<!--"AssignedDuTModuleIdents.int32LoopCounter" = 0, starts at list index [0] for Array-->
				<SetVariable Target="AssignedDuTModuleIdents.int32LoopCounter">0</SetVariable>
			</TestStep>
			<TestStep Name="InitTestedArray">
				<!--Array of assigned modules, no empty slots-->
				<InitArray TargetArray="AssignedDuTModuleIdents.RealModuleIdents.Uint32Array"></InitArray>
			</TestStep>
			<TestStep>
				<!--Array of already processed modules, no doubles-->
				<InitArray TargetArray="AllAssignedDuTModules.Uint32Array"></InitArray>
			</TestStep>
			<TestStep Name="HandleEmptySlots">
				<!--Loop through CurrentConfig.MdlId and build a new array without "empty slots"-->
			</TestStep>
			<TestStep>
				<!--Init Module Counter with 0 for Array elements-->
				<SetVariable Target="AssignedDuTModuleIdents.ArrayModule.Counter">0</SetVariable>
			</TestStep>
			<TestStep Name="ModuleCount_LoopStart">
				<Compare>
					<GreaterOrEqual>
						<Value1>AssignedDuTModuleIdents.ArrayModule.Counter</Value1>
						<Value2>CurrentConfigMdlIds.uint32Length</Value2>
						<GotoStep>LOOP_START</GotoStep>
					</GreaterOrEqual>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Get "CurrentConfig.MdlIds" item and check if 0 (empty slot).-->
				<GetArrayItem Index="AssignedDuTModuleIdents.ArrayModule.Counter" SourceArray="CurrentConfig.MdlIds" Target="AssignedDuTModuleIdents.Uint32ModuleIdent"></GetArrayItem>
				<Compare>
					<Equal>
						<Value1>AssignedDuTModuleIdents.Uint32ModuleIdent</Value1>
						<Value2>0</Value2>
						<WriteLine Id="2" Level="Output" Param0="AssignedDuTModuleIdents.ArrayModule.Counter" Param1="AssignedDuTModuleIdents.Uint32ModuleIdent" Param2="CurrentConfig.MdlIds">Item [{0}] == Empty Slot of Array '{2}'.</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>AssignedDuTModuleIdents.Uint32ModuleIdent</Value1>
						<Value2>0</Value2>
						<GotoStep>ModuleCount_LoopEnd</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="3" Level="Output" Param0="AssignedDuTModuleIdents.ArrayModule.Counter" Param1="AssignedDuTModuleIdents.Uint32ModuleIdent" Param2="CurrentConfig.MdlIds">Item [{0}] ==   #x{1:x4} of Array '{2}'.</WriteLine>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Copy modules to new array-->
				<AddArrayItem TargetArray="AssignedDuTModuleIdents.RealModuleIdents.Uint32Array">AssignedDuTModuleIdents.Uint32ModuleIdent</AddArrayItem>
				<WriteLine Id="4" Level="Verbose" Param0="AssignedDuTModuleIdents.RealModuleIdents.Uint32Array">AssignedDuTModuleIdents.RealModuleIdents.Uint32Array == {0}</WriteLine>
			</TestStep>
			<TestStep Name="ModuleCount_LoopEnd">
				<!--End of "ModuleCount_LoopStart"-->
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<SetVariable Target="AssignedDuTModuleIdents.ArrayModule.Counter">AssignedDuTModuleIdents.ArrayModule.Counter + 1</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>ModuleCount_LoopStart</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="LOOP_START">
				<!--__Loop START__-->
				<SizeOf UInt32Var="AssignedDuTModuleIdents.FiltAllMdlIds.uint32Length">AssignedDuTModuleIdents.RealModuleIdents.Uint32Array</SizeOf>
			</TestStep>
			<TestStep>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="5" Level="Verbose" Param0="AssignedDuTModuleIdents.int32LoopCounter">AssignedDuTModuleIdents.int32LoopCounter: {0}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<GreaterOrEqual>
						<Value1>AssignedDuTModuleIdents.int32LoopCounter</Value1>
						<Value2>AssignedDuTModuleIdents.FiltAllMdlIds.uint32Length</Value2>
						<GotoStep>DumpTestResult</GotoStep>
					</GreaterOrEqual>
				</Compare>
			</TestStep>
			<TestStep Name="GetSingleArrayItems">
				<GetArrayItem Index="AssignedDuTModuleIdents.int32LoopCounter" SourceArray="AssignedDuTModuleIdents.RealModuleIdents.Uint32Array" Target="AssignedDuTModuleIdents.Uint32ModuleIdent"></GetArrayItem>
			</TestStep>
			<TestStep Name="CheckItemInArray">
				<!--Check if module already in list-->
				<CallTestFunction Name="CheckItemInArrayUint32">
					<Parameter>AllAssignedDuTModules.Uint32Array</Parameter>
					<Parameter>AssignedDuTModuleIdents.Uint32ModuleIdent</Parameter>
					<OutParameter>AssignedDuTModuleIdents.boolAlreadyChecked</OutParameter>
				</CallTestFunction>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="6" Level="Verbose" Param0="AssignedDuTModuleIdents.boolAlreadyChecked">AssignedDuTModuleIdents.boolAlreadyChecked == {0}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>AssignedDuTModuleIdents.boolAlreadyChecked</Value1>
						<Value2>true</Value2>
						<GotoStep>LOOP_END</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Dump current ModuleIdent and Array content-->
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>debug_msg</Value2>
						<WriteLine Id="7" Level="Verbose" Param0="AssignedDuTModuleIdents.int32LoopCounter" Param1="AssignedDuTModuleIdents.Uint32ModuleIdent" Param2="CurrentConfig.MdlIds">Item [{0}] == 0x{1:x4} of Array '{2}'.</WriteLine>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="AddModuletoTestedArray">
				<AddArrayItem TargetArray="AllAssignedDuTModules.Uint32Array">AssignedDuTModuleIdents.Uint32ModuleIdent</AddArrayItem>
			</TestStep>
			<TestStep Name="LOOP_END">
				<!--__END of "LOOP_START", Increment loop counter__-->
				<SetVariable Target="AssignedDuTModuleIdents.int32LoopCounter">AssignedDuTModuleIdents.int32LoopCounter + 1</SetVariable>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>LOOP_START</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="DumpTestResult">
				<!--Get number of filtered assigned modules-->
				<SizeOf UInt32Var="CurrentConfigMdlIds.uint32Length">AllAssignedDuTModules.Uint32Array</SizeOf>
			</TestStep>
			<TestStep>
				<!--Dump assigned Module Array info-->
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="8" Level="Output" Param0="AssignedDuTModuleIdents.RealModuleIdents.Uint32Array">Array of filtered ModuleIdents, without empty slots: {0}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="9" Level="Output" Param0="AllAssignedDuTModules.Uint32Array">Array of filtered ModuleIdents, without empty slots and doubles: {0}</WriteLine>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Dump Test case AssignedDuTModuleIdents.result-->
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="10" Level="Output" Param0="CurrentConfigMdlIds.uint32Length">Number of DuT assigned modules without empty slots and doubles: {0}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>AssignedDuTModuleIdents.AtLeastOneModuleFound</Value1>
						<Value2>false</Value2>
						<SkipCase Id="11">No modules found.</SkipCase>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>AssignedDuTModuleIdents.result</Value1>
						<Value2>true</Value2>
						<WriteLine Id="12">Test successful.</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>AssignedDuTModuleIdents.result</Value1>
						<Value2>false</Value2>
						<WriteLine Id="13">Test failed.</WriteLine>
					</Equal>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction Name="AssignEEPROMToECAT" FunctionId="101">
			<?MAX_OUTPUT_ID 1?>
			<LocalVariables>
				<Name>assignEeprom</Name>
				<Type>Byte</Type>
			</LocalVariables>
			<TestStep>
				<SetVariable Target="assignEeprom">00</SetVariable>
			</TestStep>
			<TestStep Name="AssignEEPROMToECAT">
				<WriteEscData Source="assignEeprom">
					<Address>#x500</Address>
				</WriteEscData>
				<RaiseErrorOnFailure Id="0">Failed to assign EEPROM to ECAT</RaiseErrorOnFailure>
				<WriteLine Id="1" Level="Verbose">Assign EEPROM to ECAT</WriteLine>
			</TestStep>
		</TestFunction>
		<TestFunction Name="AssignEEPROMToPDI" FunctionId="102">
			<?MAX_OUTPUT_ID 1?>
			<LocalVariables>
				<Name>assignEeprom</Name>
				<Type>Byte</Type>
			</LocalVariables>
			<TestStep>
				<SetVariable Target="assignEeprom">01</SetVariable>
			</TestStep>
			<TestStep Name="AssignEEPROMToPDI">
				<WriteEscData Source="assignEeprom">
					<Address>#x500</Address>
				</WriteEscData>
				<RaiseErrorOnFailure Id="0">Failed to assign EEPROM to PDI</RaiseErrorOnFailure>
				<WriteLine Id="1" Level="Verbose">Assign EEPROM to PDI</WriteLine>
			</TestStep>
		</TestFunction>
		<TestFunction Name="AvailableDuTModuleIdents" FunctionId="20202">
			<?MAX_OUTPUT_ID 15?>
			<!--Initiate global array of all DuT available ModuleIdents-->
			<Description>
				<Action>Initiate global array of all DuT available ModuleIdents</Action>
				<PostCondition>Global array AllAvailableDuTModules.Uint32Array initiated</PostCondition>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<LocalVariables>
				<Name>AvailableDuTModuleIdents.result</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>AvailableDuTModuleIdents.AtLeastOneModuleFound</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>AvailableDuTModuleIdents.int32LoopCounter</Name>
				<Type>Int32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CurrentConfigAllMdlIds.uint32Length</Name>
				<Type>UInt32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CurrentConfigMdlIds.uint32Length</Name>
				<Type>UInt32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>AvailableDuTModuleIdents.FiltAllMdlIds.uint32Length</Name>
				<Type>UInt32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>AvailableDuTModuleIdents.AllModuleIdents.Uint32Array</Name>
				<Type>ArrayOfUInt32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>AvailableDuTModuleIdents.ArrayModule.Counter</Name>
				<Type>Int32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckModuleAlreadyTested.boolAlreadyChecked</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>AvailableDuTModuleIdents.Uint32ModuleIdent</Name>
				<Type>UInt32</Type>
			</LocalVariables>
			<TestStep Name="SkipNoSlots">
				<!--Skip Test if "CurrentConfig.SlotCount" == 0-->
				<Compare>
					<Equal>
						<Value1>CurrentConfig.SlotCount</Value1>
						<Value2>0</Value2>
						<SkipCase Id="0">Test skipped. No slots defined.</SkipCase>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="SkipSoE">
				<!--Skip Test if SoE Device-->
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Mailbox.SoE</Value1>
						<Value2>true</Value2>
						<SkipCase Id="1">Test skipped for SoE Devices.</SkipCase>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="INIT_RESULT">
				<!--"AvailableDuTModuleIdents.result" = true-->
				<SetVariable Target="AvailableDuTModuleIdents.result">true</SetVariable>
			</TestStep>
			<TestStep Name="GetLengthOfAllModArray">
				<!--ALL DuT defined modules list-->
				<SizeOf UInt32Var="CurrentConfigAllMdlIds.uint32Length">CurrentConfig.AllMdlIds</SizeOf>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>debug_msg</Value2>
						<WriteLine Id="2" Level="Verbose" Param0="CurrentConfig.AllMdlIds">Module identifier list of all modules that are available for DuT: {0}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CurrentConfigAllMdlIds.uint32Length</Value1>
						<Value2>0</Value2>
						<SetVariable Target="AvailableDuTModuleIdents.AtLeastOneModuleFound">true</SetVariable>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="GetLengthOfAssignedModArray">
				<!--ALL DuT defined modules list-->
				<SizeOf UInt32Var="CurrentConfigMdlIds.uint32Length">CurrentConfig.MdlIds</SizeOf>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>debug_msg</Value2>
						<WriteLine Id="3" Level="Verbose" Param0="CurrentConfig.MdlIds">Module identifier list of the currently assigned modules: {0}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CurrentConfigMdlIds.uint32Length</Value1>
						<Value2>0</Value2>
						<SetVariable Target="AvailableDuTModuleIdents.AtLeastOneModuleFound">true</SetVariable>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="INIT_LOOP_COUNTER">
				<!--"AvailableDuTModuleIdents.int32LoopCounter" = 0, starts at list index [0] for Array-->
				<SetVariable Target="AvailableDuTModuleIdents.int32LoopCounter">0</SetVariable>
			</TestStep>
			<TestStep Name="InitTestedArray">
				<!--Array of already processed modules, no doubles-->
				<InitArray TargetArray="AvailableDuTModuleIdents.AllModuleIdents.Uint32Array"></InitArray>
			</TestStep>
			<TestStep Name="InitModuleArray">
				<!--Array of found ModuleIdents-->
				<InitArray TargetArray="AllAvailableDuTModules.Uint32Array"></InitArray>
			</TestStep>
			<TestStep Name="HandleEmptySlots">
				<!--Loop through CurrentConfig.MdlId and build a new array without "empty slots"-->
			</TestStep>
			<TestStep>
				<!--Init Module Counter with 0 for Array elements-->
				<SetVariable Target="AvailableDuTModuleIdents.ArrayModule.Counter">0</SetVariable>
			</TestStep>
			<TestStep Name="ModuleCount_LoopStart">
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>debug_msg</Value2>
						<WriteLine Id="4" Level="Verbose" Param0="AvailableDuTModuleIdents.ArrayModule.Counter" Param1="CurrentConfigAllMdlIds.uint32Length">AvailableDuTModuleIdents.ArrayModule.Counter = {0} and CurrentConfigMdlIds.uint32Length = {1}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<GreaterOrEqual>
						<Value1>AvailableDuTModuleIdents.ArrayModule.Counter</Value1>
						<Value2>CurrentConfigAllMdlIds.uint32Length</Value2>
						<GotoStep>LOOP_START</GotoStep>
					</GreaterOrEqual>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Get "CurrentConfig.MdlIds" item and check if 0 (empty slot).-->
				<GetArrayItem Index="AvailableDuTModuleIdents.ArrayModule.Counter" SourceArray="CurrentConfig.AllMdlIds" Target="AvailableDuTModuleIdents.Uint32ModuleIdent"></GetArrayItem>
				<Compare>
					<Equal>
						<Value1>AvailableDuTModuleIdents.Uint32ModuleIdent</Value1>
						<Value2>0</Value2>
						<GotoStep>ModuleCount_LoopEnd</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Copy modules to new array-->
				<AddArrayItem TargetArray="AllAvailableDuTModules.Uint32Array">AvailableDuTModuleIdents.Uint32ModuleIdent</AddArrayItem>
			</TestStep>
			<TestStep Name="ModuleCount_LoopEnd">
				<!--End of "ModuleCount_LoopStart"-->
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<SetVariable Target="AvailableDuTModuleIdents.ArrayModule.Counter">AvailableDuTModuleIdents.ArrayModule.Counter + 1</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>debug_msg</Value2>
						<WriteLine Id="5" Level="Verbose" Param0="AllAvailableDuTModules.Uint32Array">AllAvailableDuTModules.Uint32Array = {0}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>ModuleCount_LoopStart</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="LOOP_START">
				<!--__Loop START__-->
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>debug_msg</Value2>
						<WriteLine Id="6" Level="Verbose" Param0="AvailableDuTModuleIdents.int32LoopCounter">AvailableDuTModuleIdents.int32LoopCounter: {0}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<GreaterOrEqual>
						<Value1>AvailableDuTModuleIdents.int32LoopCounter</Value1>
						<Value2>CurrentConfigAllMdlIds.uint32Length</Value2>
						<GotoStep>DumpTestResult</GotoStep>
					</GreaterOrEqual>
				</Compare>
			</TestStep>
			<TestStep Name="GetSingleArrayItems">
				<GetArrayItem Index="AvailableDuTModuleIdents.int32LoopCounter" SourceArray="CurrentConfig.AllMdlIds" Target="AvailableDuTModuleIdents.Uint32ModuleIdent"></GetArrayItem>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>debug_msg</Value2>
						<WriteLine Id="7" Level="Verbose" Param0="AvailableDuTModuleIdents.Uint32ModuleIdent">AvailableDuTModuleIdents.Uint32ModuleIdent = (in dec) {0} and (in hex) 0x{0:x4}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>AvailableDuTModuleIdents.Uint32ModuleIdent</Value1>
						<Value2>0</Value2>
						<GotoStep>LOOP_END</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CheckItemInArray">
				<!--Check if module already in list-->
				<CallTestFunction Name="CheckItemInArrayUint32">
					<Parameter>AvailableDuTModuleIdents.AllModuleIdents.Uint32Array</Parameter>
					<Parameter>AvailableDuTModuleIdents.Uint32ModuleIdent</Parameter>
					<OutParameter>CheckModuleAlreadyTested.boolAlreadyChecked</OutParameter>
				</CallTestFunction>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>debug_msg</Value2>
						<WriteLine Id="8" Level="Verbose" Param0="CheckModuleAlreadyTested.boolAlreadyChecked">CheckModuleAlreadyTested.boolAlreadyChecked == {0}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckModuleAlreadyTested.boolAlreadyChecked</Value1>
						<Value2>true</Value2>
						<GotoStep>LOOP_END</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Dump current ModuleIdent and Array content-->
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>debug_msg</Value2>
						<WriteLine Id="9" Level="Verbose" Param0="AvailableDuTModuleIdents.int32LoopCounter" Param1="AvailableDuTModuleIdents.Uint32ModuleIdent" Param2="CurrentConfig.AllMdlIds">Item [{0}] == 0x{1:x4} of Array '{2}'.</WriteLine>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="DumpModuleIdentInfo">
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="10" Level="Output" Param0="(AvailableDuTModuleIdents.int32LoopCounter+1)" Param1="AvailableDuTModuleIdents.Uint32ModuleIdent">Module[{0}]: Ident: #x{1:x4}</WriteLine>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="AddModuletoTestedArray">
				<AddArrayItem TargetArray="AvailableDuTModuleIdents.AllModuleIdents.Uint32Array">AvailableDuTModuleIdents.Uint32ModuleIdent</AddArrayItem>
			</TestStep>
			<TestStep Name="LOOP_END">
				<!--__END of "LOOP_START", Increment loop counter__-->
				<SetVariable Target="AvailableDuTModuleIdents.int32LoopCounter">AvailableDuTModuleIdents.int32LoopCounter + 1</SetVariable>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>LOOP_START</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="DumpTestResult">
				<!--Dump assigned Module Array info-->
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="11" Level="Output" Param0="AllAvailableDuTModules.Uint32Array">Array of filtered ModuleIdents, without empty slots: {0}</WriteLine>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Number of all available modules without empty slots-->
				<SizeOf UInt32Var="AvailableDuTModuleIdents.FiltAllMdlIds.uint32Length">AllAvailableDuTModules.Uint32Array</SizeOf>
			</TestStep>
			<TestStep>
				<!--Dump Test case AvailableDuTModuleIdents.result-->
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="12" Level="Output" Param0="AvailableDuTModuleIdents.FiltAllMdlIds.uint32Length">Number of DuT relevant modules without empty slots: {0}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>AvailableDuTModuleIdents.AtLeastOneModuleFound</Value1>
						<Value2>false</Value2>
						<SkipCase Id="13">No modules found.</SkipCase>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>AvailableDuTModuleIdents.result</Value1>
						<Value2>true</Value2>
						<WriteLine Id="14">Test successful.</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>AvailableDuTModuleIdents.result</Value1>
						<Value2>false</Value2>
						<WriteLine Id="15">Test failed. Contact EtherCAT Technology Group (ETG) for support.</WriteLine>
					</Equal>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction Name="CheckArrayBaseDataType" FunctionId="201">
			<?MAX_OUTPUT_ID 28?>
			<!--Function for Device DataType Tests-->
			<Description>
				<Action>Check the definition of a Array base DataType.</Action>
				<PostCondition></PostCondition>
				<References>
					<Reference Specification="ETG.1020"></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>CheckArrayBaseDataType.XmlFile</Name>
				<Type>String</Type>
				<Comment>Path of the xml file (absolute or relative to the ESI file).
If the parameter is null or empty the current device description will be referenced.</Comment>
			</Parameter>
			<Parameter>
				<Name>CheckArrayBaseDataType.XPath</Name>
				<Type>String</Type>
				<Comment>XPath of the current DataType</Comment>
			</Parameter>
			<LocalVariables>
				<Name>CheckArrayBaseDataType.stringXmlValue</Name>
				<Type>String</Type>
				<Comment>Tmp variable to read ESI value</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckArrayBaseDataType.IsMatch</Name>
				<Type>Bool</Type>
				<Comment>Indicates if RegEs matches</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckArrayBaseDataType.DataTypeName</Name>
				<Type>String</Type>
				<Comment>Name of the DataType</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckArrayBaseDataType.xmlBitSize</Name>
				<Type>Int32</Type>
				<Comment>Value of the Element "BitSize"</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckArrayBaseDataType.n</Name>
				<Type>UInt16</Type>
				<Comment>Value of n (from the DataType name)</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckArrayBaseDataType.BaseTypeFromName</Name>
				<Type>String</Type>
				<Comment>Base (read from Name)</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckArrayBaseDataType.xmlBaseType</Name>
				<Type>String</Type>
				<Comment>specified BaseType</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckArrayBaseDataType.BaseTypeSize</Name>
				<Type>Int32</Type>
				<Comment>BitSize of the BAse Type specified in "BaseType"</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckArrayBaseDataType.CalcBitSize</Name>
				<Type>Int32</Type>
				<Comment>Elements (n+1) * BaseTypeSize</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckArrayBaseDataType.TmpString</Name>
				<Type>String</Type>
				<Comment>tmp variable to get "n"</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckArrayBaseDataType.TmpI32</Name>
				<Type>Int32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckArrayBaseDataType.XPathDtBase</Name>
				<Type>String</Type>
				<Comment>XPath of the Base DataType element</Comment>
			</LocalVariables>
			<OutParameter>
				<Name>CheckArrayBaseDataType.Result</Name>
				<Type>Bool</Type>
				<!--If true base data type test was sucessful-->
			</OutParameter>
			<TestStep Name="INIT_RESULT">
				<!--Init Result = true-->
				<SetVariable Target="CheckArrayBaseDataType.Result">true</SetVariable>
			</TestStep>
			<TestStep Name="INIT_BASE_DATA_TYPE_SIZE">
				<!--CheckArrayBaseDataType.BaseTypeSize = -1-->
				<SetVariable Target="CheckArrayBaseDataType.BaseTypeSize">-1</SetVariable>
			</TestStep>
			<TestStep Name="INIT_FILE_PARAMETER">
				<!--if parameter is null set value to emptystring-->
				<Compare>
					<Equal>
						<Value1>CheckArrayBaseDataType.XmlFile</Value1>
						<Value2>null</Value2>
						<SetVariable Target="CheckArrayBaseDataType.XmlFile">EmptyString</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CHECK_IF_XPATH_EXISITS">
				<GetXmlValue ReturnValue="CheckArrayBaseDataType.stringXmlValue" Markup="true" FileName="CheckArrayBaseDataType.XmlFile">
					<XPath Param0="CheckArrayBaseDataType.XPath">{0}</XPath>
				</GetXmlValue>
				<!--Dump an Error if XPath is not defined is defined-->
				<Compare>
					<Equal>
						<Value1>CheckArrayBaseDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<WriteLine Id="0" Level="Error" Param0="CheckArrayBaseDataType.XPath" Param1="CheckArrayBaseDataType.XmlFile">The XPath "{0}" (File:{1}) is not defined.</WriteLine>
					</Equal>
				</Compare>
				<!--Update Error Variable-->
				<Compare>
					<Equal>
						<Value1>CheckArrayBaseDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<SetVariable Target="CheckArrayBaseDataType.Result">false</SetVariable>
					</Equal>
				</Compare>
				<!--return-->
				<Compare>
					<Equal>
						<Value1>CheckArrayBaseDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<Return Id="1"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="GET_DATATYPE_NAME">
				<!--Get DataType name from local dictionary-->
				<GetXmlValue ReturnValue="CheckArrayBaseDataType.stringXmlValue" Markup="false" FileName="CheckArrayBaseDataType.XmlFile">
					<XPath Param0="CheckArrayBaseDataType.XPath">{0}/Name</XPath>
				</GetXmlValue>
				<!--Dump an Error if no name is defined-->
				<Compare>
					<Equal>
						<Value1>CheckArrayBaseDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<WriteLine Id="2" Level="Error" Param0="CheckArrayBaseDataType.XPath" Param1="CheckArrayBaseDataType.XmlFile">A DataType name shall be defined. at File '{1}' XPath '{0}'</WriteLine>
					</Equal>
				</Compare>
				<!--Update Error Variable-->
				<Compare>
					<Equal>
						<Value1>CheckArrayBaseDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<SetVariable Target="CheckArrayBaseDataType.Result">false</SetVariable>
					</Equal>
				</Compare>
				<!--return-->
				<Compare>
					<Equal>
						<Value1>CheckArrayBaseDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<Return Id="3"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CHECK_IF_NAME_IS_VALID">
				<!--Check if Name is valid-->
				<RegexIsMatch ReturnValue="CheckArrayBaseDataType.IsMatch">
					<Pattern>^(ARRAY \[0\.\.[0-9]+\] OF (BYTE|SINT|UINT|INT|DINT|UDINT))$</Pattern>
					<InputString>CheckArrayBaseDataType.stringXmlValue</InputString>
				</RegexIsMatch>
				<!--Dump info if name is invalid-->
				<Compare>
					<Equal>
						<Value1>CheckArrayBaseDataType.IsMatch</Value1>
						<Value2>false</Value2>
						<WriteLine Id="4" Level="Verbose" Param0="CheckArrayBaseDataType.stringXmlValue">Invalid DataType name ({0}) passed to function "CheckArrayBaseDataType". Only  Array base data types are allowed.</WriteLine>
					</Equal>
				</Compare>
				<!--Set Result to false-->
				<Compare>
					<Equal>
						<Value1>CheckArrayBaseDataType.IsMatch</Value1>
						<Value2>false</Value2>
						<SetVariable Target="CheckArrayBaseDataType.Result">false</SetVariable>
					</Equal>
				</Compare>
				<!--Return-->
				<Compare>
					<Equal>
						<Value1>CheckArrayBaseDataType.IsMatch</Value1>
						<Value2>false</Value2>
						<Return Id="5"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Store DataType name in "CheckArrayBaseDataType.DataTypeName"-->
				<SetVariable Target="CheckArrayBaseDataType.DataTypeName">CheckArrayBaseDataType.stringXmlValue</SetVariable>
			</TestStep>
			<TestStep>
				<!--Get n-->
				<RegexReplace OutputString="CheckArrayBaseDataType.TmpString">
					<Pattern>^(ARRAY \[0\.\.)</Pattern>
					<InputString>CheckArrayBaseDataType.DataTypeName</InputString>
					<ReplacementString>EmptyString</ReplacementString>
				</RegexReplace>
			</TestStep>
			<TestStep>
				<!--Get n-->
				<RegexReplace OutputString="CheckArrayBaseDataType.TmpString">
					<Pattern>(\] OF (BYTE|SINT|UINT|INT|DINT|UDINT))$</Pattern>
					<InputString>CheckArrayBaseDataType.TmpString</InputString>
					<ReplacementString>EmptyString</ReplacementString>
				</RegexReplace>
			</TestStep>
			<TestStep>
				<Description Id="6" Param0="CheckArrayBaseDataType.TmpString" Level="Verbose">Convert '{0}' to Uint16 (variable n)</Description>
				<!--Get n-->
				<SetVariable Target="CheckArrayBaseDataType.n">CheckArrayBaseDataType.TmpString</SetVariable>
				<WriteLine Id="7" Level="Verbose" Param0="CheckArrayBaseDataType.n">n = {0}</WriteLine>
			</TestStep>
			<TestStep>
				<!--GetBaseType from Name-->
				<RegexReplace OutputString="CheckArrayBaseDataType.BaseTypeFromName">
					<Pattern>^(ARRAY \[0\.\.[0-9]+\] OF )</Pattern>
					<InputString>CheckArrayBaseDataType.DataTypeName</InputString>
					<ReplacementString>EmptyString</ReplacementString>
				</RegexReplace>
			</TestStep>
			<TestStep Name="GET_BASETYPE_ELEMENT">
				<!--The Element BaseType shall be defined for array base DataTypes.-->
				<GetXmlValue ReturnValue="CheckArrayBaseDataType.xmlBaseType" Markup="false" FileName="CheckArrayBaseDataType.XmlFile">
					<XPath Param0="CheckArrayBaseDataType.XPath">{0}/BaseType</XPath>
				</GetXmlValue>
				<!--Dump Error-->
				<Compare>
					<Equal>
						<Value1>CheckArrayBaseDataType.xmlBaseType</Value1>
						<Value2>null</Value2>
						<WriteLine Id="8" Level="Error" Param0="CheckArrayBaseDataType.DataTypeName" Param1="CheckArrayBaseDataType.XmlFile" Param2="CheckArrayBaseDataType.XPath">{0}.BaseType shall be defined. at File '{1}' XPath '{2}'</WriteLine>
					</Equal>
				</Compare>
				<!--Update Result-->
				<Compare>
					<Equal>
						<Value1>CheckArrayBaseDataType.xmlBaseType</Value1>
						<Value2>null</Value2>
						<SetVariable Target="CheckArrayBaseDataType.Result">false</SetVariable>
					</Equal>
				</Compare>
				<!--Goto ArrayInfo Check (GET_ARRAYINFO_ELEMENT)-->
				<Compare>
					<Equal>
						<Value1>CheckArrayBaseDataType.xmlBaseType</Value1>
						<Value2>null</Value2>
						<GotoStep>GET_ARRAYINFO_ELEMENT</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckArrayBaseDataType.xmlBaseType</Value1>
						<Value2>null</Value2>
						<WriteLine Id="9" Level="Verbose" Param0="CheckArrayBaseDataType.DataTypeName" Param1="CheckArrayBaseDataType.xmlBaseType">{0}.BaseType is {1}.</WriteLine>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Check if BaseType matches .-->
				<Compare>
					<Equal>
						<Value1>CheckArrayBaseDataType.xmlBaseType</Value1>
						<Value2>CheckArrayBaseDataType.BaseTypeFromName</Value2>
						<WriteLine Id="10" Level="Verbose">BaseType matches.</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckArrayBaseDataType.xmlBaseType</Value1>
						<Value2>CheckArrayBaseDataType.BaseTypeFromName</Value2>
						<GotoStep>GET_PARENT_DATATYPES_XPATH</GotoStep>
					</Equal>
				</Compare>
				<!--Dump an error if UINT array is used (no other basetype is allowed)-->
				<Compare>
					<Equal>
						<Value1>CheckArrayBaseDataType.BaseTypeFromName</Value1>
						<Value2>UINT</Value2>
						<WriteLine Id="11" Level="Error" Param0="CheckArrayBaseDataType.xmlBaseType" Param1="CheckArrayBaseDataType.DataTypeName" Param2="CheckArrayBaseDataType.XPath" Param3="CheckArrayBaseDataType.XmlFile">{1}.BaseType ({0}) is invalid. at File '{3}' XPath '{2}'</WriteLine>
					</Equal>
				</Compare>
				<!--Update Result and proceed with "GET_ARRAY_ELEMENT"-->
				<Compare>
					<Equal>
						<Value1>CheckArrayBaseDataType.BaseTypeFromName</Value1>
						<Value2>UINT</Value2>
						<SetVariable Target="CheckArrayBaseDataType.Result">false</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckArrayBaseDataType.BaseTypeFromName</Value1>
						<Value2>UINT</Value2>
						<GotoStep>GET_PARENT_DATATYPES_XPATH</GotoStep>
					</Equal>
				</Compare>
				<!--For Array [0..n] of BYTE the base type can be USINT otherwise dump an error.-->
				<Compare>
					<NotEqual>
						<Value1>CheckArrayBaseDataType.xmlBaseType</Value1>
						<Value2>USINT</Value2>
						<WriteLine Id="12" Level="Error" Param0="CheckArrayBaseDataType.xmlBaseType" Param1="CheckArrayBaseDataType.DataTypeName" Param2="CheckArrayBaseDataType.XPath" Param3="CheckArrayBaseDataType.XmlFile">{1}.BaseType ({0}) is invalid. at File '{3}' XPath '{2}'</WriteLine>
					</NotEqual>
				</Compare>
				<!--Update Result-->
				<Compare>
					<NotEqual>
						<Value1>CheckArrayBaseDataType.xmlBaseType</Value1>
						<Value2>USINT</Value2>
						<SetVariable Target="CheckArrayBaseDataType.Result">false</SetVariable>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="GET_PARENT_DATATYPES_XPATH">
				<!--Get XPath of the parent DataTypes-->
				<RegexReplace OutputString="CheckArrayBaseDataType.XPathDtBase">
					<Pattern>(\[[0-9]+\])$</Pattern>
					<InputString>CheckArrayBaseDataType.XPath</InputString>
					<ReplacementString>EmptyString</ReplacementString>
				</RegexReplace>
			</TestStep>
			<TestStep Name="GetBaseTypeBitSize">
				<!--Get Size of BaseType.-->
				<CallTestFunction Name="DataTypeName.GetBitSize">
					<Parameter>CheckArrayBaseDataType.xmlBaseType</Parameter>
					<Parameter>CheckArrayBaseDataType.XmlFile</Parameter>
					<Parameter>CheckArrayBaseDataType.XPathDtBase</Parameter>
					<OutParameter>CheckArrayBaseDataType.BaseTypeSize</OutParameter>
				</CallTestFunction>
				<!--Dump an error if BitSize of BaseType is -1-->
				<Compare>
					<Lower>
						<Value1>CheckArrayBaseDataType.BaseTypeSize</Value1>
						<Value2>0</Value2>
						<WriteLine Id="13" Level="Error" Param0="CheckArrayBaseDataType.xmlBaseType" Param1="CheckArrayBaseDataType.DataTypeName" Param2="CheckArrayBaseDataType.XPath" Param3="CheckArrayBaseDataType.XmlFile">{1}.BaseType ({0}) is not defined in DataType list or has no BitSize. at File '{3}' XPath '{2}'</WriteLine>
					</Lower>
				</Compare>
				<!--Update Result-->
				<Compare>
					<Lower>
						<Value1>CheckArrayBaseDataType.BaseTypeSize</Value1>
						<Value2>0</Value2>
						<SetVariable Target="CheckArrayBaseDataType.Result">false</SetVariable>
					</Lower>
				</Compare>
			</TestStep>
			<TestStep Name="GET_ARRAYINFO_ELEMENT">
				<!--The Element ArrayInfo shall be defined for Array base DataTypes.-->
				<GetXmlValue ReturnValue="CheckArrayBaseDataType.stringXmlValue" Markup="false" FileName="CheckArrayBaseDataType.XmlFile">
					<XPath Param0="CheckArrayBaseDataType.XPath">{0}/ArrayInfo</XPath>
				</GetXmlValue>
				<!--Dump an Error if ArrInfo is not defined-->
				<Compare>
					<Equal>
						<Value1>CheckArrayBaseDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<WriteLine Id="14" Level="Error" Param0="CheckArrayBaseDataType.DataTypeName" Param1="CheckArrayBaseDataType.XmlFile" Param2="CheckArrayBaseDataType.XPath">{0}.ArrayInfo shall be defined. at File '{1}' XPath '{2}'</WriteLine>
					</Equal>
				</Compare>
				<!--Update Result-->
				<Compare>
					<Equal>
						<Value1>CheckArrayBaseDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<SetVariable Target="CheckArrayBaseDataType.Result">false</SetVariable>
					</Equal>
				</Compare>
				<!--Proceed with "SubItem" test-->
				<Compare>
					<Equal>
						<Value1>CheckArrayBaseDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<GotoStep>GET_SUBITEM_ELEMENT</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--The Attribute ArrayInfo.LBound shall be 0-->
				<GetXmlValue ReturnValue="CheckArrayBaseDataType.TmpI32" Markup="false" FileName="CheckArrayBaseDataType.XmlFile">
					<XPath Param0="CheckArrayBaseDataType.XPath">{0}/ArrayInfo/LBound</XPath>
				</GetXmlValue>
				<!--Dump an Error if the Attribute ArrayInfo.LBound is not defined-->
				<Compare>
					<Equal>
						<Value1>CheckArrayBaseDataType.TmpI32</Value1>
						<Value2>null</Value2>
						<WriteLine Id="15" Level="Error" Param0="CheckArrayBaseDataType.DataTypeName" Param1="CheckArrayBaseDataType.XmlFile" Param2="CheckArrayBaseDataType.XPath">{0}.ArrayInfo@LBound shall be defined. at File '{1}' XPath '{2}'</WriteLine>
					</Equal>
				</Compare>
				<!--Update Result-->
				<Compare>
					<Equal>
						<Value1>CheckArrayBaseDataType.TmpI32</Value1>
						<Value2>null</Value2>
						<SetVariable Target="CheckArrayBaseDataType.Result">false</SetVariable>
					</Equal>
				</Compare>
				<!--Proceed with "SubItem" test-->
				<Compare>
					<Equal>
						<Value1>CheckArrayBaseDataType.TmpI32</Value1>
						<Value2>null</Value2>
						<GotoStep>GET_SUBITEM_ELEMENT</GotoStep>
					</Equal>
				</Compare>
				<!--Dump an Error in the Attribute ArrayInfo.LBound is not 0-->
				<Compare>
					<NotEqual>
						<Value1>CheckArrayBaseDataType.TmpI32</Value1>
						<Value2>0</Value2>
						<WriteLine Id="16" Level="Error" Param0="CheckArrayBaseDataType.DataTypeName" Param1="CheckArrayBaseDataType.XmlFile" Param2="CheckArrayBaseDataType.XPath">{0}.ArrayInfo@LBound shall be 0. at File '{1}' XPath '{2}'</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckArrayBaseDataType.TmpI32</Value1>
						<Value2>0</Value2>
						<WriteLine Id="17" Level="Verbose" Param0="CheckArrayBaseDataType.DataTypeName">{0}.ArrayInfo@LBound is 0.</WriteLine>
					</Equal>
				</Compare>
				<!--Update Result-->
				<Compare>
					<NotEqual>
						<Value1>CheckArrayBaseDataType.TmpI32</Value1>
						<Value2>0</Value2>
						<SetVariable Target="CheckArrayBaseDataType.Result">false</SetVariable>
					</NotEqual>
				</Compare>
				<!--Proceed with "SubItem" test-->
				<Compare>
					<NotEqual>
						<Value1>CheckArrayBaseDataType.TmpI32</Value1>
						<Value2>0</Value2>
						<GotoStep>GET_SUBITEM_ELEMENT</GotoStep>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep>
				<!--The Attribute ArrayInfo.Elements shall be (n+1)-->
				<GetXmlValue ReturnValue="CheckArrayBaseDataType.TmpI32" Markup="false" FileName="CheckArrayBaseDataType.XmlFile">
					<XPath Param0="CheckArrayBaseDataType.XPath">{0}/ArrayInfo/Elements</XPath>
				</GetXmlValue>
				<!--Dump an Error in the Attribute ArrayInfo.Elements is not defined-->
				<Compare>
					<Equal>
						<Value1>CheckArrayBaseDataType.TmpI32</Value1>
						<Value2>null</Value2>
						<WriteLine Id="18" Level="Error" Param0="CheckArrayBaseDataType.DataTypeName" Param1="CheckArrayBaseDataType.XmlFile" Param2="CheckArrayBaseDataType.XPath">{0}.ArrayInfo@Elements shall be defined. at File '{1}' XPath '{2}'</WriteLine>
					</Equal>
				</Compare>
				<!--Update Result-->
				<Compare>
					<Equal>
						<Value1>CheckArrayBaseDataType.TmpI32</Value1>
						<Value2>null</Value2>
						<SetVariable Target="CheckArrayBaseDataType.Result">false</SetVariable>
					</Equal>
				</Compare>
				<!--Proceed with "SubItem" test-->
				<Compare>
					<Equal>
						<Value1>CheckArrayBaseDataType.TmpI32</Value1>
						<Value2>null</Value2>
						<GotoStep>GET_SUBITEM_ELEMENT</GotoStep>
					</Equal>
				</Compare>
				<!--Dump an Error if the Attribute ArrayInfo.Elements is not (n+1)-->
				<Compare>
					<NotEqual>
						<Value1>CheckArrayBaseDataType.TmpI32</Value1>
						<Value2>(CheckArrayBaseDataType.n + 1)</Value2>
						<WriteLine Id="19" Level="Error" Param0="(CheckArrayBaseDataType.n + 1)" Param1="CheckArrayBaseDataType.DataTypeName" Param2="CheckArrayBaseDataType.TmpI32" Param3="CheckArrayBaseDataType.XPath">{1}.ArrayInfo@Elements shall be {0} (read {2}). XPath '{3}'</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckArrayBaseDataType.TmpI32</Value1>
						<Value2>(CheckArrayBaseDataType.n + 1)</Value2>
						<WriteLine Id="20" Level="Verbose" Param0="(CheckArrayBaseDataType.n + 1)" Param1="CheckArrayBaseDataType.DataTypeName">{1}.ArrayInfo@Elements is {0}.</WriteLine>
					</Equal>
				</Compare>
				<!--Update Result-->
				<Compare>
					<NotEqual>
						<Value1>CheckArrayBaseDataType.TmpI32</Value1>
						<Value2>(CheckArrayBaseDataType.n + 1)</Value2>
						<SetVariable Target="CheckArrayBaseDataType.Result">false</SetVariable>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="GET_SUBITEM_ELEMENT">
				<!--The Element SubItem shall not be defined for Array base DataTypes.-->
				<GetXmlValue ReturnValue="CheckArrayBaseDataType.stringXmlValue" Markup="false" FileName="CheckArrayBaseDataType.XmlFile">
					<XPath Param0="CheckArrayBaseDataType.XPath">{0}/SubItem</XPath>
				</GetXmlValue>
				<Compare>
					<NotEqual>
						<Value1>CheckArrayBaseDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<WriteLine Id="21" Level="Error" Param0="CheckArrayBaseDataType.DataTypeName" Param1="CheckArrayBaseDataType.XmlFile" Param2="CheckArrayBaseDataType.XPath">{0}.SubItem shall not be defined. at File '{1}' XPath '{2}'</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckArrayBaseDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<SetVariable Target="CheckArrayBaseDataType.Result">false</SetVariable>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="GET_ENUMINFO_ELEMENT">
				<!--The Element EnumInfo shall not be defined for array base DataTypes.-->
				<GetXmlValue ReturnValue="CheckArrayBaseDataType.stringXmlValue" Markup="false" FileName="CheckArrayBaseDataType.XmlFile">
					<XPath Param0="CheckArrayBaseDataType.XPath">{0}/EnumInfo</XPath>
				</GetXmlValue>
				<Compare>
					<NotEqual>
						<Value1>CheckArrayBaseDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<WriteLine Id="22" Level="Error" Param0="CheckArrayBaseDataType.DataTypeName" Param1="CheckArrayBaseDataType.XmlFile" Param2="CheckArrayBaseDataType.XPath">{0}.EnumInfo shall not be defined. at File '{1}' XPath '{2}'</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckArrayBaseDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<SetVariable Target="CheckArrayBaseDataType.Result">false</SetVariable>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="CHECK_BITSIZE">
				<!--The element BitSize shall be defined.-->
				<GetXmlValue ReturnValue="CheckArrayBaseDataType.xmlBitSize" Markup="false" FileName="CheckArrayBaseDataType.XmlFile">
					<XPath Param0="CheckArrayBaseDataType.XPath">{0}/BitSize</XPath>
				</GetXmlValue>
				<!--Dump Error if BitSize not defined-->
				<Compare>
					<Equal>
						<Value1>CheckArrayBaseDataType.xmlBitSize</Value1>
						<Value2>null</Value2>
						<WriteLine Id="23" Level="Error" Param0="CheckArrayBaseDataType.DataTypeName" Param1="CheckArrayBaseDataType.XmlFile" Param2="CheckArrayBaseDataType.XPath">{0}.BitSize shall be defined. at File '{1}' XPath '{2}'</WriteLine>
					</Equal>
				</Compare>
				<!--Update result (to false)-->
				<Compare>
					<Equal>
						<Value1>CheckArrayBaseDataType.xmlBitSize</Value1>
						<Value2>null</Value2>
						<SetVariable Target="CheckArrayBaseDataType.Result">false</SetVariable>
					</Equal>
				</Compare>
				<!--return-->
				<Compare>
					<Equal>
						<Value1>CheckArrayBaseDataType.xmlBitSize</Value1>
						<Value2>null</Value2>
						<Return Id="24"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--skip test if BaseType BitSize is not defined-->
				<Compare>
					<Lower>
						<Value1>CheckArrayBaseDataType.BaseTypeSize</Value1>
						<Value2>0</Value2>
						<Return Id="25"></Return>
					</Lower>
				</Compare>
			</TestStep>
			<TestStep>
				<!--increment n + 1 to get number of elements-->
				<SetVariable Target="CheckArrayBaseDataType.n">CheckArrayBaseDataType.n + 1</SetVariable>
			</TestStep>
			<TestStep>
				<!--increment number of elements * BaseTypeBitSize-->
				<SetVariable Target="CheckArrayBaseDataType.CalcBitSize">CheckArrayBaseDataType.n * CheckArrayBaseDataType.BaseTypeSize</SetVariable>
			</TestStep>
			<TestStep>
				<!--Skip BitSize comparison if referenced Base type was not found-->
				<Compare>
					<Lower>
						<Value1>CheckArrayBaseDataType.BaseTypeSize</Value1>
						<Value2>0</Value2>
						<Return Id="26"></Return>
					</Lower>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckArrayBaseDataType.xmlBitSize</Value1>
						<Value2>CheckArrayBaseDataType.CalcBitSize</Value2>
						<WriteLine Id="27" Level="Verbose" Param0="CheckArrayBaseDataType.xmlBitSize" Param1="CheckArrayBaseDataType.CalcBitSize" Param2="CheckArrayBaseDataType.DataTypeName">{2}.BitSize ({0}) matches expected BitSize ({1}).</WriteLine>
					</Equal>
				</Compare>
				<!--Dump Error if BitSize not match-->
				<Compare>
					<NotEqual>
						<Value1>CheckArrayBaseDataType.xmlBitSize</Value1>
						<Value2>CheckArrayBaseDataType.CalcBitSize</Value2>
						<WriteLine Id="28" Level="Error" Param0="CheckArrayBaseDataType.xmlBitSize" Param1="CheckArrayBaseDataType.DataTypeName" Param2="CheckArrayBaseDataType.CalcBitSize" Param3="CheckArrayBaseDataType.XPath">{1}.BitSize ({0}) is invalid (expected {2}). XPath '{3}'</WriteLine>
					</NotEqual>
				</Compare>
				<!--Update result (to false)-->
				<Compare>
					<NotEqual>
						<Value1>CheckArrayBaseDataType.xmlBitSize</Value1>
						<Value2>CheckArrayBaseDataType.CalcBitSize</Value2>
						<SetVariable Target="CheckArrayBaseDataType.Result">false</SetVariable>
					</NotEqual>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction Name="CheckDTxxxxARRDataType" FunctionId="202">
			<?MAX_OUTPUT_ID 26?>
			<!--Function for Device DataType Tests-->
			<Description>
				<Action>Check the definition of a Array base DataType.</Action>
				<PostCondition></PostCondition>
				<References>
					<Reference Specification=""></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>CheckDTxxxxARRDataType.XmlFile</Name>
				<Type>String</Type>
				<Comment>Path of the xml file (absolute or relative to the ESI file).
If the parameter is null or empty the current device description will be referenced.</Comment>
			</Parameter>
			<Parameter>
				<Name>CheckDTxxxxARRDataType.XPath</Name>
				<Type>String</Type>
				<Comment>XPath of the current DataType</Comment>
			</Parameter>
			<LocalVariables>
				<Name>CheckDTxxxxARRDataType.stringXmlValue</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckDTxxxxARRDataType.IsMatch</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckDTxxxxARRDataType.DataTypeName</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckDTxxxxARRDataType.xmlBitSize</Name>
				<Type>Int32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckDTxxxxARRDataType.TmpString</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckDTxxxxARRDataType.BaseTypeSize</Name>
				<Type>Int32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckDTxxxxARRDataType.TmpI32</Name>
				<Type>Int32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckDTxxxxARRDataType.Elements</Name>
				<Type>Int32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckDTxxxxARRDataType.XPathDtBase</Name>
				<Type>String</Type>
			</LocalVariables>
			<OutParameter>
				<Name>CheckDTxxxxARRDataType.Result</Name>
				<Type>Bool</Type>
				<!--If true base data type test was sucessful-->
			</OutParameter>
			<TestStep Name="INIT_RESULT">
				<!--Init Result = true-->
				<SetVariable Target="CheckDTxxxxARRDataType.Result">true</SetVariable>
			</TestStep>
			<TestStep Name="INIT_BASETYPE_SIZE">
				<!--CheckDTxxxxARRDataType.BaseTypeSize = -1-->
				<SetVariable Target="CheckDTxxxxARRDataType.BaseTypeSize">-1</SetVariable>
			</TestStep>
			<TestStep Name="INIT_FILE_PARAMETER">
				<!--if parameter is null set value to emptystring-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxARRDataType.XmlFile</Value1>
						<Value2>null</Value2>
						<SetVariable Target="CheckDTxxxxARRDataType.XmlFile">EmptyString</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CHECK_IF_XPATH_EXISITS">
				<GetXmlValue ReturnValue="CheckDTxxxxARRDataType.stringXmlValue" Markup="true" FileName="CheckDTxxxxARRDataType.XmlFile">
					<XPath Param0="CheckDTxxxxARRDataType.XPath">{0}</XPath>
				</GetXmlValue>
				<!--Dump an Error if XPath is not defined is defined-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxARRDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<WriteLine Id="0" Level="Error" Param0="CheckDTxxxxARRDataType.XPath" Param1="CheckDTxxxxARRDataType.XmlFile">The XPath "{0}" (File:{1}) is not defined.</WriteLine>
					</Equal>
				</Compare>
				<!--Update Error Variable-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxARRDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<SetVariable Target="CheckDTxxxxARRDataType.Result">false</SetVariable>
					</Equal>
				</Compare>
				<!--return-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxARRDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<Return Id="1"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="GET_DATATYPE_NAME">
				<!--Get DataType name from local dictionary-->
				<GetXmlValue ReturnValue="CheckDTxxxxARRDataType.stringXmlValue" Markup="false" FileName="CheckDTxxxxARRDataType.XmlFile">
					<XPath Param0="CheckDTxxxxARRDataType.XPath">{0}/Name</XPath>
				</GetXmlValue>
				<!--Dump an Error if no name is defined-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxARRDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<WriteLine Id="2" Level="Error" Param0="CheckDTxxxxARRDataType.XPath" Param1="CheckDTxxxxARRDataType.XmlFile">A DataType name shall be defined. at File '{1}' XPath '{0}'</WriteLine>
					</Equal>
				</Compare>
				<!--Update Error Variable-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxARRDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<SetVariable Target="CheckDTxxxxARRDataType.Result">false</SetVariable>
					</Equal>
				</Compare>
				<!--return-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxARRDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<Return Id="3"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="START_TEST">
				<!--Check if Name is valid-->
				<RegexIsMatch ReturnValue="CheckDTxxxxARRDataType.IsMatch">
					<Pattern>^(DT[0-9A-Fa-fXx]{1,4}ARR)$</Pattern>
					<InputString>CheckDTxxxxARRDataType.stringXmlValue</InputString>
				</RegexIsMatch>
				<!--Dump info if name is invalid-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxARRDataType.IsMatch</Value1>
						<Value2>false</Value2>
						<WriteLine Id="4" Level="Verbose" Param0="CheckDTxxxxARRDataType.stringXmlValue">Invalid DataType name ({0}) passed to function "CheckDTxxxxARRDataType". Only  Array DataTypes are allowed.</WriteLine>
					</Equal>
				</Compare>
				<!--Set Result to false-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxARRDataType.IsMatch</Value1>
						<Value2>false</Value2>
						<SetVariable Target="CheckDTxxxxARRDataType.Result">false</SetVariable>
					</Equal>
				</Compare>
				<!--Return-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxARRDataType.IsMatch</Value1>
						<Value2>false</Value2>
						<Return Id="5"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Store DataType name in "CheckDTxxxxARRDataType.DataTypeName"-->
				<SetVariable Target="CheckDTxxxxARRDataType.DataTypeName">CheckDTxxxxARRDataType.stringXmlValue</SetVariable>
			</TestStep>
			<TestStep Name="GET_BASETYPE_ELEMENT">
				<!--The Element BaseType shall be defined for DTxxxxARR DataTypes.-->
				<GetXmlValue ReturnValue="CheckDTxxxxARRDataType.stringXmlValue" Markup="false" FileName="CheckDTxxxxARRDataType.XmlFile">
					<XPath Param0="CheckDTxxxxARRDataType.XPath">{0}/BaseType</XPath>
				</GetXmlValue>
				<!--Dump Error-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxARRDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<WriteLine Id="6" Level="Error" Param0="CheckDTxxxxARRDataType.DataTypeName" Param1="CheckDTxxxxARRDataType.XmlFile" Param2="CheckDTxxxxARRDataType.XPath">{0}.BaseType shall be defined. at File '{1}' XPath '{2}'</WriteLine>
					</Equal>
				</Compare>
				<!--Update Result-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxARRDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<SetVariable Target="CheckDTxxxxARRDataType.Result">false</SetVariable>
					</Equal>
				</Compare>
				<!--Goto ArrayInfo Check (GET_ARRAYINFO_ELEMENT)-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxARRDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<GotoStep>GET_ARRAYINFO_ELEMENT</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="GET_PARENT_DATATYPES_XPATH">
				<!--Get XPath of the parent DataTypes-->
				<RegexReplace OutputString="CheckDTxxxxARRDataType.XPathDtBase">
					<Pattern>(\[[0-9]+\])$</Pattern>
					<InputString>CheckDTxxxxARRDataType.XPath</InputString>
					<ReplacementString>EmptyString</ReplacementString>
				</RegexReplace>
			</TestStep>
			<TestStep>
				<Description Id="7" Level="Verbose" Param0="CheckDTxxxxARRDataType.DataTypeName" Param1="CheckDTxxxxARRDataType.stringXmlValue">{0}.BaseType is {1}.</Description>
				<!--Check if BaseType is defined-->
				<CallTestFunction Name="DataTypeName.GetBitSize">
					<Parameter>CheckDTxxxxARRDataType.stringXmlValue</Parameter>
					<Parameter>CheckDTxxxxARRDataType.XmlFile</Parameter>
					<Parameter>CheckDTxxxxARRDataType.XPathDtBase</Parameter>
					<OutParameter>CheckDTxxxxARRDataType.BaseTypeSize</OutParameter>
				</CallTestFunction>
				<!--Dump an error if BaseType is not defined-->
				<Compare>
					<Lower>
						<Value1>CheckDTxxxxARRDataType.BaseTypeSize</Value1>
						<Value2>0</Value2>
						<WriteLine Id="8" Level="Error" Param0="CheckDTxxxxARRDataType.DataTypeName" Param1="CheckDTxxxxARRDataType.stringXmlValue" Param2="CheckDTxxxxARRDataType.XmlFile" Param3="CheckDTxxxxARRDataType.XPath">{0}.BaseType ({1}) is not defined in DataType list or has no BitSize. at File '{2}' XPath '{3}'</WriteLine>
					</Lower>
				</Compare>
				<!--Proceed with "GET_ARRAYINFO_ELEMENT"-->
				<Compare>
					<Lower>
						<Value1>CheckDTxxxxARRDataType.BaseTypeSize</Value1>
						<Value2>0</Value2>
						<GotoStep>GET_ARRAYINFO_ELEMENT</GotoStep>
					</Lower>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Check if BaseType is BaseDataType-->
				<RegexIsMatch ReturnValue="CheckDTxxxxARRDataType.IsMatch">
					<Pattern>^(BOOL|BIT|BIT[1-8]|BYTE|BITARR8|BITARR16|WORD|BITARR32|DWORD|SINT|INT|INT24|DINT|INT40|INT48|INT56|LINT|USINT|UINT|UINT24|UDINT|UINT40|UINT48|UINT56|ULINT|REAL|LREAL|(ARRAY \[0\.\.[0-9]+\] OF (BYTE|SINT|UINT|INT|DINT|UDINT))|(STRING\([0-9]+\)))$</Pattern>
					<InputString>CheckDTxxxxARRDataType.stringXmlValue</InputString>
				</RegexIsMatch>
				<!--Dump an error if BaseType is no BaseDataType-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxARRDataType.IsMatch</Value1>
						<Value2>false</Value2>
						<WriteLine Id="9" Level="Error" Param0="CheckDTxxxxARRDataType.DataTypeName" Param1="CheckDTxxxxARRDataType.stringXmlValue" Param2="CheckDTxxxxARRDataType.XmlFile" Param3="CheckDTxxxxARRDataType.XPath">{0}.BaseType ({1}) is no BaseDataType. at File '{2}' XPath '{3}'</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxARRDataType.IsMatch</Value1>
						<Value2>false</Value2>
						<SetVariable Target="CheckDTxxxxARRDataType.Result">false</SetVariable>
					</Equal>
				</Compare>
				<!--Dump an info if BaseType is BaseDataType-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxARRDataType.IsMatch</Value1>
						<Value2>true</Value2>
						<WriteLine Id="10" Level="Verbose" Param0="CheckDTxxxxARRDataType.BaseTypeSize" Param1="CheckDTxxxxARRDataType.stringXmlValue" Param2="CheckDTxxxxARRDataType.DataTypeName">{2}.BaseType ({1}, Size:{0}) is valid BaseDataType.</WriteLine>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="GET_ARRAYINFO_ELEMENT">
				<!--The Element ArrayInfo shall be defined for Array base DataTypes.-->
				<GetXmlValue ReturnValue="CheckDTxxxxARRDataType.stringXmlValue" Markup="false" FileName="CheckDTxxxxARRDataType.XmlFile">
					<XPath Param0="CheckDTxxxxARRDataType.XPath">{0}/ArrayInfo</XPath>
				</GetXmlValue>
				<!--Dump an Error if ArrInfo is not defined-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxARRDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<WriteLine Id="11" Level="Error" Param0="CheckDTxxxxARRDataType.DataTypeName" Param1="CheckDTxxxxARRDataType.XmlFile" Param2="CheckDTxxxxARRDataType.XPath">{0}.ArrayInfo shall be defined. at File '{1}' XPath '{2}'</WriteLine>
					</Equal>
				</Compare>
				<!--Update Result-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxARRDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<SetVariable Target="CheckDTxxxxARRDataType.Result">false</SetVariable>
					</Equal>
				</Compare>
				<!--Proceed with "SubItem" test-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxARRDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<GotoStep>GET_SUBITEM_ELEMENT</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--The Attribute ArrayInfo.LBound shall be 1-->
				<GetXmlValue ReturnValue="CheckDTxxxxARRDataType.TmpI32" Markup="false" FileName="CheckDTxxxxARRDataType.XmlFile">
					<XPath Param0="CheckDTxxxxARRDataType.XPath">{0}/ArrayInfo/LBound</XPath>
				</GetXmlValue>
				<!--Dump an Error if the Attribute ArrayInfo.LBound is not defined-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxARRDataType.TmpI32</Value1>
						<Value2>null</Value2>
						<WriteLine Id="12" Level="Error" Param0="CheckDTxxxxARRDataType.DataTypeName" Param1="CheckDTxxxxARRDataType.XmlFile" Param2="CheckDTxxxxARRDataType.XPath">{0}.ArrayInfo@LBound shall be defined. at File '{1}' XPath '{2}'</WriteLine>
					</Equal>
				</Compare>
				<!--Update Result-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxARRDataType.TmpI32</Value1>
						<Value2>null</Value2>
						<SetVariable Target="CheckDTxxxxARRDataType.Result">false</SetVariable>
					</Equal>
				</Compare>
				<!--Proceed with "ELEMENT_TEST" test-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxARRDataType.TmpI32</Value1>
						<Value2>null</Value2>
						<GotoStep>ELEMENT_TEST</GotoStep>
					</Equal>
				</Compare>
				<!--Dump an Error if the Attribute ArrayInfo.LBound is not 1-->
				<Compare>
					<NotEqual>
						<Value1>CheckDTxxxxARRDataType.TmpI32</Value1>
						<Value2>1</Value2>
						<WriteLine Id="13" Level="Error" Param0="CheckDTxxxxARRDataType.DataTypeName" Param1="CheckDTxxxxARRDataType.XmlFile" Param2="CheckDTxxxxARRDataType.XPath">{0}.ArrayInfo@LBound shall be 1. at File '{1}' XPath '{2}'</WriteLine>
					</NotEqual>
				</Compare>
				<!--Update Result-->
				<Compare>
					<NotEqual>
						<Value1>CheckDTxxxxARRDataType.TmpI32</Value1>
						<Value2>1</Value2>
						<SetVariable Target="CheckDTxxxxARRDataType.Result">false</SetVariable>
					</NotEqual>
				</Compare>
				<!--Proceed with "SubItem" test-->
				<Compare>
					<NotEqual>
						<Value1>CheckDTxxxxARRDataType.TmpI32</Value1>
						<Value2>1</Value2>
						<GotoStep>ELEMENT_TEST</GotoStep>
					</NotEqual>
				</Compare>
				<!--Dump an Info if LBound is valid-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxARRDataType.TmpI32</Value1>
						<Value2>1</Value2>
						<WriteLine Id="14" Level="Verbose">"ArrayInfo@LBound" is 1.</WriteLine>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="ELEMENT_TEST">
				<!--The Attribute ArrayInfo.Elements shall greater 0 and less 256-->
				<GetXmlValue ReturnValue="CheckDTxxxxARRDataType.Elements" Markup="false" FileName="CheckDTxxxxARRDataType.XmlFile">
					<XPath Param0="CheckDTxxxxARRDataType.XPath">{0}/ArrayInfo/Elements</XPath>
				</GetXmlValue>
				<!--Dump an Error in the Attribute ArrayInfo.Elements is not defined-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxARRDataType.Elements</Value1>
						<Value2>null</Value2>
						<WriteLine Id="15" Level="Error" Param0="CheckDTxxxxARRDataType.DataTypeName" Param1="CheckDTxxxxARRDataType.XmlFile" Param2="CheckDTxxxxARRDataType.XPath">{0}.ArrayInfo@Elements shall be defined. at File '{1}' XPath '{2}'</WriteLine>
					</Equal>
				</Compare>
				<!--Update Result-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxARRDataType.Elements</Value1>
						<Value2>null</Value2>
						<SetVariable Target="CheckDTxxxxARRDataType.Result">false</SetVariable>
					</Equal>
				</Compare>
				<!--Proceed with "SubItem" test-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxARRDataType.Elements</Value1>
						<Value2>null</Value2>
						<GotoStep>GET_SUBITEM_ELEMENT</GotoStep>
					</Equal>
				</Compare>
				<!--Dump value of Elements-->
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="16" Level="Verbose" Param0="CheckDTxxxxARRDataType.Elements" Param1="CheckDTxxxxARRDataType.DataTypeName">{1}.ArrayInfo@Elements is {0}.</WriteLine>
					</Equal>
				</Compare>
				<!--Dump an Error if the Attribute ArrayInfo.Elements is less 1-->
				<Compare>
					<Lower>
						<Value1>CheckDTxxxxARRDataType.Elements</Value1>
						<Value2>0</Value2>
						<WriteLine Id="17" Level="Error" Param0="CheckDTxxxxARRDataType.DataTypeName" Param1="CheckDTxxxxARRDataType.XmlFile" Param2="CheckDTxxxxARRDataType.XPath">{0}.ArrayInfo@Elements shall greater/equal 0. at File '{2}' XPath '{3}'</WriteLine>
					</Lower>
				</Compare>
				<!--Update Result-->
				<Compare>
					<Lower>
						<Value1>CheckDTxxxxARRDataType.Elements</Value1>
						<Value2>0</Value2>
						<SetVariable Target="CheckDTxxxxARRDataType.Result">false</SetVariable>
					</Lower>
				</Compare>
				<!--Dump an Error if the Attribute ArrayInfo.Elements is greater 256-->
				<Compare>
					<Greater>
						<Value1>CheckDTxxxxARRDataType.Elements</Value1>
						<Value2>255</Value2>
						<WriteLine Id="18" Level="Error" Param0="CheckDTxxxxARRDataType.DataTypeName" Param1="CheckDTxxxxARRDataType.XmlFile" Param2="CheckDTxxxxARRDataType.XPath">{0}.ArrayInfo@Elements shall less 256. at File '{2}' XPath '{3}'</WriteLine>
					</Greater>
				</Compare>
				<!--Update Result-->
				<Compare>
					<Greater>
						<Value1>CheckDTxxxxARRDataType.Elements</Value1>
						<Value2>255</Value2>
						<SetVariable Target="CheckDTxxxxARRDataType.Result">false</SetVariable>
					</Greater>
				</Compare>
			</TestStep>
			<TestStep Name="GET_SUBITEM_ELEMENT">
				<!--The Element SubItem shall not be defined for Array DataTypes.-->
				<GetXmlValue ReturnValue="CheckDTxxxxARRDataType.stringXmlValue" Markup="false" FileName="CheckDTxxxxARRDataType.XmlFile">
					<XPath Param0="CheckDTxxxxARRDataType.XPath">{0}/SubItem</XPath>
				</GetXmlValue>
				<Compare>
					<NotEqual>
						<Value1>CheckDTxxxxARRDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<WriteLine Id="19" Level="Error" Param0="CheckDTxxxxARRDataType.DataTypeName" Param1="CheckDTxxxxARRDataType.XmlFile" Param2="CheckDTxxxxARRDataType.XPath">{0}.SubItem shall not be defined. at File '{1}' XPath '{2}'</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckDTxxxxARRDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<SetVariable Target="CheckDTxxxxARRDataType.Result">false</SetVariable>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="GET_ENUMINFO_ELEMENT">
				<!--The Element EnumInfo shall not be defined for array DataTypes.-->
				<GetXmlValue ReturnValue="CheckDTxxxxARRDataType.stringXmlValue" Markup="false" FileName="CheckDTxxxxARRDataType.XmlFile">
					<XPath Param0="CheckDTxxxxARRDataType.XPath">{0}/EnumInfo</XPath>
				</GetXmlValue>
				<Compare>
					<NotEqual>
						<Value1>CheckDTxxxxARRDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<WriteLine Id="20" Level="Error" Param0="CheckDTxxxxARRDataType.DataTypeName" Param1="CheckDTxxxxARRDataType.XmlFile" Param2="CheckDTxxxxARRDataType.XPath">{0}.EnumInfo shall not be defined. at File '{1}' XPath '{2}'</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckDTxxxxARRDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<SetVariable Target="CheckDTxxxxARRDataType.Result">false</SetVariable>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="CHECK_BITSIZE">
				<!--The element BitSize shall be defined.-->
				<GetXmlValue ReturnValue="CheckDTxxxxARRDataType.xmlBitSize" Markup="false" FileName="CheckDTxxxxARRDataType.XmlFile">
					<XPath Param0="CheckDTxxxxARRDataType.XPath">{0}/BitSize</XPath>
				</GetXmlValue>
				<!--Dump Error if BitSize not defined-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxARRDataType.xmlBitSize</Value1>
						<Value2>null</Value2>
						<WriteLine Id="21" Level="Error" Param0="CheckDTxxxxARRDataType.DataTypeName" Param1="CheckDTxxxxARRDataType.XmlFile" Param2="CheckDTxxxxARRDataType.XPath">{0}.BitSize shall be defined. at File '{1}' XPath '{2}'</WriteLine>
					</Equal>
				</Compare>
				<!--Update result (to false)-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxARRDataType.xmlBitSize</Value1>
						<Value2>null</Value2>
						<SetVariable Target="CheckDTxxxxARRDataType.Result">false</SetVariable>
					</Equal>
				</Compare>
				<!--return-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxARRDataType.xmlBitSize</Value1>
						<Value2>null</Value2>
						<Return Id="22"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Skip following Tests if BaseTyp BitSize is not defined-->
				<Compare>
					<Lower>
						<Value1>CheckDTxxxxARRDataType.BaseTypeSize</Value1>
						<Value2>0</Value2>
						<Return Id="23"></Return>
					</Lower>
				</Compare>
				<!--Skip following test if ArrayInfo@Elements are less than 0-->
				<Compare>
					<Lower>
						<Value1>CheckDTxxxxARRDataType.Elements</Value1>
						<Value2>0</Value2>
						<Return Id="24"></Return>
					</Lower>
				</Compare>
				<!--Skip following test if ArrayInfo@Elements are greater than 256-->
				<Compare>
					<Greater>
						<Value1>CheckDTxxxxARRDataType.Elements</Value1>
						<Value2>256</Value2>
						<Return Id="25"></Return>
					</Greater>
				</Compare>
			</TestStep>
			<TestStep>
				<!--The defined BitSize shall match the BaseTypeSize * Elements-->
				<Compare>
					<NotEqual>
						<Value1>CheckDTxxxxARRDataType.xmlBitSize</Value1>
						<Value2>(CheckDTxxxxARRDataType.BaseTypeSize * CheckDTxxxxARRDataType.Elements)</Value2>
						<WriteLine Id="26" Level="Error" Param0="CheckDTxxxxARRDataType.xmlBitSize" Param1="CheckDTxxxxARRDataType.DataTypeName" Param2="(CheckDTxxxxARRDataType.BaseTypeSize * CheckDTxxxxARRDataType.Elements)" Param3="CheckDTxxxxARRDataType.XPath">{1}.BitSize ({0}) is invalid (expected {2}). XPath '{3}'</WriteLine>
					</NotEqual>
				</Compare>
				<!--Update result (to false)-->
				<Compare>
					<NotEqual>
						<Value1>CheckDTxxxxARRDataType.xmlBitSize</Value1>
						<Value2>(CheckDTxxxxARRDataType.BaseTypeSize * CheckDTxxxxARRDataType.Elements)</Value2>
						<SetVariable Target="CheckDTxxxxARRDataType.Result">false</SetVariable>
					</NotEqual>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction Name="CheckDTxxxxDataType" FunctionId="203">
			<?MAX_OUTPUT_ID 14?>
			<!--Function for Device DataType Tests-->
			<Description>
				<Action>Check the definition of a DTxxxx DataType definition</Action>
				<PostCondition></PostCondition>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>CheckDTxxxxDataType.XmlFile</Name>
				<Type>String</Type>
				<Comment>Path of the xml file (absolute or relative to the ESI file).
If the parameter is null or empty the current device description will be referenced.</Comment>
			</Parameter>
			<Parameter>
				<Name>CheckDTxxxxDataType.XPath</Name>
				<Type>String</Type>
				<Comment>XPath of the current DataType</Comment>
			</Parameter>
			<LocalVariables>
				<Name>CheckDTxxxxDataType.stringXmlValue</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckDTxxxxDataType.IsMatch</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckDTxxxxDataType.DataTypeName</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckDTxxxxDataType.xmlBitSize</Name>
				<Type>Int32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckDTxxxxDataType.SubItemBitSize</Name>
				<Type>Int32</Type>
			</LocalVariables>
			<OutParameter>
				<Name>CheckDTxxxxDataType.Result</Name>
				<Type>Bool</Type>
				<!--If true base data type test was sucessful-->
			</OutParameter>
			<TestStep Name="INIT_RESULT">
				<!--Init Result = true-->
				<SetVariable Target="CheckDTxxxxDataType.Result">true</SetVariable>
			</TestStep>
			<TestStep Name="INIT_FILE_PARAMETER">
				<!--if parameter is null set value to emptystring-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxDataType.XmlFile</Value1>
						<Value2>null</Value2>
						<SetVariable Target="CheckDTxxxxDataType.XmlFile">EmptyString</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CHECK_IF_XPATH_EXISITS">
				<GetXmlValue ReturnValue="CheckDTxxxxDataType.stringXmlValue" Markup="true" FileName="CheckDTxxxxDataType.XmlFile">
					<XPath Param0="CheckDTxxxxDataType.XPath">{0}</XPath>
				</GetXmlValue>
				<!--Dump an Error if XPath is not defined is defined-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<WriteLine Id="0" Level="Error" Param0="CheckDTxxxxDataType.XPath" Param1="CheckDTxxxxDataType.XmlFile">The XPath "{0}" (File:{1}) is not defined.</WriteLine>
					</Equal>
				</Compare>
				<!--Update Error Variable-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<SetVariable Target="CheckDTxxxxDataType.Result">false</SetVariable>
					</Equal>
				</Compare>
				<!--return-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<Return Id="1"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="GET_DATATYPE_NAME">
				<!--Get DataType name from local dictionary-->
				<GetXmlValue ReturnValue="CheckDTxxxxDataType.stringXmlValue" Markup="false" FileName="CheckDTxxxxDataType.XmlFile">
					<XPath Param0="CheckDTxxxxDataType.XPath">{0}/Name</XPath>
				</GetXmlValue>
				<!--Dump an Error if no name is defined-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<WriteLine Id="2" Level="Error" Param0="CheckDTxxxxDataType.XPath" Param1="CheckDTxxxxDataType.XmlFile">A DataType name shall be defined. at File '{1}' XPath '{0}'</WriteLine>
					</Equal>
				</Compare>
				<!--Update Error Variable-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<SetVariable Target="CheckDTxxxxDataType.Result">false</SetVariable>
					</Equal>
				</Compare>
				<!--return-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<Return Id="3"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="START_TEST">
				<!--Check if Name is valid-->
				<RegexIsMatch ReturnValue="CheckDTxxxxDataType.IsMatch">
					<Pattern>^(DT[0-9A-Fa-fXx]{1,4})$</Pattern>
					<InputString>CheckDTxxxxDataType.stringXmlValue</InputString>
				</RegexIsMatch>
				<!--Dump info if name is invalid-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxDataType.IsMatch</Value1>
						<Value2>false</Value2>
						<WriteLine Id="4" Level="Verbose" Param0="CheckDTxxxxDataType.stringXmlValue">Invalid DataType name ({0}) passed to function "CheckDTxxxxDataType". Only DTxxxx DataType are allowed.</WriteLine>
					</Equal>
				</Compare>
				<!--Set Result to false-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxDataType.IsMatch</Value1>
						<Value2>false</Value2>
						<SetVariable Target="CheckDTxxxxDataType.Result">false</SetVariable>
					</Equal>
				</Compare>
				<!--Return-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxDataType.IsMatch</Value1>
						<Value2>false</Value2>
						<Return Id="5"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Store DataType name in "CheckDTxxxxDataType.DataTypeName"-->
				<SetVariable Target="CheckDTxxxxDataType.DataTypeName">CheckDTxxxxDataType.stringXmlValue</SetVariable>
			</TestStep>
			<TestStep Name="GET_BASETYPE_ELEMENT">
				<!--The Element BaseType shall not be defined for DTxxxx DataTypes.-->
				<GetXmlValue ReturnValue="CheckDTxxxxDataType.stringXmlValue" Markup="false" FileName="CheckDTxxxxDataType.XmlFile">
					<XPath Param0="CheckDTxxxxDataType.XPath">{0}/BaseType</XPath>
				</GetXmlValue>
				<Compare>
					<NotEqual>
						<Value1>CheckDTxxxxDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<WriteLine Id="6" Level="Error" Param0="CheckDTxxxxDataType.DataTypeName" Param1="CheckDTxxxxDataType.XmlFile" Param2="CheckDTxxxxDataType.XPath">{0}.BaseType shall not be defined. at File '{1}' XPath '{2}'</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckDTxxxxDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<SetVariable Target="CheckDTxxxxDataType.Result">false</SetVariable>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="GET_ARRAYINFO_ELEMENT">
				<!--The Element ArrayInfo shall not be defined for DTxxxx DataTypes.-->
				<GetXmlValue ReturnValue="CheckDTxxxxDataType.stringXmlValue" Markup="false" FileName="CheckDTxxxxDataType.XmlFile">
					<XPath Param0="CheckDTxxxxDataType.XPath">{0}/ArrayInfo</XPath>
				</GetXmlValue>
				<Compare>
					<NotEqual>
						<Value1>CheckDTxxxxDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<WriteLine Id="7" Level="Error" Param0="CheckDTxxxxDataType.DataTypeName" Param1="CheckDTxxxxDataType.XmlFile" Param2="CheckDTxxxxDataType.XPath">{0}.ArrayInfo shall not be defined. at File '{1}' XPath '{2}'</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckDTxxxxDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<SetVariable Target="CheckDTxxxxDataType.Result">false</SetVariable>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="GET_SUBITEM_ELEMENT">
				<!--The Element SubItem shall be defined for DTxxxx DataTypes.-->
				<GetXmlValue ReturnValue="CheckDTxxxxDataType.stringXmlValue" Markup="false" FileName="CheckDTxxxxDataType.XmlFile">
					<XPath Param0="CheckDTxxxxDataType.XPath">{0}/SubItem</XPath>
				</GetXmlValue>
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<WriteLine Id="8" Level="Error" Param0="CheckDTxxxxDataType.DataTypeName" Param1="CheckDTxxxxDataType.XmlFile" Param2="CheckDTxxxxDataType.XPath">{0}.SubItem shall be defined. at File '{1}' XPath '{2}'</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<SetVariable Target="CheckDTxxxxDataType.Result">false</SetVariable>
					</Equal>
				</Compare>
				<!--If no SubItem defined skip SubItem Test-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<GotoStep>GET_ENUMINFO_ELEMENT</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Execute SubItemTest-->
				<CallTestFunction Name="CheckDTxxxxSubItem">
					<Parameter>CheckDTxxxxDataType.XmlFile</Parameter>
					<Parameter>CheckDTxxxxDataType.XPath</Parameter>
					<OutParameter>CheckDTxxxxDataType.SubItemBitSize</OutParameter>
				</CallTestFunction>
				<Compare>
					<Lower>
						<Value1>CheckDTxxxxDataType.SubItemBitSize</Value1>
						<Value2>0</Value2>
						<SetVariable Target="CheckDTxxxxDataType.Result">false</SetVariable>
					</Lower>
				</Compare>
			</TestStep>
			<TestStep Name="GET_ENUMINFO_ELEMENT">
				<!--The Element EnumInfo shall not be defined for DTxxxx DataTypes.-->
				<GetXmlValue ReturnValue="CheckDTxxxxDataType.stringXmlValue" Markup="false" FileName="CheckDTxxxxDataType.XmlFile">
					<XPath Param0="CheckDTxxxxDataType.XPath">{0}/EnumInfo</XPath>
				</GetXmlValue>
				<Compare>
					<NotEqual>
						<Value1>CheckDTxxxxDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<WriteLine Id="9" Level="Error" Param0="CheckDTxxxxDataType.DataTypeName" Param1="CheckDTxxxxDataType.XmlFile" Param2="CheckDTxxxxDataType.XPath">{0}.EnumInfo shall not be defined. at File '{1}' XPath '{2}'</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckDTxxxxDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<SetVariable Target="CheckDTxxxxDataType.Result">false</SetVariable>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="CHECK_BITSIZE">
				<!--The element BitSize shall be defined.-->
				<GetXmlValue ReturnValue="CheckDTxxxxDataType.xmlBitSize" Markup="false" FileName="CheckDTxxxxDataType.XmlFile">
					<XPath Param0="CheckDTxxxxDataType.XPath">{0}/BitSize</XPath>
				</GetXmlValue>
				<!--Dump Error if BitSize not defined-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxDataType.xmlBitSize</Value1>
						<Value2>null</Value2>
						<WriteLine Id="10" Level="Error" Param0="CheckDTxxxxDataType.DataTypeName" Param1="CheckDTxxxxDataType.XmlFile" Param2="CheckDTxxxxDataType.XPath">{0}.BitSize shall be defined. at File '{1}' XPath '{2}'</WriteLine>
					</Equal>
				</Compare>
				<!--Update result (to false)-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxDataType.xmlBitSize</Value1>
						<Value2>null</Value2>
						<SetVariable Target="CheckDTxxxxDataType.Result">false</SetVariable>
					</Equal>
				</Compare>
				<!--return-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxDataType.xmlBitSize</Value1>
						<Value2>null</Value2>
						<Return Id="11"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Skip compare BitSize if SubItem tests failed(<0) (Error was dumped before)-->
				<Compare>
					<Lower>
						<Value1>CheckDTxxxxDataType.SubItemBitSize</Value1>
						<Value2>0</Value2>
						<Return Id="12"></Return>
					</Lower>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Dump an Info if the BitSize is greater than the SubItem Size-->
				<Compare>
					<Greater>
						<Value1>CheckDTxxxxDataType.xmlBitSize</Value1>
						<Value2>CheckDTxxxxDataType.SubItemBitSize</Value2>
						<WriteLine Id="13" Level="Verbose" Param0="CheckDTxxxxDataType.xmlBitSize" Param1="CheckDTxxxxDataType.DataTypeName" Param2="CheckDTxxxxDataType.SubItemBitSize">{1}.BitSize ({0}) is greter than the complete SubItem BitSize ({2}).</WriteLine>
					</Greater>
				</Compare>
				<!--Dump Error if the SubItem BitSize is greater than the defined BitSize-->
				<Compare>
					<Lower>
						<Value1>CheckDTxxxxDataType.xmlBitSize</Value1>
						<Value2>CheckDTxxxxDataType.SubItemBitSize</Value2>
						<WriteLine Id="14" Level="Error" Param0="CheckDTxxxxDataType.xmlBitSize" Param1="CheckDTxxxxDataType.DataTypeName" Param2="CheckDTxxxxDataType.SubItemBitSize" Param3="CheckDTxxxxDataType.XPath">{1}.BitSize ({0}) shall not be less than the complete SubItem BitSize ({2}). XPath '{3}'</WriteLine>
					</Lower>
				</Compare>
				<!--Update result (to false)-->
				<Compare>
					<Lower>
						<Value1>CheckDTxxxxDataType.xmlBitSize</Value1>
						<Value2>CheckDTxxxxDataType.SubItemBitSize</Value2>
						<SetVariable Target="CheckDTxxxxDataType.Result">false</SetVariable>
					</Lower>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction Name="CheckDTxxxxENnnDataType" FunctionId="204">
			<?MAX_OUTPUT_ID 25?>
			<!--Function for Device DataType Tests-->
			<Description>
				<Action>Check the definition of a Array base DataType.</Action>
				<PostCondition></PostCondition>
				<References>
					<Reference Specification=""></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>CheckDTxxxxENnnDataType.XmlFile</Name>
				<Type>String</Type>
				<Comment>Path of the xml file (absolute or relative to the ESI file).
If the parameter is null or empty the current device description will be referenced.</Comment>
			</Parameter>
			<Parameter>
				<Name>CheckDTxxxxENnnDataType.XPath</Name>
				<Type>String</Type>
				<Comment>XPath of the current DataType</Comment>
			</Parameter>
			<LocalVariables>
				<Name>CheckDTxxxxENnnDataType.stringXmlValue</Name>
				<Type>String</Type>
				<Comment>Tmp variable to read ESI value</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckDTxxxxENnnDataType.IsMatch</Name>
				<Type>Bool</Type>
				<Comment>indicates in RegEx match</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckDTxxxxENnnDataType.DataTypeName</Name>
				<Type>String</Type>
				<Comment>name of the DataType</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckDTxxxxENnnDataType.xmlBitSize</Name>
				<Type>Int32</Type>
				<Comment>Value of the element "BitSize"</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckDTxxxxENnnDataType.TmpString</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckDTxxxxENnnDataType.BaseTypeSize</Name>
				<Type>Int32</Type>
				<Comment>Get Size of BaseType</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckDTxxxxENnnDataType.TmpI32</Name>
				<Type>Int32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckDTxxxxENnnDataType.MaxEnumValue</Name>
				<Type>UInt32</Type>
				<Comment>Maximum valule of an enum (2^n)</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckDTxxxxENnnDataType.u32MaxValue</Name>
				<Type>UInt32</Type>
				<Comment>Maximum value of Uint32</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckDTxxxxENnnDataType.n</Name>
				<Type>Int32</Type>
				<Comment>n (from the name)</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckDTxxxxENnnDataType.LoopCnt</Name>
				<Type>Int32</Type>
				<Comment>Counter to iterate over all EnumInfos</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckDTxxxxENnnDataType.XPathDtBase</Name>
				<Type>String</Type>
				<Comment>base XPath of DataType</Comment>
			</LocalVariables>
			<OutParameter>
				<Name>CheckDTxxxxENnnDataType.Result</Name>
				<Type>Bool</Type>
				<!--If true base data type test was sucessful-->
			</OutParameter>
			<TestStep Name="INIT_RESULT">
				<!--Init Result = true-->
				<SetVariable Target="CheckDTxxxxENnnDataType.Result">true</SetVariable>
			</TestStep>
			<TestStep Name="INIT_DATATYPE_SIZE">
				<!--CheckDTxxxxENnnDataType.BaseTypeSize = -1-->
				<SetVariable Target="CheckDTxxxxENnnDataType.BaseTypeSize">-1</SetVariable>
			</TestStep>
			<TestStep Name="INIT_FILE_PARAMETER">
				<!--if parameter is null set value to emptystring-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxENnnDataType.XmlFile</Value1>
						<Value2>null</Value2>
						<SetVariable Target="CheckDTxxxxENnnDataType.XmlFile">EmptyString</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CHECK_IF_XPATH_EXISITS">
				<GetXmlValue ReturnValue="CheckDTxxxxENnnDataType.stringXmlValue" Markup="true" FileName="CheckDTxxxxENnnDataType.XmlFile">
					<XPath Param0="CheckDTxxxxENnnDataType.XPath">{0}</XPath>
				</GetXmlValue>
				<!--Dump an Error if XPath is not defined is defined-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxENnnDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<WriteLine Id="0" Level="Error" Param0="CheckDTxxxxENnnDataType.XPath" Param1="CheckDTxxxxENnnDataType.XmlFile">The XPath "{0}" (File:{1}) is not defined.</WriteLine>
					</Equal>
				</Compare>
				<!--Update Error Variable-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxENnnDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<SetVariable Target="CheckDTxxxxENnnDataType.Result">false</SetVariable>
					</Equal>
				</Compare>
				<!--return-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxENnnDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<Return Id="1"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="GET_DATATYPE_NAME">
				<!--Get DataType name from local dictionary-->
				<GetXmlValue ReturnValue="CheckDTxxxxENnnDataType.stringXmlValue" Markup="false" FileName="CheckDTxxxxENnnDataType.XmlFile">
					<XPath Param0="CheckDTxxxxENnnDataType.XPath">{0}/Name</XPath>
				</GetXmlValue>
				<!--Dump an Error if no name is defined-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxENnnDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<WriteLine Id="2" Level="Error" Param0="CheckDTxxxxENnnDataType.XPath" Param1="CheckDTxxxxENnnDataType.XmlFile">A DataType name shall be defined. at File '{1}' XPath '{0}'</WriteLine>
					</Equal>
				</Compare>
				<!--Update Error Variable-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxENnnDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<SetVariable Target="CheckDTxxxxENnnDataType.Result">false</SetVariable>
					</Equal>
				</Compare>
				<!--return-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxENnnDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<Return Id="3"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="START_TEST">
				<!--Check if Name is valid-->
				<RegexIsMatch ReturnValue="CheckDTxxxxENnnDataType.IsMatch">
					<Pattern>^(DT[0-9A-Fa-fXx]{4}EN([0-9]{2}))$</Pattern>
					<InputString>CheckDTxxxxENnnDataType.stringXmlValue</InputString>
				</RegexIsMatch>
				<!--Dump info if name is invalid-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxENnnDataType.IsMatch</Value1>
						<Value2>false</Value2>
						<WriteLine Id="4" Level="Verbose" Param0="CheckDTxxxxENnnDataType.stringXmlValue">Invalid DataType name ({0}) passed to function "CheckDTxxxxENnnDataType". Only Enum DataTypes are allowed.</WriteLine>
					</Equal>
				</Compare>
				<!--Set Result to false-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxENnnDataType.IsMatch</Value1>
						<Value2>false</Value2>
						<SetVariable Target="CheckDTxxxxENnnDataType.Result">false</SetVariable>
					</Equal>
				</Compare>
				<!--Return-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxENnnDataType.IsMatch</Value1>
						<Value2>false</Value2>
						<Return Id="5"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Store DataType name in "CheckDTxxxxENnnDataType.DataTypeName"-->
				<SetVariable Target="CheckDTxxxxENnnDataType.DataTypeName">CheckDTxxxxENnnDataType.stringXmlValue</SetVariable>
			</TestStep>
			<TestStep>
				<!--Get n from Name-->
				<RegexReplace OutputString="CheckDTxxxxENnnDataType.stringXmlValue">
					<Pattern>^(DT[0-9A-Fa-fXx]{1,4}EN)</Pattern>
					<InputString>CheckDTxxxxENnnDataType.DataTypeName</InputString>
					<ReplacementString>EmptyString</ReplacementString>
				</RegexReplace>
			</TestStep>
			<TestStep>
				<!--Get n from Name-->
				<SetVariable Target="CheckDTxxxxENnnDataType.n">CheckDTxxxxENnnDataType.stringXmlValue</SetVariable>
				<WriteLine Id="6" Level="Verbose" Param0="CheckDTxxxxENnnDataType.n">{0} Bits used for Enum.</WriteLine>
			</TestStep>
			<TestStep Name="GET_BASETYPE_ELEMENT">
				<!--The Element BaseType shall be defined for DTxxxxENnn DataTypes.-->
				<GetXmlValue ReturnValue="CheckDTxxxxENnnDataType.stringXmlValue" Markup="false" FileName="CheckDTxxxxENnnDataType.XmlFile">
					<XPath Param0="CheckDTxxxxENnnDataType.XPath">{0}/BaseType</XPath>
				</GetXmlValue>
				<!--Dump Error-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxENnnDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<WriteLine Id="7" Level="Error" Param0="CheckDTxxxxENnnDataType.DataTypeName" Param1="CheckDTxxxxENnnDataType.XmlFile" Param2="CheckDTxxxxENnnDataType.XPath">{0}.BaseType shall be defined. at File '{1}' XPath '{2}'</WriteLine>
					</Equal>
				</Compare>
				<!--Update Result-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxENnnDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<SetVariable Target="CheckDTxxxxENnnDataType.Result">false</SetVariable>
					</Equal>
				</Compare>
				<!--Goto ArrayInfo Check (GET_ARRAYINFO_ELEMENT)-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxENnnDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<GotoStep>GET_ARRAYINFO_ELEMENT</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Base Type shall be USINT OR UINT OR UDINT-->
				<RegexIsMatch ReturnValue="CheckDTxxxxENnnDataType.IsMatch">
					<Pattern>^(BOOL|BIT|BIT[1-8]|BYTE|BITARR8|BITARR16|WORD|BITARR32|DWORD|SINT|INT|INT24|DINT|USINT|UINT|UINT24|UDINT|REAL)$</Pattern>
					<InputString>CheckDTxxxxENnnDataType.stringXmlValue</InputString>
				</RegexIsMatch>
				<!--Dump an Error if Invalid DataType is used-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxENnnDataType.IsMatch</Value1>
						<Value2>false</Value2>
						<WriteLine Id="8" Level="Error" Param0="CheckDTxxxxENnnDataType.stringXmlValue" Param1="CheckDTxxxxENnnDataType.DataTypeName" Param2="CheckDTxxxxENnnDataType.XmlFile" Param3="CheckDTxxxxENnnDataType.XPath">{1}.BaseType ({0}) is invalid (expected USINT or UINT or UDINT). at File '{2}' XPath '{3}'</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxENnnDataType.IsMatch</Value1>
						<Value2>false</Value2>
						<SetVariable Target="CheckDTxxxxENnnDataType.Result">false</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxENnnDataType.IsMatch</Value1>
						<Value2>true</Value2>
						<WriteLine Id="9" Level="Verbose" Param0="CheckDTxxxxENnnDataType.stringXmlValue" Param1="CheckDTxxxxENnnDataType.DataTypeName">{1}.BaseType ({0}) is valid.</WriteLine>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="GET_PARENT_DATATYPES_XPATH">
				<!--Get XPath of the parent DataTypes-->
				<RegexReplace OutputString="CheckDTxxxxENnnDataType.XPathDtBase">
					<Pattern>(\[[0-9]+\])$</Pattern>
					<InputString>CheckDTxxxxENnnDataType.XPath</InputString>
					<ReplacementString>EmptyString</ReplacementString>
				</RegexReplace>
			</TestStep>
			<TestStep>
				<!--Get Size of BaseType-->
				<CallTestFunction Name="DataTypeName.GetBitSize">
					<Parameter>CheckDTxxxxENnnDataType.stringXmlValue</Parameter>
					<Parameter>CheckDTxxxxENnnDataType.XmlFile</Parameter>
					<Parameter>CheckDTxxxxENnnDataType.XPathDtBase</Parameter>
					<OutParameter>CheckDTxxxxENnnDataType.BaseTypeSize</OutParameter>
				</CallTestFunction>
				<WriteLine Id="10" Level="Verbose" Param0="CheckDTxxxxENnnDataType.BaseTypeSize">BitSize for BaseType {0}.</WriteLine>
				<!--Dump an error if BaseType is not defined-->
				<Compare>
					<Lower>
						<Value1>CheckDTxxxxENnnDataType.BaseTypeSize</Value1>
						<Value2>0</Value2>
						<WriteLine Id="11" Level="Error" Param0="CheckDTxxxxENnnDataType.DataTypeName" Param1="CheckDTxxxxENnnDataType.BaseTypeSize" Param2="CheckDTxxxxENnnDataType.XmlFile" Param3="CheckDTxxxxENnnDataType.XPath">{0}.BaseType ({1}) is not defined in DataType list or has no BitSize. at File '{2}' XPath '{3}'</WriteLine>
					</Lower>
				</Compare>
			</TestStep>
			<TestStep Name="GET_ARRAYINFO_ELEMENT">
				<!--The Element ArrayInfo shall not be defined for Enum DataTypes.-->
				<GetXmlValue ReturnValue="CheckDTxxxxENnnDataType.stringXmlValue" Markup="false" FileName="CheckDTxxxxENnnDataType.XmlFile">
					<XPath Param0="CheckDTxxxxENnnDataType.XPath">{0}/ArrayInfo</XPath>
				</GetXmlValue>
				<!--Dump an Error if ArrInfo is defined-->
				<Compare>
					<NotEqual>
						<Value1>CheckDTxxxxENnnDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<WriteLine Id="12" Level="Error" Param0="CheckDTxxxxENnnDataType.DataTypeName" Param1="CheckDTxxxxENnnDataType.XmlFile" Param2="CheckDTxxxxENnnDataType.XPath">{0}.ArrayInfo shall not be defined. at File '{1}' XPath '{2}'</WriteLine>
					</NotEqual>
				</Compare>
				<!--Update Result-->
				<Compare>
					<NotEqual>
						<Value1>CheckDTxxxxENnnDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<SetVariable Target="CheckDTxxxxENnnDataType.Result">false</SetVariable>
					</NotEqual>
				</Compare>
				<!--Proceed with "SubItem" test-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxENnnDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<GotoStep>GET_SUBITEM_ELEMENT</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="GET_SUBITEM_ELEMENT">
				<!--The Element SubItem shall not be defined for Enum DataTypes.-->
				<GetXmlValue ReturnValue="CheckDTxxxxENnnDataType.stringXmlValue" Markup="false" FileName="CheckDTxxxxENnnDataType.XmlFile">
					<XPath Param0="CheckDTxxxxENnnDataType.XPath">{0}/SubItem</XPath>
				</GetXmlValue>
				<Compare>
					<NotEqual>
						<Value1>CheckDTxxxxENnnDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<WriteLine Id="13" Level="Error" Param0="CheckDTxxxxENnnDataType.DataTypeName" Param1="CheckDTxxxxENnnDataType.XmlFile" Param2="CheckDTxxxxENnnDataType.XPath">{0}.SubItem shall not be defined. at File '{1}' XPath '{2}'</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckDTxxxxENnnDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<SetVariable Target="CheckDTxxxxENnnDataType.Result">false</SetVariable>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="GET_MAX_ENUM_VALUE">
				<SetVariable Target="CheckDTxxxxENnnDataType.u32MaxValue">4294967295</SetVariable>
			</TestStep>
			<TestStep>
				<GetBits Source="CheckDTxxxxENnnDataType.u32MaxValue" Target="CheckDTxxxxENnnDataType.MaxEnumValue">
					<Offset>0</Offset>
					<Length>CheckDTxxxxENnnDataType.n</Length>
				</GetBits>
			</TestStep>
			<TestStep Name="GET_ENUMINFO_ELEMENT">
				<!--The Element EnumInfo shall be defined for Enum DataTypes.-->
				<GetXmlValue ReturnValue="CheckDTxxxxENnnDataType.stringXmlValue" Markup="false" FileName="CheckDTxxxxENnnDataType.XmlFile">
					<XPath Param0="CheckDTxxxxENnnDataType.XPath">{0}/EnumInfo</XPath>
				</GetXmlValue>
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxENnnDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<WriteLine Id="14" Level="Error" Param0="CheckDTxxxxENnnDataType.DataTypeName" Param1="CheckDTxxxxENnnDataType.XmlFile" Param2="CheckDTxxxxENnnDataType.XPath">{0}.EnumInfo shall be defined. at File '{1}' XPath '{2}'</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxENnnDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<SetVariable Target="CheckDTxxxxENnnDataType.Result">false</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxENnnDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<GotoStep>CHECK_BITSIZE</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Init Loop counter-->
				<SetVariable Target="CheckDTxxxxENnnDataType.LoopCnt">1</SetVariable>
			</TestStep>
			<TestStep Name="LoopStart">
				<!--Get Enum Text-->
				<GetXmlValue ReturnValue="CheckDTxxxxENnnDataType.stringXmlValue" Markup="false" FileName="CheckDTxxxxENnnDataType.XmlFile">
					<XPath Param0="CheckDTxxxxENnnDataType.XPath" Param1="CheckDTxxxxENnnDataType.LoopCnt">{0}/EnumInfo[{1}]/Text</XPath>
				</GetXmlValue>
			</TestStep>
			<TestStep>
				<!--Abort Loop if Enum Text is null-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxENnnDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<GotoStep>CHECK_BITSIZE</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckDTxxxxENnnDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<WriteLine Id="15" Level="Verbose" Param1="CheckDTxxxxENnnDataType.stringXmlValue" Param0="CheckDTxxxxENnnDataType.DataTypeName">{0}.EnumInfo.Text is {1}.</WriteLine>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Get Enum value-->
				<GetXmlValue ReturnValue="CheckDTxxxxENnnDataType.TmpI32" Markup="false" FileName="CheckDTxxxxENnnDataType.XmlFile">
					<XPath Param0="CheckDTxxxxENnnDataType.XPath" Param1="CheckDTxxxxENnnDataType.LoopCnt">{0}/EnumInfo[{1}]/Enum</XPath>
				</GetXmlValue>
			</TestStep>
			<TestStep>
				<!--Enum value shall be less or equal max enum value-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxENnnDataType.TmpI32</Value1>
						<Value2>null</Value2>
						<WriteLine Id="16" Level="Error" Param0="CheckDTxxxxENnnDataType.DataTypeName" Param1="CheckDTxxxxENnnDataType.XmlFile" Param2="CheckDTxxxxENnnDataType.XPath">{0}.EnumInfo.Enum shall be defined. at File '{1}' XPath '{2}'</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxENnnDataType.TmpI32</Value1>
						<Value2>null</Value2>
						<SetVariable Target="CheckDTxxxxENnnDataType.Result">false</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxENnnDataType.TmpI32</Value1>
						<Value2>null</Value2>
						<GotoStep>LoopEnd</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckDTxxxxENnnDataType.TmpI32</Value1>
						<Value2>null</Value2>
						<WriteLine Id="17" Level="Verbose" Param0="CheckDTxxxxENnnDataType.DataTypeName" Param1="CheckDTxxxxENnnDataType.TmpI32">{0}.EnumInfo.Enum is {1}.</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<Greater>
						<Value1>CheckDTxxxxENnnDataType.TmpI32</Value1>
						<Value2>CheckDTxxxxENnnDataType.MaxEnumValue</Value2>
						<WriteLine Id="19" Level="Error" Param0="CheckDTxxxxENnnDataType.TmpI32" Param1="CheckDTxxxxENnnDataType.n" Param2="CheckDTxxxxENnnDataType.MaxEnumValue" Param3="CheckDTxxxxENnnDataType.DataTypeName">{3}.EnumInfo.Enum Enum ({0}) shall be less or equal (2^{1} = {2}).</WriteLine>
					</Greater>
				</Compare>
				<Compare>
					<Greater>
						<Value1>CheckDTxxxxENnnDataType.TmpI32</Value1>
						<Value2>CheckDTxxxxENnnDataType.MaxEnumValue</Value2>
						<SetVariable Target="CheckDTxxxxENnnDataType.Result">false</SetVariable>
					</Greater>
				</Compare>
			</TestStep>
			<TestStep Name="LoopEnd">
				<SetVariable Target="CheckDTxxxxENnnDataType.LoopCnt">CheckDTxxxxENnnDataType.LoopCnt + 1</SetVariable>
				<!--Proceed with next cyle if Text and value were != null-->
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>LoopStart</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CHECK_BITSIZE">
				<!--The element BitSize shall be defined.-->
				<GetXmlValue ReturnValue="CheckDTxxxxENnnDataType.xmlBitSize" Markup="false" FileName="CheckDTxxxxENnnDataType.XmlFile">
					<XPath Param0="CheckDTxxxxENnnDataType.XPath">{0}/BitSize</XPath>
				</GetXmlValue>
				<!--Dump Error if BitSize not defined-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxENnnDataType.xmlBitSize</Value1>
						<Value2>null</Value2>
						<WriteLine Id="20" Level="Error" Param0="CheckDTxxxxENnnDataType.DataTypeName" Param1="CheckDTxxxxENnnDataType.XmlFile" Param2="CheckDTxxxxENnnDataType.XPath">{0}.BitSize shall be defined. at File '{1}' XPath '{2}'</WriteLine>
					</Equal>
				</Compare>
				<!--Update result (to false)-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxENnnDataType.xmlBitSize</Value1>
						<Value2>null</Value2>
						<SetVariable Target="CheckDTxxxxENnnDataType.Result">false</SetVariable>
					</Equal>
				</Compare>
				<!--return-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxENnnDataType.xmlBitSize</Value1>
						<Value2>null</Value2>
						<Return Id="21"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Skip following Tests if BaseType BitSize is not defined-->
				<Compare>
					<Lower>
						<Value1>CheckDTxxxxENnnDataType.BaseTypeSize</Value1>
						<Value2>0</Value2>
						<Return Id="22"></Return>
					</Lower>
				</Compare>
			</TestStep>
			<TestStep>
				<!--The defined BitSize shall be equal n-->
				<Compare>
					<NotEqual>
						<Value1>CheckDTxxxxENnnDataType.xmlBitSize</Value1>
						<Value2>CheckDTxxxxENnnDataType.n</Value2>
						<WriteLine Id="23" Level="Error" Param0="CheckDTxxxxENnnDataType.xmlBitSize" Param1="CheckDTxxxxENnnDataType.DataTypeName" Param2="CheckDTxxxxENnnDataType.n" Param3="CheckDTxxxxENnnDataType.XPath">{1}.BitSize ({0}) not match the bit size defined in the data type name. DTyyyyENxx, xx ({2}) shall be equal the BitSize value. XPath '{3}'</WriteLine>
					</NotEqual>
				</Compare>
				<!--Update result (to false)-->
				<Compare>
					<NotEqual>
						<Value1>CheckDTxxxxENnnDataType.xmlBitSize</Value1>
						<Value2>CheckDTxxxxENnnDataType.n</Value2>
						<SetVariable Target="CheckDTxxxxENnnDataType.Result">false</SetVariable>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckDTxxxxENnnDataType.xmlBitSize</Value1>
						<Value2>CheckDTxxxxENnnDataType.n</Value2>
						<Return Id="24"></Return>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep>
				<!--The defined BitSize shall be less or equal than BaseTypeSize-->
				<Compare>
					<Greater>
						<Value1>CheckDTxxxxENnnDataType.xmlBitSize</Value1>
						<Value2>CheckDTxxxxENnnDataType.BaseTypeSize</Value2>
						<WriteLine Id="25" Level="Error" Param0="CheckDTxxxxENnnDataType.xmlBitSize" Param1="CheckDTxxxxENnnDataType.DataTypeName" Param2="CheckDTxxxxENnnDataType.BaseTypeSize" Param3="CheckDTxxxxENnnDataType.XPath">{1}.BitSize ({0}) is invalid (expect less or equal {2}). XPath '{3}'</WriteLine>
					</Greater>
				</Compare>
				<!--Update result (to false)-->
				<Compare>
					<Greater>
						<Value1>CheckDTxxxxENnnDataType.xmlBitSize</Value1>
						<Value2>CheckDTxxxxENnnDataType.BaseTypeSize</Value2>
						<SetVariable Target="CheckDTxxxxENnnDataType.Result">false</SetVariable>
					</Greater>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction Name="CheckDTxxxxSubItem" FunctionId="205">
			<?MAX_OUTPUT_ID 30?>
			<!--Function for Device DataType Tests-->
			<Description>
				<Action>Check the definition of SubItem Elements</Action>
				<PostCondition></PostCondition>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>CheckDTxxxxSubItem.XmlFile</Name>
				<Type>String</Type>
				<Comment>Path of the xml file (absolute or relative to the ESI file).
If the parameter is null or empty the current device description will be referenced.</Comment>
			</Parameter>
			<Parameter>
				<Name>CheckDTxxxxSubItem.XPath</Name>
				<Type>String</Type>
				<Comment>XPath of the current DataType</Comment>
			</Parameter>
			<LocalVariables>
				<Name>CheckDTxxxxSubItem.stringXmlValue</Name>
				<Type>String</Type>
				<Comment>Tmp string to read ESI values</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckDTxxxxSubItem.IsMatch</Name>
				<Type>Bool</Type>
				<Comment>Tmp variable to indicate if RegEx match</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckDTxxxxSubItem.CompleteAccessSupported</Name>
				<Type>Bool</Type>
				<Comment>indicates if the DataType is used fro complete access</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckDTxxxxSubItem.DataTypeName</Name>
				<Type>String</Type>
				<Comment>Name of the DataType used for user messages</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckDTxxxxSubItem.xmlSubItemBitSize</Name>
				<Type>Int32</Type>
				<Comment>BitSize of the SubItem</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckDTxxxxSubItem.xmlSubItemBitOffset</Name>
				<Type>Int32</Type>
				<Comment>BitOffset of the SubItem</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckDTxxxxSubItem.xmlSubIdx</Name>
				<Type>Int32</Type>
				<Comment>SubIndex of the SubItem</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckDTxxxxSubItem.xmlPrevSubIdx</Name>
				<Type>Int32</Type>
				<Comment>SubIndex of the previous SubItem</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckDTxxxxSubItem.xmlSubName</Name>
				<Type>String</Type>
				<Comment>Name of the SubItem</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckDTxxxxSubItem.xmlSubType</Name>
				<Type>String</Type>
				<Comment>Type of the SubItem</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckDTxxxxSubItem.LoopCounter</Name>
				<Type>UInt16</Type>
				<Comment>LoopCounter</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckDTxxxxSubItem.result</Name>
				<Type>Bool</Type>
				<Comment>internal result (if false return value will be set to -1)</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckDTxxxxSubItem.i32TmpVar</Name>
				<Type>Int32</Type>
				<Comment>tmp var to store int32 variable.</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckDTxxxxSubItem.bArrayObject</Name>
				<Type>Bool</Type>
				<Comment>Indicates if an object defines an Array</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckDTxxxxSubItem.XPathDtBase</Name>
				<Type>String</Type>
				<Comment>Base XPath of current DataType</Comment>
			</LocalVariables>
			<OutParameter>
				<Name>CheckDTxxxxSubItem.CompleteSubItemBitSize</Name>
				<Type>Int32</Type>
				<!--Complete size of the SubItems-->
			</OutParameter>
			<TestStep Name="INIT_COMPLETE_BITSIZE">
				<!--CheckDTxxxxSubItem.CompleteSubItemBitSize = -1-->
				<SetVariable Target="CheckDTxxxxSubItem.CompleteSubItemBitSize">-1</SetVariable>
			</TestStep>
			<TestStep Name="INIT_RESULT">
				<!--CheckDTxxxxSubItem.result = true-->
				<SetVariable Target="CheckDTxxxxSubItem.result">true</SetVariable>
			</TestStep>
			<TestStep Name="INIT_ARRAY_INDICATION">
				<!--CheckDTxxxxSubItem.bArrayObject = false-->
				<SetVariable Target="CheckDTxxxxSubItem.bArrayObject">false</SetVariable>
			</TestStep>
			<TestStep Name="INIT_PREVIOUS_SUBIDX">
				<!--CheckDTxxxxSubItem.xmlPrevSubIdx = 0-->
				<SetVariable Target="CheckDTxxxxSubItem.xmlPrevSubIdx">0</SetVariable>
			</TestStep>
			<TestStep Name="INIT_LOOP_COUNTER">
				<!--CheckDTxxxxSubItem.LoopCounter = 1-->
				<SetVariable Target="CheckDTxxxxSubItem.LoopCounter">1</SetVariable>
			</TestStep>
			<TestStep Name="INIT_FILE_PARAMETER">
				<!--if parameter is null set value to emptystring-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxSubItem.XmlFile</Value1>
						<Value2>null</Value2>
						<SetVariable Target="CheckDTxxxxSubItem.XmlFile">EmptyString</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CHECK_IF_XPATH_EXISITS">
				<GetXmlValue ReturnValue="CheckDTxxxxSubItem.stringXmlValue" Markup="true" FileName="CheckDTxxxxSubItem.XmlFile">
					<XPath Param0="CheckDTxxxxSubItem.XPath">{0}</XPath>
				</GetXmlValue>
				<!--Dump an Error if XPath is not defined is defined-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxSubItem.stringXmlValue</Value1>
						<Value2>null</Value2>
						<WriteLine Id="0" Level="Error" Param0="CheckDTxxxxSubItem.XPath" Param1="CheckDTxxxxSubItem.XmlFile">The XPath "{0}" (File:{1}) is not defined.</WriteLine>
					</Equal>
				</Compare>
				<!--return-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxSubItem.stringXmlValue</Value1>
						<Value2>null</Value2>
						<Return Id="1"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="GET_DATATYPE_NAME">
				<!--Get DataType name from local dictionary-->
				<GetXmlValue ReturnValue="CheckDTxxxxSubItem.DataTypeName" Markup="false" FileName="CheckDTxxxxSubItem.XmlFile">
					<XPath Param0="CheckDTxxxxSubItem.XPath">{0}/Name</XPath>
				</GetXmlValue>
				<!--Dump an Error if no name is defined-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxSubItem.DataTypeName</Value1>
						<Value2>null</Value2>
						<WriteLine Id="2" Level="Error">A DataType name shall be defined.</WriteLine>
					</Equal>
				</Compare>
				<!--Update Error Variable-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxSubItem.DataTypeName</Value1>
						<Value2>null</Value2>
						<SetVariable Target="CheckDTxxxxSubItem.Result">false</SetVariable>
					</Equal>
				</Compare>
				<!--return-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxSubItem.DataTypeName</Value1>
						<Value2>null</Value2>
						<Return Id="3"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="GET_COMPLETEACCESS_SUPPORT">
				<CallTestFunction Name="DataTypeSupportCompleteAccess">
					<Parameter>CheckDTxxxxSubItem.DataTypeName</Parameter>
					<OutParameter>CheckDTxxxxSubItem.CompleteAccessSupported</OutParameter>
				</CallTestFunction>
			</TestStep>
			<TestStep Name="GET_SUBITEM_0_NAME">
				<!--Get Name of SubItem 0-->
				<GetXmlValue ReturnValue="CheckDTxxxxSubItem.stringXmlValue" Markup="false" FileName="CheckDTxxxxSubItem.XmlFile">
					<XPath Param0="CheckDTxxxxSubItem.XPath" Param1="CheckDTxxxxSubItem.LoopCounter">{0}/SubItem[{1}]/Name</XPath>
				</GetXmlValue>
				<!--Dump an error if no SubItem defined-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxSubItem.stringXmlValue</Value1>
						<Value2>null</Value2>
						<WriteLine Id="4" Level="Verbose">Skip SubItem test (no SubItem defined).</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxSubItem.stringXmlValue</Value1>
						<Value2>null</Value2>
						<SetVariable Target="CheckDTxxxxSubItem.result">false</SetVariable>
					</Equal>
				</Compare>
				<!--Return if no SubItem defined-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxSubItem.stringXmlValue</Value1>
						<Value2>null</Value2>
						<GotoStep>TEST_END</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Check SubItem 0 name-->
				<RegexIsMatch ReturnValue="CheckDTxxxxSubItem.IsMatch">
					<Pattern>^(SubIndex 000|[Nn]umber of [Ee]ntries)$</Pattern>
					<InputString>CheckDTxxxxSubItem.stringXmlValue</InputString>
				</RegexIsMatch>
				<!--Skip Error output if Si0 name doens't match-->
				<!--//DEV: previous Error output
<Compare>
	<Equal>
		<Value1>CheckDTxxxxSubItem.IsMatch</Value1>
		<Value2>false</Value2>
		<WriteLine Level="Error" Param0="CheckDTxxxxSubItem.DataTypeName" Param1="CheckDTxxxxSubItem.stringXmlValue">{0}.Subitem[0].Name ({1}) is invalid.</WriteLine>
	</Equal>
</Compare>
<Compare>
	<Equal>
		<Value1>CheckDTxxxxSubItem.IsMatch</Value1>
		<Value2>false</Value2>
		<SetVariable Target="CheckDTxxxxSubItem.result">false</SetVariable>
	</Equal>
</Compare>-->
			</TestStep>
			<TestStep Name="GET_SUBITEM_0_SUBIDX">
				<!--Get SubIdx of SubItem 0-->
				<GetXmlValue ReturnValue="CheckDTxxxxSubItem.stringXmlValue" Markup="false" FileName="CheckDTxxxxSubItem.XmlFile">
					<XPath Param0="CheckDTxxxxSubItem.XPath" Param1="CheckDTxxxxSubItem.LoopCounter">{0}/SubItem[{1}]/SubIdx</XPath>
				</GetXmlValue>
				<!--The SubIdx of SubItem 0 shall be 0-->
				<Compare>
					<NotEqual>
						<Value1>CheckDTxxxxSubItem.stringXmlValue</Value1>
						<Value2>"0"</Value2>
						<WriteLine Id="5" Level="Error" Param0="CheckDTxxxxSubItem.DataTypeName" Param1="CheckDTxxxxSubItem.stringXmlValue">{0}.Subitem[0].SubIdx ({1}) shall be 0.</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckDTxxxxSubItem.stringXmlValue</Value1>
						<Value2>"0"</Value2>
						<SetVariable Target="CheckDTxxxxSubItem.result">false</SetVariable>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="GET_SUBITEM_0_TYPE">
				<!--Get Typeof SubItem 0-->
				<GetXmlValue ReturnValue="CheckDTxxxxSubItem.stringXmlValue" Markup="false" FileName="CheckDTxxxxSubItem.XmlFile">
					<XPath Param0="CheckDTxxxxSubItem.XPath" Param1="CheckDTxxxxSubItem.LoopCounter">{0}/SubItem[{1}]/Type</XPath>
				</GetXmlValue>
				<!--The Type of SubItem 0 shall be defined-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxSubItem.stringXmlValue</Value1>
						<Value2>null</Value2>
						<WriteLine Id="6" Level="Error" Param0="CheckDTxxxxSubItem.DataTypeName">{0}.Subitem[0].Type shall be defined.</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxSubItem.stringXmlValue</Value1>
						<Value2>null</Value2>
						<SetVariable Target="CheckDTxxxxSubItem.result">false</SetVariable>
					</Equal>
				</Compare>
				<!--The Type of SubItem 0 shall be "USINT"-->
				<Compare>
					<NotEqual>
						<Value1>CheckDTxxxxSubItem.stringXmlValue</Value1>
						<Value2>"USINT"</Value2>
						<WriteLine Id="7" Level="Error" Param0="CheckDTxxxxSubItem.DataTypeName" Param1="CheckDTxxxxSubItem.stringXmlValue">{0}.Subitem[0].Type ({1}) shall be "USINT".</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckDTxxxxSubItem.stringXmlValue</Value1>
						<Value2>"USINT"</Value2>
						<SetVariable Target="CheckDTxxxxSubItem.result">false</SetVariable>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="GET_SUBITEM_0_BITSIZE">
				<!--Get BitSize of SubItem 0-->
				<GetXmlValue ReturnValue="CheckDTxxxxSubItem.stringXmlValue" Markup="false" FileName="CheckDTxxxxSubItem.XmlFile">
					<XPath Param0="CheckDTxxxxSubItem.XPath" Param1="CheckDTxxxxSubItem.LoopCounter">{0}/SubItem[{1}]/BitSize</XPath>
				</GetXmlValue>
				<!--The BitSize of SubItem 0 shall be 8-->
				<Compare>
					<NotEqual>
						<Value1>CheckDTxxxxSubItem.stringXmlValue</Value1>
						<Value2>"8"</Value2>
						<WriteLine Id="8" Level="Error" Param0="CheckDTxxxxSubItem.DataTypeName" Param1="CheckDTxxxxSubItem.stringXmlValue">{0}.Subitem[0].BitSize ({1}) shall be 8.</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckDTxxxxSubItem.stringXmlValue</Value1>
						<Value2>"8"</Value2>
						<SetVariable Target="CheckDTxxxxSubItem.result">false</SetVariable>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="GET_SUBITEM_0_BITOFFSET">
				<!--Get BitOffs of SubItem 0-->
				<GetXmlValue ReturnValue="CheckDTxxxxSubItem.stringXmlValue" Markup="false" FileName="CheckDTxxxxSubItem.XmlFile">
					<XPath Param0="CheckDTxxxxSubItem.XPath" Param1="CheckDTxxxxSubItem.LoopCounter">{0}/SubItem[{1}]/BitOffs</XPath>
				</GetXmlValue>
				<!--The BitOffs of SubItem 0 shall be 0-->
				<Compare>
					<NotEqual>
						<Value1>CheckDTxxxxSubItem.stringXmlValue</Value1>
						<Value2>"0"</Value2>
						<WriteLine Id="9" Level="Error" Param0="CheckDTxxxxSubItem.DataTypeName" Param1="CheckDTxxxxSubItem.stringXmlValue">{0}.Subitem[0].BitOffs ({1}) shall be 0.</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckDTxxxxSubItem.stringXmlValue</Value1>
						<Value2>"0"</Value2>
						<SetVariable Target="CheckDTxxxxSubItem.result">false</SetVariable>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="SET_COMPLETE_BITSIZE">
				<!--CheckDTxxxxSubItem.CompleteSubItemBitSize = 16-->
				<SetVariable Target="CheckDTxxxxSubItem.CompleteSubItemBitSize">16</SetVariable>
			</TestStep>
			<TestStep Name="INCREMENT_LOOP_COUNTER">
				<!--CheckDTxxxxSubItem.LoopCounter++-->
				<SetVariable Target="CheckDTxxxxSubItem.LoopCounter">CheckDTxxxxSubItem.LoopCounter + 1</SetVariable>
			</TestStep>
			<TestStep Name="CHECK_IF_FOLLOWING_SUBITEMS_DEFINED">
				<GetXmlValue FileName="CheckDTxxxxSubItem.XmlFile" ReturnValue="CheckDTxxxxSubItem.stringXmlValue" Markup="true">
					<XPath Param0="CheckDTxxxxSubItem.XPath" Param1="CheckDTxxxxSubItem.LoopCounter">{0}/SubItem[{1}]</XPath>
				</GetXmlValue>
				<!--Return if no following SubItems defined-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxSubItem.stringXmlValue</Value1>
						<Value2>null</Value2>
						<GotoStep>TEST_END</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="LOOP_START">
				<!--Get SubItem [LoopCounter].Name-->
				<GetXmlValue ReturnValue="CheckDTxxxxSubItem.xmlSubName" Markup="false" FileName="CheckDTxxxxSubItem.XmlFile">
					<XPath Param0="CheckDTxxxxSubItem.XPath" Param1="CheckDTxxxxSubItem.LoopCounter">{0}/SubItem[{1}]/Name</XPath>
				</GetXmlValue>
				<!--Stop Test if last SubItem reached-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxSubItem.xmlSubName</Value1>
						<Value2>null</Value2>
						<GotoStep>TEST_END</GotoStep>
					</Equal>
				</Compare>
				<!--The Name of SubItem [LoopCounter] shall be not ""-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxSubItem.xmlSubName</Value1>
						<Value2>EmptyString</Value2>
						<WriteLine Id="10" Level="Error" Param0="CheckDTxxxxSubItem.DataTypeName" Param1="(CheckDTxxxxSubItem.LoopCounter-1)">{0}.Subitem[{1}].Name shall not be an empty string.</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxSubItem.xmlSubName</Value1>
						<Value2>EmptyString</Value2>
						<SetVariable Target="CheckDTxxxxSubItem.result">false</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Dump an Error and stop the loop if the third SubItem is defined within an Array object-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxSubItem.bArrayObject</Value1>
						<Value2>true</Value2>
						<WriteLine Id="11" Level="Error">Only two SubItems shall be defined of array objects.</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxSubItem.bArrayObject</Value1>
						<Value2>true</Value2>
						<SetVariable Target="CheckDTxxxxSubItem.result">false</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxSubItem.bArrayObject</Value1>
						<Value2>true</Value2>
						<GotoStep>TEST_END</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="GET_SUBITEM_CNT_SUBIDX">
				<!--Get SubItem[LoopCounter].SubIdx-->
				<GetXmlValue ReturnValue="CheckDTxxxxSubItem.xmlSubIdx" Markup="false" FileName="CheckDTxxxxSubItem.XmlFile">
					<XPath Param0="CheckDTxxxxSubItem.XPath" Param1="CheckDTxxxxSubItem.LoopCounter">{0}/SubItem[{1}]/SubIdx</XPath>
				</GetXmlValue>
				<Compare>
					<NotEqual>
						<Value1>CheckDTxxxxSubItem.xmlSubIdx</Value1>
						<Value2>null</Value2>
						<WriteLine Id="12" Level="Verbose" Param0="CheckDTxxxxSubItem.DataTypeName" Param1="(CheckDTxxxxSubItem.LoopCounter-1)" Param2="CheckDTxxxxSubItem.xmlSubIdx">{0}.SubItem[{1}].SubIdx : {2}</WriteLine>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="GET_SUBITEM_CNT_TYPE">
				<!--Get SubItem[LoopCounter].Type-->
				<GetXmlValue ReturnValue="CheckDTxxxxSubItem.xmlSubType" Markup="false" FileName="CheckDTxxxxSubItem.XmlFile">
					<XPath Param0="CheckDTxxxxSubItem.XPath" Param1="CheckDTxxxxSubItem.LoopCounter">{0}/SubItem[{1}]/Type</XPath>
				</GetXmlValue>
				<Compare>
					<NotEqual>
						<Value1>CheckDTxxxxSubItem.xmlSubType</Value1>
						<Value2>null</Value2>
						<WriteLine Id="13" Level="Verbose" Param0="CheckDTxxxxSubItem.DataTypeName" Param1="(CheckDTxxxxSubItem.LoopCounter-1)" Param2="CheckDTxxxxSubItem.xmlSubType">{0}.SubItem[{1}].Type : {2}</WriteLine>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="GET_SUBITEM_CNT_BITSIZE">
				<!--Get SubItem[LoopCounter].BitSize-->
				<GetXmlValue ReturnValue="CheckDTxxxxSubItem.xmlSubItemBitSize" Markup="false" FileName="CheckDTxxxxSubItem.XmlFile">
					<XPath Param0="CheckDTxxxxSubItem.XPath" Param1="CheckDTxxxxSubItem.LoopCounter">{0}/SubItem[{1}]/BitSize</XPath>
				</GetXmlValue>
				<Compare>
					<NotEqual>
						<Value1>CheckDTxxxxSubItem.xmlSubItemBitSize</Value1>
						<Value2>null</Value2>
						<WriteLine Id="14" Level="Verbose" Param0="CheckDTxxxxSubItem.DataTypeName" Param1="(CheckDTxxxxSubItem.LoopCounter-1)" Param2="CheckDTxxxxSubItem.xmlSubItemBitSize">{0}.SubItem[{1}].BitSize : {2}</WriteLine>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="GET_SUBITEM_CNT_BITOFFSET">
				<!--Get SubItem[LoopCounter].BitOffset-->
				<GetXmlValue ReturnValue="CheckDTxxxxSubItem.xmlSubItemBitOffset" Markup="false" FileName="CheckDTxxxxSubItem.XmlFile">
					<XPath Param0="CheckDTxxxxSubItem.XPath" Param1="CheckDTxxxxSubItem.LoopCounter">{0}/SubItem[{1}]/BitOffs</XPath>
				</GetXmlValue>
				<!--SubItem.BitOffs shall be defined.-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxSubItem.xmlSubItemBitOffset</Value1>
						<Value2>null</Value2>
						<WriteLine Id="15" Level="Error" Param0="CheckDTxxxxSubItem.DataTypeName" Param1="(CheckDTxxxxSubItem.LoopCounter-1)">{0}.Subitem[{1}].BitOffs shall be defined.</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxSubItem.xmlSubItemBitOffset</Value1>
						<Value2>null</Value2>
						<SetVariable Target="CheckDTxxxxSubItem.result">false</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckDTxxxxSubItem.xmlSubItemBitOffset</Value1>
						<Value2>null</Value2>
						<WriteLine Id="16" Level="Verbose" Param0="CheckDTxxxxSubItem.DataTypeName" Param1="(CheckDTxxxxSubItem.LoopCounter-1)" Param2="CheckDTxxxxSubItem.xmlSubItemBitOffset">{0}.SubItem[{1}].BitOffs : {2}</WriteLine>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="CHECK_BITOFFSET">
				<!--The Bitoffset shall be greater or equal to the current BitSize-->
				<Compare>
					<Greater>
						<Value1>CheckDTxxxxSubItem.CompleteSubItemBitSize</Value1>
						<Value2>CheckDTxxxxSubItem.xmlSubItemBitOffset</Value2>
						<WriteLine Id="17" Level="Error" Param0="CheckDTxxxxSubItem.DataTypeName" Param1="(CheckDTxxxxSubItem.LoopCounter-1)" Param2="CheckDTxxxxSubItem.xmlSubItemBitOffset" Param3="CheckDTxxxxSubItem.CompleteSubItemBitSize">{0}.SubItem[{1}].BitOffs ({2}) is invalid (expected {3} or greater).</WriteLine>
					</Greater>
				</Compare>
				<Compare>
					<Greater>
						<Value1>CheckDTxxxxSubItem.CompleteSubItemBitSize</Value1>
						<Value2>CheckDTxxxxSubItem.xmlSubItemBitOffset</Value2>
						<SetVariable Target="CheckDTxxxxSubItem.result">false</SetVariable>
					</Greater>
				</Compare>
			</TestStep>
			<TestStep Name="CHECK_OVERLAPPING_BYTE_BORDER">
				<!--Check if BitOffset is within a Byte-->
				<SetVariable Target="CheckDTxxxxSubItem.i32TmpVar">CheckDTxxxxSubItem.xmlSubItemBitOffset &amp; 7</SetVariable>
				<!--Proceed if the BitOffset is on a Byte border-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxSubItem.i32TmpVar</Value1>
						<Value2>0</Value2>
						<GotoStep>DECIDE_IF_ARRAY_OR_DEFAULT_DEFINE</GotoStep>
					</Equal>
				</Compare>
				<!--Proceed if the BitSize is less than one Byte (for entries less than one Byte it is allowed to overlap Byte borders)-->
				<Compare>
					<Lower>
						<Value1>CheckDTxxxxSubItem.xmlSubItemBitSize</Value1>
						<Value2>8</Value2>
						<GotoStep>DECIDE_IF_ARRAY_OR_DEFAULT_DEFINE</GotoStep>
					</Lower>
				</Compare>
			</TestStep>
			<TestStep>
				<!--A Byte border shall not be overlap if a BitOffset is within a Byte-->
				<SetVariable Target="CheckDTxxxxSubItem.i32TmpVar">CheckDTxxxxSubItem.i32TmpVar + CheckDTxxxxSubItem.xmlSubItemBitSize</SetVariable>
				<Compare>
					<LowerOrEqual>
						<Value1>CheckDTxxxxSubItem.i32TmpVar</Value1>
						<Value2>8</Value2>
						<GotoStep>DECIDE_IF_ARRAY_OR_DEFAULT_DEFINE</GotoStep>
					</LowerOrEqual>
				</Compare>
				<!--Dump only a warning if no complete access is supported-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxSubItem.CompleteAccessSupported</Value1>
						<Value2>false</Value2>
						<WriteLine Id="18" Level="Warning" Param0="CheckDTxxxxSubItem.DataTypeName" Param1="(CheckDTxxxxSubItem.LoopCounter-1)" Param2="CheckDTxxxxSubItem.xmlSubItemBitOffset">{0}.SubItem[{1}] should not overlap the Byte border (check BitOffs ({2}) or add alignment entry before).</WriteLine>
					</Equal>
				</Compare>
				<!--Dump an error if complete access is supported-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxSubItem.CompleteAccessSupported</Value1>
						<Value2>true</Value2>
						<WriteLine Id="19" Level="Error" Param0="CheckDTxxxxSubItem.DataTypeName" Param1="(CheckDTxxxxSubItem.LoopCounter-1)" Param2="CheckDTxxxxSubItem.xmlSubItemBitOffset">{0}.SubItem[{1}] shall not overlap the Byte border (check BitOffs ({2}) or add alignment entry before).</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxSubItem.CompleteAccessSupported</Value1>
						<Value2>true</Value2>
						<SetVariable Target="CheckDTxxxxSubItem.result">false</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="DECIDE_IF_ARRAY_OR_DEFAULT_DEFINE">
				<!--SubItem[LoopCounter].SubIdx not defined => "ARRAY_ITEM"
else "DEFAULT_SUBITEM"-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxSubItem.xmlSubIdx</Value1>
						<Value2>null</Value2>
						<GotoStep>ARRAY_SUBITEM_TEST</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckDTxxxxSubItem.xmlSubIdx</Value1>
						<Value2>null</Value2>
						<GotoStep>DEFAULT_SUBITEM_TEST</GotoStep>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="ARRAY_SUBITEM_TEST">
				<Description Id="20" Level="Verbose">Check array definition (no SubIdx for the second SubItem defined).</Description>
				<!--Dump an Error if the LoopCounter is <> 2 (the Array SubItem shall be the second one)-->
				<Compare>
					<NotEqual>
						<Value1>CheckDTxxxxSubItem.LoopCounter</Value1>
						<Value2>2</Value2>
						<WriteLine Id="21" Level="Error">The Array SubItem shall be the second one.</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckDTxxxxSubItem.LoopCounter</Value1>
						<Value2>2</Value2>
						<SetVariable Target="CheckDTxxxxSubItem.result">false</SetVariable>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="CHECK_ARRAY_SUBITEM_TYPE">
				<Description Id="22" Level="Verbose">Check array definition (no SubIdx defined).</Description>
				<!--SubItem[LoopCounter].Type shall be defined-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxSubItem.xmlSubType</Value1>
						<Value2>null</Value2>
						<WriteLine Id="23" Level="Error" Param0="CheckDTxxxxSubItem.DataTypeName" Param1="CheckDTxxxxSubItem.stringXmlValue">{0}.Subitem[0].Type shall be defined.</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxSubItem.xmlSubType</Value1>
						<Value2>null</Value2>
						<SetVariable Target="CheckDTxxxxSubItem.result">false</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxSubItem.xmlSubType</Value1>
						<Value2>null</Value2>
						<GotoStep>CHECK_ARRAY_SUBITEM_BITSIZE</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--SubItem[LoopCounter].Type shall be "DTxxxxARR"-->
				<RegexIsMatch ReturnValue="CheckDTxxxxSubItem.IsMatch">
					<Pattern>^(DT[0-9A-Fa-fXx]{1,4}ARR)$</Pattern>
					<InputString>CheckDTxxxxSubItem.xmlSubType</InputString>
				</RegexIsMatch>
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxSubItem.IsMatch</Value1>
						<Value2>false</Value2>
						<WriteLine Id="24" Level="Error" Param0="CheckDTxxxxSubItem.DataTypeName" Param1="CheckDTxxxxSubItem.xmlSubType">{0}.Subitem[0].Type ({1}) shall be "DTxxxxARR".</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxSubItem.IsMatch</Value1>
						<Value2>false</Value2>
						<SetVariable Target="CheckDTxxxxSubItem.result">false</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="ARRAY_SUBITEM_TEST_END">
				<!--Indicate that the object describe an array-->
				<SetVariable Target="CheckDTxxxxSubItem.bArrayObject">true</SetVariable>
				<!--Goto Step "CHECK_SUBITEM_BITSIZE"-->
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>CHECK_SUBITEM_BITSIZE</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="DEFAULT_SUBITEM_TEST">
				<!--Definition of record object, check Type-->
				<RegexIsMatch ReturnValue="CheckDTxxxxSubItem.IsMatch">
					<Pattern>^(BOOL|BIT|BIT[1-8]|BYTE|BITARR8|BITARR16|WORD|BITARR32|DWORD|SINT|INT|INT24|DINT|INT40|INT48|INT56|LINT|USINT|UINT|UINT24|UDINT|UINT40|UINT48|UINT56|ULINT|REAL|LREAL|(DT[0-9A-F]{1,4}EN([0-9]{2}))|(ARRAY \[0\.\.[0-9]+\] OF (BYTE|SINT|UINT|INT|DINT|UDINT))|(STRING\([0-9]+\)))$</Pattern>
					<InputString>CheckDTxxxxSubItem.xmlSubType</InputString>
				</RegexIsMatch>
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxSubItem.IsMatch</Value1>
						<Value2>false</Value2>
						<WriteLine Id="25" Level="Error" Param0="CheckDTxxxxSubItem.DataTypeName" Param1="(CheckDTxxxxSubItem.LoopCounter-1)" Param2="CheckDTxxxxSubItem.xmlSubType">{0}.SubItem[{1}].Type ({2}) shall be BaseDataType or Enum.</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxSubItem.IsMatch</Value1>
						<Value2>false</Value2>
						<SetVariable Target="CheckDTxxxxSubItem.result">false</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CHECK_SUBITEM_BITSIZE">
				<!--Get XPath of the parent DataTypes-->
				<RegexReplace OutputString="CheckDTxxxxSubItem.XPathDtBase">
					<Pattern>(\[[0-9]+\])$</Pattern>
					<InputString>CheckDTxxxxSubItem.XPath</InputString>
					<ReplacementString>EmptyString</ReplacementString>
				</RegexReplace>
			</TestStep>
			<TestStep>
				<!--Get Type BitSize-->
				<CallTestFunction Name="DataTypeName.GetBitSize">
					<Parameter>CheckDTxxxxSubItem.xmlSubType</Parameter>
					<Parameter>CheckDTxxxxSubItem.XmlFile</Parameter>
					<Parameter>CheckDTxxxxSubItem.XPathDtBase</Parameter>
					<OutParameter>CheckDTxxxxSubItem.i32TmpVar</OutParameter>
				</CallTestFunction>
				<!--Dump an Error, update the result and goto "UPDATE_COMPLETE_BITSIZE" if Type is not defined-->
				<Compare>
					<Lower>
						<Value1>CheckDTxxxxSubItem.i32TmpVar</Value1>
						<Value2>0</Value2>
						<WriteLine Id="26" Level="Error" Param0="CheckDTxxxxSubItem.xmlSubType">The Type ({0}) is not defined in DataTypeList or BitSize is not defined.</WriteLine>
					</Lower>
				</Compare>
				<Compare>
					<Lower>
						<Value1>CheckDTxxxxSubItem.i32TmpVar</Value1>
						<Value2>0</Value2>
						<SetVariable Target="CheckDTxxxxSubItem.result">false</SetVariable>
					</Lower>
				</Compare>
				<Compare>
					<Lower>
						<Value1>CheckDTxxxxSubItem.i32TmpVar</Value1>
						<Value2>0</Value2>
						<GotoStep>UPDATE_COMPLETE_BITSIZE</GotoStep>
					</Lower>
				</Compare>
				<!--Dump an Error, update result and goto "LOOP_END" if BitSize is not defined-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxSubItem.xmlSubItemBitSize</Value1>
						<Value2>null</Value2>
						<WriteLine Id="27" Level="Error" Param0="CheckDTxxxxSubItem.DataTypeName" Param1="(CheckDTxxxxSubItem.LoopCounter-1)">{0}.SubItem[{1}].BitSize is not defined.</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxSubItem.xmlSubItemBitSize</Value1>
						<Value2>null</Value2>
						<SetVariable Target="CheckDTxxxxSubItem.result">false</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxSubItem.xmlSubItemBitSize</Value1>
						<Value2>null</Value2>
						<GotoStep>LOOP_END</GotoStep>
					</Equal>
				</Compare>
				<!--Check if BitSize is unequal Type BitSize-->
				<Compare>
					<NotEqual>
						<Value1>CheckDTxxxxSubItem.xmlSubItemBitSize</Value1>
						<Value2>CheckDTxxxxSubItem.i32TmpVar</Value2>
						<WriteLine Id="28" Level="Error" Param0="CheckDTxxxxSubItem.DataTypeName" Param1="(CheckDTxxxxSubItem.LoopCounter-1)" Param2="CheckDTxxxxSubItem.xmlSubItemBitSize" Param3="CheckDTxxxxSubItem.i32TmpVar">{0}.SubItem[{1}].BitSize ({2}) shall be {3}.</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckDTxxxxSubItem.xmlSubItemBitSize</Value1>
						<Value2>CheckDTxxxxSubItem.i32TmpVar</Value2>
						<SetVariable Target="CheckDTxxxxSubItem.result">false</SetVariable>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="UPDATE_COMPLETE_BITSIZE">
				<!--The BitOffset shall be defined-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxSubItem.xmlSubItemBitOffset</Value1>
						<Value2>null</Value2>
						<WriteLine Id="29" Level="Error" Param0="CheckDTxxxxSubItem.DataTypeName" Param1="CheckDTxxxxSubItem.LoopCounter">{0}.SubItem[{1}].BitOffs is not defined.</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxSubItem.xmlSubItemBitOffset</Value1>
						<Value2>null</Value2>
						<SetVariable Target="CheckDTxxxxSubItem.result">false</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxSubItem.xmlSubItemBitOffset</Value1>
						<Value2>null</Value2>
						<GotoStep>LOOP_END</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--CompleteBitSize = BitOffs + BitSize-->
				<SetVariable Target="CheckDTxxxxSubItem.CompleteSubItemBitSize">CheckDTxxxxSubItem.xmlSubItemBitOffset + CheckDTxxxxSubItem.xmlSubItemBitSize</SetVariable>
			</TestStep>
			<TestStep Name="LOOP_END">
				<!--Update Previous SubIdx-->
				<SetVariable Target="CheckDTxxxxSubItem.xmlPrevSubIdx">CheckDTxxxxSubItem.xmlSubIdx</SetVariable>
			</TestStep>
			<TestStep>
				<!--CheckDTxxxxSubItem.LoopCounter ++-->
				<SetVariable Target="CheckDTxxxxSubItem.LoopCounter">CheckDTxxxxSubItem.LoopCounter + 1</SetVariable>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>LOOP_START</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="TEST_END">
				<!--Update return value-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxSubItem.result</Value1>
						<Value2>false</Value2>
						<SetVariable Target="CheckDTxxxxSubItem.CompleteSubItemBitSize">-1</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxSubItem.result</Value1>
						<Value2>false</Value2>
						<Return Id="30"></Return>
					</Equal>
				</Compare>
				<!--If only Subindex 0 is defined set total bit size to 8-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxSubItem.LoopCounter</Value1>
						<Value2>2</Value2>
						<SetVariable Target="CheckDTxxxxSubItem.CompleteSubItemBitSize">8</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction Name="CheckDTxxxxSubItem_mod" FunctionId="20801">
			<?MAX_OUTPUT_ID 32?>
			<!--Function for Device DataType Tests-->
			<Description>
				<Action>Check the definition of SubItem Elements</Action>
				<PostCondition></PostCondition>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>CheckDTxxxxSubItem_mod.XmlFile</Name>
				<Type>String</Type>
				<Comment>Path of the xml file (absolute or relative to the ESI file).
If the parameter is null or empty the current device description will be referenced.</Comment>
			</Parameter>
			<Parameter>
				<Name>CheckDTxxxxSubItem_mod.XPath</Name>
				<Type>String</Type>
				<Comment>XPath of the current DataType</Comment>
			</Parameter>
			<LocalVariables>
				<Name>CheckDTxxxxSubItem_mod.stringXmlValue</Name>
				<Type>String</Type>
				<Comment>Tmp string to read ESI values</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckDTxxxxSubItem_mod.IsMatch</Name>
				<Type>Bool</Type>
				<Comment>Tmp variable to indicate if RegEx match</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckDTxxxxSubItem_mod.CompleteAccessSupported</Name>
				<Type>Bool</Type>
				<Comment>indicates if the DataType is used fro complete access</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckDTxxxxSubItem_mod.DataTypeName</Name>
				<Type>String</Type>
				<Comment>Name of the DataType used for user messages</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckDTxxxxSubItem_mod.xmlSubItemBitSize</Name>
				<Type>Int32</Type>
				<Comment>BitSize of the SubItem</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckDTxxxxSubItem_mod.xmlSubItemBitOffset</Name>
				<Type>Int32</Type>
				<Comment>BitOffset of the SubItem</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckDTxxxxSubItem_mod.xmlSubIdx</Name>
				<Type>Int32</Type>
				<Comment>SubIndex of the SubItem</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckDTxxxxSubItem_mod.xmlPrevSubIdx</Name>
				<Type>Int32</Type>
				<Comment>SubIndex of the previous SubItem</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckDTxxxxSubItem_mod.xmlSubName</Name>
				<Type>String</Type>
				<Comment>Name of the SubItem</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckDTxxxxSubItem_mod.xmlSubType</Name>
				<Type>String</Type>
				<Comment>Type of the SubItem</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckDTxxxxSubItem_mod.LoopCounter</Name>
				<Type>UInt16</Type>
				<Comment>LoopCounter</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckDTxxxxSubItem_mod.result</Name>
				<Type>Bool</Type>
				<Comment>internal result (if false return value will be set to -1)</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckDTxxxxSubItem_mod.i32TmpVar</Name>
				<Type>Int32</Type>
				<Comment>tmp var to store int32 variable.</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckDTxxxxSubItem_mod.bArrayObject</Name>
				<Type>Bool</Type>
				<Comment>Indicates if an object defines an Array</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckDTxxxxSubItem_mod.XPathDtBase</Name>
				<Type>String</Type>
				<Comment>Base XPath of current DataType</Comment>
			</LocalVariables>
			<OutParameter>
				<Name>CheckDTxxxxSubItem_mod.CompleteSubItemBitSize</Name>
				<Type>Int32</Type>
				<!--Complete size of the SubItems-->
			</OutParameter>
			<TestStep Name="INIT_COMPLETE_BITSIZE">
				<!--CheckDTxxxxSubItem_mod.CompleteSubItemBitSize = -1-->
				<SetVariable Target="CheckDTxxxxSubItem_mod.CompleteSubItemBitSize">-1</SetVariable>
			</TestStep>
			<TestStep Name="INIT_RESULT">
				<!--CheckDTxxxxSubItem_mod.result = true-->
				<SetVariable Target="CheckDTxxxxSubItem_mod.result">true</SetVariable>
			</TestStep>
			<TestStep Name="INIT_ARRAY_INDICATION">
				<!--CheckDTxxxxSubItem_mod.bArrayObject = false-->
				<SetVariable Target="CheckDTxxxxSubItem_mod.bArrayObject">false</SetVariable>
			</TestStep>
			<TestStep Name="INIT_PREVIOUS_SUBIDX">
				<!--CheckDTxxxxSubItem_mod.xmlPrevSubIdx = 0-->
				<SetVariable Target="CheckDTxxxxSubItem_mod.xmlPrevSubIdx">0</SetVariable>
			</TestStep>
			<TestStep Name="INIT_LOOP_COUNTER">
				<!--CheckDTxxxxSubItem_mod.LoopCounter = 1-->
				<SetVariable Target="CheckDTxxxxSubItem_mod.LoopCounter">1</SetVariable>
			</TestStep>
			<TestStep Name="INIT_FILE_PARAMETER">
				<!--if parameter is null set value to emptystring-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxSubItem_mod.XmlFile</Value1>
						<Value2>null</Value2>
						<SetVariable Target="CheckDTxxxxSubItem_mod.XmlFile">EmptyString</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CHECK_IF_XPATH_EXISITS">
				<GetXmlValue ReturnValue="CheckDTxxxxSubItem_mod.stringXmlValue" Markup="true" FileName="CheckDTxxxxSubItem_mod.XmlFile">
					<XPath Param0="CheckDTxxxxSubItem_mod.XPath">{0}</XPath>
				</GetXmlValue>
				<!--Dump an Error if XPath is not defined is defined-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxSubItem_mod.stringXmlValue</Value1>
						<Value2>null</Value2>
						<WriteLine Id="0" Level="Error" Param0="CheckDTxxxxSubItem_mod.XPath" Param1="CheckDTxxxxSubItem_mod.XmlFile">The XPath "{0}" (File:{1}) is not defined.</WriteLine>
					</Equal>
				</Compare>
				<!--return-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxSubItem_mod.stringXmlValue</Value1>
						<Value2>null</Value2>
						<Return Id="1"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="GET_DATATYPE_NAME">
				<!--Get DataType name from local dictionary-->
				<GetXmlValue ReturnValue="CheckDTxxxxSubItem_mod.DataTypeName" Markup="false" FileName="CheckDTxxxxSubItem_mod.XmlFile">
					<XPath Param0="CheckDTxxxxSubItem_mod.XPath">{0}/Name</XPath>
				</GetXmlValue>
				<!--Dump an Error if no name is defined-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxSubItem_mod.DataTypeName</Value1>
						<Value2>null</Value2>
						<WriteLine Id="2" Level="Error">A DataType name shall be defined.</WriteLine>
					</Equal>
				</Compare>
				<!--Update Error Variable-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxSubItem_mod.DataTypeName</Value1>
						<Value2>null</Value2>
						<SetVariable Target="CheckDTxxxxSubItem_mod.Result">false</SetVariable>
					</Equal>
				</Compare>
				<!--return-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxSubItem_mod.DataTypeName</Value1>
						<Value2>null</Value2>
						<Return Id="3"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="GET_COMPLETEACCESS_SUPPORT">
				<CallTestFunction Name="DataTypeSupportCA">
					<Parameter>CheckDTxxxxSubItem_mod.DataTypeName</Parameter>
					<Parameter>CheckDTxxxxSubItem_mod.XmlFile</Parameter>
					<Parameter>CheckDTxxxxSubItem_mod.XPath</Parameter>
					<OutParameter>CheckDTxxxxSubItem_mod.CompleteAccessSupported</OutParameter>
				</CallTestFunction>
			</TestStep>
			<TestStep Name="GET_SUBITEM_0_NAME">
				<!--Get Name of SubItem 0-->
				<GetXmlValue ReturnValue="CheckDTxxxxSubItem_mod.stringXmlValue" Markup="false" FileName="CheckDTxxxxSubItem_mod.XmlFile">
					<XPath Param0="CheckDTxxxxSubItem_mod.XPath" Param1="CheckDTxxxxSubItem_mod.LoopCounter">{0}/SubItem[{1}]/Name</XPath>
				</GetXmlValue>
				<!--Dump an error if no SubItem defined-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxSubItem_mod.stringXmlValue</Value1>
						<Value2>null</Value2>
						<WriteLine Id="4" Level="Verbose">Skip SubItem test (no SubItem defined).</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxSubItem_mod.stringXmlValue</Value1>
						<Value2>null</Value2>
						<SetVariable Target="CheckDTxxxxSubItem_mod.result">false</SetVariable>
					</Equal>
				</Compare>
				<!--Return if no SubItem defined-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxSubItem_mod.stringXmlValue</Value1>
						<Value2>null</Value2>
						<GotoStep>TEST_END</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Check SubItem 0 name-->
				<RegexIsMatch ReturnValue="CheckDTxxxxSubItem_mod.IsMatch">
					<Pattern>^(SubIndex 000|[Nn]umber of [Ee]ntries)$</Pattern>
					<InputString>CheckDTxxxxSubItem_mod.stringXmlValue</InputString>
				</RegexIsMatch>
				<!--Skip Error output if Si0 name doens't match-->
				<!--//DEV: previous Error output
<Compare>
	<Equal>
		<Value1>CheckDTxxxxSubItem_mod.IsMatch</Value1>
		<Value2>false</Value2>
		<WriteLine Level="Error" Param0="CheckDTxxxxSubItem_mod.DataTypeName" Param1="CheckDTxxxxSubItem_mod.stringXmlValue">{0}.Subitem[0].Name ({1}) is invalid.</WriteLine>
	</Equal>
</Compare>
<Compare>
	<Equal>
		<Value1>CheckDTxxxxSubItem_mod.IsMatch</Value1>
		<Value2>false</Value2>
		<SetVariable Target="CheckDTxxxxSubItem_mod.result">false</SetVariable>
	</Equal>
</Compare>-->
			</TestStep>
			<TestStep Name="GET_SUBITEM_0_SUBIDX">
				<!--Get SubIdx of SubItem 0-->
				<GetXmlValue ReturnValue="CheckDTxxxxSubItem_mod.stringXmlValue" Markup="false" FileName="CheckDTxxxxSubItem_mod.XmlFile">
					<XPath Param0="CheckDTxxxxSubItem_mod.XPath" Param1="CheckDTxxxxSubItem_mod.LoopCounter">{0}/SubItem[{1}]/SubIdx</XPath>
				</GetXmlValue>
				<!--The SubIdx of SubItem 0 shall be 0-->
				<Compare>
					<NotEqual>
						<Value1>CheckDTxxxxSubItem_mod.stringXmlValue</Value1>
						<Value2>"0"</Value2>
						<WriteLine Id="5" Level="Error" Param0="CheckDTxxxxSubItem_mod.DataTypeName" Param1="CheckDTxxxxSubItem_mod.stringXmlValue">{0}.Subitem[0].SubIdx ({1}) shall be 0.</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckDTxxxxSubItem_mod.stringXmlValue</Value1>
						<Value2>"0"</Value2>
						<SetVariable Target="CheckDTxxxxSubItem_mod.result">false</SetVariable>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="GET_SUBITEM_0_TYPE">
				<!--Get Typeof SubItem 0-->
				<GetXmlValue ReturnValue="CheckDTxxxxSubItem_mod.stringXmlValue" Markup="false" FileName="CheckDTxxxxSubItem_mod.XmlFile">
					<XPath Param0="CheckDTxxxxSubItem_mod.XPath" Param1="CheckDTxxxxSubItem_mod.LoopCounter">{0}/SubItem[{1}]/Type</XPath>
				</GetXmlValue>
				<!--The Type of SubItem 0 shall be defined-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxSubItem_mod.stringXmlValue</Value1>
						<Value2>null</Value2>
						<WriteLine Id="6" Level="Error" Param0="CheckDTxxxxSubItem_mod.DataTypeName">{0}.Subitem[0].Type shall be defined.</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxSubItem_mod.stringXmlValue</Value1>
						<Value2>null</Value2>
						<SetVariable Target="CheckDTxxxxSubItem_mod.result">false</SetVariable>
					</Equal>
				</Compare>
				<!--The Type of SubItem 0 shall be "USINT"-->
				<Compare>
					<NotEqual>
						<Value1>CheckDTxxxxSubItem_mod.stringXmlValue</Value1>
						<Value2>"USINT"</Value2>
						<WriteLine Id="7" Level="Error" Param0="CheckDTxxxxSubItem_mod.DataTypeName" Param1="CheckDTxxxxSubItem_mod.stringXmlValue">{0}.Subitem[0].Type ({1}) shall be "USINT".</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckDTxxxxSubItem_mod.stringXmlValue</Value1>
						<Value2>"USINT"</Value2>
						<SetVariable Target="CheckDTxxxxSubItem_mod.result">false</SetVariable>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="GET_SUBITEM_0_BITSIZE">
				<!--Get BitSize of SubItem 0-->
				<GetXmlValue ReturnValue="CheckDTxxxxSubItem_mod.stringXmlValue" Markup="false" FileName="CheckDTxxxxSubItem_mod.XmlFile">
					<XPath Param0="CheckDTxxxxSubItem_mod.XPath" Param1="CheckDTxxxxSubItem_mod.LoopCounter">{0}/SubItem[{1}]/BitSize</XPath>
				</GetXmlValue>
				<!--The BitSize of SubItem 0 shall be 8-->
				<Compare>
					<NotEqual>
						<Value1>CheckDTxxxxSubItem_mod.stringXmlValue</Value1>
						<Value2>"8"</Value2>
						<WriteLine Id="8" Level="Error" Param0="CheckDTxxxxSubItem_mod.DataTypeName" Param1="CheckDTxxxxSubItem_mod.stringXmlValue">{0}.Subitem[0].BitSize ({1}) shall be 8.</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckDTxxxxSubItem_mod.stringXmlValue</Value1>
						<Value2>"8"</Value2>
						<SetVariable Target="CheckDTxxxxSubItem_mod.result">false</SetVariable>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="GET_SUBITEM_0_BITOFFSET">
				<!--Get BitOffs of SubItem 0-->
				<GetXmlValue ReturnValue="CheckDTxxxxSubItem_mod.stringXmlValue" Markup="false" FileName="CheckDTxxxxSubItem_mod.XmlFile">
					<XPath Param0="CheckDTxxxxSubItem_mod.XPath" Param1="CheckDTxxxxSubItem_mod.LoopCounter">{0}/SubItem[{1}]/BitOffs</XPath>
				</GetXmlValue>
				<!--The BitOffs of SubItem 0 shall be 0-->
				<Compare>
					<NotEqual>
						<Value1>CheckDTxxxxSubItem_mod.stringXmlValue</Value1>
						<Value2>"0"</Value2>
						<WriteLine Id="9" Level="Error" Param0="CheckDTxxxxSubItem_mod.DataTypeName" Param1="CheckDTxxxxSubItem_mod.stringXmlValue">{0}.Subitem[0].BitOffs ({1}) shall be 0.</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckDTxxxxSubItem_mod.stringXmlValue</Value1>
						<Value2>"0"</Value2>
						<SetVariable Target="CheckDTxxxxSubItem_mod.result">false</SetVariable>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="SET_COMPLETE_BITSIZE">
				<!--CheckDTxxxxSubItem_mod.CompleteSubItemBitSize = 16-->
				<SetVariable Target="CheckDTxxxxSubItem_mod.CompleteSubItemBitSize">16</SetVariable>
			</TestStep>
			<TestStep Name="INCREMENT_LOOP_COUNTER">
				<!--CheckDTxxxxSubItem_mod.LoopCounter++-->
				<SetVariable Target="CheckDTxxxxSubItem_mod.LoopCounter">CheckDTxxxxSubItem_mod.LoopCounter + 1</SetVariable>
			</TestStep>
			<TestStep Name="CHECK_IF_FOLLOWING_SUBITEMS_DEFINED">
				<GetXmlValue FileName="CheckDTxxxxSubItem_mod.XmlFile" ReturnValue="CheckDTxxxxSubItem_mod.stringXmlValue" Markup="true">
					<XPath Param0="CheckDTxxxxSubItem_mod.XPath" Param1="CheckDTxxxxSubItem_mod.LoopCounter">{0}/SubItem[{1}]</XPath>
				</GetXmlValue>
				<!--Return if no following SubItems defined-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxSubItem_mod.stringXmlValue</Value1>
						<Value2>null</Value2>
						<GotoStep>TEST_END</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="LOOP_START">
				<!--Get SubItem [LoopCounter].Name-->
				<GetXmlValue ReturnValue="CheckDTxxxxSubItem_mod.xmlSubName" Markup="false" FileName="CheckDTxxxxSubItem_mod.XmlFile">
					<XPath Param0="CheckDTxxxxSubItem_mod.XPath" Param1="CheckDTxxxxSubItem_mod.LoopCounter">{0}/SubItem[{1}]/Name</XPath>
				</GetXmlValue>
				<!--Stop Test if last SubItem reached-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxSubItem_mod.xmlSubName</Value1>
						<Value2>null</Value2>
						<GotoStep>TEST_END</GotoStep>
					</Equal>
				</Compare>
				<!--The Name of SubItem [LoopCounter] shall be not ""-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxSubItem_mod.xmlSubName</Value1>
						<Value2>EmptyString</Value2>
						<WriteLine Id="10" Level="Error" Param0="CheckDTxxxxSubItem_mod.DataTypeName" Param1="(CheckDTxxxxSubItem_mod.LoopCounter-1)">{0}.Subitem[{1}].Name shall not be an empty string.</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxSubItem_mod.xmlSubName</Value1>
						<Value2>EmptyString</Value2>
						<SetVariable Target="CheckDTxxxxSubItem_mod.result">false</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Dump an Error and stop the loop if the third SubItem is defined within an Array object-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxSubItem_mod.bArrayObject</Value1>
						<Value2>true</Value2>
						<WriteLine Id="11" Level="Error">Only two SubItems shall be defined of array objects.</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxSubItem_mod.bArrayObject</Value1>
						<Value2>true</Value2>
						<SetVariable Target="CheckDTxxxxSubItem_mod.result">false</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxSubItem_mod.bArrayObject</Value1>
						<Value2>true</Value2>
						<GotoStep>TEST_END</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="GET_SUBITEM_CNT_SUBIDX">
				<!--Get SubItem[LoopCounter].SubIdx-->
				<GetXmlValue ReturnValue="CheckDTxxxxSubItem_mod.xmlSubIdx" Markup="false" FileName="CheckDTxxxxSubItem_mod.XmlFile">
					<XPath Param0="CheckDTxxxxSubItem_mod.XPath" Param1="CheckDTxxxxSubItem_mod.LoopCounter">{0}/SubItem[{1}]/SubIdx</XPath>
				</GetXmlValue>
				<Compare>
					<NotEqual>
						<Value1>CheckDTxxxxSubItem_mod.xmlSubIdx</Value1>
						<Value2>null</Value2>
						<WriteLine Id="12" Level="Verbose" Param0="CheckDTxxxxSubItem_mod.DataTypeName" Param1="(CheckDTxxxxSubItem_mod.LoopCounter-1)" Param2="CheckDTxxxxSubItem_mod.xmlSubIdx">{0}.SubItem[{1}].SubIdx : {2}</WriteLine>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="GET_SUBITEM_CNT_TYPE">
				<!--Get SubItem[LoopCounter].Type-->
				<GetXmlValue ReturnValue="CheckDTxxxxSubItem_mod.xmlSubType" Markup="false" FileName="CheckDTxxxxSubItem_mod.XmlFile">
					<XPath Param0="CheckDTxxxxSubItem_mod.XPath" Param1="CheckDTxxxxSubItem_mod.LoopCounter">{0}/SubItem[{1}]/Type</XPath>
				</GetXmlValue>
				<Compare>
					<NotEqual>
						<Value1>CheckDTxxxxSubItem_mod.xmlSubType</Value1>
						<Value2>null</Value2>
						<WriteLine Id="13" Level="Verbose" Param0="CheckDTxxxxSubItem_mod.DataTypeName" Param1="(CheckDTxxxxSubItem_mod.LoopCounter-1)" Param2="CheckDTxxxxSubItem_mod.xmlSubType">{0}.SubItem[{1}].Type : {2}</WriteLine>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="GET_SUBITEM_CNT_BITSIZE">
				<!--Get SubItem[LoopCounter].BitSize-->
				<GetXmlValue ReturnValue="CheckDTxxxxSubItem_mod.xmlSubItemBitSize" Markup="false" FileName="CheckDTxxxxSubItem_mod.XmlFile">
					<XPath Param0="CheckDTxxxxSubItem_mod.XPath" Param1="CheckDTxxxxSubItem_mod.LoopCounter">{0}/SubItem[{1}]/BitSize</XPath>
				</GetXmlValue>
				<Compare>
					<NotEqual>
						<Value1>CheckDTxxxxSubItem_mod.xmlSubItemBitSize</Value1>
						<Value2>null</Value2>
						<WriteLine Id="14" Level="Verbose" Param0="CheckDTxxxxSubItem_mod.DataTypeName" Param1="(CheckDTxxxxSubItem_mod.LoopCounter-1)" Param2="CheckDTxxxxSubItem_mod.xmlSubItemBitSize">{0}.SubItem[{1}].BitSize : {2}</WriteLine>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="GET_SUBITEM_CNT_BITOFFSET">
				<!--Get SubItem[LoopCounter].BitOffset-->
				<GetXmlValue ReturnValue="CheckDTxxxxSubItem_mod.xmlSubItemBitOffset" Markup="false" FileName="CheckDTxxxxSubItem_mod.XmlFile">
					<XPath Param0="CheckDTxxxxSubItem_mod.XPath" Param1="CheckDTxxxxSubItem_mod.LoopCounter">{0}/SubItem[{1}]/BitOffs</XPath>
				</GetXmlValue>
				<!--SubItem.BitOffs shall be defined.-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxSubItem_mod.xmlSubItemBitOffset</Value1>
						<Value2>null</Value2>
						<WriteLine Id="15" Level="Error" Param0="CheckDTxxxxSubItem_mod.DataTypeName" Param1="(CheckDTxxxxSubItem_mod.LoopCounter-1)">{0}.Subitem[{1}].BitOffs shall be defined.</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxSubItem_mod.xmlSubItemBitOffset</Value1>
						<Value2>null</Value2>
						<SetVariable Target="CheckDTxxxxSubItem_mod.result">false</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckDTxxxxSubItem_mod.xmlSubItemBitOffset</Value1>
						<Value2>null</Value2>
						<WriteLine Id="16" Level="Verbose" Param0="CheckDTxxxxSubItem_mod.DataTypeName" Param1="(CheckDTxxxxSubItem_mod.LoopCounter-1)" Param2="CheckDTxxxxSubItem_mod.xmlSubItemBitOffset">{0}.SubItem[{1}].BitOffs : {2}</WriteLine>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="CHECK_BITOFFSET">
				<!--The Bitoffset shall be greater or equal to the current BitSize-->
				<Compare>
					<Greater>
						<Value1>CheckDTxxxxSubItem_mod.CompleteSubItemBitSize</Value1>
						<Value2>CheckDTxxxxSubItem_mod.xmlSubItemBitOffset</Value2>
						<WriteLine Id="17" Level="Error" Param0="CheckDTxxxxSubItem_mod.DataTypeName" Param1="(CheckDTxxxxSubItem_mod.LoopCounter-1)" Param2="CheckDTxxxxSubItem_mod.xmlSubItemBitOffset" Param3="CheckDTxxxxSubItem_mod.CompleteSubItemBitSize">{0}.SubItem[{1}].BitOffs ({2}) is invalid (expected {3} or greater).</WriteLine>
					</Greater>
				</Compare>
				<Compare>
					<Greater>
						<Value1>CheckDTxxxxSubItem_mod.CompleteSubItemBitSize</Value1>
						<Value2>CheckDTxxxxSubItem_mod.xmlSubItemBitOffset</Value2>
						<SetVariable Target="CheckDTxxxxSubItem_mod.result">false</SetVariable>
					</Greater>
				</Compare>
			</TestStep>
			<TestStep Name="CHECK_OVERLAPPING_BYTE_BORDER">
				<!--Check if BitOffset is within a Byte-->
				<SetVariable Target="CheckDTxxxxSubItem_mod.i32TmpVar">CheckDTxxxxSubItem_mod.xmlSubItemBitOffset &amp; 7</SetVariable>
				<!--Proceed if the BitOffset is on a Byte border-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxSubItem_mod.i32TmpVar</Value1>
						<Value2>0</Value2>
						<GotoStep>DECIDE_IF_ARRAY_OR_DEFAULT_DEFINE</GotoStep>
					</Equal>
				</Compare>
				<!--Proceed if the BitSize is less than one Byte (for entries less than one Byte it is allowed to overlap Byte borders)-->
				<Compare>
					<Lower>
						<Value1>CheckDTxxxxSubItem_mod.xmlSubItemBitSize</Value1>
						<Value2>8</Value2>
						<GotoStep>DECIDE_IF_ARRAY_OR_DEFAULT_DEFINE</GotoStep>
					</Lower>
				</Compare>
			</TestStep>
			<TestStep Name="CHECK_SI0_PADDING">
				<!--A Byte border shall not be overlap if a BitOffset is within a Byte-->
				<SetVariable Target="CheckDTxxxxSubItem_mod.i32TmpVar">CheckDTxxxxSubItem_mod.i32TmpVar + CheckDTxxxxSubItem_mod.xmlSubItemBitSize</SetVariable>
				<Compare>
					<LowerOrEqual>
						<Value1>CheckDTxxxxSubItem_mod.i32TmpVar</Value1>
						<Value2>8</Value2>
						<GotoStep>DECIDE_IF_ARRAY_OR_DEFAULT_DEFINE</GotoStep>
					</LowerOrEqual>
				</Compare>
				<!--Dump an error if SI1 BitOffs != 16bit. SI0 shall be padded to 16bit.-->
				<Compare>
					<Equal>
						<Value1>debug_msg</Value1>
						<Value2>true</Value2>
						<WriteLine Id="18" Level="Verbose" Param0="CheckDTxxxxSubItem_mod.XPath" Param1="(CheckDTxxxxSubItem_mod.LoopCounter-1)">CHECKING {0}/SubItem[{1}]</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>(CheckDTxxxxSubItem_mod.LoopCounter - 1)</Value1>
						<Value2>1</Value2>
						<GotoStep>CHECK_SIn</GotoStep>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckDTxxxxSubItem_mod.xmlSubItemBitOffset</Value1>
						<Value2>16</Value2>
						<WriteLine Id="19" Level="Error" Param0="CheckDTxxxxSubItem_mod.DataTypeName" Param1="CheckDTxxxxSubItem_mod.xmlSubItemBitOffset">{0}.Subitem[1].BitOffs ({1}) shall be 16.</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckDTxxxxSubItem_mod.xmlSubItemBitOffset</Value1>
						<Value2>16</Value2>
						<GotoStep>DECIDE_IF_ARRAY_OR_DEFAULT_DEFINE</GotoStep>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="CHECK_SIn">
				<!--Dump only a warning if no complete access is supported-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxSubItem_mod.CompleteAccessSupported</Value1>
						<Value2>false</Value2>
						<WriteLine Id="20" Level="Warning" Param0="CheckDTxxxxSubItem_mod.DataTypeName" Param1="(CheckDTxxxxSubItem_mod.LoopCounter-1)" Param2="CheckDTxxxxSubItem_mod.xmlSubItemBitOffset">{0}.SubItem[{1}] should not overlap the Byte border (check BitOffs ({2}) or add alignment entry before).</WriteLine>
					</Equal>
				</Compare>
				<!--Dump an error if complete access is supported-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxSubItem_mod.CompleteAccessSupported</Value1>
						<Value2>true</Value2>
						<WriteLine Id="21" Level="Error" Param0="CheckDTxxxxSubItem_mod.DataTypeName" Param1="(CheckDTxxxxSubItem_mod.LoopCounter-1)" Param2="CheckDTxxxxSubItem_mod.xmlSubItemBitOffset">{0}.SubItem[{1}] shall not overlap the Byte border (check BitOffs ({2}) or add alignment entry before).</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxSubItem_mod.CompleteAccessSupported</Value1>
						<Value2>true</Value2>
						<SetVariable Target="CheckDTxxxxSubItem_mod.result">false</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="DECIDE_IF_ARRAY_OR_DEFAULT_DEFINE">
				<!--SubItem[LoopCounter].SubIdx not defined => "ARRAY_ITEM"
else "DEFAULT_SUBITEM"-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxSubItem_mod.xmlSubIdx</Value1>
						<Value2>null</Value2>
						<GotoStep>ARRAY_SUBITEM_TEST</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckDTxxxxSubItem_mod.xmlSubIdx</Value1>
						<Value2>null</Value2>
						<GotoStep>DEFAULT_SUBITEM_TEST</GotoStep>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="ARRAY_SUBITEM_TEST">
				<Description Id="22" Level="Verbose">Check array definition (no SubIdx for the second SubItem defined).</Description>
				<!--Dump an Error if the LoopCounter is <> 2 (the Array SubItem shall be the second one)-->
				<Compare>
					<NotEqual>
						<Value1>CheckDTxxxxSubItem_mod.LoopCounter</Value1>
						<Value2>2</Value2>
						<WriteLine Id="23" Level="Error">The Array SubItem shall be the second one.</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckDTxxxxSubItem_mod.LoopCounter</Value1>
						<Value2>2</Value2>
						<SetVariable Target="CheckDTxxxxSubItem_mod.result">false</SetVariable>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="CHECK_ARRAY_SUBITEM_TYPE">
				<Description Id="24" Level="Verbose">Check array definition (no SubIdx defined).</Description>
				<!--SubItem[LoopCounter].Type shall be defined-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxSubItem_mod.xmlSubType</Value1>
						<Value2>null</Value2>
						<WriteLine Id="25" Level="Error" Param0="CheckDTxxxxSubItem_mod.DataTypeName" Param1="CheckDTxxxxSubItem_mod.stringXmlValue">{0}.Subitem[0].Type shall be defined.</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxSubItem_mod.xmlSubType</Value1>
						<Value2>null</Value2>
						<SetVariable Target="CheckDTxxxxSubItem_mod.result">false</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxSubItem_mod.xmlSubType</Value1>
						<Value2>null</Value2>
						<GotoStep>CHECK_ARRAY_SUBITEM_BITSIZE</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--SubItem[LoopCounter].Type shall be "DTxxxxARR"-->
				<RegexIsMatch ReturnValue="CheckDTxxxxSubItem_mod.IsMatch">
					<Pattern>^(DT[0-9A-Fa-fXx]{1,4}ARR)$</Pattern>
					<InputString>CheckDTxxxxSubItem_mod.xmlSubType</InputString>
				</RegexIsMatch>
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxSubItem_mod.IsMatch</Value1>
						<Value2>false</Value2>
						<WriteLine Id="26" Level="Error" Param0="CheckDTxxxxSubItem_mod.DataTypeName" Param1="CheckDTxxxxSubItem_mod.xmlSubType">{0}.Subitem[0].Type ({1}) shall be "DTxxxxARR".</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxSubItem_mod.IsMatch</Value1>
						<Value2>false</Value2>
						<SetVariable Target="CheckDTxxxxSubItem_mod.result">false</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="ARRAY_SUBITEM_TEST_END">
				<!--Indicate that the object describe an array-->
				<SetVariable Target="CheckDTxxxxSubItem_mod.bArrayObject">true</SetVariable>
				<!--Goto Step "CHECK_SUBITEM_BITSIZE"-->
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>CHECK_SUBITEM_BITSIZE</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="DEFAULT_SUBITEM_TEST">
				<!--Definition of record object, check Type-->
				<RegexIsMatch ReturnValue="CheckDTxxxxSubItem_mod.IsMatch">
					<Pattern>^(BOOL|BIT|BIT[1-8]|BYTE|BITARR8|BITARR16|WORD|BITARR32|DWORD|SINT|INT|INT24|DINT|INT40|INT48|INT56|LINT|USINT|UINT|UINT24|UDINT|UINT40|UINT48|UINT56|ULINT|REAL|LREAL|(DT[0-9A-F]{1,4}EN([0-9]{2}))|(ARRAY \[0\.\.[0-9]+\] OF (BYTE|SINT|UINT|INT|DINT|UDINT))|(STRING\([0-9]+\)))$</Pattern>
					<InputString>CheckDTxxxxSubItem_mod.xmlSubType</InputString>
				</RegexIsMatch>
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxSubItem_mod.IsMatch</Value1>
						<Value2>false</Value2>
						<WriteLine Id="27" Level="Error" Param0="CheckDTxxxxSubItem_mod.DataTypeName" Param1="(CheckDTxxxxSubItem_mod.LoopCounter-1)" Param2="CheckDTxxxxSubItem_mod.xmlSubType">{0}.SubItem[{1}].Type ({2}) shall be BaseDataType or Enum.</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxSubItem_mod.IsMatch</Value1>
						<Value2>false</Value2>
						<SetVariable Target="CheckDTxxxxSubItem_mod.result">false</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CHECK_SUBITEM_BITSIZE">
				<!--Get XPath of the parent DataTypes-->
				<RegexReplace OutputString="CheckDTxxxxSubItem_mod.XPathDtBase">
					<Pattern>(\[[0-9]+\])$</Pattern>
					<InputString>CheckDTxxxxSubItem_mod.XPath</InputString>
					<ReplacementString>EmptyString</ReplacementString>
				</RegexReplace>
			</TestStep>
			<TestStep>
				<!--Get Type BitSize-->
				<CallTestFunction Name="DataTypeName.GetBitSize">
					<Parameter>CheckDTxxxxSubItem_mod.xmlSubType</Parameter>
					<Parameter>CheckDTxxxxSubItem_mod.XmlFile</Parameter>
					<Parameter>CheckDTxxxxSubItem_mod.XPathDtBase</Parameter>
					<OutParameter>CheckDTxxxxSubItem_mod.i32TmpVar</OutParameter>
				</CallTestFunction>
				<!--Dump an Error, update the result and goto "UPDATE_COMPLETE_BITSIZE" if Type is not defined-->
				<Compare>
					<Lower>
						<Value1>CheckDTxxxxSubItem_mod.i32TmpVar</Value1>
						<Value2>0</Value2>
						<WriteLine Id="28" Level="Error" Param0="CheckDTxxxxSubItem_mod.xmlSubType">The Type ({0}) is not defined in DataTypeList or BitSize is not defined.</WriteLine>
					</Lower>
				</Compare>
				<Compare>
					<Lower>
						<Value1>CheckDTxxxxSubItem_mod.i32TmpVar</Value1>
						<Value2>0</Value2>
						<SetVariable Target="CheckDTxxxxSubItem_mod.result">false</SetVariable>
					</Lower>
				</Compare>
				<Compare>
					<Lower>
						<Value1>CheckDTxxxxSubItem_mod.i32TmpVar</Value1>
						<Value2>0</Value2>
						<GotoStep>UPDATE_COMPLETE_BITSIZE</GotoStep>
					</Lower>
				</Compare>
				<!--Dump an Error, update result and goto "LOOP_END" if BitSize is not defined-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxSubItem_mod.xmlSubItemBitSize</Value1>
						<Value2>null</Value2>
						<WriteLine Id="29" Level="Error" Param0="CheckDTxxxxSubItem_mod.DataTypeName" Param1="(CheckDTxxxxSubItem_mod.LoopCounter-1)">{0}.SubItem[{1}].BitSize is not defined.</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxSubItem_mod.xmlSubItemBitSize</Value1>
						<Value2>null</Value2>
						<SetVariable Target="CheckDTxxxxSubItem_mod.result">false</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxSubItem_mod.xmlSubItemBitSize</Value1>
						<Value2>null</Value2>
						<GotoStep>LOOP_END</GotoStep>
					</Equal>
				</Compare>
				<!--Check if BitSize is unequal Type BitSize-->
				<Compare>
					<NotEqual>
						<Value1>CheckDTxxxxSubItem_mod.xmlSubItemBitSize</Value1>
						<Value2>CheckDTxxxxSubItem_mod.i32TmpVar</Value2>
						<WriteLine Id="30" Level="Error" Param0="CheckDTxxxxSubItem_mod.DataTypeName" Param1="(CheckDTxxxxSubItem_mod.LoopCounter-1)" Param2="CheckDTxxxxSubItem_mod.xmlSubItemBitSize" Param3="CheckDTxxxxSubItem_mod.i32TmpVar">{0}.SubItem[{1}].BitSize ({2}) shall be {3}.</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckDTxxxxSubItem_mod.xmlSubItemBitSize</Value1>
						<Value2>CheckDTxxxxSubItem_mod.i32TmpVar</Value2>
						<SetVariable Target="CheckDTxxxxSubItem_mod.result">false</SetVariable>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="UPDATE_COMPLETE_BITSIZE">
				<!--The BitOffset shall be defined-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxSubItem_mod.xmlSubItemBitOffset</Value1>
						<Value2>null</Value2>
						<WriteLine Id="31" Level="Error" Param0="CheckDTxxxxSubItem_mod.DataTypeName" Param1="CheckDTxxxxSubItem_mod.LoopCounter">{0}.SubItem[{1}].BitOffs is not defined.</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxSubItem_mod.xmlSubItemBitOffset</Value1>
						<Value2>null</Value2>
						<SetVariable Target="CheckDTxxxxSubItem_mod.result">false</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxSubItem_mod.xmlSubItemBitOffset</Value1>
						<Value2>null</Value2>
						<GotoStep>LOOP_END</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--CompleteBitSize = BitOffs + BitSize-->
				<SetVariable Target="CheckDTxxxxSubItem_mod.CompleteSubItemBitSize">CheckDTxxxxSubItem_mod.xmlSubItemBitOffset + CheckDTxxxxSubItem_mod.xmlSubItemBitSize</SetVariable>
			</TestStep>
			<TestStep Name="LOOP_END">
				<!--Update Previous SubIdx-->
				<SetVariable Target="CheckDTxxxxSubItem_mod.xmlPrevSubIdx">CheckDTxxxxSubItem_mod.xmlSubIdx</SetVariable>
			</TestStep>
			<TestStep>
				<!--CheckDTxxxxSubItem_mod.LoopCounter ++-->
				<SetVariable Target="CheckDTxxxxSubItem_mod.LoopCounter">CheckDTxxxxSubItem_mod.LoopCounter + 1</SetVariable>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>LOOP_START</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="TEST_END">
				<!--Update return value-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxSubItem_mod.result</Value1>
						<Value2>false</Value2>
						<SetVariable Target="CheckDTxxxxSubItem_mod.CompleteSubItemBitSize">-1</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxSubItem_mod.result</Value1>
						<Value2>false</Value2>
						<Return Id="32"></Return>
					</Equal>
				</Compare>
				<!--If only Subindex 0 is defined set total bit size to 8-->
				<Compare>
					<Equal>
						<Value1>CheckDTxxxxSubItem_mod.LoopCounter</Value1>
						<Value2>2</Value2>
						<SetVariable Target="CheckDTxxxxSubItem_mod.CompleteSubItemBitSize">8</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction Name="CheckFixedBaseDataType" FunctionId="206">
			<?MAX_OUTPUT_ID 12?>
			<!--Function for Device DataType Tests-->
			<Description>
				<Action>Check the definition of a base DataType with a fixed length</Action>
				<PostCondition></PostCondition>
				<References>
					<Reference Specification="ETG.1020"></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>CheckFixedBaseDataType.XmlFile</Name>
				<Type>String</Type>
				<Comment>Path of the xml file (absolute or relative to the ESI file). If the parameter is null or empty the current device description will be referenced.</Comment>
			</Parameter>
			<Parameter>
				<Name>CheckFixedBaseDataType.XPath</Name>
				<Type>String</Type>
				<Comment>XPath of the current DataType</Comment>
			</Parameter>
			<LocalVariables>
				<Name>CheckFixedBaseDataType.stringXmlValue</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckFixedBaseDataType.IsMatch</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckFixedBaseDataType.DataTypeName</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckFixedBaseDataType.xmlBitSize</Name>
				<Type>Int32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckFixedBaseDataType.TmpResult</Name>
				<Type>String</Type>
			</LocalVariables>
			<OutParameter>
				<Name>CheckFixedBaseDataType.Result</Name>
				<Type>Bool</Type>
				<!--If true base data type test was sucessful-->
			</OutParameter>
			<TestStep Name="INIT_RESULT">
				<!--Init Result = true-->
				<SetVariable Target="CheckFixedBaseDataType.Result">true</SetVariable>
			</TestStep>
			<TestStep Name="INIT_FILE_PARAMETER">
				<!--if parameter is null set value to emptystring-->
				<Compare>
					<Equal>
						<Value1>CheckFixedBaseDataType.XmlFile</Value1>
						<Value2>null</Value2>
						<SetVariable Target="CheckFixedBaseDataType.XmlFile">EmptyString</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CHECK_IF_XPATH_EXISITS">
				<GetXmlValue ReturnValue="CheckFixedBaseDataType.stringXmlValue" Markup="true" FileName="CheckFixedBaseDataType.XmlFile">
					<XPath Param0="CheckFixedBaseDataType.XPath">{0}</XPath>
				</GetXmlValue>
				<!--Dump an Error if XPath is not defined is defined-->
				<Compare>
					<Equal>
						<Value1>CheckFixedBaseDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<WriteLine Id="0" Level="Error" Param0="CheckFixedBaseDataType.XPath" Param1="CheckFixedBaseDataType.XmlFile">The XPath "{0}" (File:{1}) is not defined.</WriteLine>
					</Equal>
				</Compare>
				<!--Update Error Variable-->
				<Compare>
					<Equal>
						<Value1>CheckFixedBaseDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<SetVariable Target="CheckFixedBaseDataType.Result">false</SetVariable>
					</Equal>
				</Compare>
				<!--return-->
				<Compare>
					<Equal>
						<Value1>CheckFixedBaseDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<Return Id="1"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="GET_DATATYPE_NAME">
				<!--Get DataType name from local dictionary-->
				<GetXmlValue ReturnValue="CheckFixedBaseDataType.stringXmlValue" Markup="false" FileName="CheckFixedBaseDataType.XmlFile">
					<XPath Param0="CheckFixedBaseDataType.XPath">
						<!--the elements starts to count with 1 but the index is zero based-->{0}/Name</XPath>
				</GetXmlValue>
				<!--Dump an Error if no name is defined-->
				<Compare>
					<Equal>
						<Value1>CheckFixedBaseDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<WriteLine Id="2" Level="Error" Param0="CheckFixedBaseDataType.XPath" Param1="CheckFixedBaseDataType.XmlFile">A DataType name shall be defined. at File '{1}' XPath '{2}'</WriteLine>
					</Equal>
				</Compare>
				<!--Update Error Variable-->
				<Compare>
					<Equal>
						<Value1>CheckFixedBaseDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<SetVariable Target="CheckFixedBaseDataType.Result">false</SetVariable>
					</Equal>
				</Compare>
				<!--return-->
				<Compare>
					<Equal>
						<Value1>CheckFixedBaseDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<Return Id="3"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="Check_IF_NAME_IS_VALID">
				<!--Check if Name is valid-->
				<RegexIsMatch ReturnValue="CheckFixedBaseDataType.IsMatch">
					<Pattern>^(BOOL|BIT|BIT[1-8]|BYTE|BITARR8|BITARR16|WORD|BITARR32|DWORD|SINT|INT|INT24|DINT|INT40|INT48|INT56|LINT|USINT|UINT|UINT24|UDINT|UINT40|UINT48|UINT56|ULINT|REAL|LREAL|GUID)$</Pattern>
					<InputString>CheckFixedBaseDataType.stringXmlValue</InputString>
				</RegexIsMatch>
				<!--Dump info if name is invalid-->
				<Compare>
					<Equal>
						<Value1>CheckFixedBaseDataType.IsMatch</Value1>
						<Value2>false</Value2>
						<WriteLine Id="4" Level="Verbose" Param0="CheckFixedBaseDataType.stringXmlValue">Invalid DataType name ({0}) passed to function "CheckFixedBaseDataType". Only baseDataTypes with fixed length are allowed.</WriteLine>
					</Equal>
				</Compare>
				<!--Set Result to false-->
				<Compare>
					<Equal>
						<Value1>CheckFixedBaseDataType.IsMatch</Value1>
						<Value2>false</Value2>
						<SetVariable Target="CheckFixedBaseDataType.Result">false</SetVariable>
					</Equal>
				</Compare>
				<!--Return-->
				<Compare>
					<Equal>
						<Value1>CheckFixedBaseDataType.IsMatch</Value1>
						<Value2>false</Value2>
						<Return Id="5"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Store DataType name in "CheckFixedBaseDataType.DataTypeName"-->
				<SetVariable Target="CheckFixedBaseDataType.DataTypeName">CheckFixedBaseDataType.stringXmlValue</SetVariable>
			</TestStep>
			<TestStep Name="GET_BASETYPE_ELEMENT">
				<!--The Element BaseType shall not be defined for base DataTypes with fixed length-->
				<GetXmlValue ReturnValue="CheckFixedBaseDataType.stringXmlValue" Markup="false" FileName="CheckFixedBaseDataType.XmlFile">
					<XPath Param0="CheckFixedBaseDataType.XPath">{0}/BaseType</XPath>
				</GetXmlValue>
				<Compare>
					<NotEqual>
						<Value1>CheckFixedBaseDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<WriteLine Id="6" Level="Error" Param0="CheckFixedBaseDataType.DataTypeName" Param1="CheckFixedBaseDataType.XmlFile" Param2="CheckFixedBaseDataType.XPath">{0}.BaseType shall not be defined. at File '{1}' XPath '{2}'</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckFixedBaseDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<SetVariable Target="CheckFixedBaseDataType.Result">false</SetVariable>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="GET_ARRAYINFO_ELEMENT">
				<!--The Element ArrayInfo shall not be defined for base DataTypes with fixed length-->
				<GetXmlValue ReturnValue="CheckFixedBaseDataType.stringXmlValue" Markup="false" FileName="CheckFixedBaseDataType.XmlFile">
					<XPath Param0="CheckFixedBaseDataType.XPath">{0}/ArrayInfo</XPath>
				</GetXmlValue>
				<Compare>
					<NotEqual>
						<Value1>CheckFixedBaseDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<WriteLine Id="7" Level="Error" Param0="CheckFixedBaseDataType.DataTypeName" Param1="CheckFixedBaseDataType.XmlFile" Param2="CheckFixedBaseDataType.XPath">{0}.ArrayInfo shall not be defined. at File '{1}' XPath '{2}'</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckFixedBaseDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<SetVariable Target="CheckFixedBaseDataType.Result">false</SetVariable>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="GET_SUBITEM_ELEMENT">
				<!--The Element SubItem shall not be defined for base DataTypes with fixed length-->
				<GetXmlValue ReturnValue="CheckFixedBaseDataType.stringXmlValue" Markup="false" FileName="CheckFixedBaseDataType.XmlFile">
					<XPath Param0="CheckFixedBaseDataType.XPath">{0}/SubItem</XPath>
				</GetXmlValue>
				<Compare>
					<NotEqual>
						<Value1>CheckFixedBaseDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<WriteLine Id="8" Level="Error" Param0="CheckFixedBaseDataType.DataTypeName" Param1="CheckFixedBaseDataType.XmlFile" Param2="CheckFixedBaseDataType.XPath">{0}.SubItem shall not be defined. at File '{1}' XPath '{2}'</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckFixedBaseDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<SetVariable Target="CheckFixedBaseDataType.Result">false</SetVariable>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="GET_ENUMINFO_ELEMENT">
				<!--The Element EnumInfo shall not be defined for base DataTypes with fixed length-->
				<GetXmlValue ReturnValue="CheckFixedBaseDataType.stringXmlValue" Markup="false" FileName="CheckFixedBaseDataType.XmlFile">
					<XPath Param0="CheckFixedBaseDataType.XPath">{0}/EnumInfo</XPath>
				</GetXmlValue>
				<Compare>
					<NotEqual>
						<Value1>CheckFixedBaseDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<WriteLine Id="9" Level="Error" Param0="CheckFixedBaseDataType.DataTypeName" Param1="CheckFixedBaseDataType.XmlFile" Param2="CheckFixedBaseDataType.XPath">{0}.EnumInfo shall not be defined. at File '{1}' XPath '{2}'</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckFixedBaseDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<SetVariable Target="CheckFixedBaseDataType.Result">false</SetVariable>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="CHECK_BITSIZE">
				<!--The element BitSize shall be defined.-->
				<GetXmlValue ReturnValue="CheckFixedBaseDataType.xmlBitSize" Markup="false" FileName="CheckFixedBaseDataType.XmlFile">
					<XPath Param0="CheckFixedBaseDataType.XPath">{0}/BitSize</XPath>
				</GetXmlValue>
				<!--Dump Error if BitSize not defined-->
				<Compare>
					<Equal>
						<Value1>CheckFixedBaseDataType.xmlBitSize</Value1>
						<Value2>null</Value2>
						<WriteLine Id="10" Level="Error" Param0="CheckFixedBaseDataType.DataTypeName" Param1="CheckFixedBaseDataType.XmlFile" Param2="CheckFixedBaseDataType.XPath">{0}.BitSize shall be defined. at File '{1}' XPath '{2}'</WriteLine>
					</Equal>
				</Compare>
				<!--Update result (to false)-->
				<Compare>
					<Equal>
						<Value1>CheckFixedBaseDataType.xmlBitSize</Value1>
						<Value2>null</Value2>
						<SetVariable Target="CheckFixedBaseDataType.Result">false</SetVariable>
					</Equal>
				</Compare>
				<!--return-->
				<Compare>
					<Equal>
						<Value1>CheckFixedBaseDataType.xmlBitSize</Value1>
						<Value2>null</Value2>
						<Return Id="11"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--The defined BitSize shall match the DataType name-->
				<CallTestFunction Name="BaseDataType.CheckSize">
					<Parameter>CheckFixedBaseDataType.xmlBitSize</Parameter>
					<Parameter>CheckFixedBaseDataType.DataTypeName</Parameter>
					<OutParameter>CheckFixedBaseDataType.TmpResult</OutParameter>
				</CallTestFunction>
				<!--Dump Error if BitSize not match-->
				<Compare>
					<NotEqual>
						<Value1>CheckFixedBaseDataType.TmpResult</Value1>
						<Value2>EmptyString</Value2>
						<WriteLine Id="12" Level="Error" Param0="CheckFixedBaseDataType.xmlBitSize" Param1="CheckFixedBaseDataType.DataTypeName" Param2="CheckFixedBaseDataType.XPath" Param3="CheckFixedBaseDataType.XmlFile">{1}.BitSize ({0}) is invalid. at File '{3}' XPath '{2}'</WriteLine>
					</NotEqual>
				</Compare>
				<!--Update result (to false)-->
				<Compare>
					<NotEqual>
						<Value1>CheckFixedBaseDataType.TmpResult</Value1>
						<Value2>EmptyString</Value2>
						<SetVariable Target="CheckFixedBaseDataType.Result">false</SetVariable>
					</NotEqual>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction Name="CheckFMMUCat" FunctionId="301">
			<?MAX_OUTPUT_ID 22?>
			<TestStep>
				<SetVariable Target="cmpDefString">Outputs</SetVariable>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Fmmu[index]</Value1>
						<Value2>cmpDefString</Value2>
						<WriteLine Id="0" Param0="DeviceDescr.Fmmu[index]" Param1="index">EtherCAT Slave Information File FMMU {1:d}: {0}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Fmmu[index]</Value1>
						<Value2>cmpDefString</Value2>
						<GotoStep>Outputs</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<SetVariable Target="cmpDefString">Inputs</SetVariable>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Fmmu[index]</Value1>
						<Value2>cmpDefString</Value2>
						<WriteLine Id="1" Param0="DeviceDescr.Fmmu[index]" Param1="index">EtherCAT Slave Information File  FMMU {1:d}: {0}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Fmmu[index]</Value1>
						<Value2>cmpDefString</Value2>
						<GotoStep>Inputs</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<SetVariable Target="cmpDefString">MBoxState</SetVariable>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Fmmu[index]</Value1>
						<Value2>cmpDefString</Value2>
						<WriteLine Id="2" Param0="DeviceDescr.Fmmu[index]" Param1="index">EtherCAT Slave Information File FMMU {1:d}: {0}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Fmmu[index]</Value1>
						<Value2>cmpDefString</Value2>
						<GotoStep>MBoxState</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<SetVariable Target="cmpDefString">DynamicOutputs</SetVariable>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Fmmu[index]</Value1>
						<Value2>cmpDefString</Value2>
						<WriteLine Id="15" Param0="DeviceDescr.Fmmu[index]" Param1="index">EtherCAT Slave Information File FMMU {1:d}: {0}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Fmmu[index]</Value1>
						<Value2>cmpDefString</Value2>
						<GotoStep>DynamicOutputs</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<SetVariable Target="cmpDefString">DynamicInputs</SetVariable>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Fmmu[index]</Value1>
						<Value2>cmpDefString</Value2>
						<WriteLine Id="16" Param0="DeviceDescr.Fmmu[index]" Param1="index">EtherCAT Slave Information File FMMU {1:d}: {0}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Fmmu[index]</Value1>
						<Value2>cmpDefString</Value2>
						<GotoStep>DynamicInputs</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<WriteLine Id="3" Level="Verbose" Param0="EEPROM.CatFMMU[index]" Param1="index">EEPROM Category FMMU {1:d}: {0}</WriteLine>
				<Compare>
					<NotEqual>
						<Value1>EEPROM.CatFMMU[index]</Value1>
						<Value2>0</Value2>
						<RaiseError Id="4" Param0="index">E²PROM Fmmu[{0:d}] is set to 0 (not used)</RaiseError>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>EEPROM.CatFMMU[index]</Value1>
						<Value2>0</Value2>
						<Return Id="5"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="DynamicInputs">
				<WriteLine Id="17" Level="Verbose" Param0="EEPROM.CatFMMU[index]" Param1="index">EEPROM Category FMMU {1:d}: {0}</WriteLine>
				<Compare>
					<NotEqual>
						<Value1>EEPROM.CatFMMU[index]</Value1>
						<Value2>6</Value2>
						<RaiseError Id="18" Param0="index">EEPROM.CatFMMU {0} should be used for 'DynamicInputs'</RaiseError>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>EEPROM.CatFMMU[index]</Value1>
						<Value2>6</Value2>
						<Return Id="19"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="DynamicOutputs">
				<WriteLine Id="20" Level="Verbose" Param0="EEPROM.CatFMMU[index]" Param1="index">EEPROM Category FMMU {1:d}: {0}</WriteLine>
				<Compare>
					<NotEqual>
						<Value1>EEPROM.CatFMMU[index]</Value1>
						<Value2>5</Value2>
						<RaiseError Id="21" Param0="index">EEPROM.CatFMMU {0} should be used for 'DynamicOutputs'</RaiseError>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>EEPROM.CatFMMU[index]</Value1>
						<Value2>5</Value2>
						<Return Id="22"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="Outputs">
				<WriteLine Id="6" Level="Verbose" Param0="EEPROM.CatFMMU[index]" Param1="index">EEPROM Category FMMU {1:d}: {0}</WriteLine>
				<Compare>
					<NotEqual>
						<Value1>EEPROM.CatFMMU[index]</Value1>
						<Value2>1</Value2>
						<RaiseError Id="7" Param0="index">EEPROM.CatFMMU {0} should be used for 'Outputs'</RaiseError>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>EEPROM.CatFMMU[index]</Value1>
						<Value2>1</Value2>
						<Return Id="8"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="Inputs">
				<WriteLine Id="9" Level="Verbose" Param0="EEPROM.CatFMMU[index]" Param1="index">EEPROM Category FMMU {1:d}: {0}</WriteLine>
				<Compare>
					<NotEqual>
						<Value1>EEPROM.CatFMMU[index]</Value1>
						<Value2>2</Value2>
						<RaiseError Id="10" Param0="index">EEPROM.CatFMMU {0} should be used for 'Inputs'</RaiseError>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>EEPROM.CatFMMU[index]</Value1>
						<Value2>2</Value2>
						<Return Id="11"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="MBoxState">
				<WriteLine Id="12" Level="Verbose" Param0="EEPROM.CatFMMU[index]" Param1="index">EEPROM Category FMMU {1:d}: {0}</WriteLine>
				<Compare>
					<NotEqual>
						<Value1>EEPROM.CatFMMU[index]</Value1>
						<Value2>3</Value2>
						<RaiseError Id="13">EEPROM.CatFMMU {0} should be used for SyncM Status(Read Mailbox)'</RaiseError>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>EEPROM.CatFMMU[index]</Value1>
						<Value2>3</Value2>
						<Return Id="14"></Return>
					</Equal>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction Name="CheckFmmuElements" FunctionId="302">
			<?MAX_OUTPUT_ID 29?>
			<!--Check Fmmu Elements-->
			<LocalVariables>
				<Name>CheckFmmuElements.u8_EscFmmu</Name>
				<Type>Byte</Type>
				<!--number of FMMUs supported by ESC-->
			</LocalVariables>
			<LocalVariables>
				<Name>CheckFmmuElements.b_succeed</Name>
				<Type>Bool</Type>
				<!--indicates if the test was successful-->
			</LocalVariables>
			<LocalVariables>
				<Name>CheckFmmuElements.u16_index</Name>
				<Type>UInt16</Type>
				<!--counter vairable for loops-->
			</LocalVariables>
			<LocalVariables>
				<Name>CheckFmmuElements.i32_OutSm</Name>
				<Type>Int32</Type>
				<!--Indicates to first (enabled) output Sm-->
			</LocalVariables>
			<LocalVariables>
				<Name>CheckFmmuElements.i32_InSm</Name>
				<Type>Int32</Type>
				<!--Indicates to first (enabled) input Sm-->
			</LocalVariables>
			<LocalVariables>
				<Name>CheckFmmuElements.i32_OutMbxSm</Name>
				<Type>Int32</Type>
				<!--Indicates to first (enabled) OutMbx Sm-->
			</LocalVariables>
			<LocalVariables>
				<Name>CheckFmmuElements.i32_RefSM</Name>
				<Type>Int32</Type>
				<!--Referenced SM in FMMU-->
			</LocalVariables>
			<LocalVariables>
				<Name>CheckFmmuElements.str_SmOutputs</Name>
				<Type>String</Type>
				<!--String for Output SyncManager-->
			</LocalVariables>
			<LocalVariables>
				<Name>CheckFmmuElements.str_SmInputs</Name>
				<Type>String</Type>
				<!--String for Inputs SyncManager-->
			</LocalVariables>
			<LocalVariables>
				<Name>CheckFmmuElements.str_SmMBoxOut</Name>
				<Type>String</Type>
				<!--String for Out Mailbox SyncManager-->
			</LocalVariables>
			<TestStep Name="INIT_LOOPINDEX">
				<!--Throw initialization message.-->
				<SetVariable Target="CheckFmmuElements.u16_index">0</SetVariable>
			</TestStep>
			<TestStep Name="DUMP_NUMBER_OF_DEFINED_FMMUS">
				<!--Dump number of FMMUs-->
				<WriteLine Id="0" Level="Verbose" Param0="DeviceDescr.Fmmu.Count">Device contains {0} FMMU description(s).</WriteLine>
			</TestStep>
			<TestStep>
				<!--Check if FMMUs defined-->
				<Compare>
					<NotEqual>
						<Value1>DeviceDescr.Fmmu.Count</Value1>
						<Value2>0</Value2>
						<GotoStep>START</GotoStep>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>DeviceDescr.SM.Count</Value1>
						<Value2>0</Value2>
						<GotoStep>START</GotoStep>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>True</Value1>
						<Value2>True</Value2>
						<SkipCase Id="1">Skip test: no FMMU and no SyncManager are defined.</SkipCase>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="START">
				<!--CheckFmmuElements.u8_EscFmmu = 16 (maximum number of FMMUs)-->
				<SetVariable Target="CheckFmmuElements.u8_EscFmmu">16</SetVariable>
			</TestStep>
			<TestStep>
				<Compare>
					<Equal>
						<Value1>Offline</Value1>
						<Value2>true</Value2>
						<WriteLine Id="2" Level="Verbose">Test in offline mode (number of supported FMMUs by the ESC will be set to 16).</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>Offline</Value1>
						<Value2>true</Value2>
						<GotoStep>TEST_START</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CHECK_ESC_FMMUS">
				<!--Get number of supported Fmmus by ESC-->
				<ReadEscData Target="CheckFmmuElements.u8_EscFmmu">
					<Address>5</Address>
				</ReadEscData>
				<Compare>
					<Lower>
						<Value1>CheckFmmuElements.u8_EscFmmu</Value1>
						<Value2>DeviceDescr.Fmmu.Count</Value2>
						<WriteLine Id="3" Level="Error">The ESC supports less FMMUs than used in ESI file</WriteLine>
					</Lower>
				</Compare>
				<Compare>
					<Lower>
						<Value1>CheckFmmuElements.u8_EscFmmu</Value1>
						<Value2>DeviceDescr.Fmmu.Count</Value2>
						<SetVariable Target="CheckFmmuElements.b_succeed">False</SetVariable>
					</Lower>
				</Compare>
				<Compare>
					<GreaterOrEqual>
						<Value1>CheckFmmuElements.u8_EscFmmu</Value1>
						<Value2>DeviceDescr.Fmmu.Count</Value2>
						<WriteLine Id="4" Level="Verbose" Param0="CheckFmmuElements.u8_EscFmmu">ESC supports {0} FMMU(s).</WriteLine>
					</GreaterOrEqual>
				</Compare>
			</TestStep>
			<TestStep Name="TEST_START">
				<!--Set "CheckFmmuElements.i32_OutSm" = -1-->
				<SetVariable Target="CheckFmmuElements.i32_OutSm">-1</SetVariable>
			</TestStep>
			<TestStep>
				<!--Set "CheckFmmuElements.i32_InSm" = -1-->
				<SetVariable Target="CheckFmmuElements.i32_InSm">-1</SetVariable>
			</TestStep>
			<TestStep>
				<!--Set "CheckFmmuElements.i32_OutMbxSm" = -1-->
				<SetVariable Target="CheckFmmuElements.i32_OutMbxSm">-1</SetVariable>
			</TestStep>
			<TestStep>
				<!--Set "CheckFmmuElements.str_SmOutputs" = Outputs-->
				<SetVariable Target="CheckFmmuElements.str_SmOutputs">Outputs</SetVariable>
			</TestStep>
			<TestStep>
				<!--Set "CheckFmmuElements.str_SmInputs" = Inputs-->
				<SetVariable Target="CheckFmmuElements.str_SmInputs">Inputs</SetVariable>
			</TestStep>
			<TestStep>
				<!--Set "CheckFmmuElements.str_SmMBoxOut" = MBoxOut-->
				<SetVariable Target="CheckFmmuElements.str_SmMBoxOut">MBoxOut</SetVariable>
			</TestStep>
			<TestStep>
				<!--Set "CheckFmmuElements.b_succeed" = TRUE-->
				<SetVariable Target="CheckFmmuElements.b_succeed">True</SetVariable>
			</TestStep>
			<TestStep>
				<!--Get SyncManager Indicies-->
				<WriteLine Id="5" Level="Verbose">Get SyncManager Indicioes</WriteLine>
			</TestStep>
			<TestStep Name="SMLOOPSTART">
				<Compare>
					<Equal>
						<Value1>DeviceDescr.SM.Count</Value1>
						<Value2>0</Value2>
						<GotoStep>FMMUCHECK</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.SM[CheckFmmuElements.u16_index]</Value1>
						<Value2>CheckFmmuElements.str_SmOutputs</Value2>
						<GotoStep>OUTPUTSM</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.SM[CheckFmmuElements.u16_index]</Value1>
						<Value2>CheckFmmuElements.str_SmInputs</Value2>
						<GotoStep>INPUTSM</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.SM[CheckFmmuElements.u16_index]</Value1>
						<Value2>CheckFmmuElements.str_SmMBoxOut</Value2>
						<GotoStep>OUTMBXSM</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>True</Value1>
						<Value2>True</Value2>
						<GotoStep>SMLOOPEND</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="OUTPUTSM">
				<Compare>
					<GreaterOrEqual>
						<Value1>CheckFmmuElements.i32_OutSm</Value1>
						<Value2>0</Value2>
						<GotoStep>SMLOOPEND</GotoStep>
					</GreaterOrEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.SM[CheckFmmuElements.u16_index].Enable</Value1>
						<Value2>True</Value2>
						<SetVariable Target="CheckFmmuElements.i32_OutSm">CheckFmmuElements.u16_index</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>True</Value1>
						<Value2>True</Value2>
						<WriteLine Id="6" Level="Verbose" Param0="CheckFmmuElements.i32_OutSm">Process data output SyncManager found (SM {0} )</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>True</Value1>
						<Value2>True</Value2>
						<GotoStep>SMLOOPEND</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="INPUTSM">
				<Compare>
					<GreaterOrEqual>
						<Value1>CheckFmmuElements.i32_InSm</Value1>
						<Value2>0</Value2>
						<GotoStep>SMLOOPEND</GotoStep>
					</GreaterOrEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.SM[CheckFmmuElements.u16_index].Enable</Value1>
						<Value2>True</Value2>
						<SetVariable Target="CheckFmmuElements.i32_InSm">CheckFmmuElements.u16_index</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>True</Value1>
						<Value2>True</Value2>
						<WriteLine Id="7" Level="Verbose" Param0="CheckFmmuElements.i32_InSm">Process data input SyncManager found (SM {0} )</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>True</Value1>
						<Value2>True</Value2>
						<GotoStep>SMLOOPEND</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="OUTMBXSM">
				<Compare>
					<GreaterOrEqual>
						<Value1>CheckFmmuElements.i32_OutMbxSm</Value1>
						<Value2>0</Value2>
						<GotoStep>SMLOOPEND</GotoStep>
					</GreaterOrEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.SM[CheckFmmuElements.u16_index].Enable</Value1>
						<Value2>True</Value2>
						<SetVariable Target="CheckFmmuElements.i32_OutMbxSm">CheckFmmuElements.u16_index</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>True</Value1>
						<Value2>True</Value2>
						<WriteLine Id="8" Level="Verbose" Param0="CheckFmmuElements.i32_OutMbxSm">Output mailbox SyncManager found (SM {0} )</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>True</Value1>
						<Value2>True</Value2>
						<GotoStep>SMLOOPEND</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="SMLOOPEND">
				<SetVariable Target="CheckFmmuElements.u16_index">CheckFmmuElements.u16_index + 1</SetVariable>
				<Compare>
					<Lower>
						<Value1>CheckFmmuElements.u16_index</Value1>
						<Value2>DeviceDescr.SM.Count</Value2>
						<GotoStep>SMLOOPSTART</GotoStep>
					</Lower>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Check if FMMU Loop need to be skipped (if no FMMU is defined)-->
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Fmmu.Count</Value1>
						<Value2>0</Value2>
						<GotoStep>FINALSMCHECK</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Start iteration over all FMMUs-->
				<SetVariable Target="CheckFmmuElements.u16_index">0</SetVariable>
				<WriteLine Id="9" Level="Verbose">Start to Iterate over all SyncManager</WriteLine>
			</TestStep>
			<TestStep Name="FMMUCHECK">
				<!---->
				<SetVariable Target="CheckFmmuElements.i32_RefSM">-1</SetVariable>
			</TestStep>
			<TestStep>
				<!--Check FMMU matchings. Dump error if FMMU name is not matching
Inputs
Outputs
MboxState-->
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Fmmu[CheckFmmuElements.u16_index]</Value1>
						<Value2>Inputs</Value2>
						<GotoStep>INPUTS</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Fmmu[CheckFmmuElements.u16_index]</Value1>
						<Value2>Outputs</Value2>
						<GotoStep>OUTPUTS</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Fmmu[CheckFmmuElements.u16_index]</Value1>
						<Value2>MBoxState</Value2>
						<GotoStep>MBXSTATE</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>True</Value1>
						<Value2>True</Value2>
						<WriteLine Id="10" Level="Error" Param0="DeviceDescr.Fmmu[CheckFmmuElements.u16_index]" Param1="CheckFmmuElements.u16_index">Fmmu[{1}].Text ({0}) invalid. Expect "Outputs", "Inputs" or "MBoxState".</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>True</Value1>
						<Value2>True</Value2>
						<SetVariable Target="CheckFmmuElements.b_succeed">False</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>True</Value1>
						<Value2>True</Value2>
						<GotoStep>NEXT</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="OUTPUTS">
				<!--Output Fmmu found-->
				<Description Id="11" Level="Verbose" Param0="CheckFmmuElements.u16_index" Param1="DeviceDescr.Fmmu[CheckFmmuElements.u16_index]">Device:Fmmu[{0}] - {1}</Description>
				<Compare>
					<Lower>
						<Value1>CheckFmmuElements.i32_OutSm</Value1>
						<Value2>0</Value2>
						<WriteLine Id="12" Level="Warning">No process data output SyncManager defined or disabled. Remove "Outputs" FMMU or define a output SM.</WriteLine>
					</Lower>
				</Compare>
				<Compare>
					<Equal>
						<Value1>True</Value1>
						<Value2>True</Value2>
						<SetVariable Target="CheckFmmuElements.i32_OutSm">-1</SetVariable>
						<!--Reset SM indication variable to check which SM is handled by FMMU-->
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Check if Referenced SM is valid-->
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Fmmu[CheckFmmuElements.u16_index].Sm</Value1>
						<Value2>null</Value2>
						<GotoStep>NEXT</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!---->
				<SetVariable Target="CheckFmmuElements.i32_RefSM">DeviceDescr.Fmmu[CheckFmmuElements.u16_index].Sm</SetVariable>
				<Compare>
					<GreaterOrEqual>
						<Value1>CheckFmmuElements.i32_RefSM</Value1>
						<Value2>DeviceDescr.SM.Count</Value2>
						<WriteLine Id="13" Level="Error" Param0="DeviceDescr.Fmmu[CheckFmmuElements.u16_index].Sm" Param1="CheckFmmuElements.u16_index">Non defined SyncManager (SM{0}) is referenced in FMMU{1}</WriteLine>
					</GreaterOrEqual>
				</Compare>
				<Compare>
					<GreaterOrEqual>
						<Value1>CheckFmmuElements.i32_RefSM</Value1>
						<Value2>DeviceDescr.SM.Count</Value2>
						<SetVariable Target="CheckFmmuElements.b_succeed">False</SetVariable>
					</GreaterOrEqual>
				</Compare>
				<Compare>
					<GreaterOrEqual>
						<Value1>DeviceDescr.Fmmu[CheckFmmuElements.u16_index].Sm</Value1>
						<Value2>DeviceDescr.SM.Count</Value2>
						<GotoStep>NEXT</GotoStep>
						<!--Abort further test-->
					</GreaterOrEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>DeviceDescr.SM[CheckFmmuElements.i32_RefSM]</Value1>
						<Value2>CheckFmmuElements.str_SmOutputs</Value2>
						<WriteLine Id="14" Level="Error" Param0="CheckFmmuElements.u16_index">Output process data FMMU[{0}] reference non output SyncManager</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>DeviceDescr.SM[CheckFmmuElements.i32_RefSM]</Value1>
						<Value2>CheckFmmuElements.str_SmOutputs</Value2>
						<SetVariable Target="CheckFmmuElements.b_succeed">False</SetVariable>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>True</Value1>
						<Value2>True</Value2>
						<GotoStep>NEXT</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="INPUTS">
				<!--Inputs Fmmu found-->
				<Description Id="15" Level="Verbose" Param0="CheckFmmuElements.u16_index" Param1="DeviceDescr.Fmmu[CheckFmmuElements.u16_index]">Device:Fmmu[{0}] - {1}</Description>
				<Compare>
					<Lower>
						<Value1>CheckFmmuElements.i32_InSm</Value1>
						<Value2>0</Value2>
						<WriteLine Id="16" Level="Warning">No process data input SyncManager defined or disabled. Remove "Inputs" FMMU or define a input SM.</WriteLine>
					</Lower>
				</Compare>
				<Compare>
					<Equal>
						<Value1>True</Value1>
						<Value2>True</Value2>
						<SetVariable Target="CheckFmmuElements.i32_InSm">-1</SetVariable>
						<!--Reset SM indication vairable to check which SM is handled by FMMU-->
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Check if Referenced SM is valid-->
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Fmmu[CheckFmmuElements.u16_index].Sm</Value1>
						<Value2>null</Value2>
						<GotoStep>NEXT</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!---->
				<SetVariable Target="CheckFmmuElements.i32_RefSM">DeviceDescr.Fmmu[CheckFmmuElements.u16_index].Sm</SetVariable>
				<Compare>
					<GreaterOrEqual>
						<Value1>CheckFmmuElements.i32_RefSM</Value1>
						<Value2>DeviceDescr.SM.Count</Value2>
						<WriteLine Id="17" Level="Error" Param0="DeviceDescr.Fmmu[CheckFmmuElements.u16_index].Sm" Param1="CheckFmmuElements.u16_index">Non defined SyncManager (SM{0}) is referenced in FMMU{1}</WriteLine>
					</GreaterOrEqual>
				</Compare>
				<Compare>
					<GreaterOrEqual>
						<Value1>CheckFmmuElements.i32_RefSM</Value1>
						<Value2>DeviceDescr.SM.Count</Value2>
						<SetVariable Target="CheckFmmuElements.b_succeed">False</SetVariable>
					</GreaterOrEqual>
				</Compare>
				<Compare>
					<GreaterOrEqual>
						<Value1>DeviceDescr.Fmmu[CheckFmmuElements.u16_index].Sm</Value1>
						<Value2>DeviceDescr.SM.Count</Value2>
						<GotoStep>NEXT</GotoStep>
						<!--Abort further test-->
					</GreaterOrEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>DeviceDescr.SM[CheckFmmuElements.i32_RefSM]</Value1>
						<Value2>CheckFmmuElements.str_SmInputs</Value2>
						<WriteLine Id="18" Level="Error" Param0="CheckFmmuElements.u16_index">Input process data FMMU[{0}] reference non input SyncManager</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>DeviceDescr.SM[CheckFmmuElements.i32_RefSM]</Value1>
						<Value2>CheckFmmuElements.str_SmInputs</Value2>
						<SetVariable Target="CheckFmmuElements.b_succeed">False</SetVariable>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>True</Value1>
						<Value2>True</Value2>
						<GotoStep>NEXT</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="MBXSTATE">
				<!--MboxState Fmmu found-->
				<Description Id="19" Level="Verbose" Param0="CheckFmmuElements.u16_index" Param1="DeviceDescr.Fmmu[CheckFmmuElements.u16_index]">Device:Fmmu[{0}] - {1}</Description>
				<Compare>
					<Lower>
						<Value1>CheckFmmuElements.i32_OutMbxSm</Value1>
						<Value2>0</Value2>
						<WriteLine Id="20" Level="Warning">No mailbox output SyncManager defined or disabled. Remove "MBoxState" FMMU or define a mailbox output SM.</WriteLine>
					</Lower>
				</Compare>
				<Compare>
					<Equal>
						<Value1>True</Value1>
						<Value2>True</Value2>
						<SetVariable Target="CheckFmmuElements.i32_OutMbxSm">-1</SetVariable>
						<!--Reset SM indication variable to check which SM is handled by FMMU-->
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Check if OpOnly setting is valid (Shall not be define or false)-->
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Fmmu[CheckFmmuElements.u16_index].OpOnly</Value1>
						<Value2>null</Value2>
						<GotoStep>MBXSTATE_SU</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Fmmu[CheckFmmuElements.u16_index].OpOnly</Value1>
						<Value2>False</Value2>
						<GotoStep>MBXSTATE_SU</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Fmmu[CheckFmmuElements.u16_index].OpOnly</Value1>
						<Value2>True</Value2>
						<WriteLine Id="21" Level="Error" Param0="CheckFmmuElements.u16_index">FMMU[{0}].OpOnly shall be false for MBoxState FMMUs.</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Fmmu[CheckFmmuElements.u16_index].OpOnly</Value1>
						<Value2>True</Value2>
						<SetVariable Target="CheckFmmuElements.b_succeed">False</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="MBXSTATE_SU">
				<!--Check if Su setting is valid (Shall not be define)-->
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Fmmu[CheckFmmuElements.u16_index].Su</Value1>
						<Value2>null</Value2>
						<GotoStep>MBXSTATE_SM</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<GreaterOrEqual>
						<Value1>DeviceDescr.Fmmu[CheckFmmuElements.u16_index].Su</Value1>
						<Value2>0</Value2>
						<WriteLine Id="22" Level="Error" Param0="CheckFmmuElements.u16_index">FMMU[{0}].Su shall not be set for MBoxState FMMUs.</WriteLine>
					</GreaterOrEqual>
				</Compare>
				<Compare>
					<GreaterOrEqual>
						<Value1>DeviceDescr.Fmmu[CheckFmmuElements.u16_index].Su</Value1>
						<Value2>0</Value2>
						<SetVariable Target="CheckFmmuElements.b_succeed">False</SetVariable>
					</GreaterOrEqual>
				</Compare>
			</TestStep>
			<TestStep Name="MBXSTATE_SM">
				<!--Check if Referenced SM is valid-->
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Fmmu[CheckFmmuElements.u16_index].Sm</Value1>
						<Value2>null</Value2>
						<GotoStep>NEXT</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!---->
				<SetVariable Target="CheckFmmuElements.i32_RefSM">DeviceDescr.Fmmu[CheckFmmuElements.u16_index].Sm</SetVariable>
				<Compare>
					<GreaterOrEqual>
						<Value1>CheckFmmuElements.i32_RefSM</Value1>
						<Value2>DeviceDescr.SM.Count</Value2>
						<WriteLine Id="23" Level="Error" Param0="DeviceDescr.Fmmu[CheckFmmuElements.u16_index].Sm" Param1="CheckFmmuElements.u16_index">Non defined SyncManager (SM{0}) is referenced in FMMU[{1}]</WriteLine>
					</GreaterOrEqual>
				</Compare>
				<Compare>
					<GreaterOrEqual>
						<Value1>CheckFmmuElements.i32_RefSM</Value1>
						<Value2>DeviceDescr.SM.Count</Value2>
						<SetVariable Target="CheckFmmuElements.b_succeed">False</SetVariable>
					</GreaterOrEqual>
				</Compare>
				<Compare>
					<GreaterOrEqual>
						<Value1>DeviceDescr.Fmmu[CheckFmmuElements.u16_index].Sm</Value1>
						<Value2>DeviceDescr.SM.Count</Value2>
						<GotoStep>NEXT</GotoStep>
						<!--Abort further test-->
					</GreaterOrEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>DeviceDescr.SM[CheckFmmuElements.i32_RefSM]</Value1>
						<Value2>CheckFmmuElements.str_SmMBoxOut</Value2>
						<WriteLine Id="24" Level="Error" Param0="CheckFmmuElements.u16_index">Mailbox State FMMU[{0}] reference non output mailbox SyncManager</WriteLine>
						<!--Abort further test-->
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>DeviceDescr.SM[CheckFmmuElements.i32_RefSM]</Value1>
						<Value2>CheckFmmuElements.str_SmMBoxOut</Value2>
						<SetVariable Target="CheckFmmuElements.b_succeed">False</SetVariable>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>True</Value1>
						<Value2>True</Value2>
						<GotoStep>NEXT</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="NEXT">
				<!--Check next FMMU-->
				<SetVariable Target="CheckFmmuElements.u16_index">CheckFmmuElements.u16_index+1</SetVariable>
				<Compare>
					<Lower>
						<Value1>CheckFmmuElements.u16_index</Value1>
						<Value2>DeviceDescr.Fmmu.Count</Value2>
						<GotoStep>FMMUCHECK</GotoStep>
					</Lower>
				</Compare>
			</TestStep>
			<TestStep Name="FINALSMCHECK">
				<!--Check if all SM handled by a FMMU-->
				<Compare>
					<GreaterOrEqual>
						<Value1>DeviceDescr.Fmmu.Count</Value1>
						<Value2>CheckFmmuElements.u8_EscFmmu</Value2>
						<Return Id="25"></Return>
					</GreaterOrEqual>
				</Compare>
				<Compare>
					<GreaterOrEqual>
						<Value1>CheckFmmuElements.i32_OutSm</Value1>
						<Value2>0</Value2>
						<WriteLine Id="26" Level="Warning">No FMMU for OUTPUT process data defined : Add "Outputs" FMMU</WriteLine>
					</GreaterOrEqual>
				</Compare>
				<Compare>
					<GreaterOrEqual>
						<Value1>CheckFmmuElements.i32_InSm</Value1>
						<Value2>0</Value2>
						<WriteLine Id="27" Level="Warning">No FMMU for INPUT process data defined : Add "Inputs" FMMU</WriteLine>
					</GreaterOrEqual>
				</Compare>
				<Compare>
					<GreaterOrEqual>
						<Value1>CheckFmmuElements.i32_OutMbxSm</Value1>
						<Value2>0</Value2>
						<WriteLine Id="28" Level="Warning">No FMMU for MAILBOX STATE defined : Add "MBoxState" FMMU</WriteLine>
					</GreaterOrEqual>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Final Test Output-->
				<Compare>
					<Equal>
						<Value1>CheckFmmuElements.b_succeed</Value1>
						<Value2>True</Value2>
						<ReturnSuccess Id="29">FMMU defines are valid.</ReturnSuccess>
					</Equal>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction Name="CheckForExtRefDict" FunctionId="20701">
			<?MAX_OUTPUT_ID 6?>
			<!--Check for a Dictionary file, which is referenced in an external module file.-->
			<Description>
				<Purpose>Check for an Object Dictionary file, referenced within an external module file.</Purpose>
				<PreCondition>Object Dictionary file referenced within an external module file.</PreCondition>
				<Action>Check for element DictionaryFile within locally and externally defined modules.</Action>
				<PostCondition>Report a NOTE that the processing of the external referenced OD file is currently not supported.</PostCondition>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>CheckForExtRefDict.XmlFileXPath</Name>
				<Type>String</Type>
				<Comment>XPath of XML file (local, external)</Comment>
			</Parameter>
			<Parameter>
				<Name>CheckForExtRefDict.ModuleXPath</Name>
				<Type>String</Type>
				<Comment>XPath of Module</Comment>
			</Parameter>
			<Parameter>
				<Name>CheckForExtRefDict.LoopCounter</Name>
				<Type>Int32</Type>
				<Comment>Module counter</Comment>
			</Parameter>
			<LocalVariables>
				<Name>CheckForExtRefDict.strXmlValue</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckForExtRefDict.TmpXPathDictFile</Name>
				<Type>String</Type>
			</LocalVariables>
			<TestStep>
				<WriteLine Id="0" Level="Output" Param0="CheckForExtRefDict.ModuleXPath" Param1="CheckForExtRefDict.LoopCounter">Checking module {0}[{1}] for reference to external OD file.</WriteLine>
			</TestStep>
			<TestStep Name="CREATE_DICTFILE_PATH">
				<SetVariable Target="CheckForExtRefDict.TmpXPathDictFile" Param0="CheckForExtRefDict.ModuleXPath" Param1="CheckForExtRefDict.LoopCounter">{0}[{1}]/Profile/DictionaryFile</SetVariable>
			</TestStep>
			<TestStep Name="CHECK_ELEMENT">
				<GetXmlValue FileName="CheckForExtRefDict.XmlFileXPath" Markup="false" ReturnValue="CheckForExtRefDict.strXmlValue">
					<XPath Param0="CheckForExtRefDict.TmpXPathDictFile">{0}</XPath>
				</GetXmlValue>
				<Compare>
					<Equal>
						<Value1>CheckForExtRefDict.strXmlValue</Value1>
						<Value2>null</Value2>
						<WriteLine Id="1" Level="Verbose">No reference to external OD file found.</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckForExtRefDict.strXmlValue</Value1>
						<Value2>null</Value2>
						<GotoStep>END</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckForExtRefDict.strXmlValue</Value1>
						<Value2>EmptyString</Value2>
						<WriteLine Id="2" Level="Verbose">No reference to external OD file found.</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckForExtRefDict.strXmlValue</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>END</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckForExtRefDict.XmlFileXPath</Value1>
						<Value2>null</Value2>
						<GotoStep>OUTPUT_LOC</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckForExtRefDict.XmlFileXPath</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>OUTPUT_LOC</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckForExtRefDict.XmlFileXPath</Value1>
						<Value2>null</Value2>
						<GotoStep>OUTPUT_EXT</GotoStep>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckForExtRefDict.XmlFileXPath</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>OUTPUT_EXT</GotoStep>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="OUTPUT_LOC">
				<Compare>
					<NotEqual>
						<Value1>CheckForExtRefDict.strXmlValue</Value1>
						<Value2>null</Value2>
						<WriteLine Id="3" Level="Output" Param0="CheckForExtRefDict.strXmlValue" Param1="CheckForExtRefDict.TmpXPathDictFile">External OD file found ({0}) and is referenced in ESI under {1}.</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckForExtRefDict.strXmlValue</Value1>
						<Value2>null</Value2>
						<WriteLine Id="4" Level="Output">External Object Dictionary files are currently NOT SUPPORTED by offline module description tests.</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>END</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="OUTPUT_EXT">
				<Compare>
					<NotEqual>
						<Value1>CheckForExtRefDict.strXmlValue</Value1>
						<Value2>null</Value2>
						<WriteLine Id="5" Level="Output" Param0="CheckForExtRefDict.strXmlValue" Param1="CheckForExtRefDict.XmlFileXPath" Param2="CheckForExtRefDict.TmpXPathDictFile">External OD file {0} found and is referenced to file {1} under {2}.</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckForExtRefDict.strXmlValue</Value1>
						<Value2>null</Value2>
						<WriteLine Id="6" Level="Output">External Object Dictionary files are currently NOT SUPPORTED by offline module description tests.</WriteLine>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="END"></TestStep>
		</TestFunction>
		<TestFunction Name="CheckForOverlapping" FunctionId="401">
			<?MAX_OUTPUT_ID 3?>
			<TestStep>
				<Compare>
					<Equal>
						<Value1>strtAddr</Value1>
						<Value2>cmpStrtAddr</Value2>
						<RaiseError Id="0" Param0="strtAddr" Param1="cmpStrtAddr">Sync Manager start addresses are equal 0x{0:x4}</RaiseError>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<Compare>
					<Lower>
						<Value1>strtAddr</Value1>
						<Value2>cmpStrtAddr</Value2>
						<GotoStep>4</GotoStep>
					</Lower>
				</Compare>
			</TestStep>
			<TestStep>
				<Compare>
					<Greater>
						<Value1>strtAddr</Value1>
						<Value2>cmpStrtAddr</Value2>
						<GotoStep>5</GotoStep>
					</Greater>
				</Compare>
			</TestStep>
			<TestStep>
				<Compare>
					<GreaterOrEqual>
						<Value1>endAddr</Value1>
						<Value2>cmpStrtAddr</Value2>
						<RaiseError Id="1" Param0="SMStrtLenArrIndex/2" Param1="cmpIndex/2" Param2="endAddr" Param3="cmpStrtAddr">Overlapping syncmanager. End address of SM{0:d} is greater or equal to start address of SM{1:d}</RaiseError>
					</GreaterOrEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>0</Value1>
						<Value2>0</Value2>
						<Return Id="2"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<Compare>
					<LowerOrEqual>
						<Value1>strtAddr</Value1>
						<Value2>cmpEndAddr</Value2>
						<RaiseError Id="3" Param0="SMStrtLenArrIndex/2" Param1="cmpIndex/2" Param2="strtAddr" Param3="cmpEndAddr">Overlapping syncmanager. Start address of SM{0:d}(0x{2:x4}) is lower or equal to end address of SM{1:d}(0x{3:x4})</RaiseError>
					</LowerOrEqual>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction Name="CheckForValidArrayDataType" FunctionId="402">
			<?MAX_OUTPUT_ID 1?>
			<Parameter>
				<Name>CheckForValidArrayDataType.StringArrayType</Name>
				<Type>String</Type>
			</Parameter>
			<LocalVariables>
				<Name>CheckForValidArrayDataType.IntNameLength</Name>
				<Type>UInt32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckForValidArrayDataType.StringPrefix</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckForValidArrayDataType.StringExpPrefix</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckForValidArrayDataType.StringExpStPrefix</Name>
				<Type>String</Type>
			</LocalVariables>
			<OutParameter>
				<Name>CheckForValidArrayDataType.BoolComplexType</Name>
				<Type>Bool</Type>
				<DefaultValue>False</DefaultValue>
			</OutParameter>
			<TestStep Name="InitBoolComplexType">
				<SetVariable Target="CheckForValidArrayDataType.BoolComplexType">False</SetVariable>
			</TestStep>
			<TestStep Name="InitExpPreFix">
				<SetVariable Target="CheckForValidArrayDataType.StringExpPrefix">ARRAY [0..</SetVariable>
			</TestStep>
			<TestStep Name="InitExpStringPreFix">
				<SetVariable Target="CheckForValidArrayDataType.StringExpStPrefix">STRING(</SetVariable>
			</TestStep>
			<TestStep Name="GetNameLength">
				<SizeOf UInt32Var="CheckForValidArrayDataType.IntNameLength">CheckForValidArrayDataType.StringArrayType</SizeOf>
				<Compare>
					<Lower>
						<Value1>CheckForValidArrayDataType.IntNameLength</Value1>
						<Value2>9</Value2>
						<Return Id="0"></Return>
					</Lower>
				</Compare>
				<Compare>
					<Lower>
						<Value1>CheckForValidArrayDataType.IntNameLength</Value1>
						<Value2>19</Value2>
						<GotoStep>CheckArrayPrefixString</GotoStep>
					</Lower>
				</Compare>
			</TestStep>
			<TestStep Name="CheckArrayPrefix">
				<GetBits Target="CheckForValidArrayDataType.StringPrefix" Source="CheckForValidArrayDataType.StringArrayType">
					<Offset>0</Offset>
					<Length>10*16</Length>
				</GetBits>
				<Compare>
					<Equal>
						<Value1>CheckForValidArrayDataType.StringPrefix</Value1>
						<Value2>CheckForValidArrayDataType.StringExpPrefix</Value2>
						<SetVariable Target="CheckForValidArrayDataType.BoolComplexType">true</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<Return Id="1"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CheckArrayPrefixString">
				<GetBits Target="CheckForValidArrayDataType.StringPrefix" Source="CheckForValidArrayDataType.StringArrayType">
					<Offset>0</Offset>
					<Length>7*16</Length>
				</GetBits>
				<Compare>
					<Equal>
						<Value1>CheckForValidArrayDataType.StringPrefix</Value1>
						<Value2>CheckForValidArrayDataType.StringExpStPrefix</Value2>
						<SetVariable Target="CheckForValidArrayDataType.BoolComplexType">true</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction Name="CheckItemInArray" FunctionId="403">
			<?MAX_OUTPUT_ID 1?>
			<!--Checks if a specified item already exists in a specified array.-->
			<Parameter>
				<Name>CheckItemInArray.uint16ArraytoCheck</Name>
				<Type>ArrayOfUInt16</Type>
			</Parameter>
			<Parameter>
				<Name>CheckItemInArray.uint16ItemtoCheck</Name>
				<Type>UInt16</Type>
			</Parameter>
			<LocalVariables>
				<Name>CheckItemInArray.uint32Length</Name>
				<Type>UInt32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckItemInArray.uint16CurrPos</Name>
				<Type>UInt16</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckItemInArray.uint16CurrItem</Name>
				<Type>UInt16</Type>
			</LocalVariables>
			<OutParameter>
				<Name>CheckItemInArray.boolExsists</Name>
				<Type>Bool</Type>
			</OutParameter>
			<TestStep Name="ResetCurrentArrayPosition">
				<SetVariable Target="CheckItemInArray.uint16CurrPos">0</SetVariable>
			</TestStep>
			<TestStep Name="GetLengthOfArray">
				<SizeOf UInt32Var="CheckItemInArray.uint32Length">CheckItemInArray.uint16ArraytoCheck</SizeOf>
			</TestStep>
			<TestStep Name="CheckActPosition">
				<Compare>
					<GreaterOrEqual>
						<Value1>CheckItemInArray.uint16CurrPos</Value1>
						<Value2>CheckItemInArray.uint32Length</Value2>
						<SetVariable Target="CheckItemInArray.boolExsists">false</SetVariable>
					</GreaterOrEqual>
				</Compare>
				<Compare>
					<GreaterOrEqual>
						<Value1>CheckItemInArray.uint16CurrPos</Value1>
						<Value2>CheckItemInArray.uint32Length</Value2>
						<Return Id="0"></Return>
					</GreaterOrEqual>
				</Compare>
			</TestStep>
			<TestStep Name="GetCurrArrItemAndCompareToParameter">
				<GetArrayItem Index="CheckItemInArray.uint16CurrPos" SourceArray="CheckItemInArray.uint16ArraytoCheck" Target="CheckItemInArray.uint16CurrItem"></GetArrayItem>
				<Compare>
					<Equal>
						<Value1>CheckItemInArray.uint16CurrItem</Value1>
						<Value2>CheckItemInArray.uint16ItemtoCheck</Value2>
						<SetVariable Target="CheckItemInArray.boolExsists">true</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckItemInArray.uint16CurrItem</Value1>
						<Value2>CheckItemInArray.uint16ItemtoCheck</Value2>
						<Return Id="1"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="IncrementCurrPositionIfNotEqualGoToCheckItem">
				<SetVariable Target="CheckItemInArray.uint16CurrPos">CheckItemInArray.uint16CurrPos+1</SetVariable>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>CheckActPosition</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction Name="CheckItemInArrayUint32" FunctionId="20401">
			<?MAX_OUTPUT_ID 1?>
			<!--Checks if a specified item already exists in a specified array.-->
			<Parameter>
				<Name>CheckItemInArray.uint32ArraytoCheck</Name>
				<Type>ArrayOfUInt32</Type>
			</Parameter>
			<Parameter>
				<Name>CheckItemInArray.uint32ItemtoCheck</Name>
				<Type>UInt32</Type>
			</Parameter>
			<LocalVariables>
				<Name>CheckItemInArray.uint32Length</Name>
				<Type>UInt32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckItemInArray.uint32CurrPos</Name>
				<Type>UInt32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckItemInArray.uint32CurrItem</Name>
				<Type>UInt32</Type>
			</LocalVariables>
			<OutParameter>
				<Name>CheckItemInArray.boolExsists</Name>
				<Type>Bool</Type>
			</OutParameter>
			<TestStep Name="ResetCurrentArrayPosition">
				<SetVariable Target="CheckItemInArray.uint32CurrPos">0</SetVariable>
			</TestStep>
			<TestStep Name="GetLengthOfArray">
				<SizeOf UInt32Var="CheckItemInArray.uint32Length">CheckItemInArray.uint32ArraytoCheck</SizeOf>
			</TestStep>
			<TestStep Name="CheckActPosition">
				<Compare>
					<GreaterOrEqual>
						<Value1>CheckItemInArray.uint32CurrPos</Value1>
						<Value2>CheckItemInArray.uint32Length</Value2>
						<SetVariable Target="CheckItemInArray.boolExsists">false</SetVariable>
					</GreaterOrEqual>
				</Compare>
				<Compare>
					<GreaterOrEqual>
						<Value1>CheckItemInArray.uint32CurrPos</Value1>
						<Value2>CheckItemInArray.uint32Length</Value2>
						<Return Id="0"></Return>
					</GreaterOrEqual>
				</Compare>
			</TestStep>
			<TestStep Name="GetCurrArrItemAndCompareToParameter">
				<GetArrayItem Index="CheckItemInArray.uint32CurrPos" SourceArray="CheckItemInArray.uint32ArraytoCheck" Target="CheckItemInArray.uint32CurrItem"></GetArrayItem>
				<Compare>
					<Equal>
						<Value1>CheckItemInArray.uint32CurrItem</Value1>
						<Value2>CheckItemInArray.uint32ItemtoCheck</Value2>
						<SetVariable Target="CheckItemInArray.boolExsists">true</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckItemInArray.uint32CurrItem</Value1>
						<Value2>CheckItemInArray.uint32ItemtoCheck</Value2>
						<Return Id="1"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="IncrementCurrPositionIfNotEqualGoToCheckItem">
				<SetVariable Target="CheckItemInArray.uint32CurrPos">CheckItemInArray.uint32CurrPos+1</SetVariable>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>CheckActPosition</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction Name="CheckModuleRxPdoSmAssignment_gen" FunctionId="20601">
			<?MAX_OUTPUT_ID 41?>
			<!--Iterate of all defined SyncManger and check if RxPdo assignment is valid-->
			<Parameter>
				<Name>ModuleXmlFile</Name>
				<Type>String</Type>
				<!--Xml File Local/External reference-->
			</Parameter>
			<Parameter>
				<Name>XPathModuleIdent</Name>
				<Type>String</Type>
				<!--Module XPath Local/External reference-->
			</Parameter>
			<Parameter>
				<Name>CheckModuleRxPdoSMAssign.ModuleIndex</Name>
				<Type>Int32</Type>
			</Parameter>
			<Parameter>
				<Name>CheckModuleRxPdoSMAssign.RxPdoIndex</Name>
				<Type>Int16</Type>
				<!--i32TmpModuleIndex-->
			</Parameter>
			<LocalVariables>
				<Name>xxx_ADD_BEGIN_xxx</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>strXmlValueMandatory.String</Name>
				<Type>String</Type>
				<!--Mandatory flag - String-->
			</LocalVariables>
			<LocalVariables>
				<Name>strXmlValueMandatory.Bool</Name>
				<Type>Bool</Type>
				<!--Mandatory flag - Bool-->
			</LocalVariables>
			<LocalVariables>
				<Name>i32TmpExcludedIndex</Name>
				<Type>Int32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>strXmlValue.ExcludedSm.String</Name>
				<Type>String</Type>
				<!--ExcludedSm String-->
			</LocalVariables>
			<LocalVariables>
				<Name>strXmlValue.ExcludedSm.Uint16</Name>
				<Type>UInt16</Type>
				<!--ExcludedSm Uint16-->
			</LocalVariables>
			<LocalVariables>
				<Name>strXmlValue.Su.String</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>strXmlValue.Su.Uint16</Name>
				<Type>UInt16</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>strXmlValue.Virtual.String</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>strXmlValue.Virtual.Bool</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>strXmlValue.Entry</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>strXmlValue.SmDirection</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>strXmlValue.Sm.String</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>strXmlValue.Sm.Uint16</Name>
				<Type>UInt16</Type>
				<!--Converted string-->
			</LocalVariables>
			<LocalVariables>
				<Name>strXmlValue</Name>
				<Type>String</Type>
				<!--Checkup of valid RxPdo access-->
			</LocalVariables>
			<LocalVariables>
				<Name>xxx_ADD_END_xxx</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckRxPdoSmAssignment.Cnt</Name>
				<Type>UInt16</Type>
				<!--temp counter variable-->
			</LocalVariables>
			<LocalVariables>
				<Name>CheckRxPdoSmAssignment.ValidSmName</Name>
				<Type>String</Type>
				<!--Valid SM name is "Outputs"-->
			</LocalVariables>
			<LocalVariables>
				<Name>CheckRxPdoSmAssignment.PotentialSm</Name>
				<Type>UInt16</Type>
				<!--Number of potential SM to assign-->
			</LocalVariables>
			<LocalVariables>
				<Name>CheckRxPdoSmAssignment.TmpIndex</Name>
				<Type>Int32</Type>
				<!--temp testfunction result-->
			</LocalVariables>
			<LocalVariables>
				<Name>CheckRxPdoSmAssignment.bValid</Name>
				<Type>Bool</Type>
				<!--tmp testfunction result-->
			</LocalVariables>
			<OutParameter>
				<Name>CheckRxPdoSmAssignment.Valid</Name>
				<Type>Bool</Type>
			</OutParameter>
			<TestStep Name="START">
				<!--Check if SM Elements defined-->
				<WriteLine Id="0" Level="Verbose" Param0="DeviceDescr.SM.Count">{0} SyncManger defined in device description</WriteLine>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.SM.Count</Value1>
						<Value2>0</Value2>
						<SetVariable Target="CheckRxPdoSmAssignment.Valid">false</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Check if parameter "CheckModuleRxPdoSMAssign.RxPdoIndex" is valid (< DeviceDescr.RxPdo.Count)-->
				<GetXmlValue FileName="ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
					<XPath Param0="XPathModuleIdent" Param1="CheckModuleRxPdoSMAssign.ModuleIndex" Param2="CheckModuleRxPdoSMAssign.RxPdoIndex">{0}[{1}]/RxPdo[{2}]</XPath>
				</GetXmlValue>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>debug_msg</Value2>
						<WriteLine Id="1" Level="Output" Param0="XPathModuleIdent" Param1="CheckModuleRxPdoSMAssign.ModuleIndex" Param2="CheckModuleRxPdoSMAssign.RxPdoIndex">Requesting RxPdo index {0}[{1}]/RxPdo[{2}]</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValue</Value1>
						<Value2>null</Value2>
						<SetVariable Target="CheckRxPdoSmAssignment.Valid">false</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValue</Value1>
						<Value2>EmptyString</Value2>
						<SetVariable Target="CheckRxPdoSmAssignment.Valid">false</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValue</Value1>
						<Value2>null</Value2>
						<WriteLine Id="2" Level="Error" Param0="XPathModuleIdent" Param1="CheckModuleRxPdoSMAssign.ModuleIndex" Param2="CheckModuleRxPdoSMAssign.RxPdoIndex">Requested RxPdo index {0}[{1}]/RxPdo[{2}] is not valid. =&gt; skip test case</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValue</Value1>
						<Value2>EmptyString</Value2>
						<WriteLine Id="3" Level="Error" Param0="XPathModuleIdent" Param1="CheckModuleRxPdoSMAssign.ModuleIndex" Param2="CheckModuleRxPdoSMAssign.RxPdoIndex">Requested RxPdo index {0}[{1}]/RxPdo[{2}] is not valid. =&gt; skip test case</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValue</Value1>
						<Value2>null</Value2>
						<Return Id="4" Param0="XPathModuleIdent" Param1="CheckModuleRxPdoSMAssign.ModuleIndex" Param2="CheckModuleRxPdoSMAssign.RxPdoIndex">No RxPdo element found ({0}[{1}]/RxPdo[{2}]).</Return>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValue</Value1>
						<Value2>EmptyString</Value2>
						<Return Id="5" Param0="XPathModuleIdent" Param1="CheckModuleRxPdoSMAssign.ModuleIndex" Param2="CheckModuleRxPdoSMAssign.RxPdoIndex">No RxPdo element found ({0}[{1}]/RxPdo[{2}]).</Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Set "CheckRxPdoSmAssignment.Cnt" to 0-->
				<SetVariable Target="CheckRxPdoSmAssignment.Cnt">0</SetVariable>
			</TestStep>
			<TestStep>
				<!--Set "CheckRxPdoSmAssignment.Failed" to true-->
				<SetVariable Target="CheckRxPdoSmAssignment.Valid">true</SetVariable>
			</TestStep>
			<TestStep>
				<!--Set "CheckRxPdoSmAssignment.ValidSmName" to "Outputs"-->
				<SetVariable Target="CheckRxPdoSmAssignment.ValidSmName">Outputs</SetVariable>
			</TestStep>
			<TestStep>
				<!--Set "CheckRxPdoSmAssignment.PotentialSm" to 0-->
				<SetVariable Target="CheckRxPdoSmAssignment.PotentialSm">0</SetVariable>
			</TestStep>
			<TestStep>
				<!--Check if RxPdo is mandatory (XPath String check)-->
				<GetXmlValue FileName="ModuleXmlFile" Markup="false" ReturnValue="strXmlValueMandatory.String">
					<XPath Param0="XPathModuleIdent" Param1="CheckModuleRxPdoSMAssign.ModuleIndex" Param2="CheckModuleRxPdoSMAssign.RxPdoIndex">{0}[{1}]/RxPdo[{2}]/@Mandatory</XPath>
				</GetXmlValue>
				<Compare>
					<Equal>
						<Value1>strXmlValueMandatory.String</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>SM_Val_INIT</GotoStep>
					</Equal>
					<!--If Pdo is not mandatory (Attribute not found) iterate over all SyncManager-->
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValueMandatory.String</Value1>
						<Value2>null</Value2>
						<GotoStep>SM_Val_INIT</GotoStep>
					</Equal>
					<!--If Pdo is not mandatory (Attribute not found) iterate over all SyncManager-->
				</Compare>
			</TestStep>
			<TestStep>
				<!--Check if RxPdo is mandatory (XPath convert to Bool check)-->
				<GetXmlValue FileName="ModuleXmlFile" Markup="false" ReturnValue="strXmlValueMandatory.Bool">
					<XPath Param0="XPathModuleIdent" Param1="CheckModuleRxPdoSMAssign.ModuleIndex" Param2="CheckModuleRxPdoSMAssign.RxPdoIndex">{0}[{1}]/RxPdo[{2}]/@Mandatory</XPath>
				</GetXmlValue>
			</TestStep>
			<TestStep>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>debug_msg</Value2>
						<WriteLine Id="6" Level="Output" Param0="XPathModuleIdent" Param1="CheckModuleRxPdoSMAssign.ModuleIndex" Param2="CheckModuleRxPdoSMAssign.RxPdoIndex">{0}[{1}]/RxPdo[{2}]/@Mandatory</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>debug_msg</Value2>
						<WriteLine Id="7" Level="Output" Param0="strXmlValueMandatory.Bool" Param1="strXmlValueMandatory.String">strXmlValueMandatory.Bool = {0}, strXmlValueMandatory.String = {0}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValueMandatory.Bool</Value1>
						<Value2>false</Value2>
						<GotoStep>SM_Val_INIT</GotoStep>
					</Equal>
					<!--If Pdo is not mandatory iterate over all SyncManager-->
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="8" Level="Output" Param0="XPathModuleIdent" Param1="CheckModuleRxPdoSMAssign.ModuleIndex" Param2="CheckModuleRxPdoSMAssign.RxPdoIndex" Param3="strXmlValueMandatory.String">{0}[{1}]/RxPdo[{2}]/@Mandatory: {3}</WriteLine>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Raise an Error if RxPdo is mandatory and no default SM is defined-->
				<GetXmlValue FileName="ModuleXmlFile" Markup="true" ReturnValue="strXmlValue.Sm.String">
					<XPath Param0="XPathModuleIdent" Param1="CheckModuleRxPdoSMAssign.ModuleIndex" Param2="CheckModuleRxPdoSMAssign.RxPdoIndex">{0}[{1}]/RxPdo[{2}]/@Sm</XPath>
				</GetXmlValue>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>debug_msg</Value2>
						<WriteLine Id="9" Level="Output" Param0="strXmlValue.Sm.String">strXmlValue.Sm.String: {0}</WriteLine>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<SetVariable Target="strXmlValue.Sm.Uint16">strXmlValue.Sm.String</SetVariable>
			</TestStep>
			<TestStep>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>debug_msg</Value2>
						<WriteLine Id="10" Level="Output" Param0="strXmlValue.Sm.Uint16">strXmlValue.Sm.Uint16 = {0}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValue.Sm.String</Value1>
						<Value2>EmptyString</Value2>
						<SetVariable Target="CheckRxPdoSmAssignment.Valid">false</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValue.Sm.String</Value1>
						<Value2>EmptyString</Value2>
						<RaiseError Id="11" Param0="XPathModuleIdent" Param1="CheckModuleRxPdoSMAssign.ModuleIndex" Param2="CheckModuleRxPdoSMAssign.RxPdoIndex">A default SyncManager (RxPdo@Sm) shall be defined because the {0}[{1}]/RxPdo[{2}] is mandatory.</RaiseError>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValue.Sm.String</Value1>
						<Value2>null</Value2>
						<SetVariable Target="CheckRxPdoSmAssignment.Valid">false</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValue.Sm.String</Value1>
						<Value2>null</Value2>
						<RaiseError Id="12" Param0="XPathModuleIdent" Param1="CheckModuleRxPdoSMAssign.ModuleIndex" Param2="CheckModuleRxPdoSMAssign.RxPdoIndex">A default SyncManager (RxPdo@Sm) shall be defined because the {0}[{1}]/RxPdo[{2}] is mandatory.</RaiseError>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Raise an Error if RxPdo@Sm > available Sm.count-->
				<Compare>
					<LowerOrEqual>
						<Value1>DeviceDescr.SM.Count</Value1>
						<Value2>strXmlValue.Sm.Uint16</Value2>
						<RaiseError Id="13" Param0="XPathModuleIdent" Param1="CheckModuleRxPdoSMAssign.ModuleIndex" Param2="CheckModuleRxPdoSMAssign.RxPdoIndex" Param3="strXmlValue.Sm.Uint16">The referenced SyncManager ({0}[{1}]/RxPdo[{2}]/@Sm : {3}) is not defined in device description</RaiseError>
					</LowerOrEqual>
				</Compare>
			</TestStep>
			<TestStep>
				<!--If RxPdo.ExcludeSM is defined dump a warning (Pdo shall be assigned to a fixed SM so the element is not required)-->
				<GetXmlValue FileName="ModuleXmlFile" Markup="true" ReturnValue="strXmlValue.ExcludedSm.Uint16">
					<XPath Param0="XPathModuleIdent" Param1="CheckModuleRxPdoSMAssign.ModuleIndex" Param2="CheckModuleRxPdoSMAssign.RxPdoIndex">{0}[{1}]/RxPdo[{2}]/ExcludedSm</XPath>
				</GetXmlValue>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>debug_msg</Value2>
						<WriteLine Id="14" Level="Output" Param0="strXmlValue.ExcludedSm.Uint16">strXmlValue.ExcludedSm.Uint16 {0}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>strXmlValue.ExcludedSm.Uint16</Value1>
						<Value2>null</Value2>
						<WriteLine Id="15" Level="Warning" Param0="XPathModuleIdent" Param1="CheckModuleRxPdoSMAssign.ModuleIndex" Param2="CheckModuleRxPdoSMAssign.RxPdoIndex">{0}[{1}]/RxPdo[{2}] is mandatory so no ExcludeSm need to be defined.</WriteLine>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Set "CheckRxPdoSmAssignment.Cnt" to RxPdo@Sm (the PDO shall assigned to the specified SM => only this SM will be tested-->
				<SetVariable Target="CheckRxPdoSmAssignment.Cnt">strXmlValue.Sm.Uint16</SetVariable>
				<WriteLine Id="16" Level="Verbose" Param0="XPathModuleIdent" Param1="CheckModuleRxPdoSMAssign.ModuleIndex" Param2="CheckModuleRxPdoSMAssign.RxPdoIndex" Param3="CheckRxPdoSmAssignment.Cnt">{0}[{1}]/RxPdo[{2}] is fixed assigned to SyncManager[{3}] (@Mandatory == true and @SM defined)=&gt; only this SM is tested</WriteLine>
			</TestStep>
			<TestStep>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>SMLOOPSTART</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="SM_Val_INIT">
				<GetXmlValue FileName="ModuleXmlFile" Markup="true" ReturnValue="strXmlValue.Sm.String">
					<XPath Param0="XPathModuleIdent" Param1="CheckModuleRxPdoSMAssign.ModuleIndex" Param2="CheckModuleRxPdoSMAssign.RxPdoIndex">{0}[{1}]/RxPdo[{2}]/@Sm</XPath>
				</GetXmlValue>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>debug_msg</Value2>
						<WriteLine Id="17" Level="Output">CHECK SM!</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>debug_msg</Value2>
						<WriteLine Id="18" Level="Output" Param0="strXmlValue.Sm.String">strXmlValue.Sm.String: {0}</WriteLine>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<SetVariable Target="strXmlValue.Sm.Uint16">strXmlValue.Sm.String</SetVariable>
			</TestStep>
			<TestStep>
				<SetVariable Target="CheckRxPdoSmAssignment.Cnt">strXmlValue.Sm.Uint16</SetVariable>
			</TestStep>
			<TestStep>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>SMLOOPSTART</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="SMLOOPSTART">
				<WriteLine Id="19" Param0="CheckRxPdoSmAssignment.Cnt" Level="Verbose">Check SM[{0}]</WriteLine>
			</TestStep>
			<TestStep>
				<!--Check if SyncManager direction and type match-->
				<Compare>
					<Equal>
						<Value1>CheckRxPdoSmAssignment.ValidSmName</Value1>
						<Value2>DeviceDescr.SM[CheckRxPdoSmAssignment.Cnt]</Value2>
						<GotoStep>ExcludedLOOPStart</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="SMCheck">
				<!--SM direction and/or type not match dump an error if this is the default SM or proceed with next SM-->
				<Compare>
					<Equal>
						<Value1>strXmlValue.Sm.String</Value1>
						<Value2>EmptyString</Value2>
						<WriteLine Id="20" Level="Verbose" Param0="CheckRxPdoSmAssignment.Cnt" Param1="CheckRxPdoSmAssignment.ValidSmName" Param2="DeviceDescr.SM[CheckRxPdoSmAssignment.Cnt]">SM[{0}] skipped because SM type not match (expected: {1}, read: {2}).</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValue.Sm.String</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>SMLOOPEND</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValue.Sm.String</Value1>
						<Value2>null</Value2>
						<WriteLine Id="21" Level="Verbose" Param0="CheckRxPdoSmAssignment.Cnt" Param1="CheckRxPdoSmAssignment.ValidSmName" Param2="DeviceDescr.SM[CheckRxPdoSmAssignment.Cnt]">SM[{0}] skipped because SM type not match (expected: {1}, read: {2}).</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValue.Sm.String</Value1>
						<Value2>null</Value2>
						<GotoStep>SMLOOPEND</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckRxPdoSmAssignment.Cnt</Value1>
						<Value2>strXmlValue.Sm.Uint16</Value2>
						<WriteLine Id="22" Level="Verbose" Param0="CheckRxPdoSmAssignment.Cnt">SM[{0}] skipped because SM type not match.</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckRxPdoSmAssignment.Cnt</Value1>
						<Value2>strXmlValue.Sm.Uint16</Value2>
						<GotoStep>SMLOOPEND</GotoStep>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>debug_msg</Value2>
						<WriteLine Id="23" Level="Output" Param0="strXmlValue.Sm.Uint16">strXmlValue.Sm.Uint16: {0}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>True</Value1>
						<Value2>True</Value2>
						<SetVariable Target="CheckRxPdoSmAssignment.Valid">false</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>True</Value1>
						<Value2>True</Value2>
						<WriteLine Id="24" Level="Error" Param0="strXmlValue.Sm.Uint16" Param1="CheckRxPdoSmAssignment.ValidSmName" Param2="DeviceDescr.SM[CheckRxPdoSmAssignment.Cnt]">Type/Direction of default SyncManager[{0}] doesn't match. (expected "{1}", read "{2}")</WriteLine>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="ExcludedLOOPStart">
				<SetVariable Target="i32TmpExcludedIndex">1</SetVariable>
			</TestStep>
			<TestStep Name="EXCLUDESM">
				<!--Check if RxPdo.ExcludedSm is defined-->
				<GetXmlValue FileName="ModuleXmlFile" Markup="true" ReturnValue="strXmlValue.ExcludedSm.String">
					<XPath Param0="XPathModuleIdent" Param1="CheckModuleRxPdoSMAssign.ModuleIndex" Param2="CheckModuleRxPdoSMAssign.RxPdoIndex" Param3="i32TmpExcludedIndex">{0}[{1}]/RxPdo[{2}]/ExcludedSm[{3}]</XPath>
				</GetXmlValue>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>debug_msg</Value2>
						<WriteLine Id="25" Level="Output" Param0="i32TmpExcludedIndex">i32TmpExcludedIndex {0}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>debug_msg</Value2>
						<WriteLine Id="26" Level="Output" Param0="strXmlValue.Sm.String" Param1="strXmlValue.ExcludedSm.String">strXmlValue.Sm.Uint16: {0} and strXmlValue.ExcludedSm.Uint16: {1}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValue.ExcludedSm.String</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>TESTSU</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValue.ExcludedSm.String</Value1>
						<Value2>null</Value2>
						<GotoStep>TESTSU</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Check if current Sm is defined in Exclude Sm List-->
				<SetVariable Target="strXmlValue.ExcludedSm.Uint16">strXmlValue.ExcludedSm.String</SetVariable>
			</TestStep>
			<TestStep>
				<!--If current Sm is not excluded proceed with Su step-->
				<Compare>
					<Equal>
						<Value1>strXmlValue.ExcludedSm.Uint16</Value1>
						<Value2>strXmlValue.Sm.Uint16</Value2>
						<WriteLine Id="27" Level="Verbose" Param0="CheckRxPdoSmAssignment.Cnt" Param1="XPathModuleIdent" Param2="CheckModuleRxPdoSMAssign.ModuleIndex" Param3="CheckModuleRxPdoSMAssign.RxPdoIndex">SM[{0}] skipped because SM is listed in {1}[{2}]/RxPdo[{3}]/ExcludedSm</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>strXmlValue.ExcludedSm.Uint16</Value1>
						<Value2>strXmlValue.Sm.Uint16</Value2>
						<GotoStep>ExcludedLOOPEnd</GotoStep>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Dump an Error if default SM is excluded-->
				<Compare>
					<!--proceed with next Sm if no default Sm is defined-->
					<Equal>
						<Value1>strXmlValue.Sm.Uint16</Value1>
						<Value2>null</Value2>
						<GotoStep>SMLOOPEND</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValue.ExcludedSm.Uint16</Value1>
						<Value2>strXmlValue.Sm.Uint16</Value2>
						<WriteLine Id="28" Level="Error" Param0="CheckModuleRxPdoSMAssign.RxPdoIndex">RxPdo[{0}] Exclude the configured default Sm.</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValue.ExcludedSm.Uint16</Value1>
						<Value2>strXmlValue.Sm.Uint16</Value2>
						<SetVariable Target="CheckRxPdoSmAssignment.Valid">false</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValue.ExcludedSm.Uint16</Value1>
						<Value2>strXmlValue.Sm.Uint16</Value2>
						<GotoStep>SMLOOPEND</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="ExcludedLOOPEnd">
				<SetVariable Target="i32TmpExcludedIndex">i32TmpExcludedIndex + 1</SetVariable>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>EXCLUDESM</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="TESTSU">
				<!--Check if RxPdo.Su is defined-->
				<GetXmlValue FileName="ModuleXmlFile" Markup="true" ReturnValue="strXmlValue.Su.String">
					<XPath Param0="XPathModuleIdent" Param1="CheckModuleRxPdoSMAssign.ModuleIndex" Param2="CheckModuleRxPdoSMAssign.RxPdoIndex">{0}[{1}]/RxPdo[{2}]/@Su</XPath>
				</GetXmlValue>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>debug_msg</Value2>
						<WriteLine Id="29" Level="Output" Param0="strXmlValue.Su.String">strXmlValue.Su.String: {0}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValue.Su.String</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>STARTTESTSM</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValue.Su.String</Value1>
						<Value2>null</Value2>
						<GotoStep>STARTTESTSM</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="TESTSU_ON">
				<SetVariable Target="strXmlValue.Su.Uint16">strXmlValue.Su.String</SetVariable>
				<Compare>
					<Equal>
						<Value1>strXmlValue.Su.Uint16</Value1>
						<Value2>null</Value2>
						<GotoStep>STARTTESTSM</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<Compare>
					<Equal>
						<Value1>strXmlValue.Sm.String</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>STARTTESTSM</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValue.Sm.String</Value1>
						<Value2>null</Value2>
						<GotoStep>STARTTESTSM</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Check if current Sm is referenced via Su-->
				<CallTestFunction Name="IsSmReferencedViaSu">
					<Parameter>CheckRxPdoSmAssignment.Cnt</Parameter>
					<Parameter>strXmlValue.Su.Uint16</Parameter>
					<OutParameter>CheckRxPdoSmAssignment.bValid</OutParameter>
				</CallTestFunction>
			</TestStep>
			<TestStep>
				<!--Skip Sm Test if it is not referenced via Su-->
				<Compare>
					<Equal>
						<Value1>CheckRxPdoSmAssignment.bValid</Value1>
						<Value2>false</Value2>
						<WriteLine Id="30" Level="Verbose" Param0="CheckRxPdoSmAssignment.Cnt">SM[{0}] skipped because SM is not referenced via Su</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckRxPdoSmAssignment.bValid</Value1>
						<Value2>false</Value2>
						<GotoStep>SMLOOPEND</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="STARTTESTSM">
				<!--SyncManager may be used for the PDO => increment indication counter-->
				<SetVariable Target="CheckRxPdoSmAssignment.PotentialSm">CheckRxPdoSmAssignment.PotentialSm + 1</SetVariable>
			</TestStep>
			<TestStep Name="CHECKVIRTUAL">
				<!--Check if virtual settings are correct-->
				<GetXmlValue FileName="ModuleXmlFile" Markup="true" ReturnValue="strXmlValue.Virtual.String">
					<XPath Param0="XPathModuleIdent" Param1="CheckModuleRxPdoSMAssign.ModuleIndex" Param2="CheckModuleRxPdoSMAssign.RxPdoIndex">{0}[{1}]/RxPdo[{2}]/@Virtual</XPath>
				</GetXmlValue>
				<Compare>
					<Equal>
						<Value1>strXmlValue.Virtual.String</Value1>
						<Value2>EmptyString</Value2>
						<SetVariable Target="strXmlValue.Virtual.Bool">false</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValue.Virtual.String</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>NOTVIRTUAL</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValue.Virtual.String</Value1>
						<Value2>null</Value2>
						<SetVariable Target="strXmlValue.Virtual.Bool">false</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValue.Virtual.String</Value1>
						<Value2>null</Value2>
						<GotoStep>NOTVIRTUAL</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<GetXmlValue FileName="ModuleXmlFile" Markup="true" ReturnValue="strXmlValue.Virtual.Bool">
					<XPath Param0="XPathModuleIdent" Param1="CheckModuleRxPdoSMAssign.ModuleIndex" Param2="CheckModuleRxPdoSMAssign.RxPdoIndex">{0}[{1}]/RxPdo[{2}]/@Virtual</XPath>
				</GetXmlValue>
			</TestStep>
			<TestStep>
				<Compare>
					<Equal>
						<Value1>strXmlValue.Virtual.Bool</Value1>
						<Value2>false</Value2>
						<GotoStep>NOTVIRTUAL</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<GetXmlValue FileName="ModuleXmlFile" Markup="true" ReturnValue="strXmlValue.Entry">
					<XPath Param0="XPathModuleIdent" Param1="CheckModuleRxPdoSMAssign.ModuleIndex" Param2="CheckModuleRxPdoSMAssign.RxPdoIndex">{0}[{1}]/RxPdo[{2}]/Entry</XPath>
				</GetXmlValue>
				<Compare>
					<NotEqual>
						<Value1>strXmlValue.Entry</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>VIRTUALENTRIES</GotoStep>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>strXmlValue.Entry</Value1>
						<Value2>null</Value2>
						<GotoStep>VIRTUALENTRIES</GotoStep>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep>
				<!--PDO is virtual
if Entries defined goto "VIRTUALENTRIES"
else 
current SM is not virtual => correct
current SM is virtual but is not the default SM => warning because of a possible wrong configuration
the default SM is virtual => Error-->
				<Compare>
					<Equal>
						<Value1>DeviceDescr.SM[CheckRxPdoSmAssignment.Cnt].Virtual</Value1>
						<Value2>false</Value2>
						<GotoStep>SMLOOPEND</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValue.Sm.Uint16</Value1>
						<Value2>null</Value2>
						<WriteLine Id="31" Level="Warning" Param0="CheckModuleRxPdoSMAssign.RxPdoIndex" Param1="CheckRxPdoSmAssignment.Cnt">Virtual RxPdo[{0}] with no Entries may be assigned to the virtual SyncManager[{1}].</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValue.Sm.Uint16</Value1>
						<Value2>null</Value2>
						<GotoStep>SMLOOPEND</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>strXmlValue.Sm.Uint16</Value1>
						<Value2>CheckRxPdoSmAssignment.Cnt</Value2>
						<WriteLine Id="32" Level="Warning" Param0="CheckModuleRxPdoSMAssign.RxPdoIndex" Param1="CheckRxPdoSmAssignment.Cnt">Virtual RxPdo[{0}] with no Entries may be assigned to the virtual SyncManager[{1}].</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>strXmlValue.Sm.Uint16</Value1>
						<Value2>CheckRxPdoSmAssignment.Cnt</Value2>
						<GotoStep>SMLOOPEND</GotoStep>
					</NotEqual>
				</Compare>
				<Compare>
					<!--The current PDO is not virtual but the default SM is virtual-->
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="33" Level="Error" Param0="CheckModuleRxPdoSMAssign.RxPdoIndex" Param1="CheckRxPdoSmAssignment.Cnt">Virtual RxPdo[{0}] with no Entries is assigned to the virtual SyncManager[{1}].</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<SetVariable Target="CheckRxPdoSmAssignment.Valid">false</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>SMLOOPEND</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="VIRTUALENTRIES">
				<!--PDO is virtual and Entries defined
- the current SM is virtual => correct
- current SM is not virtual but is not the default SM => warning because of a possible wrong configuration
the default SM is not virtual => Error-->
				<Compare>
					<Equal>
						<Value1>DeviceDescr.SM[CheckRxPdoSmAssignment.Cnt].Virtual</Value1>
						<Value2>true</Value2>
						<GotoStep>SMLOOPEND</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValue.Sm.Uint16</Value1>
						<Value2>null</Value2>
						<WriteLine Id="34" Level="Warning" Param0="CheckModuleRxPdoSMAssign.RxPdoIndex" Param1="CheckRxPdoSmAssignment.Cnt">Virtual RxPdo[{0}] with Entries may be assigned to the non virtual SyncManager[{1}].</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValue.Sm.Uint16</Value1>
						<Value2>null</Value2>
						<GotoStep>SMLOOPEND</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>strXmlValue.Sm.Uint16</Value1>
						<Value2>CheckRxPdoSmAssignment.Cnt</Value2>
						<WriteLine Id="35" Level="Warning" Param0="CheckModuleRxPdoSMAssign.RxPdoIndex" Param1="CheckRxPdoSmAssignment.Cnt">Virtual RxPdo[{0}] with Entries may be assigned to the non virtual SyncManager[{1}].</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>strXmlValue.Sm.Uint16</Value1>
						<Value2>CheckRxPdoSmAssignment.Cnt</Value2>
						<GotoStep>SMLOOPEND</GotoStep>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="36" Level="Error" Param0="CheckModuleRxPdoSMAssign.RxPdoIndex" Param1="CheckRxPdoSmAssignment.Cnt">Virtual RxPdo[{0}] with Entries is assigned to the virtual SyncManager[{1}].</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<SetVariable Target="CheckRxPdoSmAssignment.Valid">false</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>SMLOOPEND</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="NOTVIRTUAL">
				<!--PDO is not virtual-->
				<Compare>
					<Equal>
						<Value1>DeviceDescr.SM[CheckRxPdoSmAssignment.Cnt].Virtual</Value1>
						<Value2>false</Value2>
						<GotoStep>SMLOOPEND</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValue.Sm.Uint16</Value1>
						<Value2>null</Value2>
						<WriteLine Id="37" Level="Warning" Param0="CheckModuleRxPdoSMAssign.RxPdoIndex" Param1="CheckRxPdoSmAssignment.Cnt">Non virtual RxPdo[{0}] may be assigned to virtual SyncManager[{1}]</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValue.Sm.Uint16</Value1>
						<Value2>null</Value2>
						<GotoStep>SMLOOPEND</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>strXmlValue.Sm.Uint16</Value1>
						<Value2>CheckRxPdoSmAssignment.Cnt</Value2>
						<WriteLine Id="38" Level="Warning" Param0="CheckModuleRxPdoSMAssign.RxPdoIndex" Param1="CheckRxPdoSmAssignment.Cnt">Non virtual RxPdo[{0}] may be assigned to virtual SyncManager[{1}]</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>strXmlValue.Sm.Uint16</Value1>
						<Value2>CheckRxPdoSmAssignment.Cnt</Value2>
						<GotoStep>SMLOOPEND</GotoStep>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValue.Sm.Uint16</Value1>
						<Value2>CheckRxPdoSmAssignment.Cnt</Value2>
						<WriteLine Id="39" Level="Error" Param0="CheckModuleRxPdoSMAssign.RxPdoIndex" Param1="CheckRxPdoSmAssignment.Cnt">Non virtual RxPdo[{0}] is by default assigned to virtual SyncManager[{1}]</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValue.Sm.Uint16</Value1>
						<Value2>CheckRxPdoSmAssignment.Cnt</Value2>
						<SetVariable Target="CheckRxPdoSmAssignment.Valid">false</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="SMLOOPEND">
				<!--Abort loop if
- Pdo is mandatory 
OR
- "CheckRxPdoSmAssignment.Cnt" >= "DeviceDescr.SM.Count"-->
				<SetVariable Target="CheckRxPdoSmAssignment.Cnt">CheckRxPdoSmAssignment.Cnt + 1</SetVariable>
				<Compare>
					<Equal>
						<Value1>strXmlValueMandatory.Bool</Value1>
						<Value2>true</Value2>
						<GotoStep>END</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Lower>
						<Value1>CheckRxPdoSmAssignment.Cnt</Value1>
						<Value2>DeviceDescr.SM.Count</Value2>
						<GotoStep>SMLOOPSTART</GotoStep>
					</Lower>
				</Compare>
			</TestStep>
			<TestStep Name="END">
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="40" Level="Output" Param0="CheckRxPdoSmAssignment.PotentialSm">CheckRxPdoSmAssignment.PotentialSm == {0}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckRxPdoSmAssignment.PotentialSm</Value1>
						<Value2>0</Value2>
						<WriteLine Id="41" Level="Error" Param0="XPathModuleIdent" Param1="CheckModuleRxPdoSMAssign.ModuleIndex" Param2="CheckModuleRxPdoSMAssign.RxPdoIndex">No SyncManager for {0}[{1}]/RxPdo[{2}] found</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckRxPdoSmAssignment.PotentialSm</Value1>
						<Value2>0</Value2>
						<SetVariable Target="CheckRxPdoSmAssignment.Valid">false</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction Name="CheckModuleTxPdoSmAssignment_gen" FunctionId="20603">
			<?MAX_OUTPUT_ID 39?>
			<!--Iterate of all defined SyncManger and check if TxPdo assignment is valid-->
			<Parameter>
				<Name>ModuleXmlFile</Name>
				<Type>String</Type>
				<!--Xml File Local/External reference-->
			</Parameter>
			<Parameter>
				<Name>XPathModuleIdent</Name>
				<Type>String</Type>
				<!--Module XPath Local/External reference-->
			</Parameter>
			<Parameter>
				<Name>CheckModuleTxPdoSMAssign.ModuleIndex</Name>
				<Type>Int32</Type>
			</Parameter>
			<Parameter>
				<Name>CheckModuleTxPdoSMAssign.TxPdoIndex</Name>
				<Type>Int16</Type>
				<!--i32TmpModuleIndex-->
			</Parameter>
			<LocalVariables>
				<Name>xxx_ADD_BEGIN_xxx</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>strXmlValueMandatory.String</Name>
				<Type>String</Type>
				<!--Mandatory flag - String-->
			</LocalVariables>
			<LocalVariables>
				<Name>strXmlValueMandatory.Bool</Name>
				<Type>Bool</Type>
				<!--Mandatory flag - Bool-->
			</LocalVariables>
			<LocalVariables>
				<Name>i32TmpExcludedIndex</Name>
				<Type>Int32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>strXmlValue.ExcludedSm.String</Name>
				<Type>String</Type>
				<!--ExcludedSm String-->
			</LocalVariables>
			<LocalVariables>
				<Name>strXmlValue.ExcludedSm.Uint16</Name>
				<Type>UInt16</Type>
				<!--ExcludedSm Uint16-->
			</LocalVariables>
			<LocalVariables>
				<Name>strXmlValue.Su.String</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>strXmlValue.Su.Uint16</Name>
				<Type>UInt16</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>strXmlValue.Virtual.String</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>strXmlValue.Virtual.Bool</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>strXmlValue.Entry</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>strXmlValue.SmDirection</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>strXmlValue.Sm.String</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>strXmlValue.Sm.Uint16</Name>
				<Type>UInt16</Type>
				<!--Converted string-->
			</LocalVariables>
			<LocalVariables>
				<Name>strXmlValue</Name>
				<Type>String</Type>
				<!--Checkup of valid TxPdo access-->
			</LocalVariables>
			<LocalVariables>
				<Name>xxx_ADD_END_xxx</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckTxPdoSmAssignment.Cnt</Name>
				<Type>UInt16</Type>
				<!--temp counter variable-->
			</LocalVariables>
			<LocalVariables>
				<Name>CheckTxPdoSmAssignment.ValidSmName</Name>
				<Type>String</Type>
				<!--Valid SM name is "Inputs"-->
			</LocalVariables>
			<LocalVariables>
				<Name>CheckTxPdoSmAssignment.PotentialSm</Name>
				<Type>UInt16</Type>
				<!--Number of potential SM to assign-->
			</LocalVariables>
			<LocalVariables>
				<Name>CheckTxPdoSmAssignment.TmpIndex</Name>
				<Type>Int32</Type>
				<!--temp testfunction result-->
			</LocalVariables>
			<LocalVariables>
				<Name>CheckTxPdoSmAssignment.bValid</Name>
				<Type>Bool</Type>
				<!--tmp testfunction result-->
			</LocalVariables>
			<OutParameter>
				<Name>CheckTxPdoSmAssignment.Valid</Name>
				<Type>Bool</Type>
			</OutParameter>
			<TestStep Name="START">
				<!--Check if SM Elements defined-->
				<WriteLine Id="0" Level="Verbose" Param0="DeviceDescr.SM.Count">{0} SyncManger defined in device description</WriteLine>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.SM.Count</Value1>
						<Value2>0</Value2>
						<SetVariable Target="CheckTxPdoSmAssignment.Valid">false</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Check if parameter "CheckModuleTxPdoSMAssign.TxPdoIndex" is valid (< DeviceDescr.TxPdo.Count)-->
				<GetXmlValue FileName="ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
					<XPath Param0="XPathModuleIdent" Param1="CheckModuleTxPdoSMAssign.ModuleIndex" Param2="CheckModuleTxPdoSMAssign.TxPdoIndex">{0}[{1}]/TxPdo[{2}]</XPath>
				</GetXmlValue>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>debug_msg</Value2>
						<WriteLine Id="1" Level="Output" Param0="XPathModuleIdent" Param1="CheckModuleTxPdoSMAssign.ModuleIndex" Param2="CheckModuleTxPdoSMAssign.TxPdoIndex">Requesting TxPdo index {0}[{1}]/TxPdo[{2}]</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValue</Value1>
						<Value2>null</Value2>
						<SetVariable Target="CheckTxPdoSmAssignment.Valid">false</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValue</Value1>
						<Value2>EmptyString</Value2>
						<SetVariable Target="CheckTxPdoSmAssignment.Valid">false</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValue</Value1>
						<Value2>null</Value2>
						<WriteLine Id="2" Level="Error" Param0="XPathModuleIdent" Param1="CheckModuleTxPdoSMAssign.ModuleIndex" Param2="CheckModuleTxPdoSMAssign.TxPdoIndex">Requested TxPdo index {0}[{1}]/TxPdo[{2}] is not valid. =&gt; skip test case</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValue</Value1>
						<Value2>EmptyString</Value2>
						<WriteLine Id="3" Level="Error" Param0="XPathModuleIdent" Param1="CheckModuleTxPdoSMAssign.ModuleIndex" Param2="CheckModuleTxPdoSMAssign.TxPdoIndex">Requested TxPdo index {0}[{1}]/TxPdo[{2}] is not valid. =&gt; skip test case</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValue</Value1>
						<Value2>null</Value2>
						<Return Id="4" Param0="XPathModuleIdent" Param1="CheckModuleTxPdoSMAssign.ModuleIndex" Param2="CheckModuleTxPdoSMAssign.TxPdoIndex">No TxPdo element found ({0}[{1}]/TxPdo[{2}]).</Return>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValue</Value1>
						<Value2>EmptyString</Value2>
						<Return Id="5" Param0="XPathModuleIdent" Param1="CheckModuleTxPdoSMAssign.ModuleIndex" Param2="CheckModuleTxPdoSMAssign.TxPdoIndex">No TxPdo element found ({0}[{1}]/TxPdo[{2}]).</Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Set "CheckTxPdoSmAssignment.Cnt" to 0-->
				<SetVariable Target="CheckTxPdoSmAssignment.Cnt">0</SetVariable>
			</TestStep>
			<TestStep>
				<!--Set "CheckTxPdoSmAssignment.Failed" to true-->
				<SetVariable Target="CheckTxPdoSmAssignment.Valid">true</SetVariable>
			</TestStep>
			<TestStep>
				<!--Set "CheckTxPdoSmAssignment.ValidSmName" to "Inputs"-->
				<SetVariable Target="CheckTxPdoSmAssignment.ValidSmName">Inputs</SetVariable>
			</TestStep>
			<TestStep>
				<!--Set "CheckTxPdoSmAssignment.PotentialSm" to 0-->
				<SetVariable Target="CheckTxPdoSmAssignment.PotentialSm">0</SetVariable>
			</TestStep>
			<TestStep>
				<!--Check if TxPdo is mandatory (XPath String check)-->
				<GetXmlValue FileName="ModuleXmlFile" Markup="false" ReturnValue="strXmlValueMandatory.String">
					<XPath Param0="XPathModuleIdent" Param1="CheckModuleTxPdoSMAssign.ModuleIndex" Param2="CheckModuleTxPdoSMAssign.TxPdoIndex">{0}[{1}]/TxPdo[{2}]/@Mandatory</XPath>
				</GetXmlValue>
				<Compare>
					<Equal>
						<Value1>strXmlValueMandatory.String</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>SM_Val_INIT</GotoStep>
					</Equal>
					<!--If Pdo is not mandatory (Attribute not found) iterate over all SyncManager-->
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValueMandatory.String</Value1>
						<Value2>null</Value2>
						<GotoStep>SM_Val_INIT</GotoStep>
					</Equal>
					<!--If Pdo is not mandatory (Attribute not found) iterate over all SyncManager-->
				</Compare>
			</TestStep>
			<TestStep>
				<!--Check if TxPdo is mandatory (XPath convert to Bool check)-->
				<GetXmlValue FileName="ModuleXmlFile" Markup="false" ReturnValue="strXmlValueMandatory.Bool">
					<XPath Param0="XPathModuleIdent" Param1="CheckModuleTxPdoSMAssign.ModuleIndex" Param2="CheckModuleTxPdoSMAssign.TxPdoIndex">{0}[{1}]/TxPdo[{2}]/@Mandatory</XPath>
				</GetXmlValue>
			</TestStep>
			<TestStep>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>debug_msg</Value2>
						<WriteLine Id="6" Level="Output" Param0="XPathModuleIdent" Param1="CheckModuleTxPdoSMAssign.ModuleIndex" Param2="CheckModuleTxPdoSMAssign.TxPdoIndex">{0}[{1}]/TxPdo[{2}]/@Mandatory</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>debug_msg</Value2>
						<WriteLine Id="7" Level="Output" Param0="strXmlValueMandatory.Bool" Param1="strXmlValueMandatory.String">strXmlValueMandatory.Bool = {0}, strXmlValueMandatory.String = {0}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValueMandatory.Bool</Value1>
						<Value2>false</Value2>
						<GotoStep>SM_Val_INIT</GotoStep>
					</Equal>
					<!--If Pdo is not mandatory iterate over all SyncManager-->
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="8" Level="Output" Param0="XPathModuleIdent" Param1="CheckModuleTxPdoSMAssign.ModuleIndex" Param2="CheckModuleTxPdoSMAssign.TxPdoIndex" Param3="strXmlValueMandatory.String">{0}[{1}]/TxPdo[{2}]/@Mandatory: {3}</WriteLine>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Raise an Error if TxPdo is mandatory and no default SM is defined-->
				<GetXmlValue FileName="ModuleXmlFile" Markup="true" ReturnValue="strXmlValue.Sm.String">
					<XPath Param0="XPathModuleIdent" Param1="CheckModuleTxPdoSMAssign.ModuleIndex" Param2="CheckModuleTxPdoSMAssign.TxPdoIndex">{0}[{1}]/TxPdo[{2}]/@Sm</XPath>
				</GetXmlValue>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>debug_msg</Value2>
						<WriteLine Id="9" Level="Output" Param0="strXmlValue.Sm.String">strXmlValue.Sm.String: {0}</WriteLine>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<SetVariable Target="strXmlValue.Sm.Uint16">strXmlValue.Sm.String</SetVariable>
			</TestStep>
			<TestStep>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>debug_msg</Value2>
						<WriteLine Id="10" Level="Output" Param0="strXmlValue.Sm.Uint16">strXmlValue.Sm.Uint16 = {0}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValue.Sm.String</Value1>
						<Value2>EmptyString</Value2>
						<SetVariable Target="CheckTxPdoSmAssignment.Valid">false</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValue.Sm.String</Value1>
						<Value2>EmptyString</Value2>
						<RaiseError Id="11" Param0="XPathModuleIdent" Param1="CheckModuleTxPdoSMAssign.ModuleIndex" Param2="CheckModuleTxPdoSMAssign.TxPdoIndex">A default SyncManager (TxPdo@Sm) shall be defined because the {0}[{1}]/TxPdo[{2}] is mandatory.</RaiseError>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValue.Sm.String</Value1>
						<Value2>null</Value2>
						<SetVariable Target="CheckTxPdoSmAssignment.Valid">false</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValue.Sm.String</Value1>
						<Value2>null</Value2>
						<RaiseError Id="12" Param0="XPathModuleIdent" Param1="CheckModuleTxPdoSMAssign.ModuleIndex" Param2="CheckModuleTxPdoSMAssign.TxPdoIndex">A default SyncManager (TxPdo@Sm) shall be defined because the {0}[{1}]/TxPdo[{2}] is mandatory.</RaiseError>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Raise an Error if TxPdo@Sm > available Sm.count-->
				<Compare>
					<LowerOrEqual>
						<Value1>DeviceDescr.SM.Count</Value1>
						<Value2>strXmlValue.Sm.Uint16</Value2>
						<RaiseError Id="13" Param0="XPathModuleIdent" Param1="CheckModuleTxPdoSMAssign.ModuleIndex" Param2="CheckModuleTxPdoSMAssign.TxPdoIndex" Param3="strXmlValue.Sm.Uint16">The referenced SyncManager ({0}[{1}]/TxPdo[{2}]/@Sm : {3}) is not defined in device description</RaiseError>
					</LowerOrEqual>
				</Compare>
			</TestStep>
			<TestStep>
				<!--If TxPdo.ExcludeSM is defined dump a warning (Pdo shall be assigned to a fixed SM so the element is not required)-->
				<GetXmlValue FileName="ModuleXmlFile" Markup="true" ReturnValue="strXmlValue.ExcludedSm.Uint16">
					<XPath Param0="XPathModuleIdent" Param1="CheckModuleTxPdoSMAssign.ModuleIndex" Param2="CheckModuleTxPdoSMAssign.TxPdoIndex">{0}[{1}]/TxPdo[{2}]/ExcludedSm</XPath>
				</GetXmlValue>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>debug_msg</Value2>
						<WriteLine Id="14" Level="Output" Param0="strXmlValue.ExcludedSm.Uint16">strXmlValue.ExcludedSm.Uint16 {0}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>strXmlValue.ExcludedSm.Uint16</Value1>
						<Value2>null</Value2>
						<WriteLine Id="15" Level="Warning" Param0="XPathModuleIdent" Param1="CheckModuleTxPdoSMAssign.ModuleIndex" Param2="CheckModuleTxPdoSMAssign.TxPdoIndex">{0}[{1}]/TxPdo[{2}] is mandatory so no ExcludeSm need to be defined.</WriteLine>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Set "CheckTxPdoSmAssignment.Cnt" to TxPdo@Sm (the PDO shall assigned to the specified SM => only this SM will be tested-->
				<SetVariable Target="CheckTxPdoSmAssignment.Cnt">strXmlValue.Sm.Uint16</SetVariable>
				<WriteLine Id="16" Level="Verbose" Param0="XPathModuleIdent" Param1="CheckModuleTxPdoSMAssign.ModuleIndex" Param2="CheckModuleTxPdoSMAssign.TxPdoIndex" Param3="CheckTxPdoSmAssignment.Cnt">{0}[{1}]/TxPdo[{2}] is fixed assigned to SyncManager[{3}] (@Mandatory == true and @SM defined)=&gt; only this SM is tested</WriteLine>
			</TestStep>
			<TestStep>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>SMLOOPSTART</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="SM_Val_INIT">
				<GetXmlValue FileName="ModuleXmlFile" Markup="true" ReturnValue="strXmlValue.Sm.String">
					<XPath Param0="XPathModuleIdent" Param1="CheckModuleTxPdoSMAssign.ModuleIndex" Param2="CheckModuleTxPdoSMAssign.TxPdoIndex">{0}[{1}]/TxPdo[{2}]/@Sm</XPath>
				</GetXmlValue>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>debug_msg</Value2>
						<WriteLine Id="17" Level="Output" Param0="strXmlValue.Sm.String">strXmlValue.Sm.String: {0}</WriteLine>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<SetVariable Target="strXmlValue.Sm.Uint16">strXmlValue.Sm.String</SetVariable>
			</TestStep>
			<TestStep>
				<SetVariable Target="CheckTxPdoSmAssignment.Cnt">strXmlValue.Sm.Uint16</SetVariable>
			</TestStep>
			<TestStep>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>SMLOOPSTART</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="SMLOOPSTART">
				<WriteLine Id="18" Param0="CheckTxPdoSmAssignment.Cnt" Level="Verbose">Check SM[{0}]</WriteLine>
			</TestStep>
			<TestStep>
				<!--Check if SyncManager direction and type match-->
				<Compare>
					<Equal>
						<Value1>CheckTxPdoSmAssignment.ValidSmName</Value1>
						<Value2>DeviceDescr.SM[CheckTxPdoSmAssignment.Cnt]</Value2>
						<GotoStep>ExcludedLOOPStart</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="SMCheck">
				<!--SM direction and/or type not match dump an error if this is the default SM or proceed with next SM-->
				<Compare>
					<Equal>
						<Value1>strXmlValue.Sm.String</Value1>
						<Value2>EmptyString</Value2>
						<WriteLine Id="19" Level="Verbose" Param0="CheckTxPdoSmAssignment.Cnt" Param1="CheckTxPdoSmAssignment.ValidSmName" Param2="DeviceDescr.SM[CheckTxPdoSmAssignment.Cnt]">SM[{0}] skipped because SM type not match (expected: {1}, read: {2}).</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValue.Sm.String</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>SMLOOPEND</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValue.Sm.String</Value1>
						<Value2>null</Value2>
						<WriteLine Id="20" Level="Verbose" Param0="CheckTxPdoSmAssignment.Cnt" Param1="CheckTxPdoSmAssignment.ValidSmName" Param2="DeviceDescr.SM[CheckTxPdoSmAssignment.Cnt]">SM[{0}] skipped because SM type not match (expected: {1}, read: {2}).</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValue.Sm.String</Value1>
						<Value2>null</Value2>
						<GotoStep>SMLOOPEND</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckTxPdoSmAssignment.Cnt</Value1>
						<Value2>strXmlValue.Sm.Uint16</Value2>
						<WriteLine Id="21" Level="Verbose" Param0="CheckTxPdoSmAssignment.Cnt">SM[{0}] skipped because SM type not match.</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckTxPdoSmAssignment.Cnt</Value1>
						<Value2>strXmlValue.Sm.Uint16</Value2>
						<GotoStep>SMLOOPEND</GotoStep>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>debug_msg</Value2>
						<WriteLine Id="22" Level="Output" Param0="strXmlValue.Sm.Uint16">strXmlValue.Sm.Uint16: {0}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>True</Value1>
						<Value2>True</Value2>
						<SetVariable Target="CheckTxPdoSmAssignment.Valid">false</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>True</Value1>
						<Value2>True</Value2>
						<WriteLine Id="23" Level="Error" Param0="strXmlValue.Sm.Uint16" Param1="CheckTxPdoSmAssignment.ValidSmName" Param2="DeviceDescr.SM[CheckTxPdoSmAssignment.Cnt]">Type/Direction of default SyncManager[{0}] doesn't match. (expected "{1}", read "{2}")</WriteLine>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="ExcludedLOOPStart">
				<SetVariable Target="i32TmpExcludedIndex">1</SetVariable>
			</TestStep>
			<TestStep Name="EXCLUDESM">
				<!--Check if TxPdo.ExcludedSm is defined-->
				<GetXmlValue FileName="ModuleXmlFile" Markup="true" ReturnValue="strXmlValue.ExcludedSm.String">
					<XPath Param0="XPathModuleIdent" Param1="CheckModuleTxPdoSMAssign.ModuleIndex" Param2="CheckModuleTxPdoSMAssign.TxPdoIndex" Param3="i32TmpExcludedIndex">{0}[{1}]/TxPdo[{2}]/ExcludedSm[{3}]</XPath>
				</GetXmlValue>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>debug_msg</Value2>
						<WriteLine Id="24" Level="Output" Param0="i32TmpExcludedIndex">i32TmpExcludedIndex {0}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>debug_msg</Value2>
						<WriteLine Id="25" Level="Output" Param0="strXmlValue.Sm.String" Param1="strXmlValue.ExcludedSm.String">strXmlValue.Sm.Uint16: {0} and strXmlValue.ExcludedSm.Uint16: {1}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValue.ExcludedSm.String</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>TESTSU</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValue.ExcludedSm.String</Value1>
						<Value2>null</Value2>
						<GotoStep>TESTSU</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Check if current Sm is defined in Exclude Sm List-->
				<SetVariable Target="strXmlValue.ExcludedSm.Uint16">strXmlValue.ExcludedSm.String</SetVariable>
			</TestStep>
			<TestStep>
				<!--If current Sm is not excluded proceed with Su step-->
				<Compare>
					<Equal>
						<Value1>strXmlValue.ExcludedSm.Uint16</Value1>
						<Value2>strXmlValue.Sm.Uint16</Value2>
						<WriteLine Id="26" Level="Verbose" Param0="CheckTxPdoSmAssignment.Cnt" Param1="XPathModuleIdent" Param2="CheckModuleTxPdoSMAssign.ModuleIndex" Param3="CheckModuleTxPdoSMAssign.TxPdoIndex">SM[{0}] skipped because SM is listed in {1}[{2}]/TxPdo[{3}]/ExcludedSm</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>strXmlValue.ExcludedSm.Uint16</Value1>
						<Value2>strXmlValue.Sm.Uint16</Value2>
						<GotoStep>ExcludedLOOPEnd</GotoStep>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Dump an Error if default SM is excluded-->
				<Compare>
					<!--proceed with next Sm if no default Sm is defined-->
					<Equal>
						<Value1>strXmlValue.Sm.Uint16</Value1>
						<Value2>null</Value2>
						<GotoStep>SMLOOPEND</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValue.ExcludedSm.Uint16</Value1>
						<Value2>strXmlValue.Sm.Uint16</Value2>
						<WriteLine Id="27" Level="Error" Param0="CheckModuleTxPdoSMAssign.TxPdoIndex">TxPdo[{0}] Exclude the configured default Sm.</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValue.ExcludedSm.Uint16</Value1>
						<Value2>strXmlValue.Sm.Uint16</Value2>
						<SetVariable Target="CheckTxPdoSmAssignment.Valid">false</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValue.ExcludedSm.Uint16</Value1>
						<Value2>strXmlValue.Sm.Uint16</Value2>
						<GotoStep>SMLOOPEND</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="ExcludedLOOPEnd">
				<SetVariable Target="i32TmpExcludedIndex">i32TmpExcludedIndex + 1</SetVariable>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>EXCLUDESM</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="TESTSU">
				<!--Check if TxPdo.Su is defined-->
				<GetXmlValue FileName="ModuleXmlFile" Markup="true" ReturnValue="strXmlValue.Su.String">
					<XPath Param0="XPathModuleIdent" Param1="CheckModuleTxPdoSMAssign.ModuleIndex" Param2="CheckModuleTxPdoSMAssign.TxPdoIndex">{0}[{1}]/TxPdo[{2}]/@Su</XPath>
				</GetXmlValue>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>debug_msg</Value2>
						<WriteLine Id="28" Level="Output" Param0="strXmlValue.Su.String">strXmlValue.Su.String = {0}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValue.Su.String</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>STARTTESTSM</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValue.Su.String</Value1>
						<Value2>null</Value2>
						<GotoStep>STARTTESTSM</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="TESTSU_ON">
				<SetVariable Target="strXmlValue.Su.Uint16">strXmlValue.Su.String</SetVariable>
				<Compare>
					<Equal>
						<Value1>strXmlValue.Su.Uint16</Value1>
						<Value2>null</Value2>
						<GotoStep>STARTTESTSM</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<Compare>
					<Equal>
						<Value1>strXmlValue.Sm.String</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>STARTTESTSM</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValue.Sm.String</Value1>
						<Value2>null</Value2>
						<GotoStep>STARTTESTSM</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Check if current Sm is referenced via Su-->
				<CallTestFunction Name="IsSmReferencedViaSu">
					<Parameter>CheckTxPdoSmAssignment.Cnt</Parameter>
					<Parameter>strXmlValue.Su.Uint16</Parameter>
					<OutParameter>CheckTxPdoSmAssignment.bValid</OutParameter>
				</CallTestFunction>
			</TestStep>
			<TestStep>
				<!--Skip Sm Test if it is not referenced via Su-->
				<Compare>
					<Equal>
						<Value1>CheckTxPdoSmAssignment.bValid</Value1>
						<Value2>false</Value2>
						<WriteLine Id="29" Level="Verbose" Param0="CheckTxPdoSmAssignment.Cnt">SM[{0}] skipped because SM is not referenced via Su</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckTxPdoSmAssignment.bValid</Value1>
						<Value2>false</Value2>
						<GotoStep>SMLOOPEND</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="STARTTESTSM">
				<!--SyncManager may be used for the PDO => increment indication counter-->
				<SetVariable Target="CheckTxPdoSmAssignment.PotentialSm">CheckTxPdoSmAssignment.PotentialSm + 1</SetVariable>
			</TestStep>
			<TestStep Name="CHECKVIRTUAL">
				<!--Check if virtual settings are correct-->
				<GetXmlValue FileName="ModuleXmlFile" Markup="true" ReturnValue="strXmlValue.Virtual.String">
					<XPath Param0="XPathModuleIdent" Param1="CheckModuleTxPdoSMAssign.ModuleIndex" Param2="CheckModuleTxPdoSMAssign.TxPdoIndex">{0}[{1}]/TxPdo[{2}]/@Virtual</XPath>
				</GetXmlValue>
				<Compare>
					<Equal>
						<Value1>strXmlValue.Virtual.String</Value1>
						<Value2>EmptyString</Value2>
						<SetVariable Target="strXmlValue.Virtual.Bool">false</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValue.Virtual.String</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>NOTVIRTUAL</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValue.Virtual.String</Value1>
						<Value2>null</Value2>
						<SetVariable Target="strXmlValue.Virtual.Bool">false</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValue.Virtual.String</Value1>
						<Value2>null</Value2>
						<GotoStep>NOTVIRTUAL</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<GetXmlValue FileName="ModuleXmlFile" Markup="true" ReturnValue="strXmlValue.Virtual.Bool">
					<XPath Param0="XPathModuleIdent" Param1="CheckModuleTxPdoSMAssign.ModuleIndex" Param2="CheckModuleTxPdoSMAssign.TxPdoIndex">{0}[{1}]/TxPdo[{2}]/@Virtual</XPath>
				</GetXmlValue>
			</TestStep>
			<TestStep>
				<Compare>
					<Equal>
						<Value1>strXmlValue.Virtual.Bool</Value1>
						<Value2>false</Value2>
						<GotoStep>NOTVIRTUAL</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<GetXmlValue FileName="ModuleXmlFile" Markup="true" ReturnValue="strXmlValue.Entry">
					<XPath Param0="XPathModuleIdent" Param1="CheckModuleTxPdoSMAssign.ModuleIndex" Param2="CheckModuleTxPdoSMAssign.TxPdoIndex">{0}[{1}]/TxPdo[{2}]/Entry</XPath>
				</GetXmlValue>
				<Compare>
					<NotEqual>
						<Value1>strXmlValue.Entry</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>VIRTUALENTRIES</GotoStep>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>strXmlValue.Entry</Value1>
						<Value2>null</Value2>
						<GotoStep>VIRTUALENTRIES</GotoStep>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep>
				<!--PDO is virtual
if Entries defined goto "VIRTUALENTRIES"
else 
current SM is not virtual => correct
current SM is virtual but is not the default SM => warning because of a possible wrong configuration
the default SM is virtual => Error-->
				<Compare>
					<Equal>
						<Value1>DeviceDescr.SM[CheckTxPdoSmAssignment.Cnt].Virtual</Value1>
						<Value2>false</Value2>
						<GotoStep>SMLOOPEND</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValue.Sm.Uint16</Value1>
						<Value2>null</Value2>
						<WriteLine Id="30" Level="Warning" Param0="CheckModuleTxPdoSMAssign.TxPdoIndex" Param1="CheckTxPdoSmAssignment.Cnt">Virtual TxPdo[{0}] with no Entries may be assigned to the virtual SyncManager[{1}].</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValue.Sm.Uint16</Value1>
						<Value2>null</Value2>
						<GotoStep>SMLOOPEND</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>strXmlValue.Sm.Uint16</Value1>
						<Value2>CheckTxPdoSmAssignment.Cnt</Value2>
						<WriteLine Id="31" Level="Warning" Param0="CheckModuleTxPdoSMAssign.TxPdoIndex" Param1="CheckTxPdoSmAssignment.Cnt">Virtual TxPdo[{0}] with no Entries may be assigned to the virtual SyncManager[{1}].</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>strXmlValue.Sm.Uint16</Value1>
						<Value2>CheckTxPdoSmAssignment.Cnt</Value2>
						<GotoStep>SMLOOPEND</GotoStep>
					</NotEqual>
				</Compare>
				<Compare>
					<!--The current PDO is not virtual but the default SM is virtual-->
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="32" Level="Error" Param0="CheckModuleTxPdoSMAssign.TxPdoIndex" Param1="CheckTxPdoSmAssignment.Cnt">Virtual TxPdo[{0}] with no Entries is assigned to the virtual SyncManager[{1}].</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<SetVariable Target="CheckTxPdoSmAssignment.Valid">false</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>SMLOOPEND</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="VIRTUALENTRIES">
				<!--PDO is virtual and Entries defined
- the current SM is virtual => correct
- current SM is not virtual but is not the default SM => warning because of a possible wrong configuration
the default SM is not virtual => Error-->
				<Compare>
					<Equal>
						<Value1>DeviceDescr.SM[CheckTxPdoSmAssignment.Cnt].Virtual</Value1>
						<Value2>true</Value2>
						<GotoStep>SMLOOPEND</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValue.Sm.Uint16</Value1>
						<Value2>null</Value2>
						<WriteLine Id="33" Level="Warning" Param0="CheckModuleTxPdoSMAssign.TxPdoIndex" Param1="CheckTxPdoSmAssignment.Cnt">Virtual TxPdo[{0}] with Entries may be assigned to the non virtual SyncManager[{1}].</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValue.Sm.Uint16</Value1>
						<Value2>null</Value2>
						<GotoStep>SMLOOPEND</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>strXmlValue.Sm.Uint16</Value1>
						<Value2>CheckTxPdoSmAssignment.Cnt</Value2>
						<WriteLine Id="34" Level="Warning" Param0="CheckModuleTxPdoSMAssign.TxPdoIndex" Param1="CheckTxPdoSmAssignment.Cnt">Virtual TxPdo[{0}] with Entries may be assigned to the non virtual SyncManager[{1}].</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>strXmlValue.Sm.Uint16</Value1>
						<Value2>CheckTxPdoSmAssignment.Cnt</Value2>
						<GotoStep>SMLOOPEND</GotoStep>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="35" Level="Error" Param0="CheckModuleTxPdoSMAssign.TxPdoIndex" Param1="CheckTxPdoSmAssignment.Cnt">Virtual TxPdo[{0}] with Entries is assigned to the virtual SyncManager[{1}].</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<SetVariable Target="CheckTxPdoSmAssignment.Valid">false</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>SMLOOPEND</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="NOTVIRTUAL">
				<!--PDO is not virtual-->
				<Compare>
					<Equal>
						<Value1>DeviceDescr.SM[CheckTxPdoSmAssignment.Cnt].Virtual</Value1>
						<Value2>false</Value2>
						<GotoStep>SMLOOPEND</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValue.Sm.Uint16</Value1>
						<Value2>null</Value2>
						<WriteLine Id="36" Level="Warning" Param0="CheckModuleTxPdoSMAssign.TxPdoIndex" Param1="CheckTxPdoSmAssignment.Cnt">Non virtual TxPdo[{0}] may be assigned to virtual SyncManager[{1}]</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValue.Sm.Uint16</Value1>
						<Value2>null</Value2>
						<GotoStep>SMLOOPEND</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>strXmlValue.Sm.Uint16</Value1>
						<Value2>CheckTxPdoSmAssignment.Cnt</Value2>
						<WriteLine Id="37" Level="Warning" Param0="CheckModuleTxPdoSMAssign.TxPdoIndex" Param1="CheckTxPdoSmAssignment.Cnt">Non virtual TxPdo[{0}] may be assigned to virtual SyncManager[{1}]</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>strXmlValue.Sm.Uint16</Value1>
						<Value2>CheckTxPdoSmAssignment.Cnt</Value2>
						<GotoStep>SMLOOPEND</GotoStep>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValue.Sm.Uint16</Value1>
						<Value2>CheckTxPdoSmAssignment.Cnt</Value2>
						<WriteLine Id="38" Level="Error" Param0="CheckModuleTxPdoSMAssign.TxPdoIndex" Param1="CheckTxPdoSmAssignment.Cnt">Non virtual TxPdo[{0}] is by default assigned to virtual SyncManager[{1}]</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValue.Sm.Uint16</Value1>
						<Value2>CheckTxPdoSmAssignment.Cnt</Value2>
						<SetVariable Target="CheckTxPdoSmAssignment.Valid">false</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="SMLOOPEND">
				<!--Abort loop if
- Pdo is mandatory 
OR
- "CheckTxPdoSmAssignment.Cnt" >= "DeviceDescr.SM.Count"-->
				<SetVariable Target="CheckTxPdoSmAssignment.Cnt">CheckTxPdoSmAssignment.Cnt + 1</SetVariable>
				<Compare>
					<Equal>
						<Value1>strXmlValueMandatory.Bool</Value1>
						<Value2>true</Value2>
						<GotoStep>END</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Lower>
						<Value1>CheckTxPdoSmAssignment.Cnt</Value1>
						<Value2>DeviceDescr.SM.Count</Value2>
						<GotoStep>SMLOOPSTART</GotoStep>
					</Lower>
				</Compare>
			</TestStep>
			<TestStep Name="END">
				<Compare>
					<Equal>
						<Value1>CheckTxPdoSmAssignment.PotentialSm</Value1>
						<Value2>0</Value2>
						<WriteLine Id="39" Level="Error" Param0="XPathModuleIdent" Param1="CheckModuleTxPdoSMAssign.ModuleIndex" Param2="CheckModuleTxPdoSMAssign.TxPdoIndex">No SyncManager for {0}[{1}]/TxPdo[{2}] found</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckTxPdoSmAssignment.PotentialSm</Value1>
						<Value2>0</Value2>
						<SetVariable Target="CheckTxPdoSmAssignment.Valid">false</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction Name="CheckObjectInfoData" FunctionId="501">
			<?MAX_OUTPUT_ID 4?>
			<Description>
				<Action>Check if Data is valid for used DataType</Action>
				<PostCondition>Data shall not exceed the used DataType</PostCondition>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>CheckObjectInfoData.DataType</Name>
				<Type>String</Type>
			</Parameter>
			<Parameter>
				<Name>CheckObjectInfoData.BitSize</Name>
				<Type>Int32</Type>
			</Parameter>
			<Parameter>
				<Name>CheckObjectInfoData.Data</Name>
				<Type>String</Type>
			</Parameter>
			<Parameter>
				<Name>CheckObjectInfoData.InfoString</Name>
				<Type>String</Type>
			</Parameter>
			<LocalVariables>
				<Name>CheckObjectInfoData.NumberOfNibbles</Name>
				<Type>UInt32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckObjectInfoData.LengthOfData</Name>
				<Type>UInt32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckObjectInfoData.IsMatch</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckObjectInfoData.u32Value</Name>
				<Type>UInt32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckObjectInfoData.u32MaxValue</Name>
				<Type>UInt32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckObjectInfoData.u32CurMaxValue</Name>
				<Type>UInt32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckObjectInfoData.ArrData</Name>
				<Type>ArrayOfBytes</Type>
			</LocalVariables>
			<OutParameter>
				<Name>CheckObjectInfoData.Result</Name>
				<Type>Bool</Type>
			</OutParameter>
			<TestStep Name="INIT_RESULT">
				<SetVariable Target="CheckObjectInfoData.Result">true</SetVariable>
			</TestStep>
			<TestStep Name="GetNumberOfNibbles">
				<SetVariable Target="CheckObjectInfoData.NumberOfNibbles">(CheckObjectInfoData.BitSize + 3) /4</SetVariable>
				<!--min size is one Byte-->
				<Compare>
					<Lower>
						<Value1>CheckObjectInfoData.NumberOfNibbles</Value1>
						<Value2>2</Value2>
						<SetVariable Target="CheckObjectInfoData.NumberOfNibbles">2</SetVariable>
					</Lower>
				</Compare>
			</TestStep>
			<TestStep Name="GetLengthOfData">
				<SizeOf UInt32Var="CheckObjectInfoData.LengthOfData">CheckObjectInfoData.Data</SizeOf>
			</TestStep>
			<TestStep Name="CompareLengthVsNibble">
				<Compare>
					<Equal>
						<Value1>CheckObjectInfoData.LengthOfData</Value1>
						<Value2>0</Value2>
						<WriteLine Id="0" Level="Error" Param0="CheckObjectInfoData.InfoString">{0} Invalid Default Data Element: Length of Default Data is 0.</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckObjectInfoData.LengthOfData</Value1>
						<Value2>0</Value2>
						<SetVariable Target="CheckObjectInfoData.Result">false</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckObjectInfoData.LengthOfData</Value1>
						<Value2>0</Value2>
						<Return Id="1"></Return>
					</Equal>
				</Compare>
				<Compare>
					<Greater>
						<Value1>CheckObjectInfoData.LengthOfData</Value1>
						<Value2>CheckObjectInfoData.NumberOfNibbles</Value2>
						<WriteLine Id="2" Level="Error" Param0="CheckObjectInfoData.InfoString" Param1="CheckObjectInfoData.Data" Param2="CheckObjectInfoData.DataType">{0} ({1}) is too long for the used DataType ({2}).</WriteLine>
					</Greater>
				</Compare>
				<Compare>
					<Greater>
						<Value1>CheckObjectInfoData.LengthOfData</Value1>
						<Value2>CheckObjectInfoData.NumberOfNibbles</Value2>
						<SetVariable Target="CheckObjectInfoData.Result">false</SetVariable>
					</Greater>
				</Compare>
			</TestStep>
			<TestStep Name="SkipIfBitSizeIsGreaterOrEqualOneByte">
				<Compare>
					<Greater>
						<Value1>CheckObjectInfoData.BitSize</Value1>
						<Value2>7</Value2>
						<Return Id="3"></Return>
					</Greater>
				</Compare>
			</TestStep>
			<TestStep Name="GetValueOfData">
				<SetVariable Target="CheckObjectInfoData.ArrData">CheckObjectInfoData.Data</SetVariable>
			</TestStep>
			<TestStep>
				<SetVariable Target="CheckObjectInfoData.u32Value">CheckObjectInfoData.ArrData[0]</SetVariable>
			</TestStep>
			<TestStep Name="GetMaxValue">
				<SetVariable Target="CheckObjectInfoData.u32MaxValue">65535</SetVariable>
			</TestStep>
			<TestStep>
				<GetBits Source="CheckObjectInfoData.u32MaxValue" Target="CheckObjectInfoData.u32CurMaxValue">
					<Offset>0</Offset>
					<Length>CheckObjectInfoData.BitSize</Length>
				</GetBits>
			</TestStep>
			<TestStep Name="ComparDataValueAndCurMaxValue">
				<Compare>
					<Greater>
						<Value1>CheckObjectInfoData.u32Value</Value1>
						<Value2>CheckObjectInfoData.u32CurMaxValue</Value2>
						<WriteLine Id="4" Level="Error" Param0="CheckObjectInfoData.InfoString" Param1="CheckObjectInfoData.u32Value" Param2="CheckObjectInfoData.u32CurMaxValue">{0} ({1}) is too large for the used DataType (max {2}).</WriteLine>
					</Greater>
				</Compare>
				<Compare>
					<Greater>
						<Value1>CheckObjectInfoData.u32Value</Value1>
						<Value2>CheckObjectInfoData.u32CurMaxValue</Value2>
						<SetVariable Target="CheckObjectInfoData.Result">false</SetVariable>
					</Greater>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction Name="CheckObjectInfoString" FunctionId="502">
			<?MAX_OUTPUT_ID 2?>
			<Description>
				<Action>Check if Data is valid for used DataType</Action>
				<PostCondition>'DefaultString' shall not exceed the used DataType and shall only used for STRING(n)</PostCondition>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>CheckObjectInfoString.DataType</Name>
				<Type>String</Type>
			</Parameter>
			<Parameter>
				<Name>CheckObjectInfoString.BitSize</Name>
				<Type>Int32</Type>
			</Parameter>
			<Parameter>
				<Name>CheckObjectInfoString.String</Name>
				<Type>String</Type>
			</Parameter>
			<Parameter>
				<Name>CheckObjectInfoString.InfoString</Name>
				<Type>String</Type>
			</Parameter>
			<LocalVariables>
				<Name>CheckObjectInfoString.LengthOfString</Name>
				<Type>UInt32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckObjectInfoString.IsMatch</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<OutParameter>
				<Name>CheckObjectInfoString.Result</Name>
				<Type>Bool</Type>
			</OutParameter>
			<TestStep Name="INIT_RESULT">
				<SetVariable Target="CheckObjectInfoString.Result">true</SetVariable>
			</TestStep>
			<TestStep Name="CHECK_IF_STRING">
				<RegexIsMatch ReturnValue="CheckObjectInfoString.IsMatch">
					<Pattern>^(STRING\([0-9]+\))$</Pattern>
					<InputString>CheckObjectInfoString.DataType</InputString>
				</RegexIsMatch>
				<Compare>
					<Equal>
						<Value1>CheckObjectInfoString.IsMatch</Value1>
						<Value2>false</Value2>
						<WriteLine Id="0" Level="Error" Param0="CheckObjectInfoString.InfoString" Param1="CheckObjectInfoString.DataType">'{0}' shall not be defined for {1}.</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckObjectInfoString.IsMatch</Value1>
						<Value2>false</Value2>
						<SetVariable Target="CheckObjectInfoString.Result">false</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckObjectInfoString.IsMatch</Value1>
						<Value2>false</Value2>
						<Return Id="1"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="GetLengthOfString">
				<SizeOf UInt32Var="CheckObjectInfoString.LengthOfString">CheckObjectInfoString.String</SizeOf>
			</TestStep>
			<TestStep Name="CompareLengthVsBitSize">
				<Compare>
					<Greater>
						<Value1>CheckObjectInfoString.LengthOfString</Value1>
						<Value2>CheckObjectInfoString.BitSize / 8</Value2>
						<WriteLine Id="2" Level="Error" Param0="CheckObjectInfoString.InfoString" Param1="CheckObjectInfoString.String" Param2="CheckObjectInfoData.DataType">{0} ({1}) is too long for the used DataType ({2}).</WriteLine>
					</Greater>
				</Compare>
				<Compare>
					<Greater>
						<Value1>CheckObjectInfoString.LengthOfString</Value1>
						<Value2>CheckObjectInfoString.BitSize / 8</Value2>
						<SetVariable Target="CheckObjectInfoString.Result">false</SetVariable>
					</Greater>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction Name="CheckObjectInfoValue" FunctionId="503">
			<?MAX_OUTPUT_ID 2?>
			<Description>
				<Action>Check if Value is valid for used DataType</Action>
				<PostCondition>Value shall not exceed the used DataType and shall only used for DataType with a fixed length</PostCondition>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>CheckObjectInfoValue.DataType</Name>
				<Type>String</Type>
			</Parameter>
			<Parameter>
				<Name>CheckObjectInfoValue.BitSize</Name>
				<Type>Int32</Type>
			</Parameter>
			<Parameter>
				<Name>CheckObjectInfoValue.Value</Name>
				<Type>Int64</Type>
			</Parameter>
			<Parameter>
				<Name>CheckObjectInfoValue.InfoString</Name>
				<Type>String</Type>
			</Parameter>
			<LocalVariables>
				<Name>CheckObjectInfoValue.MaxValue</Name>
				<Type>Int64</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckObjectInfoValue.CurMaxValue</Name>
				<Type>Int64</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckObjectInfoValue.IsMatch</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<OutParameter>
				<Name>CheckObjectInfoValue.Result</Name>
				<Type>Bool</Type>
			</OutParameter>
			<TestStep Name="INIT_RESULT">
				<SetVariable Target="CheckObjectInfoValue.Result">true</SetVariable>
			</TestStep>
			<TestStep Name="INIT_MAX_VALUE">
				<SetVariable Target="CheckObjectInfoValue.MaxValue">9223372036854775807</SetVariable>
			</TestStep>
			<TestStep Name="CHECK_IF_FIXED_LENGTH_TYPE">
				<RegexIsMatch ReturnValue="CheckObjectInfoValue.IsMatch">
					<Pattern>^(BOOL|BIT|BIT[1-8]|BYTE|BITARR8|BITARR16|WORD|BITARR32|DWORD|SINT|INT|INT24|DINT|INT40|INT48|INT56|LINT|USINT|UINT|UINT24|UDINT|UINT40|UINT48|UINT56|ULINT|REAL|LREAL|(DT[0-9A-F]{1,4}EN([0-9]{2})))$</Pattern>
					<InputString>CheckObjectInfoValue.DataType</InputString>
				</RegexIsMatch>
				<Compare>
					<Equal>
						<Value1>CheckObjectInfoValue.IsMatch</Value1>
						<Value2>false</Value2>
						<WriteLine Id="0" Level="Error" Param0="CheckObjectInfoValue.InfoString" Param1="CheckObjectInfoValue.DataType">'{0}' shall not be defined for {1}.</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckObjectInfoValue.IsMatch</Value1>
						<Value2>false</Value2>
						<SetVariable Target="CheckObjectInfoValue.Result">false</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckObjectInfoValue.IsMatch</Value1>
						<Value2>false</Value2>
						<Return Id="1"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="GET_CURRENT_MAX_VALUE">
				<GetBits Source="CheckObjectInfoValue.MaxValue" Target="CheckObjectInfoValue.CurMaxValue">
					<Offset>0</Offset>
					<Length>CheckObjectInfoValue.BitSize</Length>
				</GetBits>
			</TestStep>
			<TestStep Name="CompareCurMaxValueVsValue">
				<Compare>
					<Lower>
						<Value1>CheckObjectInfoValue.CurMaxValue</Value1>
						<Value2>CheckObjectInfoValue.Value</Value2>
						<WriteLine Id="2" Level="Error" Param0="CheckObjectInfoValue.InfoString" Param1="CheckObjectInfoValue.Value" Param2="CheckObjectInfoValue.DataType">{0} ({1}) is too long for the used DataType ({2}).</WriteLine>
					</Lower>
				</Compare>
				<Compare>
					<Lower>
						<Value1>CheckObjectInfoValue.CurMaxValue</Value1>
						<Value2>CheckObjectInfoValue.Value</Value2>
						<SetVariable Target="CheckObjectInfoValue.Result">false</SetVariable>
					</Lower>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction Name="CheckRemainingSm" FunctionId="601">
			<?MAX_OUTPUT_ID 1?>
			<Parameter>
				<Name>CheckRemainingSm.boolOutputs</Name>
				<Type>Bool</Type>
			</Parameter>
			<Parameter>
				<Name>CheckRemainingSm.arrCheckedSm</Name>
				<Type>ArrayOfUInt16</Type>
			</Parameter>
			<LocalVariables>
				<Name>CheckRemainingSm.uint16Counter</Name>
				<Type>UInt16</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckRemainingSm.stringSmName</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckRemainingSm.boolAlreadyChecked</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<OutParameter>
				<Name>CheckRemainingSm.ErrorCounter</Name>
				<Type>UInt16</Type>
			</OutParameter>
			<TestStep Name="CheckForSmType">
				<Compare>
					<Equal>
						<Value1>CheckRemainingSm.boolOutputs</Value1>
						<Value2>true</Value2>
						<SetVariable Target="CheckRemainingSm.stringSmName">Outputs</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckRemainingSm.boolOutputs</Value1>
						<Value2>false</Value2>
						<SetVariable Target="CheckRemainingSm.stringSmName">Inputs</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CheckIfEnd">
				<Compare>
					<GreaterOrEqual>
						<Value1>CheckRemainingSm.uint16Counter</Value1>
						<Value2>DeviceDescr.SM.Count</Value2>
						<Return Id="0"></Return>
					</GreaterOrEqual>
				</Compare>
			</TestStep>
			<TestStep Name="CheckSmName">
				<Compare>
					<NotEqual>
						<Value1>DeviceDescr.SM[CheckRemainingSm.uint16Counter]</Value1>
						<Value2>CheckRemainingSm.stringSmName</Value2>
						<GotoStep>IncrementCounter</GotoStep>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<CallTestFunction Name="CheckItemInArray">
							<Parameter>CheckRemainingSm.arrCheckedSm</Parameter>
							<Parameter>CheckRemainingSm.uint16Counter</Parameter>
							<OutParameter>CheckRemainingSm.boolAlreadyChecked</OutParameter>
						</CallTestFunction>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckRemainingSm.boolAlreadyChecked</Value1>
						<Value2>true</Value2>
						<GotoStep>IncrementCounter</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CheckDefaultSize">
				<Compare>
					<Equal>
						<Value1>DeviceDescr.SM[CheckRemainingSm.uint16Counter].DefaultSize</Value1>
						<Value2>0</Value2>
						<GotoStep>IncrementCounter</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.SM[CheckRemainingSm.uint16Counter].DefaultSize</Value1>
						<Value2>null</Value2>
						<GotoStep>IncrementCounter</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="1" Level="Error" Param0="CheckRemainingSm.uint16Counter" Param1="DeviceDescr.SM[CheckRemainingSm.uint16Counter].DefaultSize">CheckRemainingSm: Default Size (actual value: {1} Byte) of SM {0} shall be zero or null because there is no default PDO assignment.</WriteLine>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="IncrementErrorCounter">
				<SetVariable Target="CheckRemainingSm.ErrorCounter">CheckRemainingSm.ErrorCounter+1</SetVariable>
			</TestStep>
			<TestStep Name="IncrementCounter">
				<SetVariable Target="CheckRemainingSm.uint16Counter">CheckRemainingSm.uint16Counter+1</SetVariable>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>CheckIfEnd</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction Name="CheckRxPdoCat" FunctionId="701">
			<?MAX_OUTPUT_ID 8?>
			<TestStep>
				<WriteLine Id="0" Level="Verbose" Param0="DeviceDescr.RxPdo[index].Index" Param1="index" Param2="EEPROM.CatRXPdo[index].PDOIndex">EtherCAT Slave Information File RxPDO[{1:d}] Index: 0x{0:x4}, E²PROM RxPDO[{1:d}] PDOIndex: 0x{2:x4}</WriteLine>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.RxPdo[index].Virtual</Value1>
						<Value2>true</Value2>
						<Return Id="1">Virtual RxPdo --&gt; break compare RxPdos</Return>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>DeviceDescr.RxPdo[index].Index</Value1>
						<Value2>EEPROM.CatRXPdo[index].PDOIndex</Value2>
						<RaiseError Id="2" Param0="index">PdoIndexes of RxPDO{0:d} unequal</RaiseError>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Mailbox AND DeviceDescr.Mailbox.SoE</Value1>
						<Value2>true</Value2>
						<GotoStep>CheckEntryCount</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Mailbox.CoE</Value1>
						<Value2>false</Value2>
						<GotoStep>CheckEntryCount</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Greater>
						<Value1>EEPROM.CatRXPdo[index].PDOIndex</Value1>
						<Value2>#x17ff</Value2>
						<RaiseError Id="3">RxPDO Index has to be greater than 0x15FF and lower than 0x1800</RaiseError>
					</Greater>
				</Compare>
				<Compare>
					<Lower>
						<Value1>EEPROM.CatRXPdo[index].PDOIndex</Value1>
						<Value2>#x1600</Value2>
						<RaiseError Id="4">RxPDO Index has to be greater than 0x15FF and lower than 0x1800</RaiseError>
					</Lower>
				</Compare>
			</TestStep>
			<TestStep Name="CheckEntryCount">
				<WriteLine Id="5" Level="Verbose" Param0="DeviceDescr.RxPdo[index].Entry.Count" Param1="index" Param2="EEPROM.CatRXPdo[index].Entry.Count">EtherCAT Slave Information File RxPdo[{1:d}] number of entries: {0}, E²PROM RxPdo[{1:d}]  number of entries: {2:d}</WriteLine>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.RxPdo[index].Entry.Count</Value1>
						<Value2>0</Value2>
						<WriteLine Id="6" Param0="index">The DeviceDescription has no element for Device:RxPdo[{0:d}]:Entry</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>DeviceDescr.RxPdo[index].Entry.Count</Value1>
						<Value2>EEPROM.CatRXPdo[index].Entry.Count</Value2>
						<RaiseError Id="7" Param0="index">Number of entries of RxPDO{0:d} unequal</RaiseError>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.RxPdo[index].Entry.Count</Value1>
						<Value2>0</Value2>
						<Return Id="8"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<SetVariable Target="entryIdx">0</SetVariable>
			</TestStep>
			<TestStep Name="NextEntry">
				<CallFunction>CheckRxPdoEntry</CallFunction>
			</TestStep>
			<TestStep>
				<SetVariable Target="entryIdx">entryIdx+1</SetVariable>
			</TestStep>
			<TestStep Name="checkIndex">
				<Compare>
					<Lower>
						<Value1>entryIdx</Value1>
						<Value2>DeviceDescr.RxPdo[index].Entry.Count</Value2>
						<GotoStep>NextEntry</GotoStep>
					</Lower>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction Name="CheckRxPdoEntry" FunctionId="702">
			<?MAX_OUTPUT_ID 5?>
			<TestStep>
				<WriteLine Id="0" Level="Verbose" Param0="DeviceDescr.RxPdo[index].Entry[entryIdx].Index" Param1="index" Param2="EEPROM.CatRXPdo[index].Entry[entryIdx].EntryIndex" Param3="entryIdx">EtherCAT Slave Information File RxPDO[{1:d}]:Entry[{3:d}]:Index: 0x{0:x4}, E²PROM RxPDO[{1:d}] Entry[{3:d}]Index: 0x{2:x4}</WriteLine>
				<Compare>
					<NotEqual>
						<Value1>DeviceDescr.RxPdo[index].Entry[entryIdx].Index</Value1>
						<Value2>EEPROM.CatRXPdo[index].Entry[entryIdx].EntryIndex</Value2>
						<RaiseError Id="1" Param0="index" Param1="entryIdx">PdoIndexes of RxPDO[{0:d}]Entry[{1}] unequal</RaiseError>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep>
				<WriteLine Id="2" Level="Verbose" Param0="DeviceDescr.RxPdo[index].Entry[entryIdx].SubIndex" Param1="index" Param2="EEPROM.CatRXPdo[index].Entry[entryIdx].Subindex" Param3="entryIdx">EtherCAT Slave Information File RxPDO[{1:d}]:Entry[{3:d}]:SubIndex: {0:d},  E²PROM RxPDO[{1:d}] Entry[{3:d}]Subindex: {2:d}</WriteLine>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.RxPdo[index].Entry[entryIdx].SubIndex</Value1>
						<Value2>null</Value2>
						<GotoStep>CompareBitLen</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Mailbox.SoE</Value1>
						<Value2>true</Value2>
						<GotoStep>CompareBitLen</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>DeviceDescr.RxPdo[index].Entry[entryIdx].SubIndex</Value1>
						<Value2>EEPROM.CatRXPdo[index].Entry[entryIdx].Subindex</Value2>
						<RaiseError Id="3" Param0="index" Param1="entryIdx">Subindex of RxPDO[{0:d}] Entry[{1:d}] unequal</RaiseError>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="CompareBitLen">
				<WriteLine Id="4" Level="Verbose" Param0="DeviceDescr.RxPdo[index].Entry[entryIdx].BitLen" Param1="index" Param2="EEPROM.CatRXPdo[index].Entry[entryIdx].BitLen" Param3="entryIdx">EtherCAT Slave Information File RxPDO[{1:d}]:Entry[{3:d}]:BitLen {0:d},  E²PROM RxPDO[{1:d}] Entry[{3:d}]BitLen: {2:d}</WriteLine>
				<Compare>
					<NotEqual>
						<Value1>DeviceDescr.RxPdo[index].Entry[entryIdx].BitLen</Value1>
						<Value2>EEPROM.CatRXPdo[index].Entry[entryIdx].BitLen</Value2>
						<RaiseError Id="5" Param0="index" Param1="entryIdx">BitLen of RxPDO[{0:d}] Entry[{1:d}] unequal</RaiseError>
					</NotEqual>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction Name="CheckRxPdoExcludeElement" FunctionId="703">
			<?MAX_OUTPUT_ID 7?>
			<Parameter>
				<Name>CheckRxPdoExcludeElement.PdoIndex</Name>
				<Type>UInt16</Type>
				<!--Zero based index of the PDO-->
			</Parameter>
			<LocalVariables>
				<Name>CheckRxPdoExcludeElement.Cnt</Name>
				<Type>UInt16</Type>
				<!--temp counter variable-->
			</LocalVariables>
			<LocalVariables>
				<Name>CheckRxPdoExcludeElement.i32Index</Name>
				<Type>Int32</Type>
				<!--index of excluded PDO-->
			</LocalVariables>
			<LocalVariables>
				<Name>CheckRxPdoExcludeElement.i32Index2</Name>
				<Type>Int32</Type>
				<!--index of current PDO in Excluded RxPdo exclude list-->
			</LocalVariables>
			<LocalVariables>
				<Name>CheckRxPdoExcludeElement.NumExclude</Name>
				<Type>UInt32</Type>
				<!--Number of exclude PDOs-->
			</LocalVariables>
			<LocalVariables>
				<Name>CheckRxPdoExcludeElement.ExcludePdoIndex</Name>
				<Type>Int32</Type>
				<!--Index of the Excluded RxPdo-->
			</LocalVariables>
			<LocalVariables>
				<Name>CheckRxPdoExcludeElement.u16ArrRxPdo</Name>
				<Type>ArrayOfUInt16</Type>
				<!--array to store all defined RxPdo indicies-->
			</LocalVariables>
			<OutParameter>
				<Name>CheckRxPdoExcludeElement.Valid</Name>
				<Type>Bool</Type>
			</OutParameter>
			<TestStep>
				<!--Check if requested PDO index is defined-->
				<Compare>
					<GreaterOrEqual>
						<Value1>CheckRxPdoExcludeElement.PdoIndex</Value1>
						<Value2>DeviceDescr.RxPdo.Count</Value2>
						<WriteLine Id="0" Level="Error" Param0="CheckRxPdoExcludeElement.PdoIndex">Requested RxPdo {0} not defined in ESI.</WriteLine>
					</GreaterOrEqual>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Init "CheckRxPdoExcludeElement.Valid" = true-->
				<SetVariable Target="CheckRxPdoExcludeElement.Valid">true</SetVariable>
			</TestStep>
			<TestStep>
				<!--Check if Exclude elements defined-->
				<Compare>
					<Equal>
						<Value1>DeviceDescr.RxPdo[CheckRxPdoExcludeElement.PdoIndex].Exclude</Value1>
						<Value2>null</Value2>
						<WriteLine Id="1" Level="Verbose" Param0="CheckRxPdoExcludeElement.PdoIndex">No Exclude element defined for RxPdo[{0}].</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.RxPdo[CheckRxPdoExcludeElement.PdoIndex].Exclude</Value1>
						<Value2>null</Value2>
						<Return Id="2"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Copy all defined RxPdo indicies to Uint16Array-->
				<CallTestFunction Name="RxPdoElementsToArray">
					<OutParameter>CheckRxPdoExcludeElement.u16ArrRxPdo</OutParameter>
				</CallTestFunction>
			</TestStep>
			<TestStep>
				<!--Init "CheckRxPdoExcludeElement.Cnt" = 0-->
				<SetVariable Target="CheckRxPdoExcludeElement.Cnt">0</SetVariable>
			</TestStep>
			<TestStep>
				<!--Init "CheckRxPdoExcludeElement.NumExclude" = 0-->
				<SetVariable Target="CheckRxPdoExcludeElement.NumExclude">0</SetVariable>
			</TestStep>
			<TestStep>
				<!--Get Number of Exclude Elements-->
				<SizeOf UInt32Var="CheckRxPdoExcludeElement.NumExclude">DeviceDescr.RxPdo[CheckRxPdoExcludeElement.PdoIndex].Exclude</SizeOf>
				<WriteLine Id="3" Level="Verbose" Param0="CheckRxPdoExcludeElement.PdoIndex" Param1="CheckRxPdoExcludeElement.NumExclude">RxPdo[{0}] has {1} exclude PDO(s)</WriteLine>
			</TestStep>
			<TestStep Name="LOOPSTART">
				<!--Check if loop condition still valid-->
				<Compare>
					<GreaterOrEqual>
						<Value1>CheckRxPdoExcludeElement.Cnt</Value1>
						<Value2>CheckRxPdoExcludeElement.NumExclude</Value2>
						<Return Id="4"></Return>
					</GreaterOrEqual>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Init "CheckRxPdoExcludeElement.i32Index" = -1-->
				<SetVariable Target="CheckRxPdoExcludeElement.i32Index">-1</SetVariable>
			</TestStep>
			<TestStep>
				<!--Get Index of current excluded Pdo-->
				<CallTestFunction Name="ArrayOfUInt16.IndexOf">
					<Parameter>DeviceDescr.RxPdo[CheckRxPdoExcludeElement.PdoIndex].Exclude[CheckRxPdoExcludeElement.Cnt]</Parameter>
					<Parameter>CheckRxPdoExcludeElement.u16ArrRxPdo</Parameter>
					<OutParameter>CheckRxPdoExcludeElement.i32Index</OutParameter>
				</CallTestFunction>
				<WriteLine Id="5" Level="Verbose" Param0="DeviceDescr.RxPdo[CheckRxPdoExcludeElement.PdoIndex].Exclude[CheckRxPdoExcludeElement.Cnt]" Param1="CheckRxPdoExcludeElement.i32Index">Excluded RxPdo (0x{0:x4}) found at element index {1}.</WriteLine>
			</TestStep>
			<TestStep>
				<!--Dump Warning if non defined RxPdo is exlcuded-->
				<Compare>
					<Equal>
						<Value1>CheckRxPdoExcludeElement.i32Index</Value1>
						<Value2>-1</Value2>
						<WriteLine Id="6" Level="Warning" Param0="DeviceDescr.RxPdo[CheckRxPdoExcludeElement.PdoIndex].Exclude[CheckRxPdoExcludeElement.Cnt]">Index 0x{0:x4} is not defined in RxPdo device description</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckRxPdoExcludeElement.i32Index</Value1>
						<Value2>-1</Value2>
						<GotoStep>LOOPEND</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Init "CheckRxPdoExcludeElement.i32Index2" = -1-->
				<SetVariable Target="CheckRxPdoExcludeElement.i32Index2">-1</SetVariable>
			</TestStep>
			<TestStep>
				<!--current RxPdo shall also be excluded by Excluded RxPdo-->
				<CallTestFunction Name="ArrayOfUInt16.IndexOf">
					<Parameter>DeviceDescr.RxPdo[CheckRxPdoExcludeElement.PdoIndex].Index</Parameter>
					<Parameter>DeviceDescr.RxPdo[CheckRxPdoExcludeElement.i32Index].Exclude</Parameter>
					<OutParameter>CheckRxPdoExcludeElement.i32Index2</OutParameter>
				</CallTestFunction>
				<Compare>
					<Equal>
						<Value1>CheckRxPdoExcludeElement.i32Index2</Value1>
						<Value2>-1</Value2>
						<WriteLine Id="7" Level="Error" Param0="DeviceDescr.RxPdo[CheckRxPdoExcludeElement.PdoIndex].Index" Param1="DeviceDescr.RxPdo[CheckRxPdoExcludeElement.i32Index].Index">Current RxPdo (0x{0:x4}) is not excluded by 0x{1:x4}.</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckRxPdoExcludeElement.i32Index2</Value1>
						<Value2>-1</Value2>
						<SetVariable Target="CheckRxPdoExcludeElement.Valid">false</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="LOOPEND">
				<!--Last step in loop-->
				<SetVariable Target="CheckRxPdoExcludeElement.Cnt">CheckRxPdoExcludeElement.Cnt +1</SetVariable>
			</TestStep>
		</TestFunction>
		<TestFunction Name="CheckRxPdoExcludeElement_gen" FunctionId="20602">
			<?MAX_OUTPUT_ID 17?>
			<Parameter>
				<Name>RxPdoExclude.XmlFileXPath</Name>
				<Type>String</Type>
				<Comment>XPath of XML file (local, external)</Comment>
			</Parameter>
			<Parameter>
				<Name>RxPdoExclude.ModuleXPath</Name>
				<Type>String</Type>
				<Comment>XPath of Module</Comment>
			</Parameter>
			<Parameter>
				<Name>CountRxPdoExclude.ModuleCount</Name>
				<Type>Int32</Type>
				<Comment>Module Count for XPath string</Comment>
			</Parameter>
			<Parameter>
				<Name>CheckRxPdoExcludeElement.PdoIndex</Name>
				<Type>Int32</Type>
				<!--Zero based index of the PDO-->
				<Comment>RxPdo Count for XPath string</Comment>
			</Parameter>
			<LocalVariables>
				<Name>CheckRxPdoExcludeElement.Cnt</Name>
				<Type>UInt16</Type>
				<!--temp counter variable-->
			</LocalVariables>
			<LocalVariables>
				<Name>CheckRxPdoExcludeElement.i32Index</Name>
				<Type>Int32</Type>
				<!--index of excluded PDO-->
			</LocalVariables>
			<LocalVariables>
				<Name>CheckRxPdoExcludeElement.i32Index2</Name>
				<Type>Int32</Type>
				<!--index of current PDO in Excluded RxPdo exclude list-->
			</LocalVariables>
			<LocalVariables>
				<Name>CheckRxPdoExcludeElement.NumExclude</Name>
				<Type>UInt32</Type>
				<!--Number of exclude PDOs-->
			</LocalVariables>
			<LocalVariables>
				<Name>CheckRxPdoExcludeElement.ExcludePdoIndex</Name>
				<Type>Int32</Type>
				<!--Index of the Excluded RxPdo-->
			</LocalVariables>
			<LocalVariables>
				<Name>CheckRxPdoExcludeElement.u16ArrRxPdo</Name>
				<Type>ArrayOfUInt16</Type>
				<!--array to store all defined RxPdo indicies-->
			</LocalVariables>
			<LocalVariables>
				<Name>xxx_ADD_BEGIN_xxx</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>strXmlValue.RxPdoExcludeIndex.Uint16</Name>
				<Type>UInt16</Type>
				<!--Pdo Index-->
			</LocalVariables>
			<LocalVariables>
				<Name>strXmlValue.RxPdoExclude.String</Name>
				<Type>String</Type>
				<!--Pdo Exclude String-->
			</LocalVariables>
			<LocalVariables>
				<Name>strXmlValue.RxPdoExclude.Uint16</Name>
				<Type>UInt16</Type>
				<!--Pdo Exclude Uint16-->
			</LocalVariables>
			<LocalVariables>
				<Name>Uint32TmpExcludedIndex</Name>
				<Type>UInt32</Type>
				<!--Temporary Exclude Counter-->
			</LocalVariables>
			<LocalVariables>
				<Name>CheckExcludeElement.u16ArrRxPdo</Name>
				<Type>ArrayOfUInt16</Type>
				<!--array to store all defined Excludes-->
			</LocalVariables>
			<LocalVariables>
				<Name>strXmlValue.RxPdoExcludeIndex2.Uint16</Name>
				<Type>UInt16</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>xxx_ADD_END_xxx</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<OutParameter>
				<Name>CheckRxPdoExcludeElement.Valid</Name>
				<Type>Bool</Type>
			</OutParameter>
			<TestStep>
				<!--Check if requested PDO index is defined-->
				<GetXmlValue FileName="RxPdoExclude.XmlFileXPath" Markup="false" ReturnValue="strXmlValue.RxPdoExcludeIndex.Uint16">
					<XPath Param0="RxPdoExclude.ModuleXPath" Param1="CountRxPdoExclude.ModuleCount" Param2="CheckRxPdoExcludeElement.PdoIndex">{0}[{1}]/RxPdo[{2}]/Index</XPath>
				</GetXmlValue>
				<Compare>
					<NotEqual>
						<Value1>strXmlValue.RxPdoExcludeIndex.Uint16</Value1>
						<Value2>0</Value2>
						<GotoStep>CHECKOK</GotoStep>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValue.RxPdoExcludeIndex.Uint16</Value1>
						<Value2>null</Value2>
						<WriteLine Id="0" Level="Error" Param0="RxPdoExclude.ModuleXPath" Param1="CountRxPdoExclude.ModuleCount" Param2="CheckRxPdoExcludeElement.PdoIndex">Requested {0}[{1}]/RxPdo[{2}] not defined in ESI.</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValue.RxPdoExcludeIndex.Uint16</Value1>
						<Value2>EmptyString</Value2>
						<WriteLine Id="1" Level="Error" Param0="RxPdoExclude.ModuleXPath" Param1="CountRxPdoExclude.ModuleCount" Param2="CheckRxPdoExcludeElement.PdoIndex">Requested {0}[{1}]/RxPdo[{2}] not defined in ESI.</WriteLine>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CHECKOK">
				<!--Init "CheckRxPdoExcludeElement.Valid" = true-->
				<SetVariable Target="CheckRxPdoExcludeElement.Valid">true</SetVariable>
			</TestStep>
			<TestStep>
				<!--Check if Exclude elements defined-->
				<GetXmlValue FileName="RxPdoExclude.XmlFileXPath" Markup="false" ReturnValue="strXmlValue.RxPdoExclude.String">
					<XPath Param0="RxPdoExclude.ModuleXPath" Param1="CountRxPdoExclude.ModuleCount" Param2="CheckRxPdoExcludeElement.PdoIndex">{0}[{1}]/RxPdo[{2}]/Exclude</XPath>
				</GetXmlValue>
				<Compare>
					<Equal>
						<Value1>strXmlValue.RxPdoExclude.String</Value1>
						<Value2>EmptyString</Value2>
						<WriteLine Id="2" Level="Verbose" Param0="RxPdoExclude.ModuleXPath" Param1="CountRxPdoExclude.ModuleCount" Param2="CheckRxPdoExcludeElement.PdoIndex">No Exclude element defined for {0}[{1}]/RxPdo[{2}].</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValue.RxPdoExclude.String</Value1>
						<Value2>EmptyString</Value2>
						<Return Id="3"></Return>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValue.RxPdoExclude.String</Value1>
						<Value2>null</Value2>
						<WriteLine Id="4" Level="Verbose" Param0="RxPdoExclude.ModuleXPath" Param1="CountRxPdoExclude.ModuleCount" Param2="CheckRxPdoExcludeElement.PdoIndex">No Exclude element defined for {0}[{1}]/RxPdo[{2}].</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValue.RxPdoExclude.String</Value1>
						<Value2>null</Value2>
						<Return Id="5"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Copy all defined RxPdo indicies to Uint16Array-->
				<CallTestFunction Name="PdoElementsToArray_gen">
					<Parameter>true</Parameter>
					<Parameter>RxPdoExclude.XmlFileXPath</Parameter>
					<Parameter>RxPdoExclude.ModuleXPath</Parameter>
					<Parameter>CountRxPdoExclude.ModuleCount</Parameter>
					<Parameter>CheckRxPdoExcludeElement.PdoIndex</Parameter>
					<OutParameter>CheckRxPdoExcludeElement.u16ArrRxPdo</OutParameter>
				</CallTestFunction>
			</TestStep>
			<TestStep>
				<!--Init "CheckRxPdoExcludeElement.Cnt" = 1 (because of XPath)-->
				<SetVariable Target="CheckRxPdoExcludeElement.Cnt">1</SetVariable>
			</TestStep>
			<TestStep>
				<!--Init "CheckRxPdoExcludeElement.NumExclude" = 0-->
				<SetVariable Target="CheckRxPdoExcludeElement.NumExclude">0</SetVariable>
			</TestStep>
			<TestStep>
				<SetVariable Target="Uint32TmpExcludedIndex">1</SetVariable>
			</TestStep>
			<TestStep Name="EXCLUDE_Count_LOOPSTART">
				<!--Get Number of Exclude Elements-->
			</TestStep>
			<TestStep>
				<!--Check if RxPdo.Exclude is defined-->
				<GetXmlValue FileName="RxPdoExclude.XmlFileXPath" Markup="false" ReturnValue="strXmlValue.RxPdoExclude.String">
					<XPath Param0="RxPdoExclude.ModuleXPath" Param1="CountRxPdoExclude.ModuleCount" Param2="CheckRxPdoExcludeElement.PdoIndex" Param3="Uint32TmpExcludedIndex">{0}[{1}]/RxPdo[{2}]/Exclude[{3}]</XPath>
				</GetXmlValue>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>debug_msg</Value2>
						<WriteLine Id="6" Level="Output" Param0="strXmlValue.RxPdoExclude.String">strXmlValue.RxPdoExclude.String: {0}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValue.RxPdoExclude.String</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>NUM_EXCLUDED_EL</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValue.RxPdoExclude.String</Value1>
						<Value2>null</Value2>
						<GotoStep>NUM_EXCLUDED_EL</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<WriteLine Id="7" Level="Verbose" Param0="RxPdoExclude.ModuleXPath" Param1="CountRxPdoExclude.ModuleCount" Param2="CheckRxPdoExcludeElement.PdoIndex" Param3="Uint32TmpExcludedIndex">Exclude PDO(s) found in: {0}[{1}]/RxPdo[{2}]/Exclude[{3}].</WriteLine>
			</TestStep>
			<TestStep Name="ExcludedLOOPEnd">
				<SetVariable Target="Uint32TmpExcludedIndex">Uint32TmpExcludedIndex + 1</SetVariable>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>EXCLUDE_Count_LOOPSTART</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="NUM_EXCLUDED_EL">
				<!--Set number of Excluded elements and report number.-->
				<SetVariable Target="Uint32TmpExcludedIndex">Uint32TmpExcludedIndex - 1</SetVariable>
				<WriteLine Id="8" Level="Verbose" Param0="RxPdoExclude.ModuleXPath" Param1="CountRxPdoExclude.ModuleCount" Param2="CheckRxPdoExcludeElement.PdoIndex" Param3="Uint32TmpExcludedIndex">{0}[{1}]/RxPdo[{2}] has {3} exclude PDO(s)</WriteLine>
			</TestStep>
			<TestStep Name="LOOPSTART">
				<SetVariable Target="CheckRxPdoExcludeElement.NumExclude">Uint32TmpExcludedIndex</SetVariable>
			</TestStep>
			<TestStep>
				<!--Check if loop condition still valid-->
				<Compare>
					<Greater>
						<Value1>CheckRxPdoExcludeElement.Cnt</Value1>
						<Value2>CheckRxPdoExcludeElement.NumExclude</Value2>
						<Return Id="9"></Return>
					</Greater>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Init "CheckRxPdoExcludeElement.i32Index" = -1-->
				<SetVariable Target="CheckRxPdoExcludeElement.i32Index">-1</SetVariable>
			</TestStep>
			<TestStep>
				<!--Get Index of current excluded Pdo-->
				<GetXmlValue FileName="RxPdoExclude.XmlFileXPath" Markup="false" ReturnValue="strXmlValue.RxPdoExclude.Uint16">
					<XPath Param0="RxPdoExclude.ModuleXPath" Param1="CountRxPdoExclude.ModuleCount" Param2="CheckRxPdoExcludeElement.PdoIndex" Param3="CheckRxPdoExcludeElement.Cnt">{0}[{1}]/RxPdo[{2}]/Exclude[{3}]</XPath>
				</GetXmlValue>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>debug_msg</Value2>
						<WriteLine Id="10" Level="Output" Param0="CheckRxPdoExcludeElement.Cnt">Value of "CheckRxPdoExcludeElement.Cnt": {0}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>debug_msg</Value2>
						<WriteLine Id="11" Level="Output" Param0="strXmlValue.RxPdoExclude.Uint16">Value of "strXmlValue.RxPdoExclude.Uint16": {0}</WriteLine>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<CallTestFunction Name="ArrayOfUInt16.IndexOf">
					<Parameter>strXmlValue.RxPdoExclude.Uint16</Parameter>
					<Parameter>CheckRxPdoExcludeElement.u16ArrRxPdo</Parameter>
					<OutParameter>CheckRxPdoExcludeElement.i32Index</OutParameter>
				</CallTestFunction>
				<WriteLine Id="12" Level="Verbose" Param0="strXmlValue.RxPdoExclude.Uint16" Param1="CheckRxPdoExcludeElement.i32Index">Excluded RxPdo (0x{0:x4}) found at element index {1}.</WriteLine>
			</TestStep>
			<TestStep>
				<!--Dump Warning if non defined RxPdo is exlcuded-->
				<Compare>
					<Equal>
						<Value1>CheckRxPdoExcludeElement.i32Index</Value1>
						<Value2>-1</Value2>
						<WriteLine Id="13" Level="Warning" Param0="strXmlValue.RxPdoExclude.Uint16">Index 0x{0:x4} is not defined in RxPdo device description</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckRxPdoExcludeElement.i32Index</Value1>
						<Value2>-1</Value2>
						<GotoStep>LOOPEND</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Init "CheckRxPdoExcludeElement.i32Index2" = -1-->
				<SetVariable Target="CheckRxPdoExcludeElement.i32Index2">-1</SetVariable>
			</TestStep>
			<TestStep>
				<!--current RxPdo shall also be excluded by Excluded RxPdo-->
				<GetXmlValue FileName="RxPdoExclude.XmlFileXPath" Markup="false" ReturnValue="strXmlValue.RxPdoExcludeIndex.Uint16">
					<XPath Param0="RxPdoExclude.ModuleXPath" Param1="CountRxPdoExclude.ModuleCount" Param2="CheckRxPdoExcludeElement.PdoIndex">{0}[{1}]/RxPdo[{2}]/Index</XPath>
				</GetXmlValue>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>debug_msg</Value2>
						<WriteLine Id="14" Level="Output" Param0="CheckRxPdoExcludeElement.PdoIndex">Value of CheckRxPdoExcludeElement.PdoIndex: {0}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>debug_msg</Value2>
						<WriteLine Id="15" Level="Output" Param0="strXmlValue.RxPdoExcludeIndex.Uint16">Value of "strXmlValue.RxPdoExcludeIndex.Uint16": {0}</WriteLine>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--CheckRxPdoExcludeElement.i32Index+1 (+1 because of XPath)-->
				<GetXmlValue FileName="RxPdoExclude.XmlFileXPath" Markup="false" ReturnValue="strXmlValue.RxPdoExcludeIndex2.Uint16">
					<XPath Param0="RxPdoExclude.ModuleXPath" Param1="CountRxPdoExclude.ModuleCount" Param2="CheckRxPdoExcludeElement.i32Index">{0}[{1}]/RxPdo[{2}]/Index</XPath>
				</GetXmlValue>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>debug_msg</Value2>
						<WriteLine Id="16" Level="Output" Param0="strXmlValue.RxPdoExcludeIndex2.Uint16">Value of "strXmlValue.RxPdoExcludeIndex2.Uint16": {0}</WriteLine>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<CallTestFunction Name="PdoExcludeElementsToArray_gen">
					<Parameter>true</Parameter>
					<Parameter>RxPdoExclude.XmlFileXPath</Parameter>
					<Parameter>RxPdoExclude.ModuleXPath</Parameter>
					<Parameter>CountRxPdoExclude.ModuleCount</Parameter>
					<Parameter>CheckRxPdoExcludeElement.i32Index</Parameter>
					<OutParameter>CheckExcludeElement.u16ArrRxPdo</OutParameter>
				</CallTestFunction>
			</TestStep>
			<TestStep>
				<CallTestFunction Name="ArrayOfUInt16.IndexOf">
					<Parameter>strXmlValue.RxPdoExcludeIndex.Uint16</Parameter>
					<Parameter>CheckExcludeElement.u16ArrRxPdo</Parameter>
					<OutParameter>CheckRxPdoExcludeElement.i32Index2</OutParameter>
				</CallTestFunction>
				<Compare>
					<Equal>
						<Value1>CheckRxPdoExcludeElement.i32Index2</Value1>
						<Value2>-1</Value2>
						<WriteLine Id="17" Level="Error" Param0="strXmlValue.RxPdoExcludeIndex.Uint16" Param1="strXmlValue.RxPdoExclude.Uint16">Current RxPdo (0x{0:x4}) is not excluded by 0x{1:x4}.</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckRxPdoExcludeElement.i32Index2</Value1>
						<Value2>-1</Value2>
						<SetVariable Target="CheckRxPdoExcludeElement.Valid">false</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="LOOPEND">
				<!--Last step in loop-->
				<SetVariable Target="CheckRxPdoExcludeElement.Cnt">CheckRxPdoExcludeElement.Cnt +1</SetVariable>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>LOOPSTART</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction Name="CheckRxPdoSmAssignment" FunctionId="704">
			<?MAX_OUTPUT_ID 24?>
			<!--Iterate of all defined SyncManger and check if RxPdo assignment is valid-->
			<Parameter>
				<Name>CheckRxPdoSmAssignment.PdoIndex</Name>
				<Type>UInt16</Type>
				<!--Zero based index of the RxPDO-->
			</Parameter>
			<LocalVariables>
				<Name>CheckRxPdoSmAssignment.Cnt</Name>
				<Type>UInt16</Type>
				<!--temp counter variable-->
			</LocalVariables>
			<LocalVariables>
				<Name>CheckRxPdoSmAssignment.ValidSmName</Name>
				<Type>String</Type>
				<!--Valid SM name is "Outputs"-->
			</LocalVariables>
			<LocalVariables>
				<Name>CheckRxPdoSmAssignment.PotentialSm</Name>
				<Type>UInt16</Type>
				<!--Number of potential SM to assign-->
			</LocalVariables>
			<LocalVariables>
				<Name>CheckRxPdoSmAssignment.TmpIndex</Name>
				<Type>Int32</Type>
				<!--temp testfunction result-->
			</LocalVariables>
			<LocalVariables>
				<Name>CheckRxPdoSmAssignment.bValid</Name>
				<Type>Bool</Type>
				<!--tmp testfunction result-->
			</LocalVariables>
			<OutParameter>
				<Name>CheckRxPdoSmAssignment.Valid</Name>
				<Type>Bool</Type>
			</OutParameter>
			<TestStep Name="START">
				<!--Check if SM Elements defined-->
				<WriteLine Id="0" Level="Verbose" Param0="DeviceDescr.SM.Count">{0} SyncManger defined in device description</WriteLine>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.SM.Count</Value1>
						<Value2>0</Value2>
						<SetVariable Target="CheckRxPdoSmAssignment.Valid">false</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Check if parameter "CheckRxPdoSmAssignment.PdoIndex" is valid (< DeviceDescr.RxPdo.Count)-->
				<Compare>
					<LowerOrEqual>
						<Value1>DeviceDescr.RxPdo.Count</Value1>
						<Value2>CheckRxPdoSmAssignment.PdoIndex</Value2>
						<WriteLine Id="1" Level="Error" Param0="CheckRxPdoSmAssignment.PdoIndex" Param1="DeviceDescr.RxPdo.Count">Requested RxPdo index {0} greater or equal {1} =&gt; skip test case</WriteLine>
					</LowerOrEqual>
				</Compare>
				<Compare>
					<LowerOrEqual>
						<Value1>DeviceDescr.RxPdo.Count</Value1>
						<Value2>CheckRxPdoSmAssignment.PdoIndex</Value2>
						<SetVariable Target="CheckRxPdoSmAssignment.Valid">false</SetVariable>
					</LowerOrEqual>
				</Compare>
				<Compare>
					<LowerOrEqual>
						<Value1>DeviceDescr.RxPdo.Count</Value1>
						<Value2>CheckRxPdoSmAssignment.PdoIndex</Value2>
						<Return Id="2"></Return>
					</LowerOrEqual>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Set "CheckRxPdoSmAssignment.Cnt" to 0-->
				<SetVariable Target="CheckRxPdoSmAssignment.Cnt">0</SetVariable>
			</TestStep>
			<TestStep>
				<!--Set "CheckRxPdoSmAssignment.Failed" to true-->
				<SetVariable Target="CheckRxPdoSmAssignment.Valid">true</SetVariable>
			</TestStep>
			<TestStep>
				<!--Set "CheckRxPdoSmAssignment.ValidSmName" to "Outputs"-->
				<SetVariable Target="CheckRxPdoSmAssignment.ValidSmName">Outputs</SetVariable>
			</TestStep>
			<TestStep>
				<!--Set "CheckRxPdoSmAssignment.PotentialSm" to 0-->
				<SetVariable Target="CheckRxPdoSmAssignment.PotentialSm">0</SetVariable>
			</TestStep>
			<TestStep>
				<!--Set "CheckRxPdoSmAssignment.Cnt" to 0-->
				<SetVariable Target="CheckRxPdoSmAssignment.Cnt">0</SetVariable>
			</TestStep>
			<TestStep>
				<!--Check if RxPdo is mandatory-->
				<Description Id="3"> </Description>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.RxPdo[CheckRxPdoSmAssignment.PdoIndex].Mandatory</Value1>
						<Value2>false</Value2>
						<GotoStep>SMLOOPSTART</GotoStep>
					</Equal>
					<!--If Pdo is not mandatory iterate over all SyncManager-->
				</Compare>
			</TestStep>
			<TestStep>
				<!--Raise an Error if RxPdo is mandatory and no default SM is defined-->
				<Compare>
					<Equal>
						<Value1>DeviceDescr.RxPdo[CheckRxPdoSmAssignment.PdoIndex].Sm</Value1>
						<Value2>null</Value2>
						<SetVariable Target="CheckRxPdoSmAssignment.Valid">false</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.RxPdo[CheckRxPdoSmAssignment.PdoIndex].Sm</Value1>
						<Value2>null</Value2>
						<RaiseError Id="4" Param0="CheckRxPdoSmAssignment.PdoIndex">A default SyncManager (RxPdo@Sm) shall be defined because the RxPdo[{0}] is mandatory.</RaiseError>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Raise an Error if RxPdo@Sm > available Sm.count-->
				<Compare>
					<LowerOrEqual>
						<Value1>DeviceDescr.SM.Count</Value1>
						<Value2>DeviceDescr.RxPdo[CheckRxPdoSmAssignment.PdoIndex].Sm</Value2>
						<RaiseError Id="5" Param0="CheckRxPdoSmAssignment.PdoIndex" Param1="DeviceDescr.RxPdo[CheckRxPdoSmAssignment.PdoIndex].Sm">The referenced SyncManager (RxPdo[{0}].Sm : {1}) is not defined in device description</RaiseError>
					</LowerOrEqual>
				</Compare>
			</TestStep>
			<TestStep>
				<!--If RxPdo.ExcludeSM is defined dump a warning (Pdo shall be assigned to a fixed SM so the element is not required)-->
				<Compare>
					<NotEqual>
						<Value1>DeviceDescr.RxPdo[CheckRxPdoSmAssignment.PdoIndex].ExcludedSm</Value1>
						<Value2>null</Value2>
						<WriteLine Id="6" Level="Warning" Param0="CheckRxPdoSmAssignment.PdoIndex">RxPdo[{0}] is mandatory so no ExcludeSm need to be defined.</WriteLine>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Set "CheckRxPdoSmAssignment.Cnt" to RxPdo@Sm (the PDO shall assigned to the specified SM => only this SM will be tested-->
				<SetVariable Target="CheckRxPdoSmAssignment.Cnt">DeviceDescr.RxPdo[CheckRxPdoSmAssignment.PdoIndex].Sm</SetVariable>
				<WriteLine Id="7" Level="Verbose" Param0="CheckRxPdoSmAssignment.PdoIndex" Param1="CheckRxPdoSmAssignment.Cnt">RxPdo[{0}] is fixed assigned to SyncManager[{1}] (@Mandatory == true and @SM defined)=&gt; only this SM is tested</WriteLine>
			</TestStep>
			<TestStep Name="SMLOOPSTART">
				<WriteLine Id="8" Param0="CheckRxPdoSmAssignment.Cnt" Level="Verbose">Check SM[{0}]</WriteLine>
			</TestStep>
			<TestStep>
				<!--Check if SyncManager direction and type match-->
				<Compare>
					<Equal>
						<Value1>CheckRxPdoSmAssignment.ValidSmName</Value1>
						<Value2>DeviceDescr.SM[CheckRxPdoSmAssignment.Cnt]</Value2>
						<GotoStep>EXCLUDESM</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--SM direction and/or type not match dump an error if this is the default SM or proceed with next SM-->
				<Compare>
					<Equal>
						<Value1>DeviceDescr.RxPdo[CheckRxPdoSmAssignment.PdoIndex].Sm</Value1>
						<Value2>null</Value2>
						<WriteLine Id="9" Level="Verbose" Param0="CheckRxPdoSmAssignment.Cnt" Param1="CheckRxPdoSmAssignment.ValidSmName" Param2="DeviceDescr.SM[CheckRxPdoSmAssignment.Cnt]">SM[{0}] skipped because SM type not match (expected: {1}, read: {2}).</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.RxPdo[CheckRxPdoSmAssignment.PdoIndex].Sm</Value1>
						<Value2>null</Value2>
						<GotoStep>SMLOOPEND</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckRxPdoSmAssignment.Cnt</Value1>
						<Value2>DeviceDescr.RxPdo[CheckRxPdoSmAssignment.PdoIndex].Sm</Value2>
						<WriteLine Id="10" Level="Verbose" Param0="CheckRxPdoSmAssignment.Cnt">SM[{0}] skipped because SM type not match.</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckRxPdoSmAssignment.Cnt</Value1>
						<Value2>DeviceDescr.RxPdo[CheckRxPdoSmAssignment.PdoIndex].Sm</Value2>
						<GotoStep>SMLOOPEND</GotoStep>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>True</Value1>
						<Value2>True</Value2>
						<SetVariable Target="CheckRxPdoSmAssignment.Valid">false</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>True</Value1>
						<Value2>True</Value2>
						<WriteLine Id="11" Level="Error" Param0="DeviceDescr.RxPdo[CheckRxPdoSmAssignment.PdoIndex].Sm" Param1="CheckRxPdoSmAssignment.ValidSmName" Param2="DeviceDescr.SM[CheckRxPdoSmAssignment.Cnt]">Type/Direction of default SyncManager[{0}] doens't match. (expected "{1}", read "{2}")</WriteLine>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="EXCLUDESM">
				<!--Check if RxPdo.ExcludedSm is defined-->
				<Compare>
					<Equal>
						<Value1>DeviceDescr.RxPdo[CheckRxPdoSmAssignment.PdoIndex].ExcludedSm</Value1>
						<Value2>null</Value2>
						<GotoStep>TESTSU</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Check if current Sm is defined in Exclude Sm List-->
				<CallTestFunction Name="ArrayOfInt32.IndexOf">
					<Parameter>CheckRxPdoSmAssignment.Cnt</Parameter>
					<Parameter>DeviceDescr.RxPdo[CheckRxPdoSmAssignment.PdoIndex].ExcludedSm</Parameter>
					<OutParameter>i32TmpIndex</OutParameter>
				</CallTestFunction>
			</TestStep>
			<TestStep>
				<!--If current Sm is not excluded proceed with Su step-->
				<Compare>
					<Equal>
						<Value1>CheckRxPdoSmAssignment.TmpIndex</Value1>
						<Value2>-1</Value2>
						<GotoStep>TESTSU</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckRxPdoSmAssignment.TmpIndex</Value1>
						<Value2>-1</Value2>
						<WriteLine Id="12" Level="Verbose" Param0="CheckRxPdoSmAssignment.Cnt">SM[{0}] skipped because SM is listed in RxPdo.ExcludedSm</WriteLine>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Dump an Error if default SM is excluded-->
				<Compare>
					<!--proceed with next Sm if no default Sm is defined-->
					<Equal>
						<Value1>DeviceDescr.RxPdo[CheckRxPdoSmAssignment.PdoIndex].Sm</Value1>
						<Value2>null</Value2>
						<GotoStep>SMLOOPEND</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckRxPdoSmAssignment.TmpIndex</Value1>
						<Value2>DeviceDescr.RxPdo[CheckRxPdoSmAssignment.PdoIndex].Sm</Value2>
						<WriteLine Id="13" Level="Error" Param0="CheckRxPdoSmAssignment.PdoIndex">RxPdo[{0}] Exclude the configured default Sm.</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckRxPdoSmAssignment.TmpIndex</Value1>
						<Value2>DeviceDescr.RxPdo[CheckRxPdoSmAssignment.PdoIndex].Sm</Value2>
						<SetVariable Target="CheckRxPdoSmAssignment.Valid">false</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckRxPdoSmAssignment.TmpIndex</Value1>
						<Value2>DeviceDescr.RxPdo[CheckRxPdoSmAssignment.PdoIndex].Sm</Value2>
						<GotoStep>SMLOOPEND</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="TESTSU">
				<!--Check if RxPdo.Su is defined-->
				<Compare>
					<Equal>
						<Value1>DeviceDescr.RxPdo[CheckRxPdoSmAssignment.PdoIndex].Su</Value1>
						<Value2>null</Value2>
						<GotoStep>STARTTESTSM</GotoStep>
					</Equal>
				</Compare>
				<!--Skip if Sm not defined-->
				<Compare>
					<Equal>
						<Value1>DeviceDescr.RxPdo[CheckRxPdoSmAssignment.PdoIndex].Sm</Value1>
						<Value2>null</Value2>
						<GotoStep>STARTTESTSM</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Check if current Sm is referenced via Su-->
				<CallTestFunction Name="IsSmReferencedViaSu">
					<Parameter>CheckRxPdoSmAssignment.Cnt</Parameter>
					<Parameter>DeviceDescr.RxPdo[CheckRxPdoSmAssignment.PdoIndex].Su</Parameter>
					<OutParameter>CheckRxPdoSmAssignment.bValid</OutParameter>
				</CallTestFunction>
			</TestStep>
			<TestStep>
				<!--Skip Sm Test if it is not referenced via Su-->
				<Compare>
					<Equal>
						<Value1>CheckRxPdoSmAssignment.bValid</Value1>
						<Value2>false</Value2>
						<WriteLine Id="14" Level="Verbose" Param0="CheckRxPdoSmAssignment.Cnt">SM[{0}] skipped because SM is not referenced via Su</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckRxPdoSmAssignment.bValid</Value1>
						<Value2>false</Value2>
						<GotoStep>SMLOOPEND</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="STARTTESTSM">
				<!--SyncManager may be used for the PDO => increment indication counter-->
				<SetVariable Target="CheckRxPdoSmAssignment.PotentialSm">CheckRxPdoSmAssignment.PotentialSm + 1</SetVariable>
			</TestStep>
			<TestStep Name="CHECKVIRTUAL">
				<!--Check if virtual settings are correct-->
				<Compare>
					<Equal>
						<Value1>DeviceDescr.RxPdo[CheckRxPdoSmAssignment.PdoIndex].Virtual</Value1>
						<Value2>false</Value2>
						<GotoStep>NOTVIRTUAL</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--PDO is virtual
if Entries defined goto "VIRTUALENTRIES"
else 
current SM is not virtual => correct
current SM is virtual but is not the default SM => warning because of a possible wrong configuration
the default SM is virtual => Error-->
				<Compare>
					<NotEqual>
						<Value1>DeviceDescr.RxPdo[CheckRxPdoSmAssignment.PdoIndex].Entry.Count</Value1>
						<Value2>0</Value2>
						<GotoStep>VIRTUALENTRIES</GotoStep>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.SM[CheckRxPdoSmAssignment.Cnt].Virtual</Value1>
						<Value2>false</Value2>
						<GotoStep>SMLOOPEND</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.RxPdo[CheckRxPdoSmAssignment.PdoIndex].Sm</Value1>
						<Value2>null</Value2>
						<WriteLine Id="15" Level="Warning" Param0="CheckRxPdoSmAssignment.PdoIndex" Param1="CheckRxPdoSmAssignment.Cnt">Virtual RxPdo[{0}] with no Entries may be assigned to the virtual SyncManager[{1}].</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.RxPdo[CheckRxPdoSmAssignment.PdoIndex].Sm</Value1>
						<Value2>null</Value2>
						<GotoStep>SMLOOPEND</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>DeviceDescr.RxPdo[CheckRxPdoSmAssignment.PdoIndex].Sm</Value1>
						<Value2>CheckRxPdoSmAssignment.Cnt</Value2>
						<WriteLine Id="16" Level="Warning" Param0="CheckRxPdoSmAssignment.PdoIndex" Param1="CheckRxPdoSmAssignment.Cnt">Virtual RxPdo[{0}] with no Entries may be assigned to the virtual SyncManager[{1}].</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>DeviceDescr.RxPdo[CheckRxPdoSmAssignment.PdoIndex].Sm</Value1>
						<Value2>CheckRxPdoSmAssignment.Cnt</Value2>
						<GotoStep>SMLOOPEND</GotoStep>
					</NotEqual>
				</Compare>
				<Compare>
					<!--The current PDO is not virtual but the default SM is virtual-->
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="17" Level="Error" Param0="CheckRxPdoSmAssignment.PdoIndex" Param1="CheckRxPdoSmAssignment.Cnt">Virtual RxPdo[{0}] with no Entries is assigned to the virtual SyncManager[{1}].</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<SetVariable Target="CheckRxPdoSmAssignment.Valid">false</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>SMLOOPEND</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="VIRTUALENTRIES">
				<!--PDO is virtual and Entries defined
- the current SM is virtual => correct
- current SM is not virtual but is not the default SM => warning because of a possible wrong configuration
the default SM is not virtual => Error-->
				<Compare>
					<Equal>
						<Value1>DeviceDescr.SM[CheckRxPdoSmAssignment.Cnt].Virtual</Value1>
						<Value2>true</Value2>
						<GotoStep>SMLOOPEND</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.RxPdo[CheckRxPdoSmAssignment.PdoIndex].Sm</Value1>
						<Value2>null</Value2>
						<WriteLine Id="18" Level="Warning" Param0="CheckRxPdoSmAssignment.PdoIndex" Param1="CheckRxPdoSmAssignment.Cnt">Virtual RxPdo[{0}] with Entries may be assigned to the non virtual SyncManager[{1}].</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.RxPdo[CheckRxPdoSmAssignment.PdoIndex].Sm</Value1>
						<Value2>null</Value2>
						<GotoStep>SMLOOPEND</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>DeviceDescr.RxPdo[CheckRxPdoSmAssignment.PdoIndex].Sm</Value1>
						<Value2>CheckRxPdoSmAssignment.Cnt</Value2>
						<WriteLine Id="19" Level="Warning" Param0="CheckRxPdoSmAssignment.PdoIndex" Param1="CheckRxPdoSmAssignment.Cnt">Virtual RxPdo[{0}] with Entries may be assigned to the non virtual SyncManager[{1}].</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>DeviceDescr.RxPdo[CheckRxPdoSmAssignment.PdoIndex].Sm</Value1>
						<Value2>CheckRxPdoSmAssignment.Cnt</Value2>
						<GotoStep>SMLOOPEND</GotoStep>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="20" Level="Error" Param0="CheckRxPdoSmAssignment.PdoIndex" Param1="CheckRxPdoSmAssignment.Cnt">Virtual RxPdo[{0}] with Entries is assigned to the virtual SyncManager[{1}].</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<SetVariable Target="CheckRxPdoSmAssignment.Valid">false</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>SMLOOPEND</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="NOTVIRTUAL">
				<!--PDO is not virtual-->
				<Compare>
					<Equal>
						<Value1>DeviceDescr.SM[CheckRxPdoSmAssignment.Cnt].Virtual</Value1>
						<Value2>false</Value2>
						<GotoStep>SMLOOPEND</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.RxPdo[CheckRxPdoSmAssignment.PdoIndex].Sm</Value1>
						<Value2>null</Value2>
						<WriteLine Id="21" Level="Warning" Param0="CheckRxPdoSmAssignment.PdoIndex" Param1="CheckRxPdoSmAssignment.Cnt">Non virtual RxPdo[{0}] may be assigned to virtual SyncManager[{1}]</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.RxPdo[CheckRxPdoSmAssignment.PdoIndex].Sm</Value1>
						<Value2>null</Value2>
						<GotoStep>SMLOOPEND</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>DeviceDescr.RxPdo[CheckRxPdoSmAssignment.PdoIndex].Sm</Value1>
						<Value2>CheckRxPdoSmAssignment.Cnt</Value2>
						<WriteLine Id="22" Level="Warning" Param0="CheckRxPdoSmAssignment.PdoIndex" Param1="CheckRxPdoSmAssignment.Cnt">Non virtual RxPdo[{0}] may be assigned to virtual SyncManager[{1}]</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>DeviceDescr.RxPdo[CheckRxPdoSmAssignment.PdoIndex].Sm</Value1>
						<Value2>CheckRxPdoSmAssignment.Cnt</Value2>
						<GotoStep>SMLOOPEND</GotoStep>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.RxPdo[CheckRxPdoSmAssignment.PdoIndex].Sm</Value1>
						<Value2>CheckRxPdoSmAssignment.Cnt</Value2>
						<WriteLine Id="23" Level="Error" Param0="CheckRxPdoSmAssignment.PdoIndex" Param1="CheckRxPdoSmAssignment.Cnt">Non virtual RxPdo[{0}] is by default assigned to virtual SyncManager[{1}]</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.RxPdo[CheckRxPdoSmAssignment.PdoIndex].Sm</Value1>
						<Value2>CheckRxPdoSmAssignment.Cnt</Value2>
						<SetVariable Target="CheckRxPdoSmAssignment.Valid">false</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="SMLOOPEND">
				<!--Abort loop if
- Pdo is mandatory 
OR
- "CheckRxPdoSmAssignment.Cnt" >= "DeviceDescr.SM.Count"-->
				<SetVariable Target="CheckRxPdoSmAssignment.Cnt">CheckRxPdoSmAssignment.Cnt + 1</SetVariable>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.RxPdo[CheckRxPdoSmAssignment.PdoIndex].Mandatory</Value1>
						<Value2>true</Value2>
						<GotoStep>END</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Lower>
						<Value1>CheckRxPdoSmAssignment.Cnt</Value1>
						<Value2>DeviceDescr.SM.Count</Value2>
						<GotoStep>SMLOOPSTART</GotoStep>
					</Lower>
				</Compare>
			</TestStep>
			<TestStep Name="END">
				<Compare>
					<Equal>
						<Value1>CheckRxPdoSmAssignment.PotentialSm</Value1>
						<Value2>0</Value2>
						<WriteLine Id="24" Level="Error" Param0="CheckRxPdoSmAssignment.PdoIndex">No SyncManager for RxPdo[{0}] found</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckRxPdoSmAssignment.PotentialSm</Value1>
						<Value2>0</Value2>
						<SetVariable Target="CheckRxPdoSmAssignment.Valid">false</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction Name="CheckSMCat" FunctionId="801">
			<?MAX_OUTPUT_ID 10?>
			<TestStep>
				<WriteLine Id="0" Level="Verbose" Param0="DeviceDescr.SM[index].StartAddress" Param1="index" Param2="EEPROM.CatSyncMan[index].PhysicalStartAddress">EtherCAT Slave Information File Sm {1:d} StartAddress: 0x{0:x4}, E²PROM Sm {1:d} PhysicalStartAddress: 0x{2:x4}</WriteLine>
				<Compare>
					<NotEqual>
						<Value1>DeviceDescr.SM[index].StartAddress</Value1>
						<Value2>EEPROM.CatSyncMan[index].PhysicalStartAddress</Value2>
						<RaiseError Id="1" Param0="index">Start Addresses of SM{0:d} unequal</RaiseError>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep>
				<WriteLine Id="2" Level="Verbose" Param0="DeviceDescr.SM[index].DefaultSize" Param1="index" Param2="EEPROM.CatSyncMan[index].Length">EtherCAT Slave Information File Sm {1:d} DefaulSize: 0x{0:x4}, E²PROM Sm {1:d} Length: 0x{2:x4}</WriteLine>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.SM[index].DefaultSize</Value1>
						<Value2>null</Value2>
						<WriteLine Id="3" Param0="index">The DeviceDescription has no attribute for Device:SM[{0:d}]:DefaultSize</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.SM[index].DefaultSize</Value1>
						<Value2>null</Value2>
						<GotoStep>3</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>DeviceDescr.SM[index].DefaultSize</Value1>
						<Value2>EEPROM.CatSyncMan[index].Length</Value2>
						<RaiseError Id="4" Param0="index">Default length of SM{0:d} unequal</RaiseError>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep>
				<WriteLine Id="5" Level="Verbose" Param0="DeviceDescr.SM[index].ControlByte" Param1="index" Param2="EEPROM.CatSyncMan[index].ControlRegister">EtherCAT Slave Information File Sm {1:d} ControlByte: 0x{0:x2}, E²PROM Sm {1:d} ControlRegister: 0x{2:x2}</WriteLine>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.SM[index].ControlByte</Value1>
						<Value2>null</Value2>
						<WriteLine Id="6" Param0="index">The DeviceDescription has no attribute for Device:SM[{0:d}]:ControlByte</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.SM[index].ControlByte</Value1>
						<Value2>null</Value2>
						<GotoStep>4</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>DeviceDescr.SM[index].ControlByte</Value1>
						<Value2>EEPROM.CatSyncMan[index].ControlRegister</Value2>
						<RaiseError Id="7" Param0="index">ControlByte of SM{0:d} unequal</RaiseError>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.SM[index].Enable</Value1>
						<Value2>null</Value2>
						<Return Id="8" Param0="index">The DeviceDescription has no attribute for Device:SM[{0:d}]:Enable</Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<SetVariable Target="boolVar">EEPROM.CatSyncMan[index].Activate</SetVariable>
			</TestStep>
			<TestStep>
				<WriteLine Id="9" Level="Verbose" Param0="DeviceDescr.SM[index].Enable" Param1="index" Param2="boolVar">EtherCAT Slave Information File Sm {1:d} Enable: {0}, E²PROM Sm {1:d} Activate: {2}</WriteLine>
				<Compare>
					<NotEqual>
						<Value1>DeviceDescr.SM[index].Enable</Value1>
						<Value2>boolVar</Value2>
						<RaiseError Id="10" Param0="index">Enable of SM{0:d} unequal</RaiseError>
					</NotEqual>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction Name="CheckSmOrder" FunctionId="802">
			<?MAX_OUTPUT_ID 19?>
			<!--Checks correct Order of Sm elements-->
			<LocalVariables>
				<Name>CheckSmOrder_i</Name>
				<Type>UInt16</Type>
				<!--Iteration-->
			</LocalVariables>
			<LocalVariables>
				<Name>CheckSmOrder_PdSmOffset</Name>
				<Type>Int32</Type>
				<!--Offset of 2 if MailBoxSyncManagers are used-->
			</LocalVariables>
			<LocalVariables>
				<Name>CheckSmOrder_FirstMBoxOut</Name>
				<Type>Int32</Type>
				<!--Position when MBoxOut occured first-->
			</LocalVariables>
			<LocalVariables>
				<Name>CheckSmOrder_FirstMBoxIn</Name>
				<Type>Int32</Type>
				<!--Position when MBoxIn occured first-->
			</LocalVariables>
			<LocalVariables>
				<Name>CheckSmOrder_FirstOutputs</Name>
				<Type>Int32</Type>
				<!--Position when Outputs occured first-->
			</LocalVariables>
			<LocalVariables>
				<Name>CheckSmOrder_FirstInputs</Name>
				<Type>Int32</Type>
				<!--Position when Inputs occured first-->
			</LocalVariables>
			<OutParameter>
				<Name>CheckSmOrder_Error</Name>
				<Type>Bool</Type>
			</OutParameter>
			<TestStep>
				<!--show initialization message-->
				<WriteLine Id="0" Level="Verbose">Testfunction CheckSmOrder called</WriteLine>
			</TestStep>
			<TestStep>
				<!--CheckSmOrder_i = 0-->
				<SetVariable Target="CheckSmOrder_i">0</SetVariable>
			</TestStep>
			<TestStep>
				<!--CheckSmOrder_FirstMBoxOut = -1-->
				<SetVariable Target="CheckSmOrder_FirstMBoxOut">-1</SetVariable>
			</TestStep>
			<TestStep>
				<!--CheckSmOrder_FirstMBoxIn = -1-->
				<SetVariable Target="CheckSmOrder_FirstMBoxIn">-1</SetVariable>
			</TestStep>
			<TestStep>
				<!--CheckSmOrder_FirstOutputs = -1-->
				<SetVariable Target="CheckSmOrder_FirstOutputs">-1</SetVariable>
			</TestStep>
			<TestStep>
				<!--CheckSmOrder_FirstInputs = -1-->
				<SetVariable Target="CheckSmOrder_FirstInputs">-1</SetVariable>
			</TestStep>
			<TestStep>
				<!--CheckSmOrder_PdSmOffset = 0-->
				<SetVariable Target="CheckSmOrder_PdSmOffset">0</SetVariable>
			</TestStep>
			<TestStep Name="Iteration1">
				<!--show [Text]-->
				<WriteLine Id="1" Param0="CheckSmOrder_i" Param1="DeviceDescr.SM[CheckSmOrder_i]" Level="Verbose">Testing entry {0}. [Text] of Sm: {1}</WriteLine>
			</TestStep>
			<TestStep Name="MBoxOut">
				<!--if (Text != MBoxOut)
   goto step MBoxIn-->
				<Compare>
					<NotEqual>
						<Value1>DeviceDescr.SM[CheckSmOrder_i]</Value1>
						<Value2>MBoxOut</Value2>
						<GotoStep>MBoxIn</GotoStep>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep>
				<!--if MBoxOut already defined -> Error-->
				<Compare>
					<GreaterOrEqual>
						<Value1>CheckSmOrder_FirstMBoxOut</Value1>
						<Value2>0</Value2>
						<SetVariable Target="CheckSmOrder_Error">True</SetVariable>
					</GreaterOrEqual>
				</Compare>
				<Compare>
					<GreaterOrEqual>
						<Value1>CheckSmOrder_FirstMBoxOut</Value1>
						<Value2>0</Value2>
						<WriteLine Id="2" Level="Error">MBoxOut may only be defined once</WriteLine>
					</GreaterOrEqual>
				</Compare>
			</TestStep>
			<TestStep>
				<!--if MBoxOut not yet defined -> Set first position-->
				<Compare>
					<Lower>
						<Value1>CheckSmOrder_FirstMBoxOut</Value1>
						<Value2>0</Value2>
						<SetVariable Target="CheckSmOrder_FirstMBoxOut">CheckSmOrder_i</SetVariable>
					</Lower>
				</Compare>
			</TestStep>
			<TestStep Name="MBoxIn">
				<!--if (Text != MBoxIn)
   goto step Outputs-->
				<Compare>
					<NotEqual>
						<Value1>DeviceDescr.SM[CheckSmOrder_i]</Value1>
						<Value2>MBoxIn</Value2>
						<GotoStep>Outputs</GotoStep>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep>
				<!--if MBoxIn already defined -> Error-->
				<Compare>
					<GreaterOrEqual>
						<Value1>CheckSmOrder_FirstMBoxIn</Value1>
						<Value2>0</Value2>
						<SetVariable Target="CheckSmOrder_Error">True</SetVariable>
					</GreaterOrEqual>
				</Compare>
				<Compare>
					<GreaterOrEqual>
						<Value1>CheckSmOrder_FirstMBoxIn</Value1>
						<Value2>0</Value2>
						<WriteLine Id="3" Level="Error">FirstMBoxIn may only be defined once</WriteLine>
					</GreaterOrEqual>
				</Compare>
			</TestStep>
			<TestStep>
				<!--If MBoxOut not yet defined -> Set first position-->
				<Compare>
					<Lower>
						<Value1>CheckSmOrder_FirstMBoxIn</Value1>
						<Value2>0</Value2>
						<SetVariable Target="CheckSmOrder_FirstMBoxIn">CheckSmOrder_i</SetVariable>
					</Lower>
				</Compare>
			</TestStep>
			<TestStep Name="Outputs">
				<!--if (Text != Outputs)
   goto step Inputs-->
				<Compare>
					<NotEqual>
						<Value1>DeviceDescr.SM[CheckSmOrder_i]</Value1>
						<Value2>Outputs</Value2>
						<GotoStep>Inputs</GotoStep>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep>
				<!--If Outputs not yet defined -> Set first position-->
				<Compare>
					<Lower>
						<Value1>CheckSmOrder_FirstOutputs</Value1>
						<Value2>0</Value2>
						<SetVariable Target="CheckSmOrder_FirstOutputs">CheckSmOrder_i</SetVariable>
					</Lower>
				</Compare>
			</TestStep>
			<TestStep Name="Inputs">
				<!--if (Text != Outputs)
   goto step NextIteration1-->
				<Compare>
					<NotEqual>
						<Value1>DeviceDescr.SM[CheckSmOrder_i]</Value1>
						<Value2>Inputs</Value2>
						<GotoStep>NextIteration1</GotoStep>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep>
				<!--If Inputs not yet defined -> Set first position-->
				<Compare>
					<Lower>
						<Value1>CheckSmOrder_FirstInputs</Value1>
						<Value2>0</Value2>
						<SetVariable Target="CheckSmOrder_FirstInputs">CheckSmOrder_i</SetVariable>
					</Lower>
				</Compare>
			</TestStep>
			<TestStep Name="NextIteration1">
				<!--CheckSmOrder_i++

If (CheckSmOrder_i< SM.Count)
   next step-->
				<SetVariable Target="CheckSmOrder_i">CheckSmOrder_i+1</SetVariable>
				<Compare>
					<Greater>
						<Value1>DeviceDescr.SM.Count</Value1>
						<Value2>CheckSmOrder_i</Value2>
						<GotoStep>Iteration1</GotoStep>
					</Greater>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Verbose Output of found positions-->
				<WriteLine Id="4" Param0="CheckSmOrder_FirstMBoxOut" Level="Verbose">First Position of MBoxOut: {0}</WriteLine>
				<WriteLine Id="5" Param0="CheckSmOrder_FirstMBoxIn" Level="Verbose">First Position of MBoxIn: {0}</WriteLine>
				<WriteLine Id="6" Param0="CheckSmOrder_FirstOutputs" Level="Verbose">First Position of Outputs: {0}</WriteLine>
				<WriteLine Id="7" Param0="CheckSmOrder_FirstInputs" Level="Verbose">First Position of Inputs: {0}</WriteLine>
			</TestStep>
			<TestStep Name="MBoxOutTest">
				<!--if (MBoxOut defined)
   goto step MBoxOutTestDefined
else
  decrease Offset for next Sm -->
				<Compare>
					<GreaterOrEqual>
						<Value1>CheckSmOrder_FirstMBoxOut</Value1>
						<Value2>0</Value2>
						<GotoStep>MBoxOutTestDefined</GotoStep>
					</GreaterOrEqual>
				</Compare>
				<Compare>
					<Lower>
						<Value1>CheckSmOrder_FirstMBoxOut</Value1>
						<Value2>0</Value2>
						<SetVariable Target="CheckSmOrder_PdSmOffset">CheckSmOrder_PdSmOffset-1</SetVariable>
					</Lower>
				</Compare>
			</TestStep>
			<TestStep Name="MBoxOutTestNotDefined">
				<!--If no MBoxOut Sm defined no MBoxIn Sm shall be defined-->
				<Compare>
					<GreaterOrEqual>
						<Value1>CheckSmOrder_FirstMBoxIn</Value1>
						<Value2>0</Value2>
						<SetVariable Target="CheckSmOrder_Error">True</SetVariable>
					</GreaterOrEqual>
				</Compare>
				<Compare>
					<GreaterOrEqual>
						<Value1>CheckSmOrder_FirstMBoxIn</Value1>
						<Value2>0</Value2>
						<WriteLine Id="8" Level="Error">If no SyncManager is configured as Mailbox Out also no in In direction shall be defined</WriteLine>
					</GreaterOrEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>1</Value1>
						<Value2>1</Value2>
						<GotoStep>MBoxInTest</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="MBoxOutTestDefined">
				<!--If MBoxOut Sm defined MBoxIn Sm shall be defined and it shall be Sm0-->
				<Compare>
					<NotEqual>
						<Value1>CheckSmOrder_FirstMBoxOut</Value1>
						<Value2>0</Value2>
						<SetVariable Target="CheckSmOrder_Error">True</SetVariable>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckSmOrder_FirstMBoxOut</Value1>
						<Value2>0</Value2>
						<WriteLine Id="9" Level="Error">If SyncManager MbxOut is configured it has to be Sm0</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<Lower>
						<Value1>CheckSmOrder_FirstMBoxIn</Value1>
						<Value2>0</Value2>
						<WriteLine Id="10" Level="Error">If MbxOut SyncManager is configured, also MbxIn SyncManager has to be configured</WriteLine>
					</Lower>
				</Compare>
				<Compare>
					<Lower>
						<Value1>CheckSmOrder_FirstMBoxIn</Value1>
						<Value2>0</Value2>
						<SetVariable Target="CheckSmOrder_Error">True</SetVariable>
					</Lower>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Verbose Output SmOffset-->
				<WriteLine Id="11" Param0="CheckSmOrder_PdSmOffset" Level="Verbose">CheckSmOrder_PdSmOffset: {0}</WriteLine>
			</TestStep>
			<TestStep Name="MBoxInTest">
				<!--if (MBoxIn defined)
   goto step MBoxInTestDefined
else
  decrease Offset for next Sm -->
				<Compare>
					<GreaterOrEqual>
						<Value1>CheckSmOrder_FirstMBoxIn</Value1>
						<Value2>0</Value2>
						<GotoStep>MBoxInTestDefined</GotoStep>
					</GreaterOrEqual>
				</Compare>
				<Compare>
					<Lower>
						<Value1>CheckSmOrder_FirstMBoxIn</Value1>
						<Value2>0</Value2>
						<SetVariable Target="CheckSmOrder_PdSmOffset">CheckSmOrder_PdSmOffset-1</SetVariable>
					</Lower>
				</Compare>
			</TestStep>
			<TestStep Name="MBoxInTestNotDefined">
				<!--If no MBoxIn Sm defined no MBoxOut Sm shall be defined-->
				<Compare>
					<GreaterOrEqual>
						<Value1>CheckSmOrder_FirstMBoxOut</Value1>
						<Value2>0</Value2>
						<SetVariable Target="CheckSmOrder_Error">True</SetVariable>
					</GreaterOrEqual>
				</Compare>
				<Compare>
					<GreaterOrEqual>
						<Value1>CheckSmOrder_FirstMBoxOut</Value1>
						<Value2>0</Value2>
						<WriteLine Id="12" Level="Error">If no SyncManager is configured as Mailbox In also no in Out direction shall be defined</WriteLine>
					</GreaterOrEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>1</Value1>
						<Value2>1</Value2>
						<GotoStep>OutputsTest</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="MBoxInTestDefined">
				<!--If MBoxIn Sm defined MBoxOut Sm shall be defined and it shall be Sm1-->
				<Compare>
					<NotEqual>
						<Value1>CheckSmOrder_FirstMBoxIn</Value1>
						<Value2>1</Value2>
						<WriteLine Id="13" Level="Error">If SyncManager MbxIn is configured it has to be Sm1</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckSmOrder_FirstMBoxIn</Value1>
						<Value2>1</Value2>
						<SetVariable Target="CheckSmOrder_Error">True</SetVariable>
					</NotEqual>
				</Compare>
				<Compare>
					<Lower>
						<Value1>CheckSmOrder_FirstMBoxOut</Value1>
						<Value2>0</Value2>
						<SetVariable Target="CheckSmOrder_Error">True</SetVariable>
					</Lower>
				</Compare>
				<Compare>
					<Lower>
						<Value1>CheckSmOrder_FirstMBoxOut</Value1>
						<Value2>0</Value2>
						<WriteLine Id="14" Level="Error">If MbxIn SyncManager is configured, also MbxOut SyncManager has to be configured</WriteLine>
					</Lower>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Verbose Output SmOffset-->
				<WriteLine Id="15" Param0="CheckSmOrder_PdSmOffset" Level="Verbose">CheckSmOrder_PdSmOffset: {0}</WriteLine>
			</TestStep>
			<TestStep Name="OutputsTest">
				<!--if (Outputs defined)
   goto step OutputsTestDefined
else
  decrease Offset for next Sm -->
				<Compare>
					<GreaterOrEqual>
						<Value1>CheckSmOrder_FirstOutputs</Value1>
						<Value2>0</Value2>
						<GotoStep>OutputsTestDefined</GotoStep>
					</GreaterOrEqual>
				</Compare>
				<Compare>
					<Lower>
						<Value1>CheckSmOrder_FirstOutputs</Value1>
						<Value2>0</Value2>
						<SetVariable Target="CheckSmOrder_PdSmOffset">CheckSmOrder_PdSmOffset-1</SetVariable>
					</Lower>
				</Compare>
			</TestStep>
			<TestStep Name="OutputsTestNotDefined">
				<!--If no Outputs Sm defined goto Inputs test-->
				<Compare>
					<Equal>
						<Value1>1</Value1>
						<Value2>1</Value2>
						<GotoStep>InputsTest</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="OutputsTestDefined">
				<!--If Outputs Sm definedit shall be Sm2 + SmOffset-->
				<Compare>
					<NotEqual>
						<Value1>CheckSmOrder_FirstOutputs</Value1>
						<Value2>2+CheckSmOrder_PdSmOffset</Value2>
						<SetVariable Target="CheckSmOrder_Error">True</SetVariable>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckSmOrder_FirstOutputs</Value1>
						<Value2>2+CheckSmOrder_PdSmOffset</Value2>
						<WriteLine Id="16" Level="Error" Param0="2+CheckSmOrder_PdSmOffset">If Output SyncManager is defined it shall be Sm{0}</WriteLine>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Verbose Output SmOffset-->
				<WriteLine Id="17" Param0="CheckSmOrder_PdSmOffset" Level="Verbose">CheckSmOrder_PdSmOffset: {0}</WriteLine>
			</TestStep>
			<TestStep Name="InputsTest">
				<!--if (Inputs defined)
   goto step InputsTestDefined-->
				<Compare>
					<GreaterOrEqual>
						<Value1>CheckSmOrder_FirstInputs</Value1>
						<Value2>0</Value2>
						<GotoStep>InputsTestDefined</GotoStep>
					</GreaterOrEqual>
				</Compare>
			</TestStep>
			<TestStep Name="InputsTestNotDefined">
				<!--If no Outputs Sm defined goto end-->
				<Compare>
					<Equal>
						<Value1>1</Value1>
						<Value2>1</Value2>
						<GotoStep>Return</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="InputsTestDefined">
				<!--If Inputs Sm defined it shall be Sm3 + SmOffset-->
				<Compare>
					<NotEqual>
						<Value1>CheckSmOrder_FirstInputs</Value1>
						<Value2>3+CheckSmOrder_PdSmOffset</Value2>
						<SetVariable Target="CheckSmOrder_Error">True</SetVariable>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckSmOrder_FirstInputs</Value1>
						<Value2>3+CheckSmOrder_PdSmOffset</Value2>
						<WriteLine Id="18" Level="Error" Param0="3+CheckSmOrder_PdSmOffset">If Input SyncManager is defined it shall be Sm{0}</WriteLine>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="Return">
				<!--show end message-->
				<WriteLine Id="19" Level="Verbose">returned from Test Function CheckSmOrder</WriteLine>
			</TestStep>
		</TestFunction>
		<TestFunction Name="CheckStringBaseDataType" FunctionId="901">
			<?MAX_OUTPUT_ID 12?>
			<!--Function for Device DataType Tests-->
			<Description>
				<Action>Check the definition of a base DataType with a fixed length</Action>
				<PostCondition></PostCondition>
				<References>
					<Reference Specification="ETG.1020"></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>CheckStringBaseDataType.XmlFile</Name>
				<Type>String</Type>
				<Comment>Path of the xml file (absolute or relative to the ESI file).
If the parameter is null or empty the current device description will be referenced.</Comment>
			</Parameter>
			<Parameter>
				<Name>CheckStringBaseDataType.XPath</Name>
				<Type>String</Type>
				<Comment>XPath of the current DataType</Comment>
			</Parameter>
			<LocalVariables>
				<Name>CheckStringBaseDataType.stringXmlValue</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckStringBaseDataType.IsMatch</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckStringBaseDataType.DataTypeName</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckStringBaseDataType.xmlBitSize</Name>
				<Type>Int32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckStringBaseDataType.TmpResult</Name>
				<Type>String</Type>
			</LocalVariables>
			<OutParameter>
				<Name>CheckStringBaseDataType.Result</Name>
				<Type>Bool</Type>
				<!--If true base data type test was sucessful-->
			</OutParameter>
			<TestStep Name="INIT_RESULT">
				<!--Init Result = true-->
				<SetVariable Target="CheckStringBaseDataType.Result">true</SetVariable>
			</TestStep>
			<TestStep Name="INIT_FILE_PARAMETER">
				<!--if parameter is null set value to emptystring-->
				<Compare>
					<Equal>
						<Value1>CheckStringBaseDataType.XmlFile</Value1>
						<Value2>null</Value2>
						<SetVariable Target="CheckStringBaseDataType.XmlFile">EmptyString</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CHECK_IF_XPATH_EXISITS">
				<GetXmlValue ReturnValue="CheckStringBaseDataType.stringXmlValue" Markup="true" FileName="CheckStringBaseDataType.XmlFile">
					<XPath Param0="CheckStringBaseDataType.XPath">{0}</XPath>
				</GetXmlValue>
				<!--Dump an Error if XPath is not defined is defined-->
				<Compare>
					<Equal>
						<Value1>CheckStringBaseDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<WriteLine Id="0" Level="Error" Param0="CheckStringBaseDataType.XPath" Param1="CheckStringBaseDataType.XmlFile">The XPath "{0}" (File:{1}) is not defined.</WriteLine>
					</Equal>
				</Compare>
				<!--Update Error Variable-->
				<Compare>
					<Equal>
						<Value1>CheckStringBaseDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<SetVariable Target="CheckStringBaseDataType.Result">false</SetVariable>
					</Equal>
				</Compare>
				<!--return-->
				<Compare>
					<Equal>
						<Value1>CheckStringBaseDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<Return Id="1"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="GET_DATATYPE_NAME">
				<!--Get DataType name from local dictionary-->
				<GetXmlValue ReturnValue="CheckStringBaseDataType.stringXmlValue" Markup="false" FileName="CheckStringBaseDataType.XmlFile">
					<XPath Param0="CheckStringBaseDataType.XPath">{0}/Name</XPath>
				</GetXmlValue>
				<!--Dump an Error if no name is defined-->
				<Compare>
					<Equal>
						<Value1>CheckStringBaseDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<WriteLine Id="2" Level="Error" Param0="CheckStringBaseDataType.XPath" Param1="CheckStringBaseDataType.XmlFile">A DataType name shall be defined. at File '{1}' Path '{0}'</WriteLine>
					</Equal>
				</Compare>
				<!--Update Error Variable-->
				<Compare>
					<Equal>
						<Value1>CheckStringBaseDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<SetVariable Target="CheckStringBaseDataType.Result">false</SetVariable>
					</Equal>
				</Compare>
				<!--return-->
				<Compare>
					<Equal>
						<Value1>CheckStringBaseDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<Return Id="3"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="START_TEST">
				<!--Check if Name is valid-->
				<RegexIsMatch ReturnValue="CheckStringBaseDataType.IsMatch">
					<Pattern>^(STRING\([0-9]+\))$</Pattern>
					<InputString>CheckStringBaseDataType.stringXmlValue</InputString>
				</RegexIsMatch>
				<!--Dump info if name is invalid-->
				<Compare>
					<Equal>
						<Value1>CheckStringBaseDataType.IsMatch</Value1>
						<Value2>false</Value2>
						<WriteLine Id="4" Level="Verbose" Param0="CheckStringBaseDataType.stringXmlValue">Invalid DataType name ({0}) passed to function "CheckStringBaseDataType". Only String BaseDataTypes are allowed.</WriteLine>
					</Equal>
				</Compare>
				<!--Set Result to false-->
				<Compare>
					<Equal>
						<Value1>CheckStringBaseDataType.IsMatch</Value1>
						<Value2>false</Value2>
						<SetVariable Target="CheckStringBaseDataType.Result">false</SetVariable>
					</Equal>
				</Compare>
				<!--Return-->
				<Compare>
					<Equal>
						<Value1>CheckStringBaseDataType.IsMatch</Value1>
						<Value2>false</Value2>
						<Return Id="5"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Store DataType name in "CheckStringBaseDataType.DataTypeName"-->
				<SetVariable Target="CheckStringBaseDataType.DataTypeName">CheckStringBaseDataType.stringXmlValue</SetVariable>
			</TestStep>
			<TestStep Name="GET_BASETYPE_ELEMENT">
				<!--The Element BaseType shall not be defined for String base DataTypes.-->
				<GetXmlValue ReturnValue="CheckStringBaseDataType.stringXmlValue" Markup="false" FileName="CheckStringBaseDataType.XmlFile">
					<XPath Param0="CheckStringBaseDataType.XPath">{0}/BaseType</XPath>
				</GetXmlValue>
				<Compare>
					<NotEqual>
						<Value1>CheckStringBaseDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<WriteLine Id="6" Level="Error" Param0="CheckStringBaseDataType.DataTypeName" Param1="CheckStringBaseDataType.XmlFile" Param2="CheckStringBaseDataType.XPath">{0}.BaseType shall not be defined. at File '{1}' Path '{2}'</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckStringBaseDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<SetVariable Target="CheckStringBaseDataType.Result">false</SetVariable>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="GET_ARRAYINFO_ELEMENT">
				<!--The Element ArrayInfo shall not be defined for String base DataTypes.-->
				<GetXmlValue ReturnValue="CheckStringBaseDataType.stringXmlValue" Markup="false" FileName="CheckStringBaseDataType.XmlFile">
					<XPath Param0="CheckStringBaseDataType.XPath">{0}/ArrayInfo</XPath>
				</GetXmlValue>
				<Compare>
					<NotEqual>
						<Value1>CheckStringBaseDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<WriteLine Id="7" Level="Error" Param0="CheckStringBaseDataType.DataTypeName" Param1="CheckStringBaseDataType.XmlFile" Param2="CheckStringBaseDataType.XPath">{0}.ArrayInfo shall not be defined. at File '{1}' Path '{2}'</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckStringBaseDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<SetVariable Target="CheckStringBaseDataType.Result">false</SetVariable>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="GET_SUBITEM_ELEMENT">
				<!--The Element SubItem shall not be defined for String base DataTypes.-->
				<GetXmlValue ReturnValue="CheckStringBaseDataType.stringXmlValue" Markup="false" FileName="CheckStringBaseDataType.XmlFile">
					<XPath Param0="CheckStringBaseDataType.XPath">{0}/SubItem</XPath>
				</GetXmlValue>
				<Compare>
					<NotEqual>
						<Value1>CheckStringBaseDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<WriteLine Id="8" Level="Error" Param0="CheckStringBaseDataType.DataTypeName" Param1="CheckStringBaseDataType.XmlFile" Param2="CheckStringBaseDataType.XPath">{0}.SubItem shall not be defined. at File '{1}' Path '{2}'</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckStringBaseDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<SetVariable Target="CheckStringBaseDataType.Result">false</SetVariable>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="GET_ENUMINFO_ELEMENT">
				<!--The Element EnumInfo shall not be defined for String base DataTypes.-->
				<GetXmlValue ReturnValue="CheckStringBaseDataType.stringXmlValue" Markup="false" FileName="CheckStringBaseDataType.XmlFile">
					<XPath Param0="CheckStringBaseDataType.XPath">{0}/EnumInfo</XPath>
				</GetXmlValue>
				<Compare>
					<NotEqual>
						<Value1>CheckStringBaseDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<WriteLine Id="9" Level="Error" Param0="CheckStringBaseDataType.DataTypeName" Param1="CheckStringBaseDataType.XmlFile" Param2="CheckStringBaseDataType.XPath">{0}.EnumInfo shall not be defined. at File '{1}' Path '{2}'</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckStringBaseDataType.stringXmlValue</Value1>
						<Value2>null</Value2>
						<SetVariable Target="CheckStringBaseDataType.Result">false</SetVariable>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="CHECK_BITSIZE">
				<!--The element BitSize shall be defined.-->
				<GetXmlValue ReturnValue="CheckStringBaseDataType.xmlBitSize" Markup="false" FileName="CheckStringBaseDataType.XmlFile">
					<XPath Param0="CheckStringBaseDataType.XPath">{0}/BitSize</XPath>
				</GetXmlValue>
				<!--Dump Error if BitSize not defined-->
				<Compare>
					<Equal>
						<Value1>CheckStringBaseDataType.xmlBitSize</Value1>
						<Value2>null</Value2>
						<WriteLine Id="10" Level="Error" Param0="CheckStringBaseDataType.DataTypeName" Param1="CheckStringBaseDataType.XmlFile" Param2="CheckStringBaseDataType.XPath">{0}.BitSize shall be defined. at File '{1}' Path '{2}'</WriteLine>
					</Equal>
				</Compare>
				<!--Update result (to false)-->
				<Compare>
					<Equal>
						<Value1>CheckStringBaseDataType.xmlBitSize</Value1>
						<Value2>null</Value2>
						<SetVariable Target="CheckStringBaseDataType.Result">false</SetVariable>
					</Equal>
				</Compare>
				<!--return-->
				<Compare>
					<Equal>
						<Value1>CheckStringBaseDataType.xmlBitSize</Value1>
						<Value2>null</Value2>
						<Return Id="11"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--The defined BitSize shall match the DataType name-->
				<CallTestFunction Name="BaseDataType.CheckSize">
					<Parameter>CheckStringBaseDataType.xmlBitSize</Parameter>
					<Parameter>CheckStringBaseDataType.DataTypeName</Parameter>
					<OutParameter>CheckStringBaseDataType.TmpResult</OutParameter>
				</CallTestFunction>
				<!--Dump Error if BitSize not match-->
				<Compare>
					<NotEqual>
						<Value1>CheckStringBaseDataType.TmpResult</Value1>
						<Value2>EmptyString</Value2>
						<WriteLine Id="12" Level="Error" Param0="CheckStringBaseDataType.xmlBitSize" Param1="CheckStringBaseDataType.DataTypeName" Param2="CheckStringBaseDataType.XmlFile" Param3="CheckStringBaseDataType.XPath">{1}.BitSize ({0}) is invalid. at File '{2}' Path '{3}'</WriteLine>
					</NotEqual>
				</Compare>
				<!--Update result (to false)-->
				<Compare>
					<NotEqual>
						<Value1>CheckStringBaseDataType.TmpResult</Value1>
						<Value2>EmptyString</Value2>
						<SetVariable Target="CheckStringBaseDataType.Result">false</SetVariable>
					</NotEqual>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction Name="CheckStrtAddrs" FunctionId="1001">
			<?MAX_OUTPUT_ID 4?>
			<TestStep>
				<SetVariable Target="cmpIndex">0</SetVariable>
			</TestStep>
			<TestStep>
				<SetVariable Target="SMStrtLenArrIndex">0</SetVariable>
			</TestStep>
			<TestStep>
				<SizeOf UInt32Var="uInt32Val">arrStrtEndAddr</SizeOf>
				<Compare>
					<Equal>
						<Value1>uInt32Val</Value1>
						<Value2>0</Value2>
						<RaiseError Id="0" Param0="uInt32Val">ArrayLength = {0:d}</RaiseError>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>SMStrtLenArrIndex</Value1>
						<Value2>cmpIndex</Value2>
						<GotoStep>9</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<GetArrayItem Index="SMStrtLenArrIndex" SourceArray="arrStrtEndAddr" Target="strtAddr"></GetArrayItem>
				<WriteLine Id="1" Level="Verbose" Param0="strtAddr" Param1="SMStrtLenArrIndex/2">StartAddress SM{1:d} = 0x{0:x} </WriteLine>
			</TestStep>
			<TestStep>
				<GetArrayItem Index="SMStrtLenArrIndex+1" SourceArray="arrStrtEndAddr" Target="endAddr"></GetArrayItem>
				<WriteLine Id="2" Level="Verbose" Param0="endAddr" Param1="SMStrtLenArrIndex/2">EndAddress SM{1:d} = 0x{0:x}</WriteLine>
			</TestStep>
			<TestStep>
				<GetArrayItem Index="cmpIndex" SourceArray="arrStrtEndAddr" Target="cmpStrtAddr"></GetArrayItem>
				<WriteLine Id="3" Level="Verbose" Param0="cmpStrtAddr" Param1="cmpIndex/2">StartAddress SM{1:d} = 0x{0:x}  </WriteLine>
			</TestStep>
			<TestStep>
				<GetArrayItem Index="cmpIndex+1" SourceArray="arrStrtEndAddr" Target="cmpEndAddr"></GetArrayItem>
				<WriteLine Id="4" Level="Verbose" Param0="cmpEndAddr" Param1="cmpIndex/2">EndAddress SM{1:d} = 0x{0:x}</WriteLine>
			</TestStep>
			<TestStep>
				<CallFunction>CheckForOverlapping</CallFunction>
			</TestStep>
			<TestStep>
				<SetVariable Target="cmpIndex">cmpIndex+2</SetVariable>
				<Compare>
					<Lower>
						<Value1>cmpIndex</Value1>
						<Value2>uInt32Val</Value2>
						<GotoStep>3</GotoStep>
					</Lower>
				</Compare>
			</TestStep>
			<TestStep>
				<SetVariable Target="cmpIndex">0</SetVariable>
			</TestStep>
			<TestStep>
				<SetVariable Target="SMStrtLenArrIndex">SMStrtLenArrIndex+2</SetVariable>
			</TestStep>
			<TestStep>
				<Compare>
					<Lower>
						<Value1>SMStrtLenArrIndex</Value1>
						<Value2>uInt32Val</Value2>
						<GotoStep>4</GotoStep>
					</Lower>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction Name="CheckTxPdoCat" FunctionId="1101">
			<?MAX_OUTPUT_ID 8?>
			<TestStep>
				<WriteLine Id="0" Level="Verbose" Param0="DeviceDescr.TxPdo[index].Index" Param1="index" Param2="EEPROM.CatTXPdo[index].PDOIndex">EtherCAT Slave Information File TxPDO[{1:d}] Index: 0x{0:x4}, E²PROM TxPDO[{1:d}] PDOIndex: 0x{2:x4}</WriteLine>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.TxPdo[index].Virtual</Value1>
						<Value2>true</Value2>
						<Return Id="1">Virtual TxPdo --&gt; break compare TxPdos</Return>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>DeviceDescr.TxPdo[index].Index</Value1>
						<Value2>EEPROM.CatTXPdo[index].PDOIndex</Value2>
						<RaiseError Id="2" Param0="index">PdoIndexes of TxPDO{0:d} unequal</RaiseError>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Mailbox.CoE</Value1>
						<Value2>false</Value2>
						<GotoStep>CheckEntryCount</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Mailbox.SoE</Value1>
						<Value2>true</Value2>
						<GotoStep>CheckEntryCount</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Greater>
						<Value1>EEPROM.CatTXPdo[index].PDOIndex</Value1>
						<Value2>#x1bff</Value2>
						<RaiseError Id="3">TxPDO Index has to be greater than 0x19FF and lower than 0x1C00</RaiseError>
					</Greater>
				</Compare>
				<Compare>
					<Lower>
						<Value1>EEPROM.CatTXPdo[index].PDOIndex</Value1>
						<Value2>#x1a00</Value2>
						<RaiseError Id="4">TxPDO Index has to be greater than 0x19FF and lower than 0x1C00</RaiseError>
					</Lower>
				</Compare>
			</TestStep>
			<TestStep Name="CheckEntryCount">
				<WriteLine Id="5" Level="Verbose" Param0="DeviceDescr.TxPdo[index].Entry.Count" Param1="index" Param2="EEPROM.CatTXPdo[index].Entry.Count">EtherCAT Slave Information File TxPdo[{1:d}] number of entries: {0}, E²PROM Sm[{1:d}]  number of entries: {2:d}</WriteLine>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.TxPdo[index].Entry.Count</Value1>
						<Value2>0</Value2>
						<WriteLine Id="6" Param0="index">The DeviceDescription has no element for Device:TxPdo[{0:d}]:Entry</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>DeviceDescr.TxPdo[index].Entry.Count</Value1>
						<Value2>EEPROM.CatTXPdo[index].Entry.Count</Value2>
						<RaiseError Id="7" Param0="index">Number of entries of TxPDO{0:d} unequal</RaiseError>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.TxPdo[index].Entry.Count</Value1>
						<Value2>0</Value2>
						<Return Id="8"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<SetVariable Target="entryIdx">0</SetVariable>
			</TestStep>
			<TestStep Name="NextEntry">
				<CallFunction>CheckTxPdoEntry</CallFunction>
			</TestStep>
			<TestStep>
				<SetVariable Target="entryIdx">entryIdx+1</SetVariable>
			</TestStep>
			<TestStep Name="checkIndex">
				<Compare>
					<Lower>
						<Value1>entryIdx</Value1>
						<Value2>DeviceDescr.TxPdo[index].Entry.Count</Value2>
						<GotoStep>NextEntry</GotoStep>
					</Lower>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction Name="CheckTxPdoEntry" FunctionId="1102">
			<?MAX_OUTPUT_ID 5?>
			<TestStep>
				<WriteLine Id="0" Level="Verbose" Param0="DeviceDescr.TxPdo[index].Entry[entryIdx].Index" Param1="index" Param2="EEPROM.CatTXPdo[index].Entry[entryIdx].EntryIndex" Param3="entryIdx">EtherCAT Slave Information File TxPDO[{1:d}]:Entry[{3:d}]:Index: 0x{0:x4}, E²PROM TxPDO[{1:d}] Entry[{3:d}]Index: 0x{2:x4}</WriteLine>
				<Compare>
					<NotEqual>
						<Value1>DeviceDescr.TxPdo[index].Entry[entryIdx].Index</Value1>
						<Value2>EEPROM.CatTXPdo[index].Entry[entryIdx].EntryIndex</Value2>
						<RaiseError Id="1" Param0="index" Param1="entryIdx">PdoIndexes of TxPDO[{0:d}]Entry[{1}] unequal</RaiseError>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep>
				<WriteLine Id="2" Level="Verbose" Param0="DeviceDescr.TxPdo[index].Entry[entryIdx].SubIndex" Param1="index" Param2="EEPROM.CatTXPdo[index].Entry[entryIdx].Subindex" Param3="entryIdx">EtherCAT Slave Information File TxPDO[{1:d}]:Entry[{3:d}]:SubIndex: {0:d},  E²PROM TxPDO[{1:d}] Entry[{3:d}]Subindex: {2:d}</WriteLine>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.TxPdo[index].Entry[entryIdx].SubIndex</Value1>
						<Value2>null</Value2>
						<GotoStep>CompareBitLen</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Mailbox.SoE</Value1>
						<Value2>true</Value2>
						<GotoStep>CompareBitLen</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>DeviceDescr.TxPdo[index].Entry[entryIdx].SubIndex</Value1>
						<Value2>EEPROM.CatTXPdo[index].Entry[entryIdx].Subindex</Value2>
						<RaiseError Id="3" Param0="index" Param1="entryIdx">Subindex of TxPDO[{0:d}] Entry[{1:d}] unequal</RaiseError>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="CompareBitLen">
				<WriteLine Id="4" Level="Verbose" Param0="DeviceDescr.TxPdo[index].Entry[entryIdx].BitLen" Param1="index" Param2="EEPROM.CatTXPdo[index].Entry[entryIdx].BitLen" Param3="entryIdx">EtherCAT Slave Information File TxPDO[{1:d}]:Entry[{3:d}]:BitLen {0:d},  E²PROM TxPDO[{1:d}] Entry[{3:d}]BitLen: {2:d}</WriteLine>
				<Compare>
					<NotEqual>
						<Value1>DeviceDescr.TxPdo[index].Entry[entryIdx].BitLen</Value1>
						<Value2>EEPROM.CatTXPdo[index].Entry[entryIdx].BitLen</Value2>
						<RaiseError Id="5" Param0="index" Param1="entryIdx">BitLen of TxPDO[{0:d}] Entry[{1:d}] unequal</RaiseError>
					</NotEqual>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction Name="CheckTxPdoExcludeElement" FunctionId="1103">
			<?MAX_OUTPUT_ID 7?>
			<Parameter>
				<Name>CheckTxPdoExcludeElement.PdoIndex</Name>
				<Type>UInt16</Type>
				<!--Zero based index of the PDO-->
			</Parameter>
			<LocalVariables>
				<Name>CheckTxPdoExcludeElement.Cnt</Name>
				<Type>UInt16</Type>
				<!--temp counter variable-->
			</LocalVariables>
			<LocalVariables>
				<Name>CheckTxPdoExcludeElement.i32Index</Name>
				<Type>Int32</Type>
				<!--index of excluded PDO-->
			</LocalVariables>
			<LocalVariables>
				<Name>CheckTxPdoExcludeElement.i32Index2</Name>
				<Type>Int32</Type>
				<!--index of current PDO in Excluded TxPdo exclude list-->
			</LocalVariables>
			<LocalVariables>
				<Name>CheckTxPdoExcludeElement.NumExclude</Name>
				<Type>UInt32</Type>
				<!--Number of exclude PDOs-->
			</LocalVariables>
			<LocalVariables>
				<Name>CheckTxPdoExcludeElement.ExcludePdoIndex</Name>
				<Type>Int32</Type>
				<!--Index of the Excluded TxPdo-->
			</LocalVariables>
			<LocalVariables>
				<Name>CheckTxPdoExcludeElement.u16ArrTxPdo</Name>
				<Type>ArrayOfUInt16</Type>
				<!--array to store all defined TxPdo indicies-->
			</LocalVariables>
			<OutParameter>
				<Name>CheckTxPdoExcludeElement.Valid</Name>
				<Type>Bool</Type>
			</OutParameter>
			<TestStep>
				<!--Check if requested PDO index is defined-->
				<Compare>
					<GreaterOrEqual>
						<Value1>CheckTxPdoExcludeElement.PdoIndex</Value1>
						<Value2>DeviceDescr.TxPdo.Count</Value2>
						<WriteLine Id="0" Level="Error" Param0="CheckTxPdoExcludeElement.PdoIndex">Requested TxPdo {0} not defined in ESI.</WriteLine>
					</GreaterOrEqual>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Init "CheckTxPdoExcludeElement.Valid" = true-->
				<SetVariable Target="CheckTxPdoExcludeElement.Valid">true</SetVariable>
			</TestStep>
			<TestStep>
				<!--Check if Exclude elements defined-->
				<Compare>
					<Equal>
						<Value1>DeviceDescr.TxPdo[CheckTxPdoExcludeElement.PdoIndex].Exclude</Value1>
						<Value2>null</Value2>
						<WriteLine Id="1" Level="Verbose" Param0="CheckTxPdoExcludeElement.PdoIndex">No Exclude element defined for TxPdo[{0}].</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.TxPdo[CheckTxPdoExcludeElement.PdoIndex].Exclude</Value1>
						<Value2>null</Value2>
						<Return Id="2"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Copy all defined TxPdo indicies to Uint16Array-->
				<CallTestFunction Name="TxPdoElementsToArray">
					<OutParameter>CheckTxPdoExcludeElement.u16ArrTxPdo</OutParameter>
				</CallTestFunction>
			</TestStep>
			<TestStep>
				<!--Init "CheckTxPdoExcludeElement.Cnt" = 0-->
				<SetVariable Target="CheckTxPdoExcludeElement.Cnt">0</SetVariable>
			</TestStep>
			<TestStep>
				<!--Init "CheckTxPdoExcludeElement.NumExclude" = 0-->
				<SetVariable Target="CheckTxPdoExcludeElement.NumExclude">0</SetVariable>
			</TestStep>
			<TestStep>
				<!--Get Number of Exclude Elements-->
				<SizeOf UInt32Var="CheckTxPdoExcludeElement.NumExclude">DeviceDescr.TxPdo[CheckTxPdoExcludeElement.PdoIndex].Exclude</SizeOf>
				<WriteLine Id="3" Level="Verbose" Param0="CheckTxPdoExcludeElement.PdoIndex" Param1="CheckTxPdoExcludeElement.NumExclude">TxPdo[{0}] has {1} exclude PDO(s)</WriteLine>
			</TestStep>
			<TestStep Name="LOOPSTART">
				<!--Check if loop condition still valid-->
				<Compare>
					<GreaterOrEqual>
						<Value1>CheckTxPdoExcludeElement.Cnt</Value1>
						<Value2>CheckTxPdoExcludeElement.NumExclude</Value2>
						<Return Id="4"></Return>
					</GreaterOrEqual>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Init "CheckTxPdoExcludeElement.i32Index" = -1-->
				<SetVariable Target="CheckTxPdoExcludeElement.i32Index">-1</SetVariable>
			</TestStep>
			<TestStep>
				<!--Get Index of current excluded Pdo-->
				<CallTestFunction Name="ArrayOfUInt16.IndexOf">
					<Parameter>DeviceDescr.TxPdo[CheckTxPdoExcludeElement.PdoIndex].Exclude[CheckTxPdoExcludeElement.Cnt]</Parameter>
					<Parameter>CheckTxPdoExcludeElement.u16ArrTxPdo</Parameter>
					<OutParameter>CheckTxPdoExcludeElement.i32Index</OutParameter>
				</CallTestFunction>
				<WriteLine Id="5" Level="Verbose" Param0="DeviceDescr.TxPdo[CheckTxPdoExcludeElement.PdoIndex].Exclude[CheckTxPdoExcludeElement.Cnt]" Param1="CheckTxPdoExcludeElement.i32Index">Excluded TxPdo (0x{0:x4}) found at element index {1}.</WriteLine>
			</TestStep>
			<TestStep>
				<!--Dump Warning if non defined TxPdo is exlcuded-->
				<Compare>
					<Equal>
						<Value1>CheckTxPdoExcludeElement.i32Index</Value1>
						<Value2>-1</Value2>
						<WriteLine Id="6" Level="Warning" Param0="DeviceDescr.TxPdo[CheckTxPdoExcludeElement.PdoIndex].Exclude[CheckTxPdoExcludeElement.Cnt]">Index 0x{0:x4} is not defined in TxPdo device description</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckTxPdoExcludeElement.i32Index</Value1>
						<Value2>-1</Value2>
						<GotoStep>LOOPEND</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Init "CheckTxPdoExcludeElement.i32Index2" = -1-->
				<SetVariable Target="CheckTxPdoExcludeElement.i32Index2">-1</SetVariable>
			</TestStep>
			<TestStep>
				<!--current TxPdo shall also be excluded by Excluded TxPdo-->
				<CallTestFunction Name="ArrayOfUInt16.IndexOf">
					<Parameter>DeviceDescr.TxPdo[CheckTxPdoExcludeElement.PdoIndex].Index</Parameter>
					<Parameter>DeviceDescr.TxPdo[CheckTxPdoExcludeElement.i32Index].Exclude</Parameter>
					<OutParameter>CheckTxPdoExcludeElement.i32Index2</OutParameter>
				</CallTestFunction>
				<Compare>
					<Equal>
						<Value1>CheckTxPdoExcludeElement.i32Index2</Value1>
						<Value2>-1</Value2>
						<WriteLine Id="7" Level="Error" Param0="DeviceDescr.TxPdo[CheckTxPdoExcludeElement.PdoIndex].Index" Param1="DeviceDescr.TxPdo[CheckTxPdoExcludeElement.i32Index].Index">Current TxPdo (0x{0:x4}) is not excluded by 0x{1:x4}.</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckTxPdoExcludeElement.i32Index2</Value1>
						<Value2>-1</Value2>
						<SetVariable Target="CheckTxPdoExcludeElement.Valid">false</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="LOOPEND">
				<!--Last step in loop-->
				<SetVariable Target="CheckTxPdoExcludeElement.Cnt">CheckTxPdoExcludeElement.Cnt +1</SetVariable>
			</TestStep>
		</TestFunction>
		<TestFunction Name="CheckTxPdoExcludeElement_gen" FunctionId="20604">
			<?MAX_OUTPUT_ID 17?>
			<Parameter>
				<Name>TxPdoExclude.XmlFileXPath</Name>
				<Type>String</Type>
				<Comment>XPath of XML file (local, external)</Comment>
			</Parameter>
			<Parameter>
				<Name>TxPdoExclude.ModuleXPath</Name>
				<Type>String</Type>
				<Comment>XPath of Module</Comment>
			</Parameter>
			<Parameter>
				<Name>CountTxPdoExclude.ModuleCount</Name>
				<Type>Int32</Type>
				<Comment>Module Count for XPath string</Comment>
			</Parameter>
			<Parameter>
				<Name>CheckTxPdoExcludeElement.PdoIndex</Name>
				<Type>Int32</Type>
				<!--Zero based index of the PDO-->
				<Comment>TxPdo Count for XPath string</Comment>
			</Parameter>
			<LocalVariables>
				<Name>CheckTxPdoExcludeElement.Cnt</Name>
				<Type>UInt16</Type>
				<!--temp counter variable-->
			</LocalVariables>
			<LocalVariables>
				<Name>CheckTxPdoExcludeElement.i32Index</Name>
				<Type>Int32</Type>
				<!--index of excluded PDO-->
			</LocalVariables>
			<LocalVariables>
				<Name>CheckTxPdoExcludeElement.i32Index2</Name>
				<Type>Int32</Type>
				<!--index of current PDO in Excluded TxPdo exclude list-->
			</LocalVariables>
			<LocalVariables>
				<Name>CheckTxPdoExcludeElement.NumExclude</Name>
				<Type>UInt32</Type>
				<!--Number of exclude PDOs-->
			</LocalVariables>
			<LocalVariables>
				<Name>CheckTxPdoExcludeElement.ExcludePdoIndex</Name>
				<Type>Int32</Type>
				<!--Index of the Excluded TxPdo-->
			</LocalVariables>
			<LocalVariables>
				<Name>CheckTxPdoExcludeElement.u16ArrTxPdo</Name>
				<Type>ArrayOfUInt16</Type>
				<!--array to store all defined TxPdo indicies-->
			</LocalVariables>
			<LocalVariables>
				<Name>xxx_ADD_BEGIN_xxx</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>strXmlValue.TxPdoExcludeIndex.Uint16</Name>
				<Type>UInt16</Type>
				<!--Pdo Index-->
			</LocalVariables>
			<LocalVariables>
				<Name>strXmlValue.TxPdoExclude.String</Name>
				<Type>String</Type>
				<!--Pdo Exclude String-->
			</LocalVariables>
			<LocalVariables>
				<Name>strXmlValue.TxPdoExclude.Uint16</Name>
				<Type>UInt16</Type>
				<!--Pdo Exclude Uint16-->
			</LocalVariables>
			<LocalVariables>
				<Name>Uint32TmpExcludedIndex</Name>
				<Type>UInt32</Type>
				<!--Temporary Exclude Counter-->
			</LocalVariables>
			<LocalVariables>
				<Name>CheckExcludeElement.u16ArrTxPdo</Name>
				<Type>ArrayOfUInt16</Type>
				<!--array to store all defined Excludes-->
			</LocalVariables>
			<LocalVariables>
				<Name>strXmlValue.TxPdoExcludeIndex2.Uint16</Name>
				<Type>UInt16</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>xxx_ADD_END_xxx</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<OutParameter>
				<Name>CheckTxPdoExcludeElement.Valid</Name>
				<Type>Bool</Type>
			</OutParameter>
			<TestStep>
				<!--Check if requested PDO index is defined-->
				<GetXmlValue FileName="TxPdoExclude.XmlFileXPath" Markup="false" ReturnValue="strXmlValue.TxPdoExcludeIndex.Uint16">
					<XPath Param0="TxPdoExclude.ModuleXPath" Param1="CountTxPdoExclude.ModuleCount" Param2="CheckTxPdoExcludeElement.PdoIndex">{0}[{1}]/TxPdo[{2}]/Index</XPath>
				</GetXmlValue>
				<Compare>
					<NotEqual>
						<Value1>strXmlValue.TxPdoExcludeIndex.Uint16</Value1>
						<Value2>0</Value2>
						<GotoStep>CHECKOK</GotoStep>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValue.TxPdoExcludeIndex.Uint16</Value1>
						<Value2>null</Value2>
						<WriteLine Id="0" Level="Error" Param0="TxPdoExclude.ModuleXPath" Param1="CountTxPdoExclude.ModuleCount" Param2="CheckTxPdoExcludeElement.PdoIndex">Requested {0}[{1}]/TxPdo[{2}] not defined in ESI.</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValue.TxPdoExcludeIndex.Uint16</Value1>
						<Value2>EmptyString</Value2>
						<WriteLine Id="1" Level="Error" Param0="TxPdoExclude.ModuleXPath" Param1="CountTxPdoExclude.ModuleCount" Param2="CheckTxPdoExcludeElement.PdoIndex">Requested {0}[{1}]/TxPdo[{2}] not defined in ESI.</WriteLine>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CHECKOK">
				<!--Init "CheckTxPdoExcludeElement.Valid" = true-->
				<SetVariable Target="CheckTxPdoExcludeElement.Valid">true</SetVariable>
			</TestStep>
			<TestStep>
				<!--Check if Exclude elements defined-->
				<GetXmlValue FileName="TxPdoExclude.XmlFileXPath" Markup="false" ReturnValue="strXmlValue.TxPdoExclude.String">
					<XPath Param0="TxPdoExclude.ModuleXPath" Param1="CountTxPdoExclude.ModuleCount" Param2="CheckTxPdoExcludeElement.PdoIndex">{0}[{1}]/TxPdo[{2}]/Exclude</XPath>
				</GetXmlValue>
				<Compare>
					<Equal>
						<Value1>strXmlValue.TxPdoExclude.String</Value1>
						<Value2>EmptyString</Value2>
						<WriteLine Id="2" Level="Verbose" Param0="TxPdoExclude.ModuleXPath" Param1="CountTxPdoExclude.ModuleCount" Param2="CheckTxPdoExcludeElement.PdoIndex">No Exclude element defined for {0}[{1}]/TxPdo[{2}].</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValue.TxPdoExclude.String</Value1>
						<Value2>EmptyString</Value2>
						<Return Id="3"></Return>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValue.TxPdoExclude.String</Value1>
						<Value2>null</Value2>
						<WriteLine Id="4" Level="Verbose" Param0="TxPdoExclude.ModuleXPath" Param1="CountTxPdoExclude.ModuleCount" Param2="CheckTxPdoExcludeElement.PdoIndex">No Exclude element defined for {0}[{1}]/TxPdo[{2}].</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValue.TxPdoExclude.String</Value1>
						<Value2>null</Value2>
						<Return Id="5"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Copy all defined TxPdo indicies to Uint16Array-->
				<CallTestFunction Name="PdoElementsToArray_gen">
					<Parameter>false</Parameter>
					<Parameter>TxPdoExclude.XmlFileXPath</Parameter>
					<Parameter>TxPdoExclude.ModuleXPath</Parameter>
					<Parameter>CountTxPdoExclude.ModuleCount</Parameter>
					<Parameter>CheckTxPdoExcludeElement.PdoIndex</Parameter>
					<OutParameter>CheckTxPdoExcludeElement.u16ArrTxPdo</OutParameter>
				</CallTestFunction>
			</TestStep>
			<TestStep>
				<!--Init "CheckTxPdoExcludeElement.Cnt" = 1 (because of XPath)-->
				<SetVariable Target="CheckTxPdoExcludeElement.Cnt">1</SetVariable>
			</TestStep>
			<TestStep>
				<!--Init "CheckTxPdoExcludeElement.NumExclude" = 0-->
				<SetVariable Target="CheckTxPdoExcludeElement.NumExclude">0</SetVariable>
			</TestStep>
			<TestStep>
				<SetVariable Target="Uint32TmpExcludedIndex">1</SetVariable>
			</TestStep>
			<TestStep Name="EXCLUDE_Count_LOOPSTART">
				<!--Get Number of Exclude Elements-->
			</TestStep>
			<TestStep>
				<!--Check if TxPdo.Exclude is defined-->
				<GetXmlValue FileName="TxPdoExclude.XmlFileXPath" Markup="false" ReturnValue="strXmlValue.TxPdoExclude.String">
					<XPath Param0="TxPdoExclude.ModuleXPath" Param1="CountTxPdoExclude.ModuleCount" Param2="CheckTxPdoExcludeElement.PdoIndex" Param3="Uint32TmpExcludedIndex">{0}[{1}]/TxPdo[{2}]/Exclude[{3}]</XPath>
				</GetXmlValue>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>debug_msg</Value2>
						<WriteLine Id="6" Level="Output" Param0="strXmlValue.TxPdoExclude.String">strXmlValue.TxPdoExclude.String: {0}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValue.TxPdoExclude.String</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>NUM_EXCLUDED_EL</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValue.TxPdoExclude.String</Value1>
						<Value2>null</Value2>
						<GotoStep>NUM_EXCLUDED_EL</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<WriteLine Id="7" Level="Verbose" Param0="TxPdoExclude.ModuleXPath" Param1="CountTxPdoExclude.ModuleCount" Param2="CheckTxPdoExcludeElement.PdoIndex" Param3="Uint32TmpExcludedIndex">Exclude PDO(s) found in: {0}[{1}]/TxPdo[{2}]/Exclude[{3}].</WriteLine>
			</TestStep>
			<TestStep Name="ExcludedLOOPEnd">
				<SetVariable Target="Uint32TmpExcludedIndex">Uint32TmpExcludedIndex + 1</SetVariable>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>EXCLUDE_Count_LOOPSTART</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="NUM_EXCLUDED_EL">
				<!--Set number of Excluded elements and report number.-->
				<SetVariable Target="Uint32TmpExcludedIndex">Uint32TmpExcludedIndex - 1</SetVariable>
				<WriteLine Id="8" Level="Verbose" Param0="TxPdoExclude.ModuleXPath" Param1="CountTxPdoExclude.ModuleCount" Param2="CheckTxPdoExcludeElement.PdoIndex" Param3="Uint32TmpExcludedIndex">{0}[{1}]/TxPdo[{2}] has {3} exclude PDO(s)</WriteLine>
			</TestStep>
			<TestStep Name="LOOPSTART">
				<SetVariable Target="CheckTxPdoExcludeElement.NumExclude">Uint32TmpExcludedIndex</SetVariable>
			</TestStep>
			<TestStep>
				<!--Check if loop condition still valid-->
				<Compare>
					<Greater>
						<Value1>CheckTxPdoExcludeElement.Cnt</Value1>
						<Value2>CheckTxPdoExcludeElement.NumExclude</Value2>
						<Return Id="9"></Return>
					</Greater>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Init "CheckTxPdoExcludeElement.i32Index" = -1-->
				<SetVariable Target="CheckTxPdoExcludeElement.i32Index">-1</SetVariable>
			</TestStep>
			<TestStep>
				<!--Get Index of current excluded Pdo-->
				<GetXmlValue FileName="TxPdoExclude.XmlFileXPath" Markup="false" ReturnValue="strXmlValue.TxPdoExclude.Uint16">
					<XPath Param0="TxPdoExclude.ModuleXPath" Param1="CountTxPdoExclude.ModuleCount" Param2="CheckTxPdoExcludeElement.PdoIndex" Param3="CheckTxPdoExcludeElement.Cnt">{0}[{1}]/TxPdo[{2}]/Exclude[{3}]</XPath>
				</GetXmlValue>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>debug_msg</Value2>
						<WriteLine Id="10" Level="Output" Param0="CheckTxPdoExcludeElement.Cnt">Value of "CheckTxPdoExcludeElement.Cnt": {0}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>debug_msg</Value2>
						<WriteLine Id="11" Level="Output" Param0="strXmlValue.TxPdoExclude.Uint16">Value of "strXmlValue.TxPdoExclude.Uint16": {0}</WriteLine>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<CallTestFunction Name="ArrayOfUInt16.IndexOf">
					<Parameter>strXmlValue.TxPdoExclude.Uint16</Parameter>
					<Parameter>CheckTxPdoExcludeElement.u16ArrTxPdo</Parameter>
					<OutParameter>CheckTxPdoExcludeElement.i32Index</OutParameter>
				</CallTestFunction>
				<WriteLine Id="12" Level="Verbose" Param0="strXmlValue.TxPdoExclude.Uint16" Param1="CheckTxPdoExcludeElement.i32Index">Excluded TxPdo (0x{0:x4}) found at element index {1}.</WriteLine>
			</TestStep>
			<TestStep>
				<!--Dump Warning if non defined TxPdo is exlcuded-->
				<Compare>
					<Equal>
						<Value1>CheckTxPdoExcludeElement.i32Index</Value1>
						<Value2>-1</Value2>
						<WriteLine Id="13" Level="Warning" Param0="strXmlValue.TxPdoExclude.Uint16">Index 0x{0:x4} is not defined in TxPdo device description</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckTxPdoExcludeElement.i32Index</Value1>
						<Value2>-1</Value2>
						<GotoStep>LOOPEND</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Init "CheckTxPdoExcludeElement.i32Index2" = -1-->
				<SetVariable Target="CheckTxPdoExcludeElement.i32Index2">-1</SetVariable>
			</TestStep>
			<TestStep>
				<!--current TxPdo shall also be excluded by Excluded TxPdo-->
				<GetXmlValue FileName="TxPdoExclude.XmlFileXPath" Markup="false" ReturnValue="strXmlValue.TxPdoExcludeIndex.Uint16">
					<XPath Param0="TxPdoExclude.ModuleXPath" Param1="CountTxPdoExclude.ModuleCount" Param2="CheckTxPdoExcludeElement.PdoIndex">{0}[{1}]/TxPdo[{2}]/Index</XPath>
				</GetXmlValue>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>debug_msg</Value2>
						<WriteLine Id="14" Level="Output" Param0="CheckTxPdoExcludeElement.PdoIndex">Value of CheckTxPdoExcludeElement.PdoIndex: {0}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>debug_msg</Value2>
						<WriteLine Id="15" Level="Output" Param0="strXmlValue.TxPdoExcludeIndex.Uint16">Value of "strXmlValue.TxPdoExcludeIndex.Uint16": {0}</WriteLine>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--CheckTxPdoExcludeElement.i32Index+1 (+1 because of XPath)-->
				<GetXmlValue FileName="TxPdoExclude.XmlFileXPath" Markup="false" ReturnValue="strXmlValue.TxPdoExcludeIndex2.Uint16">
					<XPath Param0="TxPdoExclude.ModuleXPath" Param1="CountTxPdoExclude.ModuleCount" Param2="CheckTxPdoExcludeElement.i32Index">{0}[{1}]/TxPdo[{2}]/Index</XPath>
				</GetXmlValue>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>debug_msg</Value2>
						<WriteLine Id="16" Level="Output" Param0="strXmlValue.TxPdoExcludeIndex2.Uint16">Value of "strXmlValue.TxPdoExcludeIndex2.Uint16": {0}</WriteLine>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<CallTestFunction Name="PdoExcludeElementsToArray_gen">
					<Parameter>false</Parameter>
					<Parameter>TxPdoExclude.XmlFileXPath</Parameter>
					<Parameter>TxPdoExclude.ModuleXPath</Parameter>
					<Parameter>CountTxPdoExclude.ModuleCount</Parameter>
					<Parameter>CheckTxPdoExcludeElement.i32Index</Parameter>
					<OutParameter>CheckExcludeElement.u16ArrTxPdo</OutParameter>
				</CallTestFunction>
			</TestStep>
			<TestStep>
				<CallTestFunction Name="ArrayOfUInt16.IndexOf">
					<Parameter>strXmlValue.TxPdoExcludeIndex.Uint16</Parameter>
					<Parameter>CheckExcludeElement.u16ArrTxPdo</Parameter>
					<OutParameter>CheckTxPdoExcludeElement.i32Index2</OutParameter>
				</CallTestFunction>
				<Compare>
					<Equal>
						<Value1>CheckTxPdoExcludeElement.i32Index2</Value1>
						<Value2>-1</Value2>
						<WriteLine Id="17" Level="Error" Param0="strXmlValue.TxPdoExcludeIndex.Uint16" Param1="strXmlValue.TxPdoExclude.Uint16">Current TxPdo (0x{0:x4}) is not excluded by 0x{1:x4}.</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckTxPdoExcludeElement.i32Index2</Value1>
						<Value2>-1</Value2>
						<SetVariable Target="CheckTxPdoExcludeElement.Valid">false</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="LOOPEND">
				<!--Last step in loop-->
				<SetVariable Target="CheckTxPdoExcludeElement.Cnt">CheckTxPdoExcludeElement.Cnt +1</SetVariable>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>LOOPSTART</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction Name="CheckTxPdoSmAssignment" FunctionId="1104">
			<?MAX_OUTPUT_ID 24?>
			<!--Iterate of all defined SyncManger and check if TxPdo assignment is valid-->
			<Parameter>
				<Name>CheckTxPdoSmAssignment.PdoIndex</Name>
				<Type>UInt16</Type>
				<!--Zero based index of the TxPdo-->
			</Parameter>
			<LocalVariables>
				<Name>CheckTxPdoSmAssignment.Cnt</Name>
				<Type>UInt16</Type>
				<!--temp counter variable-->
			</LocalVariables>
			<LocalVariables>
				<Name>CheckTxPdoSmAssignment.ValidSmName</Name>
				<Type>String</Type>
				<!--Valid SM name is "Inputs"-->
			</LocalVariables>
			<LocalVariables>
				<Name>CheckTxPdoSmAssignment.PotentialSm</Name>
				<Type>UInt16</Type>
				<!--Number of potential SM to assign-->
			</LocalVariables>
			<LocalVariables>
				<Name>CheckTxPdoSmAssignment.TmpIndex</Name>
				<Type>Int32</Type>
				<!--temp testfunction result-->
			</LocalVariables>
			<LocalVariables>
				<Name>CheckTxPdoSmAssignment.bValid</Name>
				<Type>Bool</Type>
				<!--tmp testfunction result-->
			</LocalVariables>
			<OutParameter>
				<Name>CheckTxPdoSmAssignment.Valid</Name>
				<Type>Bool</Type>
			</OutParameter>
			<TestStep Name="START">
				<!--Check if SM Elements defined-->
				<WriteLine Id="0" Level="Verbose" Param0="DeviceDescr.SM.Count">{0} SyncManger defined in device description</WriteLine>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.SM.Count</Value1>
						<Value2>0</Value2>
						<SetVariable Target="CheckTxPdoSmAssignment.Valid">false</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Check if parameter "CheckTxPdoSmAssignment.PdoIndex" is valid (< DeviceDescr.TxPdo.Count)-->
				<Compare>
					<LowerOrEqual>
						<Value1>DeviceDescr.TxPdo.Count</Value1>
						<Value2>CheckTxPdoSmAssignment.PdoIndex</Value2>
						<WriteLine Id="1" Level="Error" Param0="CheckTxPdoSmAssignment.PdoIndex" Param1="DeviceDescr.TxPdo.Count">Requested TxPdo index {0} greater or equal {1} =&gt; skip test case</WriteLine>
					</LowerOrEqual>
				</Compare>
				<Compare>
					<LowerOrEqual>
						<Value1>DeviceDescr.TxPdo.Count</Value1>
						<Value2>CheckTxPdoSmAssignment.PdoIndex</Value2>
						<SetVariable Target="CheckTxPdoSmAssignment.Valid">false</SetVariable>
					</LowerOrEqual>
				</Compare>
				<Compare>
					<LowerOrEqual>
						<Value1>DeviceDescr.TxPdo.Count</Value1>
						<Value2>CheckTxPdoSmAssignment.PdoIndex</Value2>
						<Return Id="2"></Return>
					</LowerOrEqual>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Set "CheckTxPdoSmAssignment.Cnt" to 0-->
				<SetVariable Target="CheckTxPdoSmAssignment.Cnt">0</SetVariable>
			</TestStep>
			<TestStep>
				<!--Set "CheckTxPdoSmAssignment.Failed" to true-->
				<SetVariable Target="CheckTxPdoSmAssignment.Valid">true</SetVariable>
			</TestStep>
			<TestStep>
				<!--Set "CheckTxPdoSmAssignment.ValidSmName" to "Inputs"-->
				<SetVariable Target="CheckTxPdoSmAssignment.ValidSmName">Inputs</SetVariable>
			</TestStep>
			<TestStep>
				<!--Set "CheckTxPdoSmAssignment.PotentialSm" to 0-->
				<SetVariable Target="CheckTxPdoSmAssignment.PotentialSm">0</SetVariable>
			</TestStep>
			<TestStep>
				<!--Set "CheckTxPdoSmAssignment.Cnt" to 0-->
				<SetVariable Target="CheckTxPdoSmAssignment.Cnt">0</SetVariable>
			</TestStep>
			<TestStep>
				<!--Check if TxPdo is mandatory-->
				<Description Id="3"> </Description>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.TxPdo[CheckTxPdoSmAssignment.PdoIndex].Mandatory</Value1>
						<Value2>false</Value2>
						<GotoStep>SMLOOPSTART</GotoStep>
					</Equal>
					<!--If Pdo is not mandatory iterate over all SyncManager-->
				</Compare>
			</TestStep>
			<TestStep>
				<!--Raise an Error if TxPdo is mandatory and no default SM is defined-->
				<Compare>
					<Equal>
						<Value1>DeviceDescr.TxPdo[CheckTxPdoSmAssignment.PdoIndex].Sm</Value1>
						<Value2>null</Value2>
						<SetVariable Target="CheckTxPdoSmAssignment.Valid">false</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.TxPdo[CheckTxPdoSmAssignment.PdoIndex].Sm</Value1>
						<Value2>null</Value2>
						<RaiseError Id="4" Param0="CheckTxPdoSmAssignment.PdoIndex">A default SyncManager (TxPdo@Sm) shall be defined because the TxPdo[{0}] is mandatory.</RaiseError>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Raise an Error if TxPdo@Sm > available Sm.count-->
				<Compare>
					<LowerOrEqual>
						<Value1>DeviceDescr.SM.Count</Value1>
						<Value2>DeviceDescr.TxPdo[CheckTxPdoSmAssignment.PdoIndex].Sm</Value2>
						<RaiseError Id="5" Param0="CheckTxPdoSmAssignment.PdoIndex" Param1="DeviceDescr.TxPdo[CheckTxPdoSmAssignment.PdoIndex].Sm">The referenced SyncManager (TxPdo[{0}].Sm : {1}) is not defined in device description</RaiseError>
					</LowerOrEqual>
				</Compare>
			</TestStep>
			<TestStep>
				<!--If TxPdo.ExcludeSM is defined dump a warning (Pdo shall be assigned to a fixed SM so the element is not required)-->
				<Compare>
					<NotEqual>
						<Value1>DeviceDescr.TxPdo[CheckTxPdoSmAssignment.PdoIndex].ExcludedSm</Value1>
						<Value2>null</Value2>
						<WriteLine Id="6" Level="Warning" Param0="CheckTxPdoSmAssignment.PdoIndex">TxPdo[{0}] is mandatory so no ExcludeSm need to be defined.</WriteLine>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Set "CheckTxPdoSmAssignment.Cnt" to TxPdo@Sm (the PDO shall assigned to the specified SM => only this SM will be tested-->
				<SetVariable Target="CheckTxPdoSmAssignment.Cnt">DeviceDescr.TxPdo[CheckTxPdoSmAssignment.PdoIndex].Sm</SetVariable>
				<WriteLine Id="7" Level="Verbose" Param0="CheckTxPdoSmAssignment.PdoIndex" Param1="CheckTxPdoSmAssignment.Cnt">TxPdo[{0}] is fixed assigned to SyncManager[{1}] (@Mandatory == true and @SM defined)=&gt; only this SM is tested</WriteLine>
			</TestStep>
			<TestStep Name="SMLOOPSTART">
				<WriteLine Id="8" Param0="CheckTxPdoSmAssignment.Cnt" Level="Verbose">Check SM[{0}]</WriteLine>
			</TestStep>
			<TestStep>
				<!--Check if SyncManager direction and type match-->
				<Compare>
					<Equal>
						<Value1>CheckTxPdoSmAssignment.ValidSmName</Value1>
						<Value2>DeviceDescr.SM[CheckTxPdoSmAssignment.Cnt]</Value2>
						<GotoStep>EXCLUDESM</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--SM direction and/or type not match dump an error if this is the default SM or proceed with next SM-->
				<Compare>
					<Equal>
						<Value1>DeviceDescr.TxPdo[CheckTxPdoSmAssignment.PdoIndex].Sm</Value1>
						<Value2>null</Value2>
						<WriteLine Id="9" Level="Verbose" Param0="CheckTxPdoSmAssignment.Cnt" Param1="CheckTxPdoSmAssignment.ValidSmName" Param2="DeviceDescr.SM[CheckTxPdoSmAssignment.Cnt]">SM[{0}] skipped because SM type not match (expected: {1}, read: {2}).</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.TxPdo[CheckTxPdoSmAssignment.PdoIndex].Sm</Value1>
						<Value2>null</Value2>
						<GotoStep>SMLOOPEND</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckTxPdoSmAssignment.Cnt</Value1>
						<Value2>DeviceDescr.TxPdo[CheckTxPdoSmAssignment.PdoIndex].Sm</Value2>
						<WriteLine Id="10" Level="Verbose" Param0="CheckTxPdoSmAssignment.Cnt">SM[{0}] skipped because SM type not match.</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckTxPdoSmAssignment.Cnt</Value1>
						<Value2>DeviceDescr.TxPdo[CheckTxPdoSmAssignment.PdoIndex].Sm</Value2>
						<GotoStep>SMLOOPEND</GotoStep>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>True</Value1>
						<Value2>True</Value2>
						<SetVariable Target="CheckTxPdoSmAssignment.Valid">false</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>True</Value1>
						<Value2>True</Value2>
						<WriteLine Id="11" Level="Error" Param0="DeviceDescr.TxPdo[CheckTxPdoSmAssignment.PdoIndex].Sm" Param1="CheckTxPdoSmAssignment.ValidSmName" Param2="DeviceDescr.SM[CheckTxPdoSmAssignment.Cnt]">Type/Direction of default SyncManager[{0}] doens't match. (expected "{1}", read "{2}")</WriteLine>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="EXCLUDESM">
				<!--Check if TxPdo.ExcludedSm is defined-->
				<Compare>
					<Equal>
						<Value1>DeviceDescr.TxPdo[CheckTxPdoSmAssignment.PdoIndex].ExcludedSm</Value1>
						<Value2>null</Value2>
						<GotoStep>TESTSU</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Check if current Sm is defined in Exclude Sm List-->
				<CallTestFunction Name="ArrayOfInt32.IndexOf">
					<Parameter>CheckTxPdoSmAssignment.Cnt</Parameter>
					<Parameter>DeviceDescr.TxPdo[CheckTxPdoSmAssignment.PdoIndex].ExcludedSm</Parameter>
					<OutParameter>i32TmpIndex</OutParameter>
				</CallTestFunction>
			</TestStep>
			<TestStep>
				<!--If current Sm is not excluded proceed with Su step-->
				<Compare>
					<Equal>
						<Value1>CheckTxPdoSmAssignment.TmpIndex</Value1>
						<Value2>-1</Value2>
						<GotoStep>TESTSU</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckTxPdoSmAssignment.TmpIndex</Value1>
						<Value2>-1</Value2>
						<WriteLine Id="12" Level="Verbose" Param0="CheckTxPdoSmAssignment.Cnt">SM[{0}] skipped because SM is listed in TxPdo.ExcludedSm</WriteLine>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Dump an Error if default SM is excluded-->
				<Compare>
					<!--proceed with next Sm if no default Sm is defined-->
					<Equal>
						<Value1>DeviceDescr.TxPdo[CheckTxPdoSmAssignment.PdoIndex].Sm</Value1>
						<Value2>null</Value2>
						<GotoStep>SMLOOPEND</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckTxPdoSmAssignment.TmpIndex</Value1>
						<Value2>DeviceDescr.TxPdo[CheckTxPdoSmAssignment.PdoIndex].Sm</Value2>
						<WriteLine Id="13" Level="Error" Param0="CheckTxPdoSmAssignment.PdoIndex">TxPdo[{0}] Exclude the configured default Sm.</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckTxPdoSmAssignment.TmpIndex</Value1>
						<Value2>DeviceDescr.TxPdo[CheckTxPdoSmAssignment.PdoIndex].Sm</Value2>
						<SetVariable Target="CheckTxPdoSmAssignment.Valid">false</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckTxPdoSmAssignment.TmpIndex</Value1>
						<Value2>DeviceDescr.TxPdo[CheckTxPdoSmAssignment.PdoIndex].Sm</Value2>
						<GotoStep>SMLOOPEND</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="TESTSU">
				<!--Check if TxPdo.Su is defined-->
				<Compare>
					<Equal>
						<Value1>DeviceDescr.TxPdo[CheckTxPdoSmAssignment.PdoIndex].Su</Value1>
						<Value2>null</Value2>
						<GotoStep>STARTTESTSM</GotoStep>
					</Equal>
				</Compare>
				<!--Skip if Sm not defined-->
				<Compare>
					<Equal>
						<Value1>DeviceDescr.TxPdo[CheckTxPdoSmAssignment.PdoIndex].Sm</Value1>
						<Value2>null</Value2>
						<GotoStep>STARTTESTSM</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Check if current Sm is referenced via Su-->
				<CallTestFunction Name="IsSmReferencedViaSu">
					<Parameter>CheckTxPdoSmAssignment.Cnt</Parameter>
					<Parameter>DeviceDescr.TxPdo[CheckTxPdoSmAssignment.PdoIndex].Su</Parameter>
					<OutParameter>CheckTxPdoSmAssignment.bValid</OutParameter>
				</CallTestFunction>
			</TestStep>
			<TestStep>
				<!--Skip Sm Test if it is not referenced via Su-->
				<Compare>
					<Equal>
						<Value1>CheckTxPdoSmAssignment.bValid</Value1>
						<Value2>false</Value2>
						<WriteLine Id="14" Level="Verbose" Param0="CheckTxPdoSmAssignment.Cnt">SM[{0}] skipped because SM is not referenced via Su</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckTxPdoSmAssignment.bValid</Value1>
						<Value2>false</Value2>
						<GotoStep>SMLOOPEND</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="STARTTESTSM">
				<!--SyncManager may be used for the PDO => increment indication counter-->
				<SetVariable Target="CheckTxPdoSmAssignment.PotentialSm">CheckTxPdoSmAssignment.PotentialSm + 1</SetVariable>
			</TestStep>
			<TestStep Name="CHECKVIRTUAL">
				<!--Check if virtual settings are correct-->
				<Compare>
					<Equal>
						<Value1>DeviceDescr.TxPdo[CheckTxPdoSmAssignment.PdoIndex].Virtual</Value1>
						<Value2>false</Value2>
						<GotoStep>NOTVIRTUAL</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--PDO is virtual
if Entries defined goto "VIRTUALENTRIES"
else 
current SM is not virtual => correct
current SM is virtual but is not the default SM => warning because of a possible wrong configuration
the default SM is virtual => Error-->
				<Compare>
					<NotEqual>
						<Value1>DeviceDescr.TxPdo[CheckTxPdoSmAssignment.PdoIndex].Entry.Count</Value1>
						<Value2>0</Value2>
						<GotoStep>VIRTUALENTRIES</GotoStep>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.SM[CheckTxPdoSmAssignment.Cnt].Virtual</Value1>
						<Value2>false</Value2>
						<GotoStep>SMLOOPEND</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.TxPdo[CheckTxPdoSmAssignment.PdoIndex].Sm</Value1>
						<Value2>null</Value2>
						<WriteLine Id="15" Level="Warning" Param0="CheckTxPdoSmAssignment.PdoIndex" Param1="CheckTxPdoSmAssignment.Cnt">Virtual TxPdo[{0}] with no Entries may be assigned to the virtual SyncManager[{1}].</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.TxPdo[CheckTxPdoSmAssignment.PdoIndex].Sm</Value1>
						<Value2>null</Value2>
						<GotoStep>SMLOOPEND</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>DeviceDescr.TxPdo[CheckTxPdoSmAssignment.PdoIndex].Sm</Value1>
						<Value2>CheckTxPdoSmAssignment.Cnt</Value2>
						<WriteLine Id="16" Level="Warning" Param0="CheckTxPdoSmAssignment.PdoIndex" Param1="CheckTxPdoSmAssignment.Cnt">Virtual TxPdo[{0}] with no Entries may be assigned to the virtual SyncManager[{1}].</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>DeviceDescr.TxPdo[CheckTxPdoSmAssignment.PdoIndex].Sm</Value1>
						<Value2>CheckTxPdoSmAssignment.Cnt</Value2>
						<GotoStep>SMLOOPEND</GotoStep>
					</NotEqual>
				</Compare>
				<Compare>
					<!--The current PDO is not virtual but the default SM is virtual-->
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="17" Level="Error" Param0="CheckTxPdoSmAssignment.PdoIndex" Param1="CheckTxPdoSmAssignment.Cnt">Virtual TxPdo[{0}] with no Entries is assigned to the virtual SyncManager[{1}].</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<SetVariable Target="CheckTxPdoSmAssignment.Valid">false</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>SMLOOPEND</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="VIRTUALENTRIES">
				<!--PDO is virtual and Entries defined
- the current SM is virtual => correct
- current SM is not virtual but is not the default SM => warning because of a possible wrong configuration
the default SM is not virtual => Error-->
				<Compare>
					<Equal>
						<Value1>DeviceDescr.SM[CheckTxPdoSmAssignment.Cnt].Virtual</Value1>
						<Value2>true</Value2>
						<GotoStep>SMLOOPEND</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.TxPdo[CheckTxPdoSmAssignment.PdoIndex].Sm</Value1>
						<Value2>null</Value2>
						<WriteLine Id="18" Level="Warning" Param0="CheckTxPdoSmAssignment.PdoIndex" Param1="CheckTxPdoSmAssignment.Cnt">Virtual TxPdo[{0}] with Entries may be assigned to the non virtual SyncManager[{1}].</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.TxPdo[CheckTxPdoSmAssignment.PdoIndex].Sm</Value1>
						<Value2>null</Value2>
						<GotoStep>SMLOOPEND</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>DeviceDescr.TxPdo[CheckTxPdoSmAssignment.PdoIndex].Sm</Value1>
						<Value2>CheckTxPdoSmAssignment.Cnt</Value2>
						<WriteLine Id="19" Level="Warning" Param0="CheckTxPdoSmAssignment.PdoIndex" Param1="CheckTxPdoSmAssignment.Cnt">Virtual TxPdo[{0}] with Entries may be assigned to the non virtual SyncManager[{1}].</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>DeviceDescr.TxPdo[CheckTxPdoSmAssignment.PdoIndex].Sm</Value1>
						<Value2>CheckTxPdoSmAssignment.Cnt</Value2>
						<GotoStep>SMLOOPEND</GotoStep>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="20" Level="Error" Param0="CheckTxPdoSmAssignment.PdoIndex" Param1="CheckTxPdoSmAssignment.Cnt">Virtual TxPdo[{0}] with Entries is assigned to the virtual SyncManager[{1}].</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<SetVariable Target="CheckTxPdoSmAssignment.Valid">false</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>SMLOOPEND</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="NOTVIRTUAL">
				<!--PDO is not virtual-->
				<Compare>
					<Equal>
						<Value1>DeviceDescr.SM[CheckTxPdoSmAssignment.Cnt].Virtual</Value1>
						<Value2>false</Value2>
						<GotoStep>SMLOOPEND</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.TxPdo[CheckTxPdoSmAssignment.PdoIndex].Sm</Value1>
						<Value2>null</Value2>
						<WriteLine Id="21" Level="Warning" Param0="CheckTxPdoSmAssignment.PdoIndex" Param1="CheckTxPdoSmAssignment.Cnt">Non virtual TxPdo[{0}] may be assigned to virtual SyncManager[{1}]</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.TxPdo[CheckTxPdoSmAssignment.PdoIndex].Sm</Value1>
						<Value2>null</Value2>
						<GotoStep>SMLOOPEND</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>DeviceDescr.TxPdo[CheckTxPdoSmAssignment.PdoIndex].Sm</Value1>
						<Value2>CheckTxPdoSmAssignment.Cnt</Value2>
						<WriteLine Id="22" Level="Warning" Param0="CheckTxPdoSmAssignment.PdoIndex" Param1="CheckTxPdoSmAssignment.Cnt">Non virtual TxPdo[{0}] may be assigned to virtual SyncManager[{1}]</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>DeviceDescr.TxPdo[CheckTxPdoSmAssignment.PdoIndex].Sm</Value1>
						<Value2>CheckTxPdoSmAssignment.Cnt</Value2>
						<GotoStep>SMLOOPEND</GotoStep>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.TxPdo[CheckTxPdoSmAssignment.PdoIndex].Sm</Value1>
						<Value2>CheckTxPdoSmAssignment.Cnt</Value2>
						<WriteLine Id="23" Level="Error" Param0="CheckTxPdoSmAssignment.PdoIndex" Param1="CheckTxPdoSmAssignment.Cnt">Non virtual TxPdo[{0}] is by default assigned to virtual SyncManager[{1}]</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.TxPdo[CheckTxPdoSmAssignment.PdoIndex].Sm</Value1>
						<Value2>CheckTxPdoSmAssignment.Cnt</Value2>
						<SetVariable Target="CheckTxPdoSmAssignment.Valid">false</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="SMLOOPEND">
				<!--Abort loop if
- Pdo is mandatory 
OR
- "CheckTxPdoSmAssignment.Cnt" >= "DeviceDescr.SM.Count"-->
				<SetVariable Target="CheckTxPdoSmAssignment.Cnt">CheckTxPdoSmAssignment.Cnt + 1</SetVariable>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.TxPdo[CheckTxPdoSmAssignment.PdoIndex].Mandatory</Value1>
						<Value2>true</Value2>
						<GotoStep>END</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Lower>
						<Value1>CheckTxPdoSmAssignment.Cnt</Value1>
						<Value2>DeviceDescr.SM.Count</Value2>
						<GotoStep>SMLOOPSTART</GotoStep>
					</Lower>
				</Compare>
			</TestStep>
			<TestStep Name="END">
				<Compare>
					<Equal>
						<Value1>CheckTxPdoSmAssignment.PotentialSm</Value1>
						<Value2>0</Value2>
						<WriteLine Id="24" Level="Error" Param0="CheckTxPdoSmAssignment.PdoIndex">No SyncManager for TxPdo[{0}] found</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckTxPdoSmAssignment.PotentialSm</Value1>
						<Value2>0</Value2>
						<SetVariable Target="CheckTxPdoSmAssignment.Valid">false</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction Name="DataTypeSupportCA" FunctionId="20501">
			<?MAX_OUTPUT_ID 8?>
			<Description>
				<Purpose>Checks if Complete Access is supported for a DataType (of of the referenced objects support CA)</Purpose>
				<PreCondition>-none</PreCondition>
				<Action>-checks the default SDO access and the exception in the object element</Action>
				<PostCondition></PostCondition>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>DataTypeSupportCA.strDtName</Name>
				<Type>String</Type>
				<Comment>Name of the data type</Comment>
			</Parameter>
			<Parameter>
				<Name>DataTypeSupportCA.XmlFile</Name>
				<Type>String</Type>
				<Comment>Path of the xml file (absolute or relative to the ESI file).
If the parameter is null or empty the current device description will be referenced.</Comment>
			</Parameter>
			<Parameter>
				<Name>DataTypeSupportCA.XPath</Name>
				<Type>String</Type>
				<Comment>XPath of the current DataType</Comment>
			</Parameter>
			<LocalVariables>
				<Name>DataTypeSupportCA.xmlFile</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>DataTypeSupportCA.ObjCnt</Name>
				<Type>UInt32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>DataTypeSupportCA.tmpStr</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>DataTypeSupportCA.ObjName</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>DataTypeSupportCA.xPathObject</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>DataTypeSupportCA.XPathModule</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>DataTypeSupportCA.Mailbox</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>DataTypeSupportCA.MailboxCoE</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>DataTypeSupportCA.MailboxCoECA</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>DataTypeSupportCA.Od</Name>
				<Type>ObjectDictionary</Type>
			</LocalVariables>
			<OutParameter>
				<Name>DataTypeSupportCA.boolCaSupport</Name>
				<Type>Bool</Type>
			</OutParameter>
			<TestStep>
				<RegexReplace OutputString="DataTypeSupportCA.XPathModule">
					<Pattern>/Profile/.*</Pattern>
					<InputString>DataTypeSupportCA.XPath</InputString>
					<ReplacementString>EmptyString</ReplacementString>
				</RegexReplace>
			</TestStep>
			<TestStep Name="debug_msg">
				<Compare>
					<Equal>
						<Value1>debug_msg</Value1>
						<Value2>true</Value2>
						<WriteLine Id="0" Level="Verbose" Param0="DataTypeSupportCA.XmlFile">XPath XMLFile: {0}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>debug_msg</Value1>
						<Value2>true</Value2>
						<WriteLine Id="1" Level="Verbose" Param0="DataTypeSupportCA.XPath">XPath DT: {0}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>debug_msg</Value1>
						<Value2>true</Value2>
						<WriteLine Id="2" Level="Verbose" Param0="DataTypeSupportCA.XPathModule">XPath Replacement: {0}</WriteLine>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="SetDefaultValue">
				<SetVariable Target="DataTypeSupportCA.boolCaSupport">false</SetVariable>
			</TestStep>
			<TestStep Name="InitObjCnt">
				<SetVariable Target="DataTypeSupportCA.ObjCnt">1</SetVariable>
			</TestStep>
			<TestStep Name="GetDefaultAccess_Device">
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Mailbox</Value1>
						<Value2>false</Value2>
						<GotoStep>GetDefaultAccess_Module</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Mailbox.CoE</Value1>
						<Value2>false</Value2>
						<GotoStep>GetDefaultAccess_Module</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Mailbox.CoE.CompleteAccess</Value1>
						<Value2>false</Value2>
						<GotoStep>GetDefaultAccess_Module</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Mailbox.CoE.CompleteAccess</Value1>
						<Value2>true</Value2>
						<SetVariable Target="DataTypeSupportCA.boolCaSupport">true</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Mailbox.CoE.CompleteAccess</Value1>
						<Value2>true</Value2>
						<WriteLine Id="3" Level="Output">/EtherCATInfo/Descriptions/Devices/Device/Mailbox/CoE/@CompleteAccess: SDO complete access supported by default for all objects. Checking for Object exceptions...</WriteLine>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="GetDefaultAccess_Module">
				<GetXmlValue ReturnValue="DataTypeSupportCA.MailboxCoECA" Markup="true" FileName="DataTypeSupportCA.XmlFile">
					<XPath Param0="DataTypeSupportCA.XPathModule">{0}/Mailbox/CoE/@CompleteAccess</XPath>
				</GetXmlValue>
			</TestStep>
			<TestStep Name="debug_msg2">
				<Compare>
					<Equal>
						<Value1>debug_msg</Value1>
						<Value2>true</Value2>
						<WriteLine Id="4" Level="Verbose" Param0="DataTypeSupportCA.MailboxCoECA">Value Module/Mailbox/CoE/CA: {0}</WriteLine>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<Compare>
					<Equal>
						<Value1>DataTypeSupportCA.MailboxCoECA</Value1>
						<Value2>null</Value2>
						<GotoStep>GetObjectAccess</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DataTypeSupportCA.MailboxCoECA</Value1>
						<Value2>false</Value2>
						<GotoStep>GetObjectAccess</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DataTypeSupportCA.MailboxCoECA</Value1>
						<Value2>true</Value2>
						<SetVariable Target="DataTypeSupportCA.boolCaSupport">true</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DataTypeSupportCA.MailboxCoECA</Value1>
						<Value2>true</Value2>
						<WriteLine Id="5" Level="Output" Param0="DataTypeSupportCA.XPathModule">{0}/Mailbox/CoE/@CompleteAccess: SDO complete access supported by default for all objects. Checking for Object exceptions...</WriteLine>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="GetObjectAccess">
				<SetVariable Target="DataTypeSupportCA.xPathObject" Param0="DataTypeSupportCA.XPathModule">{0}/Profile/Dictionary/Objects/Object</SetVariable>
			</TestStep>
			<TestStep Name="ObjLoopStart">
				<GetXmlValue ReturnValue="DataTypeSupportCA.tmpStr" Markup="true" FileName="DataTypeSupportCA.XmlFile">
					<XPath Param0="DataTypeSupportCA.xPathObject" Param1="DataTypeSupportCA.ObjCnt">{0}[{1}]</XPath>
				</GetXmlValue>
				<Compare>
					<Equal>
						<Value1>DataTypeSupportCA.tmpStr</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>END</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DataTypeSupportCA.tmpStr</Value1>
						<Value2>null</Value2>
						<GotoStep>END</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CheckUsedDt">
				<GetXmlValue ReturnValue="DataTypeSupportCA.tmpStr" Markup="false" FileName="DataTypeSupportCA.XmlFile">
					<XPath Param0="DataTypeSupportCA.xPathObject" Param1="DataTypeSupportCA.ObjCnt">{0}[{1}]/Type</XPath>
				</GetXmlValue>
				<Compare>
					<Equal>
						<Value1>debug_msg</Value1>
						<Value2>true</Value2>
						<WriteLine Id="6" Level="Verbose" Param0="DataTypeSupportCA.tmpStr">Object/Type: {0}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>debug_msg</Value1>
						<Value2>true</Value2>
						<WriteLine Id="7" Level="Verbose" Param0="DataTypeSupportCA.strDtName">Searched DT: {0}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>DataTypeSupportCA.tmpStr</Value1>
						<Value2>DataTypeSupportCA.strDtName</Value2>
						<GotoStep>ObjLoopEnd</GotoStep>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="GetObjectException">
				<GetXmlValue ReturnValue="DataTypeSupportCA.tmpStr" Markup="false" FileName="DataTypeSupportCA.XmlFile">
					<XPath Param0="DataTypeSupportCA.xPathObject" Param1="DataTypeSupportCA.ObjCnt">{0}[{1}]/Flags/SdoAccess</XPath>
				</GetXmlValue>
				<Compare>
					<Equal>
						<Value1>DataTypeSupportCA.tmpStr</Value1>
						<Value2>"CompleteAccess"</Value2>
						<SetVariable Target="DataTypeSupportCA.boolCaSupport">true</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DataTypeSupportCA.tmpStr</Value1>
						<Value2>"CompleteAccess"</Value2>
						<GotoStep>END</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DataTypeSupportCA.tmpStr</Value1>
						<Value2>"SubIndexAccess"</Value2>
						<SetVariable Target="DataTypeSupportCA.boolCaSupport">false</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="ObjLoopEnd">
				<SetVariable Target="DataTypeSupportCA.ObjCnt">DataTypeSupportCA.ObjCnt + 1</SetVariable>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>ObjLoopStart</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="END">
				<WriteLine Id="8" Level="Verbose" Param0="DataTypeSupportCA.boolCaSupport" Param1="DataTypeSupportCA.strDtName">Complete access for data type {1} : {0}</WriteLine>
			</TestStep>
		</TestFunction>
		<TestFunction Name="DetailedStringCompare" FunctionId="1201">
			<?MAX_OUTPUT_ID 6?>
			<Parameter>
				<Name>DetailedStringCompare.String1</Name>
				<Type>String</Type>
			</Parameter>
			<Parameter>
				<Name>DetailedStringCompare.String2</Name>
				<Type>String</Type>
			</Parameter>
			<LocalVariables>
				<Name>DetailedStringCompare.String1Escaped</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>DetailedStringCompare.String2Escaped</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>DetailedStringCompare.StringPattern</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>DetailedStringCompare.BoolReturnValue</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<OutParameter>
				<Name>DetailedStringCompare.BoolIsMatch</Name>
				<Type>Bool</Type>
			</OutParameter>
			<TestStep Name="CheckValues">
				<Compare>
					<Equal>
						<Value1>DetailedStringCompare.String1</Value1>
						<Value2>null</Value2>
						<Return Id="0"></Return>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DetailedStringCompare.String2</Value1>
						<Value2>null</Value2>
						<Return Id="1"></Return>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DetailedStringCompare.String1</Value1>
						<Value2>String.Empty</Value2>
						<Return Id="2"></Return>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DetailedStringCompare.String2</Value1>
						<Value2>String.Empty</Value2>
						<Return Id="3"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="EscapeString1">
				<CallTestFunction Name="EscapeSpecificString">
					<Parameter>DetailedStringCompare.String1</Parameter>
					<OutParameter>DetailedStringCompare.String1Escaped</OutParameter>
				</CallTestFunction>
			</TestStep>
			<TestStep Name="EscapeString2">
				<CallTestFunction Name="EscapeSpecificString">
					<Parameter>DetailedStringCompare.String2</Parameter>
					<OutParameter>DetailedStringCompare.String2Escaped</OutParameter>
				</CallTestFunction>
			</TestStep>
			<TestStep Name="SetPattern">
				<SetVariable Target="DetailedStringCompare.StringPattern" Param0="DetailedStringCompare.String1Escaped">^\s*{0}\s*$</SetVariable>
			</TestStep>
			<TestStep Name="CheckValue">
				<RegexIsMatch ReturnValue="DetailedStringCompare.BoolReturnValue">
					<Pattern>DetailedStringCompare.StringPattern</Pattern>
					<InputString>DetailedStringCompare.String2</InputString>
				</RegexIsMatch>
			</TestStep>
			<TestStep>
				<Compare>
					<Equal>
						<Value1>DetailedStringCompare.BoolReturnValue</Value1>
						<Value2>true</Value2>
						<WriteLine Id="4" Level="Warning" Param0="DetailedStringCompare.String1" Param1="DetailedStringCompare.String2" Param2="EEPROM.CatGeneral.NameIdx-1">EEPROM String (Index {2}) Value: '{1}' contains one or more white spaces compared with ESI String '{0}'</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DetailedStringCompare.BoolReturnValue</Value1>
						<Value2>true</Value2>
						<SetVariable Target="DetailedStringCompare.BoolIsMatch">true</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DetailedStringCompare.BoolReturnValue</Value1>
						<Value2>true</Value2>
						<Return Id="5"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<SetVariable Target="DetailedStringCompare.StringPattern" Param0="DetailedStringCompare.String2Escaped">^\s*{0}\s*$</SetVariable>
			</TestStep>
			<TestStep>
				<RegexIsMatch ReturnValue="DetailedStringCompare.BoolReturnValue">
					<Pattern>DetailedStringCompare.StringPattern</Pattern>
					<InputString>DetailedStringCompare.String1</InputString>
				</RegexIsMatch>
			</TestStep>
			<TestStep>
				<Compare>
					<Equal>
						<Value1>DetailedStringCompare.BoolReturnValue</Value1>
						<Value2>true</Value2>
						<WriteLine Id="6" Level="Warning" Param0="DetailedStringCompare.String1" Param1="DetailedStringCompare.String2" Param2="EEPROM.CatGeneral.NameIdx-1">ESI String '{0}' contains one or more white spaces compared with EEPROM String (Index {2}) Value: '{1}'</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DetailedStringCompare.BoolReturnValue</Value1>
						<Value2>true</Value2>
						<SetVariable Target="DetailedStringCompare.BoolIsMatch">true</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction Name="DumpFmmuSyncManagerWarning" FunctionId="1301">
			<?MAX_OUTPUT_ID 1?>
			<!--Check List of SyncManagers and dump a warning if at least one is enabled (will be called if the number of FMMUs and SyncManager mismatch)-->
			<Parameter>
				<Name>DumpFmmuSyncManagerWarning.SmArray</Name>
				<Type>ArrayOfBytes</Type>
			</Parameter>
			<Parameter>
				<Name>DumpFmmuSyncManagerWarning.Text</Name>
				<Type>String</Type>
			</Parameter>
			<LocalVariables>
				<Name>DumpFmmuSyncManagerWarning.Counter</Name>
				<Type>UInt32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>DumpFmmuSyncManagerWarning.Len</Name>
				<Type>UInt32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>DumpFmmuSyncManagerWarning.SmIndex</Name>
				<Type>Byte</Type>
			</LocalVariables>
			<TestStep Name="INIT_COUNTER">
				<SetVariable Target="DumpFmmuSyncManagerWarning.Counter">0</SetVariable>
			</TestStep>
			<TestStep Name="GET_ARRAY_LEN">
				<SizeOf UInt32Var="DumpFmmuSyncManagerWarning.Len">DumpFmmuSyncManagerWarning.SmArray</SizeOf>
			</TestStep>
			<TestStep Name="LOOP_START">
				<SetVariable Target="DumpFmmuSyncManagerWarning.SmIndex">DumpFmmuSyncManagerWarning.SmArray[DumpFmmuSyncManagerWarning.Counter]</SetVariable>
			</TestStep>
			<TestStep Name="CHECK_ENABLE">
				<Compare>
					<Equal>
						<Value1>DeviceDescr.SM[DumpFmmuSyncManagerWarning.SmIndex].Enable</Value1>
						<Value2>true</Value2>
						<RaiseWarning Id="0" Param0="DumpFmmuSyncManagerWarning.Text">{0}</RaiseWarning>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.SM[DumpFmmuSyncManagerWarning.SmIndex].Enable</Value1>
						<Value2>true</Value2>
						<Return Id="1"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="LOOP_END">
				<SetVariable Target="DumpFmmuSyncManagerWarning.Counter">DumpFmmuSyncManagerWarning.Counter + 1</SetVariable>
				<Compare>
					<Lower>
						<Value1>DumpFmmuSyncManagerWarning.Counter</Value1>
						<Value2>DumpFmmuSyncManagerWarning.Len</Value2>
						<GotoStep>LOOP_START</GotoStep>
					</Lower>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction Name="EscapeSpecificString" FunctionId="1401">
			<?MAX_OUTPUT_ID 2?>
			<Parameter>
				<Name>EscapeSpecificString.StringToEscape</Name>
				<Type>String</Type>
				<Comment>String to escape</Comment>
			</Parameter>
			<LocalVariables>
				<Name>EscapeSpecificString.BoolResult</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<OutParameter>
				<Name>EscapeSpecificString.EscapedString</Name>
				<Type>String</Type>
			</OutParameter>
			<TestStep>
				<Compare>
					<Equal>
						<Value1>EscapeSpecificString.StringToEscape</Value1>
						<Value2>null</Value2>
						<Return Id="0"></Return>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>EscapeSpecificString.StringToEscape</Value1>
						<Value2>String.Empty</Value2>
						<Return Id="1"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<RegexIsMatch ReturnValue="EscapeSpecificString.BoolResult">
					<Pattern>\.|\^|\$|\*|\+|\?|\(|\)|\[|\{|\\|\||\^|\-|\]</Pattern>
					<InputString>EscapeSpecificString.StringToEscape</InputString>
				</RegexIsMatch>
				<Compare>
					<Equal>
						<Value1>EscapeSpecificString.BoolResult</Value1>
						<Value2>false</Value2>
						<SetVariable Target="EscapeSpecificString.EscapedString" Param0="EscapeSpecificString.StringToEscape">{0}</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>EscapeSpecificString.BoolResult</Value1>
						<Value2>false</Value2>
						<Return Id="2"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<RegexReplace OutputString="EscapeSpecificString.EscapedString">
					<Pattern>\\</Pattern>
					<InputString>EscapeSpecificString.StringToEscape</InputString>
					<ReplacementString>\\</ReplacementString>
				</RegexReplace>
			</TestStep>
			<TestStep>
				<RegexReplace OutputString="EscapeSpecificString.EscapedString">
					<Pattern>\.</Pattern>
					<InputString>EscapeSpecificString.StringToEscape</InputString>
					<ReplacementString>\.</ReplacementString>
				</RegexReplace>
			</TestStep>
			<TestStep>
				<RegexReplace OutputString="EscapeSpecificString.EscapedString">
					<Pattern>\^</Pattern>
					<InputString>EscapeSpecificString.EscapedString</InputString>
					<ReplacementString>\^</ReplacementString>
				</RegexReplace>
			</TestStep>
			<TestStep>
				<RegexReplace OutputString="EscapeSpecificString.EscapedString">
					<Pattern>\$</Pattern>
					<InputString>EscapeSpecificString.EscapedString</InputString>
					<ReplacementString>\$</ReplacementString>
				</RegexReplace>
			</TestStep>
			<TestStep>
				<RegexReplace OutputString="EscapeSpecificString.EscapedString">
					<Pattern>\*</Pattern>
					<InputString>EscapeSpecificString.EscapedString</InputString>
					<ReplacementString>\*</ReplacementString>
				</RegexReplace>
			</TestStep>
			<TestStep>
				<RegexReplace OutputString="EscapeSpecificString.EscapedString">
					<Pattern>\+</Pattern>
					<InputString>EscapeSpecificString.EscapedString</InputString>
					<ReplacementString>\+</ReplacementString>
				</RegexReplace>
			</TestStep>
			<TestStep>
				<RegexReplace OutputString="EscapeSpecificString.EscapedString">
					<Pattern>\?</Pattern>
					<InputString>EscapeSpecificString.EscapedString</InputString>
					<ReplacementString>\?</ReplacementString>
				</RegexReplace>
			</TestStep>
			<TestStep>
				<RegexReplace OutputString="EscapeSpecificString.EscapedString">
					<Pattern>\(</Pattern>
					<InputString>EscapeSpecificString.EscapedString</InputString>
					<ReplacementString>\(</ReplacementString>
				</RegexReplace>
			</TestStep>
			<TestStep>
				<RegexReplace OutputString="EscapeSpecificString.EscapedString">
					<Pattern>\)</Pattern>
					<InputString>EscapeSpecificString.EscapedString</InputString>
					<ReplacementString>\)</ReplacementString>
				</RegexReplace>
			</TestStep>
			<TestStep>
				<RegexReplace OutputString="EscapeSpecificString.EscapedString">
					<Pattern>\[</Pattern>
					<InputString>EscapeSpecificString.EscapedString</InputString>
					<ReplacementString>\[</ReplacementString>
				</RegexReplace>
			</TestStep>
			<TestStep>
				<RegexReplace OutputString="EscapeSpecificString.EscapedString">
					<Pattern>\{</Pattern>
					<InputString>EscapeSpecificString.EscapedString</InputString>
					<ReplacementString>\{</ReplacementString>
				</RegexReplace>
			</TestStep>
			<TestStep>
				<RegexReplace OutputString="EscapeSpecificString.EscapedString">
					<Pattern>\|</Pattern>
					<InputString>EscapeSpecificString.EscapedString</InputString>
					<ReplacementString>\|</ReplacementString>
				</RegexReplace>
			</TestStep>
			<TestStep>
				<RegexReplace OutputString="EscapeSpecificString.EscapedString">
					<Pattern>\^</Pattern>
					<InputString>EscapeSpecificString.EscapedString</InputString>
					<ReplacementString>\^</ReplacementString>
				</RegexReplace>
			</TestStep>
			<TestStep>
				<RegexReplace OutputString="EscapeSpecificString.EscapedString">
					<Pattern>\-</Pattern>
					<InputString>EscapeSpecificString.EscapedString</InputString>
					<ReplacementString>\-</ReplacementString>
				</RegexReplace>
			</TestStep>
		</TestFunction>
		<TestFunction Name="ExternalModuleIdentList" FunctionId="20102">
			<?MAX_OUTPUT_ID 10?>
			<!--Initiate global array of external ModuleIdents-->
			<Description>
				<Action>Initiate global array of external ModuleIdents</Action>
				<PostCondition>Global array AllExternalModuleIdents.Uint32Array initiated</PostCondition>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<LocalVariables>
				<Name>ExternalModuleIdentList.LocExt_InitToggle</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>ExternalModuleIdentList.result</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>ExternalModuleIdentList.AtLeastOneModuleFound</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>ExternalModuleIdentList.int32LoopCounter</Name>
				<Type>Int32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>ExternalModuleIdentList.ext_XPathDtTmp</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>ExternalModuleIdentList.strXmlValue</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>ExternalModuleIdentList.uint32Length</Name>
				<Type>UInt32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>ExternalModuleIdentList.Uint32ModuleIdent</Name>
				<Type>UInt32</Type>
			</LocalVariables>
			<TestStep Name="Toggle_LOC_EXT">
				<!--Flag for InitGlobalVariables for default XPaths of local or external file-->
				<SetVariable Target="ExternalModuleIdentList.LocExt_InitToggle">true</SetVariable>
				<WriteLine Id="0" Level="Output">Checking for external file with modules.</WriteLine>
			</TestStep>
			<TestStep Name="SkipSoE">
				<!--Skip Test if SoE Device-->
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Mailbox.SoE</Value1>
						<Value2>true</Value2>
						<SkipCase Id="1">Test skipped for SoE Devices.</SkipCase>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="InitGlobalVariables">
				<!--Init global XPaths-->
				<CallTestFunction Name="InitGlobalVariablesForModuleODTest">
					<Parameter>ExternalModuleIdentList.LocExt_InitToggle</Parameter>
				</CallTestFunction>
			</TestStep>
			<TestStep Name="INIT_RESULT">
				<!--"ExternalModuleIdentList.result" = true-->
				<SetVariable Target="ExternalModuleIdentList.result">true</SetVariable>
			</TestStep>
			<TestStep Name="INIT_LOOP_COUNTER">
				<!--"ExternalModuleIdentList.int32LoopCounter" = 1, not starting with list index [0]-->
				<SetVariable Target="ExternalModuleIdentList.int32LoopCounter">1</SetVariable>
			</TestStep>
			<TestStep Name="InitModuleArray">
				<!--Array of found ModuleIdents-->
				<InitArray TargetArray="AllExternalModuleIdents.Uint32Array"></InitArray>
			</TestStep>
			<TestStep Name="DataTypeLoopStart">
				<!--__Loop START for EXTERNAL modules__-->
				<Compare>
					<Equal>
						<Value1>ext_XPathModuleIdent</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>DumpTestResult</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CREATE_XPATH_FOR_DT_ELEMENT">
				<SetVariable Target="ExternalModuleIdentList.ext_XPathDtTmp" Param0="ext_XPathModuleIdent" Param1="ExternalModuleIdentList.int32LoopCounter">{0}[{1}]/Type/@ModuleIdent</SetVariable>
			</TestStep>
			<TestStep Name="CHECK_IF_LAST_ELEMENT">
				<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="ExternalModuleIdentList.strXmlValue">
					<XPath Param0="ExternalModuleIdentList.ext_XPathDtTmp">{0}</XPath>
				</GetXmlValue>
				<Compare>
					<Equal>
						<Value1>ExternalModuleIdentList.strXmlValue</Value1>
						<Value2>null</Value2>
						<GotoStep>DumpTestResult</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>ExternalModuleIdentList.strXmlValue</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>DumpTestResult</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<SetVariable Target="ExternalModuleIdentList.AtLeastOneModuleFound">true</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="2" Level="Verbose" Param0="ext_ModuleXmlFile" Param1="ExternalModuleIdentList.ext_XPathDtTmp">{0}{1}</WriteLine>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="ExternalModuleIdentList.Uint32ModuleIdent">
					<XPath Param0="ExternalModuleIdentList.ext_XPathDtTmp">{0}</XPath>
				</GetXmlValue>
				<Compare>
					<Equal>
						<Value1>ExternalModuleIdentList.Uint32ModuleIdent</Value1>
						<Value2>0</Value2>
						<WriteLine Id="3" Level="Output" Param0="ExternalModuleIdentList.int32LoopCounter" Param1="ExternalModuleIdentList.strXmlValue">Module[{0}]: Ident: {1} - "Empty"</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>ExternalModuleIdentList.Uint32ModuleIdent</Value1>
						<Value2>0</Value2>
						<GotoStep>HandleEmptySlots</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="4" Level="Output" Param0="ExternalModuleIdentList.int32LoopCounter" Param1="ExternalModuleIdentList.strXmlValue">Module[{0}]: Ident: {1}</WriteLine>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="HandleEmptySlots">
				<!--SKIP If module Ident equals 0x0-->
				<Compare>
					<Equal>
						<Value1>ExternalModuleIdentList.Uint32ModuleIdent</Value1>
						<Value2>0</Value2>
						<GotoStep>DataTypeLoopEnd</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="AddModuleIdentToArray">
				<AddArrayItem TargetArray="AllExternalModuleIdents.Uint32Array">ExternalModuleIdentList.Uint32ModuleIdent</AddArrayItem>
			</TestStep>
			<TestStep Name="DataTypeLoopEnd">
				<!--__END of "DataTypeLoopStart", increment loop counter__-->
				<SetVariable Target="ExternalModuleIdentList.int32LoopCounter">ExternalModuleIdentList.int32LoopCounter + 1</SetVariable>
				<!--Goto Loop start-->
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>DataTypeLoopStart</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="DumpTestResult">
				<!--Dump test case ExternalModuleIdentList.result-->
				<SizeOf UInt32Var="ExternalModuleIdentList.uint32Length">AllExternalModuleIdents.Uint32Array</SizeOf>
			</TestStep>
			<TestStep>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="5" Level="Output" Param0="AllExternalModuleIdents.Uint32Array">Array of found external ModuleIdents: {0}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="6" Level="Output" Param0="ExternalModuleIdentList.uint32Length">Number of real modules: {0}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="7" Level="Output" Param0="((ExternalModuleIdentList.int32LoopCounter - 1) - ExternalModuleIdentList.uint32Length)">Number of "Empty" modules: {0}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>ExternalModuleIdentList.AtLeastOneModuleFound</Value1>
						<Value2>false</Value2>
						<SkipCase Id="8">No modules found.</SkipCase>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>ExternalModuleIdentList.result</Value1>
						<Value2>true</Value2>
						<ReturnSuccess Id="9">Test successful.</ReturnSuccess>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>ExternalModuleIdentList.result</Value1>
						<Value2>false</Value2>
						<RaiseError Id="10">Test failed.</RaiseError>
					</Equal>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction Name="FMMU.CreateArray" FunctionId="1501">
			<!--Get all FMMUs of a specific Type-->
			<Parameter>
				<Name>FMMU.CreateArray.Filter</Name>
				<Type>String</Type>
				<Comment>Filter string for the FMMU</Comment>
			</Parameter>
			<LocalVariables>
				<Name>FMMU.CreateArray.LoopCounter</Name>
				<Type>UInt16</Type>
			</LocalVariables>
			<OutParameter>
				<Name>FMMU.CreateArray.OutArr</Name>
				<Type>ArrayOfUInt16</Type>
			</OutParameter>
			<TestStep Name="INIT_FMMU_ARR">
				<InitArray TargetArray="FMMU.CreateArray.OutArr" Length="0"></InitArray>
			</TestStep>
			<TestStep Name="INIT_LOOP_COUNTER">
				<SetVariable Target="FMMU.CreateArray.LoopCounter">0</SetVariable>
			</TestStep>
			<TestStep Name="LOOP_START">
				<Compare>
					<NotEqual>
						<Value1>DeviceDescr.Fmmu[FMMU.CreateArray.LoopCounter]</Value1>
						<Value2>FMMU.CreateArray.Filter</Value2>
						<GotoStep>LOOP_END</GotoStep>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="ADD_INDEX_TOARRAY">
				<AddArrayItem TargetArray="FMMU.CreateArray.OutArr">FMMU.CreateArray.LoopCounter</AddArrayItem>
			</TestStep>
			<TestStep Name="LOOP_END">
				<SetVariable Target="FMMU.CreateArray.LoopCounter">FMMU.CreateArray.LoopCounter + 1</SetVariable>
				<Compare>
					<Lower>
						<Value1>FMMU.CreateArray.LoopCounter</Value1>
						<Value2>DeviceDescr.Fmmu.Count</Value2>
						<GotoStep>LOOP_START</GotoStep>
					</Lower>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction Name="GetAllInputSm" FunctionId="1601">
			<?MAX_OUTPUT_ID 1?>
			<!--Finds all input SyncManagers (ESI based) (possible are 16 entities).
Used variables: smDirection 
return values: 
- noInputSm
- allInputSm
- inputSmCount
- firstInputSm-->
			<TestStep>
				<!--Clear allInputSm array-->
				<InitArray Length="0" TargetArray="allInputSm"></InitArray>
			</TestStep>
			<TestStep>
				<!--Clear inputSmCount-->
				<SetVariable Target="inputSmCount">0</SetVariable>
			</TestStep>
			<TestStep>
				<!--Init smType = Inputs-->
				<SetVariable Target="smType">Inputs</SetVariable>
			</TestStep>
			<TestStep>
				<!--Init index8-->
				<SetVariable Target="index8">0</SetVariable>
			</TestStep>
			<TestStep>
				<!--Init noInputSm = TRUE-->
				<SetVariable Target="noInputSm">True</SetVariable>
			</TestStep>
			<TestStep>
				<!--Init inputSmCount-->
				<SetVariable Target="inputSmCount">0</SetVariable>
			</TestStep>
			<TestStep>
				<!--Any ESI Sm available?-->
				<Compare>
					<Equal>
						<Value1>DeviceDescr.SM.Count</Value1>
						<Value2>0</Value2>
						<RaiseError Id="0">INFO | No Sm Element in ESI defined!</RaiseError>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="INPUT">
				<!--ESI Sm:Text available?-->
				<Compare>
					<Equal>
						<Value1>DeviceDescr.SM[index8]</Value1>
						<Value2>null</Value2>
						<RaiseError Id="1" Param0="index8">INFO: No Sm:Text element defined in ESI for SyncManager{0}</RaiseError>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--SM = Input Sm ?-->
				<Compare>
					<NotEqual>
						<Value1>DeviceDescr.SM[index8]</Value1>
						<Value2>Inputs</Value2>
						<GotoStep>NEXT</GotoStep>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep>
				<!--update allInputSm-->
				<AddArrayItem TargetArray="allInputSm">index8</AddArrayItem>
			</TestStep>
			<TestStep>
				<!--Set firstInputSm-->
				<GetArrayItem Index="0" SourceArray="allInputSm" Target="firstInputSm"></GetArrayItem>
			</TestStep>
			<TestStep>
				<!--update inputSmCount-->
				<SetVariable Target="inputSmCount">inputSmCount+1</SetVariable>
			</TestStep>
			<TestStep Name="NEXT">
				<!--Done? otherwise check next Sm-->
				<SetVariable Target="index8">index8+1</SetVariable>
				<Compare>
					<Lower>
						<Value1>index8</Value1>
						<Value2>DeviceDescr.SM.Count</Value2>
						<GotoStep>INPUT</GotoStep>
					</Lower>
				</Compare>
			</TestStep>
			<TestStep Name="END">
				<!--Set noInputSm-->
				<Compare>
					<Equal>
						<Value1>inputSmCount</Value1>
						<Value2>0</Value2>
						<GotoStep>LOGGEROUT</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--noInputSm = FALSE-->
				<SetVariable Target="noInputSm">False</SetVariable>
			</TestStep>
			<TestStep Name="LOGGEROUT">
				<!--Write Result to Logger-->
			</TestStep>
		</TestFunction>
		<TestFunction Name="GetAllOutputSm" FunctionId="1602">
			<?MAX_OUTPUT_ID 1?>
			<!--Finds all output SyncManagers - ESI based (possible are 16 entities).  Used variables:
- smDirection
return values
- noOutputSm
- allOutputSm
- outputSmCount
- firstOutputSm-->
			<TestStep>
				<!--Clear allOutputSm array-->
				<InitArray Length="0" TargetArray="allOutputSm"></InitArray>
			</TestStep>
			<TestStep>
				<!--Clear outputSmCount-->
				<SetVariable Target="outputSmCount">0</SetVariable>
			</TestStep>
			<TestStep>
				<!--Init smType = Outputs-->
				<SetVariable Target="smType">Outputs</SetVariable>
			</TestStep>
			<TestStep>
				<!--Init index8-->
				<SetVariable Target="index8">0</SetVariable>
			</TestStep>
			<TestStep>
				<!--Init noOutputSm = TRUE-->
				<SetVariable Target="noOutputSm">True</SetVariable>
			</TestStep>
			<TestStep>
				<!--Init outputSmCount-->
				<SetVariable Target="outputSmCount">0</SetVariable>
			</TestStep>
			<TestStep>
				<!--Any ESI Sm available?-->
				<Compare>
					<Equal>
						<Value1>DeviceDescr.SM.Count</Value1>
						<Value2>0</Value2>
						<RaiseError Id="0">INFO | No Sm Element in ESI defined!</RaiseError>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="OUTPUT">
				<!--ESI Sm:Text Available?-->
				<Compare>
					<Equal>
						<Value1>DeviceDescr.SM[index8]</Value1>
						<Value2>null</Value2>
						<RaiseError Id="1" Param0="index8">INFO: No Sm:Text defined in ESI for SyncManager{0}</RaiseError>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--SM = output Sm ?-->
				<Compare>
					<NotEqual>
						<Value1>DeviceDescr.SM[index8]</Value1>
						<Value2>Outputs</Value2>
						<GotoStep>NEXT</GotoStep>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep>
				<!--update allOutputSm-->
				<AddArrayItem TargetArray="allOutputSm">index8</AddArrayItem>
			</TestStep>
			<TestStep>
				<!--Set firstOutputSm-->
				<GetArrayItem Index="0" SourceArray="allOutputSm" Target="firstOutputSm"></GetArrayItem>
			</TestStep>
			<TestStep>
				<!--update outputSmCount-->
				<SetVariable Target="outputSmCount">outputSmCount+1</SetVariable>
			</TestStep>
			<TestStep Name="NEXT">
				<!--Done? otherwise check next Sm-->
				<SetVariable Target="index8">index8+1</SetVariable>
				<Compare>
					<Lower>
						<Value1>index8</Value1>
						<Value2>DeviceDescr.SM.Count</Value2>
						<GotoStep>OUTPUT</GotoStep>
					</Lower>
				</Compare>
			</TestStep>
			<TestStep Name="END">
				<!--Set noOutputSm-->
				<Compare>
					<Equal>
						<Value1>outputSmCount</Value1>
						<Value2>0</Value2>
						<GotoStep>LOGGEROUT</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--noOutputSm = FALSE-->
				<SetVariable Target="noOutputSm">False</SetVariable>
			</TestStep>
			<TestStep Name="LOGGEROUT">
				<!--Write Result to Logger-->
			</TestStep>
		</TestFunction>
		<TestFunction Name="GetAllPdSm" FunctionId="1603">
			<!--Finds all Process Data SyncManagers (possible are 16 entities). 

Return values:
- noPdSm
- allPdSm
- pdSmCount-->
			<TestStep>
				<!--Clear allInputSm array-->
				<InitArray Length="0" TargetArray="allPdSm"></InitArray>
			</TestStep>
			<TestStep>
				<!--Clear pdSmCount-->
				<SetVariable Target="pdSmCount">0</SetVariable>
			</TestStep>
			<TestStep>
				<CallFunction>GetAllOutputSm</CallFunction>
			</TestStep>
			<TestStep>
				<AddArrayItem TargetArray="allPdSm">allOutputSm</AddArrayItem>
			</TestStep>
			<TestStep>
				<CallFunction>GetAllInputSm</CallFunction>
			</TestStep>
			<TestStep>
				<AddArrayItem TargetArray="allPdSm">allInputSm</AddArrayItem>
			</TestStep>
			<TestStep>
				<!--Set noPdSm-->
				<SetVariable Target="noPdSm">noInputSm AND noOutputSm</SetVariable>
			</TestStep>
			<TestStep>
				<!--Set pdSmCount-->
				<SetVariable Target="pdSmCount">inputSmCount+outputSmCount</SetVariable>
			</TestStep>
		</TestFunction>
		<TestFunction Name="GetEEPROMData" FunctionId="1701">
			<?MAX_OUTPUT_ID 2?>
			<Parameter>
				<Name>WordAddress</Name>
				<Type>UInt16</Type>
				<Comment>Word address to read</Comment>
			</Parameter>
			<Parameter>
				<Name>ByteLength</Name>
				<Type>Int32</Type>
				<Comment>Bytes to read</Comment>
			</Parameter>
			<LocalVariables>
				<Name>assignEeprom</Name>
				<Type>Byte</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>eepromData</Name>
				<Type>UInt16</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>bytesRead</Name>
				<Type>Int32</Type>
			</LocalVariables>
			<OutParameter>
				<Name>dataBytes</Name>
				<Type>ArrayOfBytes</Type>
			</OutParameter>
			<TestStep>
				<SetVariable Target="assignEeprom">00</SetVariable>
			</TestStep>
			<TestStep Name="AssignEEPROMToECAT">
				<WriteEscData Source="assignEeprom">
					<Address>#x500</Address>
				</WriteEscData>
			</TestStep>
			<TestStep Name="Read">
				<ReadEEProm Target="eepromData">
					<Address>WordAddress</Address>
					<Length>2</Length>
				</ReadEEProm>
				<RaiseErrorOnFailure Id="0">Failed to read EEPROM!</RaiseErrorOnFailure>
			</TestStep>
			<TestStep>
				<AddArrayItem TargetArray="dataBytes">eepromData</AddArrayItem>
				<RaiseErrorOnFailure Id="1">Failed to add array item</RaiseErrorOnFailure>
			</TestStep>
			<TestStep>
				<SetVariable Target="WordAddress">WordAddress+1</SetVariable>
			</TestStep>
			<TestStep>
				<SetVariable Target="bytesRead">bytesRead+2</SetVariable>
				<Compare>
					<NotEqual>
						<Value1>bytesRead</Value1>
						<Value2>ByteLength</Value2>
						<GotoStep>Read</GotoStep>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep>
				<WriteLine Id="2" Level="Verbose" Param0="dataBytes">EEPROM Data : {0}</WriteLine>
			</TestStep>
			<TestStep>
				<SetVariable Target="assignEeprom">1</SetVariable>
			</TestStep>
			<TestStep Name="AssignEEPROMToPDI">
				<WriteEscData Source="assignEeprom">
					<Address>#x500</Address>
				</WriteEscData>
			</TestStep>
		</TestFunction>
		<TestFunction Name="GetFixedSmLength" FunctionId="1702">
			<?MAX_OUTPUT_ID 3?>
			<!--Get the fixed length of a SyncManager. -->
			<Description>
				<Purpose>Get the fixed length of a SyncManager</Purpose>
				<PreCondition>Referenced SyncManager Index shall be available</PreCondition>
				<Action>1. Process data SyncMananger 
	Iterate over all assigned PDOs
2. for non Process data SyncManager the default size (if defined is returned)</Action>
				<PostCondition>1. If at least one PDO is not fixed or not mandatory -1 is returned
2. IF no default size is defined -1 is returned</PostCondition>
				<References>
					<Reference Specification="ETG.2000"></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>GetFixedSmLength.SmNumber</Name>
				<Type>Int32</Type>
				<!--Zero based index of the SyncManager-->
			</Parameter>
			<LocalVariables>
				<Name>GetFixedSmLength.SmName</Name>
				<Type>String</Type>
			</LocalVariables>
			<OutParameter>
				<Name>GetFixedSmLength.Length</Name>
				<Type>Int32</Type>
			</OutParameter>
			<TestStep Name="InitReturnValue">
				<SetVariable Target="GetFixedSmLength.Length">-1</SetVariable>
			</TestStep>
			<TestStep Name="RaiseErrorIfInvalidSmIndex">
				<Compare>
					<Greater>
						<Value1>GetFixedSmLength.SmNumber</Value1>
						<Value2>DeviceDescr.SM.Count</Value2>
						<RaiseError Id="0" Param0="GetFixedSmLength.SmNumber">Function "GetFixedSmLength" : Paramter "GetFixedSmLength.SmNumber" ({0}) shall not be greater than available SyncManager channel.</RaiseError>
					</Greater>
				</Compare>
			</TestStep>
			<TestStep Name="GetSyncManagerName">
				<SetVariable Target="GetFixedSmLength.SmName">DeviceDescr.SM[GetFixedSmLength.SmNumber]</SetVariable>
				<Compare>
					<Equal>
						<Value1>GetFixedSmLength.SmName</Value1>
						<Value2>"Outputs"</Value2>
						<GotoStep>GetPdoLength</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>GetFixedSmLength.SmName</Value1>
						<Value2>"Inputs"</Value2>
						<GotoStep>GetPdoLength</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="HandleNonProcessDataSyncManager">
				<Description Id="1" Level="Verbose" Param0="DeviceDescr.SM[GetFixedSmLength.SmNumber].DefaultSize" Param1="GetFixedSmLength.SmNumber">SM[{1}].Defaultsize : '{0}'</Description>
				<Compare>
					<NotEqual>
						<Value1>DeviceDescr.SM[GetFixedSmLength.SmNumber].DefaultSize</Value1>
						<Value2>null</Value2>
						<SetVariable Target="GetFixedSmLength.Length">DeviceDescr.SM[GetFixedSmLength.SmNumber].DefaultSize</SetVariable>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>DumpLength</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="GetPdoLength">
				<Description Id="2" Level="Verbose" Param0="GetFixedSmLength.SmNumber">Calc SM[{0}] size.</Description>
				<GetMaxPdoLength SyncMan="GetFixedSmLength.SmNumber" Int32Var="GetFixedSmLength.Length" Source="CurrentConfig"></GetMaxPdoLength>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>DumpLength</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="DumpLength">
				<WriteLine Id="3" Param0="GetFixedSmLength.SmNumber" Param1="GetFixedSmLength.Length" Level="Verbose">Calculated length of SM[{0}] : {1}</WriteLine>
			</TestStep>
		</TestFunction>
		<TestFunction Name="GetFmmuBySu" FunctionId="1703">
			<?MAX_OUTPUT_ID 2?>
			<!--Get Fmmu index (zero based) of the first matching Fmmu (Su and direction match)-->
			<Parameter>
				<Name>GetFmmuBySu.Su</Name>
				<Type>UInt16</Type>
				<!--Su-->
			</Parameter>
			<Parameter>
				<Name>GetFmmuBySu.Name</Name>
				<Type>String</Type>
				<!--Direction of the Fmmu-->
			</Parameter>
			<LocalVariables>
				<Name>GetFmmuBySu.Cnt</Name>
				<Type>UInt16</Type>
				<!--temp counter variable-->
			</LocalVariables>
			<OutParameter>
				<Name>GetFmmuBySu.i32Index</Name>
				<Type>Int32</Type>
			</OutParameter>
			<TestStep>
				<!--Check if Fmmu elements are defined -->
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Fmmu.Count</Value1>
						<Value2>0</Value2>
						<Return Id="0"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<SetVariable Target="GetFmmuBySu.i32Index">-1</SetVariable>
			</TestStep>
			<TestStep>
				<SetVariable Target="GetFmmuBySu.Cnt">0</SetVariable>
			</TestStep>
			<TestStep Name="LOOPSTART">
				<!--Check if Loop finished-->
				<Compare>
					<GreaterOrEqual>
						<Value1>GetFmmuBySu.Cnt</Value1>
						<Value2>DeviceDescr.Fmmu.Count</Value2>
						<Return Id="1"></Return>
					</GreaterOrEqual>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Check if Fmmu@Su defined-->
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Fmmu[GetFmmuBySu.Cnt].Su</Value1>
						<Value2>null</Value2>
						<GotoStep>LOOPEND</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>DeviceDescr.Fmmu[GetFmmuBySu.Cnt].Su</Value1>
						<Value2>GetFmmuBySu.Su</Value2>
						<GotoStep>LOOPEND</GotoStep>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>DeviceDescr.Fmmu[GetFmmuBySu.Cnt]</Value1>
						<Value2>GetFmmuBySu.Name</Value2>
						<GotoStep>LOOPEND</GotoStep>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<SetVariable Target="GetFmmuBySu.i32Index">GetFmmuBySu.Cnt</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<Return Id="2"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="LOOPEND">
				<!--Increment counter-->
				<SetVariable Target="GetFmmuBySu.Cnt">GetFmmuBySu.Cnt +1</SetVariable>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>LOOPSTART</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction Name="GetNonVirtualSmCount" FunctionId="1704">
			<?MAX_OUTPUT_ID 0?>
			<LocalVariables>
				<Name>smIndex</Name>
				<Type>Int32</Type>
			</LocalVariables>
			<OutParameter>
				<Name>GetNonVirtualSmCount.SmCount</Name>
				<Type>Int32</Type>
			</OutParameter>
			<TestStep Name="CheckEsiSmCount">
				<Compare>
					<Equal>
						<Value1>DeviceDescr.SM.Count</Value1>
						<Value2>0</Value2>
						<Return Id="0"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="checkVirtual">
				<Compare>
					<Equal>
						<Value1>DeviceDescr.SM[smIndex].Virtual</Value1>
						<Value2>true</Value2>
						<GotoStep>increment</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="incrementSmCount">
				<SetVariable Target="GetNonVirtualSmCount.SmCount">GetNonVirtualSmCount.SmCount+1</SetVariable>
			</TestStep>
			<TestStep Name="increment">
				<SetVariable Target="smIndex">smIndex+1</SetVariable>
			</TestStep>
			<TestStep Name="LoopEnd">
				<Compare>
					<Lower>
						<Value1>smIndex</Value1>
						<Value2>DeviceDescr.SM.Count</Value2>
						<GotoStep>checkVirtual</GotoStep>
					</Lower>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction Name="GetRxPdoEntryBitSize" FunctionId="1705">
			<?MAX_OUTPUT_ID 1?>
			<!--Get the bit size of a specific RxPDO-->
			<Parameter>
				<Name>GetRxPdoEntryBitSize.Index</Name>
				<Type>Int32</Type>
				<!--Zero based index of the RxPDO-->
			</Parameter>
			<LocalVariables>
				<Name>GetRxPdoEntryBitSize.EntryCounter</Name>
				<Type>UInt32</Type>
			</LocalVariables>
			<OutParameter>
				<Name>GetRxPdoEntryBitSize.Length</Name>
				<Type>Int32</Type>
			</OutParameter>
			<TestStep Name="InitReturnValue">
				<SetVariable Target="GetRxPdoEntryBitSize.Length">0</SetVariable>
			</TestStep>
			<TestStep Name="InitEntryCounter">
				<SetVariable Target="GetRxPdoEntryBitSize.EntryCounter">0</SetVariable>
			</TestStep>
			<TestStep Name="RaiseErrorIfInvalidRxPDOIndex">
				<Compare>
					<Greater>
						<Value1>GetRxPdoEntryBitSize.Index</Value1>
						<Value2>DeviceDescr.RxPdo.Count</Value2>
						<RaiseError Id="0" Param0="GetRxPdoEntryBitSize.Index">Function "GetRxPdoEntryBitSize" : Paramter "GetRxPdoEntryBitSize.Index" ({0}) shall not be greater than available RxPDOs.</RaiseError>
					</Greater>
				</Compare>
			</TestStep>
			<TestStep Name="LoopStart">
				<Compare>
					<GreaterOrEqual>
						<Value1>GetRxPdoEntryBitSize.EntryCounter</Value1>
						<Value2>DeviceDescr.RxPdo[GetRxPdoEntryBitSize.Index].Entry.Count</Value2>
						<GotoStep>END</GotoStep>
					</GreaterOrEqual>
				</Compare>
			</TestStep>
			<TestStep>
				<SetVariable Target="GetRxPdoEntryBitSize.Length">GetRxPdoEntryBitSize.Length + DeviceDescr.RxPdo[GetRxPdoEntryBitSize.Index].Entry[GetRxPdoEntryBitSize.EntryCounter].BitLen</SetVariable>
			</TestStep>
			<TestStep>
				<SetVariable Target="GetRxPdoEntryBitSize.EntryCounter">GetRxPdoEntryBitSize.EntryCounter + 1</SetVariable>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>LoopStart</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="END">
				<Description Id="1" Param0="GetRxPdoEntryBitSize.Index" Param1="GetRxPdoEntryBitSize.Length" Level="Verbose">Calculated Bit size of RxPdo[{0}] : {1}</Description>
			</TestStep>
		</TestFunction>
		<TestFunction Name="GetSmLength" FunctionId="1706">
			<?MAX_OUTPUT_ID 2?>
			<TestStep>
				<Compare>
					<NotEqual>
						<Value1>DeviceDescr.Mailbox</Value1>
						<Value2>true</Value2>
						<GotoStep>FromXml</GotoStep>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep>
				<Compare>
					<NotEqual>
						<Value1>DeviceDescr.Mailbox.CoE</Value1>
						<Value2>true</Value2>
						<GotoStep>FromXml</GotoStep>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Mailbox.CoE.PdoUpload</Value1>
						<Value2>true</Value2>
						<GotoStep>FromOD</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="FromXml">
				<GetMaxPdoLength Int32Var="smLen" Source="Xml" SyncMan="index"></GetMaxPdoLength>
				<!--Sonderfall für SM Länge = 1: kein 3 buffer 28.07.08-->
				<Compare>
					<Equal>
						<Value1>smLen</Value1>
						<Value2>1</Value2>
						<GotoStep>ReturnLength</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>0</Value1>
						<Value2>0</Value2>
						<GotoStep>CheckForCntrlByte</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="FromOD">
				<CallTestFunction Name="Reset"></CallTestFunction>
			</TestStep>
			<TestStep>
				<CallTestFunction Name="SetStateMachTimeouts"></CallTestFunction>
			</TestStep>
			<TestStep>
				<RunToState SendProcessData="false" Timeout="t_preopTimeout">
					<State>PREOP</State>
				</RunToState>
			</TestStep>
			<TestStep>
				<GetMaxPdoLength Int32Var="smLen" Source="OD" SyncMan="index"></GetMaxPdoLength>
			</TestStep>
			<TestStep Name="CheckForCntrlByte">
				<Compare>
					<NotEqual>
						<Value1>DeviceDescr.SM[index].ControlByte</Value1>
						<Value2>null</Value2>
						<GotoStep>CheckIfBuffered</GotoStep>
					</NotEqual>
				</Compare>
				<!--if SM is not virtual assume that the SM is running in 3 Buffer mode-->
				<Compare>
					<Equal>
						<Value1>DeviceDescr.SM[index].Virtual</Value1>
						<Value2>false</Value2>
						<GotoStep>ReturnBufferedLength</GotoStep>
					</Equal>
				</Compare>
				<!--if SM is virtual the SM is running in 1 Buffer mode-->
				<Compare>
					<Equal>
						<Value1>DeviceDescr.SM[index].ControlByte</Value1>
						<Value2>null</Value2>
						<GotoStep>ReturnLength</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CheckIfBuffered">
				<GetBits Source="DeviceDescr.SM[index].ControlByte" Target="byteVal2">
					<Offset>0</Offset>
					<Length>2</Length>
				</GetBits>
			</TestStep>
			<TestStep>
				<Compare>
					<Equal>
						<Value1>byteVal2</Value1>
						<Value2>00</Value2>
						<GotoStep>ReturnBufferedLength</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="ReturnLength">
				<SetVariable Target="smLen">smLen</SetVariable>
				<WriteLine Id="0" Level="Verbose" Param0="smLen" Param1="index">SM{1:d} Length {0:d} Byte</WriteLine>
				<Compare>
					<NotEqual>
						<Value1>1</Value1>
						<Value2>0</Value2>
						<Return Id="1"></Return>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="ReturnBufferedLength">
				<SetVariable Target="smLen">smLen*3</SetVariable>
				<WriteLine Id="2" Level="Verbose" Param0="smLen" Param1="index">SM{1:d} Lenth(buffered) {0:d} Byte</WriteLine>
			</TestStep>
		</TestFunction>
		<TestFunction Name="GetSubItemDataType" FunctionId="1707">
			<?MAX_OUTPUT_ID 2?>
			<Description>
				<Action>Get the DataType of a specified SubItem (identified by name)</Action>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>GetSubItemDataType.SubItemName</Name>
				<Type>String</Type>
				<Comment>name of the subitem</Comment>
			</Parameter>
			<Parameter>
				<Name>GetSubItemDataType.ParentDataTypeName</Name>
				<Type>String</Type>
				<Comment>name of the parent dataType</Comment>
			</Parameter>
			<Parameter>
				<Name>GetSubItemDataType.xPathDT</Name>
				<Type>String</Type>
				<Comment>base xPath to the Datatype Elements</Comment>
			</Parameter>
			<Parameter>
				<Name>GetSubItemDataType.xmlFile</Name>
				<Type>String</Type>
				<Comment>xml file contains the object description</Comment>
			</Parameter>
			<LocalVariables>
				<Name>GetSubItemDataType.IsMatch</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>GetSubItemDataType.strTmp</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>GetSubItemDataType.tmpXPath</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>GetSubItemDataType.i32NumberOfElements</Name>
				<Type>Int32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>GetSubItemDataType.i32LoopCounter</Name>
				<Type>Int32</Type>
			</LocalVariables>
			<OutParameter>
				<Name>GetSubItemDataType.DataTypeName</Name>
				<Type>String</Type>
			</OutParameter>
			<TestStep Name="INIT_RESULT">
				<SetVariable Target="GetSubItemDataType.DataTypeName">EmptyString</SetVariable>
			</TestStep>
			<TestStep Name="HandleApostrophInXpath">
				<RegexIsMatch ReturnValue="GetSubItemDataType.IsMatch">
					<Pattern>'</Pattern>
					<InputString>GetSubItemDataType.SubItemName</InputString>
				</RegexIsMatch>
				<Compare>
					<Equal>
						<Value1>GetSubItemDataType.IsMatch</Value1>
						<Value2>true</Value2>
						<SetVariable Param0="GetSubItemDataType.SubItemName" Target="GetSubItemDataType.SubItemName">""{0}""</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>GetSubItemDataType.IsMatch</Value1>
						<Value2>true</Value2>
						<GotoStep>TRY_TO_GET_RECORD_INFO</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<SetVariable Param0="GetSubItemDataType.SubItemName" Target="GetSubItemDataType.SubItemName">'{0}'</SetVariable>
			</TestStep>
			<TestStep Name="TRY_TO_GET_RECORD_INFO">
				<GetXmlValue FileName="GetSubItemDataType.xmlFile" Markup="false" ReturnValue="GetSubItemDataType.DataTypeName">
					<XPath Param0="GetSubItemDataType.xPathDT" Param1="GetSubItemDataType.ParentDataTypeName" Param2="GetSubItemDataType.SubItemName">{0}[Name = '{1}']/SubItem[Name = {2}]/Type</XPath>
				</GetXmlValue>
				<Compare>
					<Equal>
						<Value1>GetSubItemDataType.DataTypeName</Value1>
						<Value2>null</Value2>
						<GotoStep>CHECK_IF_ARRAY</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>GetSubItemDataType.DataTypeName</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>CHECK_IF_ARRAY</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="0" Param0="GetSubItemDataType.DataTypeName" Level="Verbose">GetSubItemDataType | DataTypeName='{0}'</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<Return Id="1"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CHECK_IF_ARRAY">
				<!--If the second SubItem Element has no SubIndex get the DataType from DTxxxARR definition-->
				<GetXmlValue FileName="GetSubItemDataType.xmlFile" Markup="false" ReturnValue="GetSubItemDataType.strTmp">
					<XPath Param0="GetSubItemDataType.xPathDT" Param1="GetSubItemDataType.ParentDataTypeName">{0}[Name = '{1}']/SubItem[2]/SubIdx</XPath>
				</GetXmlValue>
				<Compare>
					<NotEqual>
						<Value1>GetSubItemDataType.strTmp</Value1>
						<Value2>null</Value2>
						<GotoStep>END</GotoStep>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="HANDLE_ARRAY">
				<GetXmlValue FileName="GetSubItemDataType.xmlFile" Markup="false" ReturnValue="GetSubItemDataType.DataTypeName">
					<XPath Param0="GetSubItemDataType.xPathDT" Param1="GetSubItemDataType.ParentDataTypeName">{0}[Name = '{1}ARR']/BaseType</XPath>
				</GetXmlValue>
				<Compare>
					<Equal>
						<Value1>GetSubItemDataType.DataTypeName</Value1>
						<Value2>null</Value2>
						<SetVariable Target="GetSubItemDataType.DataTypeName">EmptyString</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<Return Id="2"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="END">
				<Compare>
					<Equal>
						<Value1>GetSubItemDataType.DataTypeName</Value1>
						<Value2>null</Value2>
						<SetVariable Target="GetSubItemDataType.DataTypeName">EmptyString</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction Name="GetSyncManagers" FunctionId="1708">
			<?MAX_OUTPUT_ID 0?>
			<!--Get array of specified SyncManages-->
			<Parameter>
				<Name>GetSyncManagers.TypeFilter</Name>
				<Type>String</Type>
			</Parameter>
			<Parameter>
				<Name>GetSyncManagers.OnlyNonConsecutive</Name>
				<Type>Bool</Type>
				<Comment>get only SM which are not consecutive</Comment>
			</Parameter>
			<LocalVariables>
				<Name>GetSyncManagers.LoopCounter</Name>
				<Type>Byte</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>GetSyncManagers.EndAddress</Name>
				<Type>Int32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>GetSyncManagers.CurSmSize</Name>
				<Type>Int32</Type>
			</LocalVariables>
			<OutParameter>
				<Name>GetSyncManagers.SmArray</Name>
				<Type>ArrayOfBytes</Type>
			</OutParameter>
			<TestStep Name="INIT_RETURN_ARRAY">
				<InitArray Length="0" TargetArray="GetSyncManagers.SmArray"></InitArray>
			</TestStep>
			<TestStep Name="INIT_LOOP_COUNTER">
				<SetVariable Target="GetSyncManagers.LoopCounter">0</SetVariable>
			</TestStep>
			<TestStep Name="INIT_ENDADDRESS">
				<SetVariable Target="GetSyncManagers.EndAddress">0</SetVariable>
			</TestStep>
			<TestStep Name="RETURN_IF_NO_SM_AVAILABLE">
				<!--Any ESI Sm available?-->
				<Compare>
					<Equal>
						<Value1>DeviceDescr.SM.Count</Value1>
						<Value2>0</Value2>
						<Return Id="0"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="LOOP_START">
				<!--ESI Sm:Text Available?-->
				<Compare>
					<Equal>
						<Value1>DeviceDescr.SM[GetSyncManagers.LoopCounter]</Value1>
						<Value2>null</Value2>
						<GotoStep>NEXT</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="SKIP_IF_FILTER_NOT_MATCH">
				<Compare>
					<NotEqual>
						<Value1>DeviceDescr.SM[GetSyncManagers.LoopCounter]</Value1>
						<Value2>GetSyncManagers.TypeFilter</Value2>
						<GotoStep>NEXT</GotoStep>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="CHECK_BUFFER_RANGE">
				<Compare>
					<Equal>
						<Value1>GetSyncManagers.EndAddress</Value1>
						<Value2>DeviceDescr.SM[GetSyncManagers.LoopCounter].StartAddress</Value2>
						<GotoStep>CONSECUTIVE_BUFFER</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="NON_CONSECUTIVE_BUFFER">
				<AddArrayItem TargetArray="GetSyncManagers.SmArray">GetSyncManagers.LoopCounter</AddArrayItem>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>GET_FIXED_LENGTH</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CONSECUTIVE_BUFFER">
				<Compare>
					<Equal>
						<Value1>GetSyncManagers.OnlyNonConsecutive</Value1>
						<Value2>true</Value2>
						<GotoStep>GET_FIXED_LENGTH</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<AddArrayItem TargetArray="GetSyncManagers.SmArray">GetSyncManagers.LoopCounter</AddArrayItem>
			</TestStep>
			<TestStep Name="GET_FIXED_LENGTH">
				<CallTestFunction Name="GetFixedSmLength">
					<Parameter>GetSyncManagers.LoopCounter</Parameter>
					<OutParameter>GetSyncManagers.CurSmSize</OutParameter>
				</CallTestFunction>
			</TestStep>
			<TestStep Name="UPDATE_END_ADDRESS">
				<Compare>
					<GreaterOrEqual>
						<Value1>GetSyncManagers.CurSmSize</Value1>
						<Value2>0</Value2>
						<SetVariable Target="GetSyncManagers.EndAddress">DeviceDescr.SM[GetSyncManagers.LoopCounter].StartAddress + GetSyncManagers.CurSmSize</SetVariable>
					</GreaterOrEqual>
				</Compare>
				<Compare>
					<Lower>
						<Value1>GetSyncManagers.CurSmSize</Value1>
						<Value2>0</Value2>
						<SetVariable Target="GetSyncManagers.EndAddress">DeviceDescr.SM[GetSyncManagers.LoopCounter].StartAddress</SetVariable>
					</Lower>
				</Compare>
			</TestStep>
			<TestStep Name="NEXT">
				<!--Done? otherwise check next Sm-->
				<SetVariable Target="GetSyncManagers.LoopCounter">GetSyncManagers.LoopCounter+1</SetVariable>
				<Compare>
					<Lower>
						<Value1>GetSyncManagers.LoopCounter</Value1>
						<Value2>DeviceDescr.SM.Count</Value2>
						<GotoStep>LOOP_START</GotoStep>
					</Lower>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction Name="GetTxPdoEntryBitSize" FunctionId="1709">
			<?MAX_OUTPUT_ID 1?>
			<!--Get the bit size of a specific TxPDO-->
			<Parameter>
				<Name>GetTxPdoEntryBitSize.Index</Name>
				<Type>Int32</Type>
				<!--Zero based index of the TxPDO-->
			</Parameter>
			<LocalVariables>
				<Name>GetTxPdoEntryBitSize.EntryCounter</Name>
				<Type>UInt32</Type>
			</LocalVariables>
			<OutParameter>
				<Name>GetTxPdoEntryBitSize.Length</Name>
				<Type>Int32</Type>
			</OutParameter>
			<TestStep Name="InitReturnValue">
				<SetVariable Target="GetTxPdoEntryBitSize.Length">0</SetVariable>
			</TestStep>
			<TestStep Name="InitEntryCounter">
				<SetVariable Target="GetTxPdoEntryBitSize.EntryCounter">0</SetVariable>
			</TestStep>
			<TestStep Name="RaiseErrorIfInvalidTxPDOIndex">
				<Compare>
					<Greater>
						<Value1>GetTxPdoEntryBitSize.Index</Value1>
						<Value2>DeviceDescr.TxPdo.Count</Value2>
						<RaiseError Id="0" Param0="GetTxPdoEntryBitSize.Index">Function "GetTxPdoEntryBitSize" : Paramter "GetTxPdoEntryBitSize.Index" ({0}) shall not be greater than available TxPDOs.</RaiseError>
					</Greater>
				</Compare>
			</TestStep>
			<TestStep Name="LoopStart">
				<Compare>
					<GreaterOrEqual>
						<Value1>GetTxPdoEntryBitSize.EntryCounter</Value1>
						<Value2>DeviceDescr.TxPdo[GetTxPdoEntryBitSize.Index].Entry.Count</Value2>
						<GotoStep>END</GotoStep>
					</GreaterOrEqual>
				</Compare>
			</TestStep>
			<TestStep>
				<SetVariable Target="GetTxPdoEntryBitSize.Length">GetTxPdoEntryBitSize.Length + DeviceDescr.TxPdo[GetTxPdoEntryBitSize.Index].Entry[GetTxPdoEntryBitSize.EntryCounter].BitLen</SetVariable>
			</TestStep>
			<TestStep>
				<SetVariable Target="GetTxPdoEntryBitSize.EntryCounter">GetTxPdoEntryBitSize.EntryCounter + 1</SetVariable>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>LoopStart</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="END">
				<Description Id="1" Param0="GetTxPdoEntryBitSize.Index" Param1="GetTxPdoEntryBitSize.Length" Level="Verbose">Calculated Bit size of TxPdo[{0}] : {1}</Description>
			</TestStep>
		</TestFunction>
		<TestFunction Name="InitGlobalVariablesForDataTypeTest" FunctionId="1801">
			<?MAX_OUTPUT_ID 3?>
			<!--Function for Device DataType Tests-->
			<LocalVariables>
				<Name>strXmlReturnValue</Name>
				<Type>String</Type>
			</LocalVariables>
			<TestStep Name="CHECK_IF_EXTERNAL_DICTIONARY_DEFINED">
				<!--Check if external Dictionary is defined-->
				<GetXmlValue ReturnValue="XmlFile" Markup="false">
					<XPath>Profile[position()=1]/DictionaryFile</XPath>
				</GetXmlValue>
				<!--If no external object dictionary is defined set Xmlfile = EmptyString-->
				<Compare>
					<Equal>
						<Value1>XmlFile</Value1>
						<Value2>null</Value2>
						<SetVariable Target="XmlFile">EmptyString</SetVariable>
					</Equal>
				</Compare>
				<!--GoTo SET_XPATH if external dictionary is defined-->
				<Compare>
					<NotEqual>
						<Value1>XmlFile</Value1>
						<Value2>EmptyString</Value2>
						<WriteLine Id="0" Level="Verbose" Param0="XmlFile">A external offline dictionary was found ({0}).</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>XmlFile</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>SET_XPATH</GotoStep>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="CHECK_IF_LOCAL_DICTIONARY_DEFINED">
				<!--Check if local Dictionary is defined-->
				<GetXmlValue ReturnValue="strXmlReturnValue" Markup="false">
					<XPath>Profile[position()=1]/Dictionary/DataTypes/DataType</XPath>
				</GetXmlValue>
				<!--Set "XmlFile" to EmptyString-->
				<Compare>
					<NotEqual>
						<Value1>strXmlReturnValue</Value1>
						<Value2>null</Value2>
						<SetVariable Target="XmlFile">EmptyString</SetVariable>
					</NotEqual>
				</Compare>
				<!--Dump a user info that a local dictionary was found-->
				<Compare>
					<NotEqual>
						<Value1>strXmlReturnValue</Value1>
						<Value2>null</Value2>
						<WriteLine Id="1" Level="Verbose">A local offline dictionary was found.</WriteLine>
					</NotEqual>
				</Compare>
				<!--Return if no dictionary was found-->
				<Compare>
					<Equal>
						<Value1>strXmlReturnValue</Value1>
						<Value2>null</Value2>
						<SkipCase Id="2">Test skipped. No offline dictionary found.</SkipCase>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="SET_XPATH">
				<!--if XmlFile != EmptyString set the XPath according the external dictionary file-->
				<Compare>
					<NotEqual>
						<Value1>XmlFile</Value1>
						<Value2>EmptyString</Value2>
						<WriteLine Id="3" Level="Verbose" Param0="XmlFile">External offline object dictionary found ({0}).</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>XmlFile</Value1>
						<Value2>EmptyString</Value2>
						<SetVariable Target="XPathDt">/EtherCATDict/Dictionary/DataTypes/DataType</SetVariable>
					</NotEqual>
				</Compare>
				<!--Set XPathDt to the local dictionary-->
				<Compare>
					<Equal>
						<Value1>XmlFile</Value1>
						<Value2>EmptyString</Value2>
						<SetVariable Target="XPathDt">Profile[position()=1]/Dictionary/DataTypes/DataType</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction Name="InitGlobalVariablesForModuleODTest" FunctionId="20301">
			<?MAX_OUTPUT_ID 4?>
			<!--Function to initiate globale variables for Module Object Dictionary test-->
			<Parameter>
				<Name>Toggle</Name>
				<Type>Bool</Type>
				<Comment>Toggle between Initializations</Comment>
			</Parameter>
			<LocalVariables>
				<Name>ext_present</Name>
				<Type>Bool</Type>
				<Comment>Indication for modules in external file</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>loc_present</Name>
				<Type>Bool</Type>
				<Comment>Indication for modules within ESI</Comment>
			</LocalVariables>
			<TestStep>
				<SetVariable Target="ext_ModuleXmlFile.Length">1</SetVariable>
			</TestStep>
			<TestStep>
				<SetVariable Target="ext_present">true</SetVariable>
			</TestStep>
			<TestStep>
				<SetVariable Target="loc_present">true</SetVariable>
				<Compare>
					<Equal>
						<Value1>Toggle</Value1>
						<Value2>false</Value2>
						<GotoStep>CHECK_IF_LOCAL_MODULES_PRESENT</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CHECK_IF_EXTERNAL_MODULE_FILE_PRESENT">
				<!--Check if external Module file is present-->
				<GetXmlValue ReturnValue="ext_ModuleXmlFile" Markup="false">
					<XPath Param0="ext_ModuleXmlFile.Length">/EtherCATInfo/InfoReference[{0}]</XPath>
				</GetXmlValue>
				<!--- Set "ext_ModuleXmlfile" to EmptyString if no external file is found
- Inicialize "ext_XPathModuleIdent" to EmptyString-->
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<SetVariable Target="ext_ModuleXmlFile.XPath">/EtherCATInfo/InfoReference</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<SetVariable Target="ext_XPathModuleIdent">EmptyString</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>ext_ModuleXmlFile</Value1>
						<Value2>null</Value2>
						<SetVariable Target="ext_present">false</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>ext_ModuleXmlFile</Value1>
						<Value2>null</Value2>
						<SetVariable Target="ext_ModuleXmlFile">EmptyString</SetVariable>
					</Equal>
				</Compare>
				<!--Set XPath if external module file was found.-->
				<Compare>
					<NotEqual>
						<Value1>ext_present</Value1>
						<Value2>false</Value2>
						<WriteLine Id="0" Level="Verbose" Param0="ext_ModuleXmlFile">External file: ({0}).</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>ext_ModuleXmlFile</Value1>
						<Value2>EmptyString</Value2>
						<SetVariable Target="ext_XPathModuleIdent">/EtherCATModule/Modules/Module</SetVariable>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>ext_present</Value1>
						<Value2>false</Value2>
						<WriteLine Id="1" Level="Output">No external file with modules was found.</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>ext_present</Value1>
						<Value2>false</Value2>
						<GotoStep>INIT_END</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CHECK_IF_MULTIPLE_MODULE_FILE_PRESENT">
				<SetVariable Target="ext_ModuleXmlFile.Length">ext_ModuleXmlFile.Length + 1</SetVariable>
				<!--Check if multiple module files are present-->
			</TestStep>
			<TestStep>
				<GetXmlValue ReturnValue="ext_ModuleXmlFile" Markup="false">
					<XPath Param0="ext_ModuleXmlFile.Length">/EtherCATInfo/InfoReference[{0}]</XPath>
				</GetXmlValue>
				<Compare>
					<NotEqual>
						<Value1>ext_ModuleXmlFile</Value1>
						<Value2>null</Value2>
						<WriteLine Id="2" Level="Verbose" Param0="ext_ModuleXmlFile">Other external module files: ({0}).</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>ext_ModuleXmlFile</Value1>
						<Value2>null</Value2>
						<SetVariable Target="ext_ModuleXmlFile.Length">ext_ModuleXmlFile.Length - 1</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>ext_ModuleXmlFile</Value1>
						<Value2>null</Value2>
						<SetVariable Target="ext_ModuleXmlFile.XPath">/EtherCATInfo/InfoReference</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>ext_ModuleXmlFile</Value1>
						<Value2>null</Value2>
						<GotoStep>INIT_END</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>CHECK_IF_MULTIPLE_MODULE_FILE_PRESENT</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CHECK_IF_LOCAL_MODULES_PRESENT">
				<!--Check if Modules are present locally-->
				<GetXmlValue ReturnValue="loc_ModuleXmlFile" Markup="false">
					<XPath>/EtherCATInfo/Descriptions/Modules/Module</XPath>
				</GetXmlValue>
				<!--Set XPath and set "loc_ModuleXmlFile" to EmptyString (EmptyString in any case, since the local reference to modules is given with "loc_XPathModuleIdent"), if local modules were found-->
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<SetVariable Target="loc_XPathModuleIdent">EmptyString</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<SetVariable Target="ext_ModuleXmlFile.XPath">/EtherCATInfo/InfoReference</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>loc_ModuleXmlFile</Value1>
						<Value2>null</Value2>
						<SetVariable Target="loc_present">false</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>loc_ModuleXmlFile</Value1>
						<Value2>null</Value2>
						<SetVariable Target="loc_XPathModuleIdent">/EtherCATInfo/Descriptions/Modules/Module</SetVariable>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>loc_ModuleXmlFile</Value1>
						<Value2>null</Value2>
						<SetVariable Target="loc_ModuleXmlFile">EmptyString</SetVariable>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>loc_ModuleXmlFile</Value1>
						<Value2>null</Value2>
						<SetVariable Target="loc_ModuleXmlFile">EmptyString</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>loc_present</Value1>
						<Value2>false</Value2>
						<WriteLine Id="3" Level="Output">Local modules were found.</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>loc_present</Value1>
						<Value2>false</Value2>
						<WriteLine Id="4" Level="Output">No locally defined modules in ESI.</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>INIT_END</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="INIT_END"></TestStep>
		</TestFunction>
		<TestFunction Name="InitGlobalVariablesForObjectTests" FunctionId="1802">
			<?MAX_OUTPUT_ID 3?>
			<LocalVariables>
				<Name>strXmlReturnValue</Name>
				<Type>String</Type>
			</LocalVariables>
			<TestStep Name="CHECK_IF_EXTERNAL_DICTIONARY_DEFINED">
				<!--Check if external Dictionary is defined-->
				<GetXmlValue ReturnValue="XmlFile" Markup="false">
					<XPath>Profile[position()=1]/DictionaryFile</XPath>
				</GetXmlValue>
				<!--If no external object dictionary is defined set Xmlfile = EmptyString-->
				<Compare>
					<Equal>
						<Value1>XmlFile</Value1>
						<Value2>null</Value2>
						<SetVariable Target="XmlFile">EmptyString</SetVariable>
					</Equal>
				</Compare>
				<!--GoTo SET_XPATH if external dictionary is defined-->
				<Compare>
					<NotEqual>
						<Value1>XmlFile</Value1>
						<Value2>EmptyString</Value2>
						<WriteLine Id="0" Level="Verbose" Param0="XmlFile">A local offline dictionary was found ({0}).</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>XmlFile</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>SET_XPATH</GotoStep>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="CHECK_IF_LOCAL_DICTIONARY_DEFINED">
				<!--Check if local Dictionary is defined-->
				<GetXmlValue ReturnValue="strXmlReturnValue" Markup="false">
					<XPath>Profile[position()=1]/Dictionary/Objects/Object</XPath>
				</GetXmlValue>
				<!--Set "XmlFile" to EmptyString-->
				<Compare>
					<NotEqual>
						<Value1>strXmlReturnValue</Value1>
						<Value2>null</Value2>
						<SetVariable Target="XmlFile">EmptyString</SetVariable>
					</NotEqual>
				</Compare>
				<!--Dump a user info that a local dictionary was found-->
				<Compare>
					<NotEqual>
						<Value1>strXmlReturnValue</Value1>
						<Value2>null</Value2>
						<WriteLine Id="1" Level="Verbose">A local offline dictionary was found.</WriteLine>
					</NotEqual>
				</Compare>
				<!--Return if no dictionary was found-->
				<Compare>
					<Equal>
						<Value1>strXmlReturnValue</Value1>
						<Value2>null</Value2>
						<SkipCase Id="2">Test skipped. No offline dictionary found.</SkipCase>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="SET_XPATH">
				<!--if XmlFile != EmptyString set the XPath according the external dictionary file-->
				<Compare>
					<NotEqual>
						<Value1>XmlFile</Value1>
						<Value2>EmptyString</Value2>
						<WriteLine Id="3" Level="Verbose" Param0="XmlFile">External offline object dictionary found ({0}).</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>XmlFile</Value1>
						<Value2>EmptyString</Value2>
						<SetVariable Target="XPathObject">/EtherCATDict/Dictionary/Objects/Object</SetVariable>
					</NotEqual>
				</Compare>
				<!--Set XPathObject to the local dictionary-->
				<Compare>
					<Equal>
						<Value1>XmlFile</Value1>
						<Value2>EmptyString</Value2>
						<SetVariable Target="XPathObject">Profile[position()=1]/Dictionary/Objects/Object</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction Name="IsSmReferencedViaSu" FunctionId="1901">
			<?MAX_OUTPUT_ID 6?>
			<!--Gets "Su" and "SyncManager index" to check if the SM is referenced via the SyncUnit-->
			<Parameter>
				<Name>IsSmReferencedViaSu.SmIndex</Name>
				<Type>UInt16</Type>
				<!--Zero based index of the SyncManager-->
			</Parameter>
			<Parameter>
				<Name>IsSmReferencedViaSu.Su</Name>
				<Type>UInt16</Type>
				<!--Number of the SyncUnit-->
			</Parameter>
			<LocalVariables>
				<Name>IsSmReferencedViaSu.Cnt</Name>
				<Type>UInt16</Type>
				<!--temp counter variable-->
			</LocalVariables>
			<LocalVariables>
				<Name>IsSmReferencedViaSu.strSmName</Name>
				<Type>String</Type>
				<!--Sm search pattern (SM name) required if no fixed Sm is referenced-->
			</LocalVariables>
			<LocalVariables>
				<Name>IsSmReferencedViaSu.ArrSm</Name>
				<Type>ArrayOfBytes</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>IsSmReferencedViaSu.ArrIndex</Name>
				<Type>Int32</Type>
			</LocalVariables>
			<OutParameter>
				<Name>IsSmReferencedViaSu.Valid</Name>
				<Type>Bool</Type>
			</OutParameter>
			<TestStep>
				<!--Check if FMMU Elements defined-->
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Fmmu.Count</Value1>
						<Value2>0</Value2>
						<WriteLine Id="0" Level="Error">No FMMU defined in device description.</WriteLine>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="INIT_COUNTER_VAR">
				<!--Init counter variable-->
				<SetVariable Target="IsSmReferencedViaSu.Cnt">0</SetVariable>
			</TestStep>
			<TestStep Name="INIT_SM_SEARCH_PATTERN">
				<SetVariable Target="IsSmReferencedViaSu.strSmName">EmptyString</SetVariable>
			</TestStep>
			<TestStep>
				<!--Init Return variable-->
				<SetVariable Target="IsSmReferencedViaSu.Valid">false</SetVariable>
			</TestStep>
			<TestStep Name="LOOPSTART">
				<!--Stop loop -->
				<Compare>
					<LowerOrEqual>
						<Value1>DeviceDescr.Fmmu.Count</Value1>
						<Value2>IsSmReferencedViaSu.Cnt</Value2>
						<Return Id="1"></Return>
					</LowerOrEqual>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Check if Su of current FMMU is defined-->
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Fmmu[IsSmReferencedViaSu.Cnt].Su</Value1>
						<Value2>null</Value2>
						<GotoStep>LOOPEND</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Continue with next FMMU if Su value not match-->
				<Compare>
					<NotEqual>
						<Value1>DeviceDescr.Fmmu[IsSmReferencedViaSu.Cnt].Su</Value1>
						<Value2>IsSmReferencedViaSu.Su</Value2>
						<GotoStep>LOOPEND</GotoStep>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="CHECK_SM_REFERENCE">
				<!--if SM refernce is set-->
				<Compare>
					<NotEqual>
						<Value1>DeviceDescr.Fmmu[IsSmReferencedViaSu.Cnt].Sm</Value1>
						<Value2>null</Value2>
						<GotoStep>FIXED_SM_REFERENCE</GotoStep>
					</NotEqual>
				</Compare>
				<!--set SM serach pattern-->
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Fmmu[IsSmReferencedViaSu.Cnt]</Value1>
						<Value2>Outputs</Value2>
						<SetVariable Target="IsSmReferencedViaSu.strSmName">Outputs</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Fmmu[IsSmReferencedViaSu.Cnt]</Value1>
						<Value2>Inputs</Value2>
						<SetVariable Target="IsSmReferencedViaSu.strSmName">Inputs</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Fmmu[IsSmReferencedViaSu.Cnt]</Value1>
						<Value2>MBoxState</Value2>
						<SetVariable Target="IsSmReferencedViaSu.strSmName">MBoxIn</SetVariable>
					</Equal>
				</Compare>
				<!--Skip if no supported FMMU is set-->
				<Compare>
					<Equal>
						<Value1>IsSmReferencedViaSu.strSmName</Value1>
						<Value2>EmptyString</Value2>
						<WriteLine Id="2" Level="Output" Param0="DeviceDescr.Fmmu[IsSmReferencedViaSu.Cnt]">FMMU '{0}' not handled!</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>IsSmReferencedViaSu.strSmName</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>LOOPEND</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="SEARCH_SM">
				<CallTestFunction Name="GetSyncManagers">
					<Parameter>IsSmReferencedViaSu.strSmName</Parameter>
					<Parameter>false</Parameter>
					<OutParameter>IsSmReferencedViaSu.ArrSm</OutParameter>
				</CallTestFunction>
			</TestStep>
			<TestStep Name="CHECK_IF_AT_LEAST_ONE_MATCHING_SM_DEFINED">
				<CallTestFunction Name="ArrayOfBytes.IndexOf">
					<Parameter>IsSmReferencedViaSu.SmIndex</Parameter>
					<Parameter>IsSmReferencedViaSu.ArrSm</Parameter>
					<OutParameter>IsSmReferencedViaSu.ArrIndex</OutParameter>
				</CallTestFunction>
				<Compare>
					<Lower>
						<Value1>IsSmReferencedViaSu.ArrIndex</Value1>
						<Value2>0</Value2>
						<WriteLine Id="3" Level="Verbose" Param0="IsSmReferencedViaSu.Cnt" Param1="IsSmReferencedViaSu.ArrSm" Param2="IsSmReferencedViaSu.SmIndex">SM '{2}' no found in SmList ({1}); FMMU[{0}] </WriteLine>
					</Lower>
				</Compare>
				<Compare>
					<GreaterOrEqual>
						<Value1>IsSmReferencedViaSu.ArrIndex</Value1>
						<Value2>0</Value2>
						<SetVariable Target="IsSmReferencedViaSu.Valid">true</SetVariable>
					</GreaterOrEqual>
				</Compare>
				<Compare>
					<GreaterOrEqual>
						<Value1>IsSmReferencedViaSu.ArrIndex</Value1>
						<Value2>0</Value2>
						<Return Id="4"></Return>
					</GreaterOrEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>LOOPEND</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="FIXED_SM_REFERENCE">
				<!--Check if Fmmu.Sm match requested Sm-->
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Fmmu[IsSmReferencedViaSu.Cnt].Sm</Value1>
						<Value2>IsSmReferencedViaSu.SmIndex</Value2>
						<SetVariable Target="IsSmReferencedViaSu.Valid">true</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Fmmu[IsSmReferencedViaSu.Cnt].Sm</Value1>
						<Value2>IsSmReferencedViaSu.SmIndex</Value2>
						<WriteLine Id="5" Level="Verbose" Param0="IsSmReferencedViaSu.SmIndex" Param1="IsSmReferencedViaSu.Su">SM[{0}] is referenced via Su {1}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Fmmu[IsSmReferencedViaSu.Cnt].Sm</Value1>
						<Value2>IsSmReferencedViaSu.SmIndex</Value2>
						<Return Id="6"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="LOOPEND">
				<!--Increment loop counter-->
				<SetVariable Target="IsSmReferencedViaSu.Cnt">IsSmReferencedViaSu.Cnt + 1</SetVariable>
				<!--proceed with next cycle-->
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>LOOPSTART</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction Name="LocalModuleIdentList" FunctionId="20101">
			<?MAX_OUTPUT_ID 10?>
			<!--Initiate global array of local ModuleIdents-->
			<Description>
				<Action>Initiate global array of local ModuleIdents</Action>
				<PostCondition>Global array AllLocalModuleIdents.Uint32Array initiated</PostCondition>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<LocalVariables>
				<Name>LocalModuleIdentList.LocExt_InitToggle</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>LocalModuleIdentList.result</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>LocalModuleIdentList.AtLeastOneModuleFound</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>LocalModuleIdentList.int32LoopCounter</Name>
				<Type>Int32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>LocalModuleIdentList.loc_XPathDtTmp</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>LocalModuleIdentList.strXmlValue</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>LocalModuleIdentList.uint32Length</Name>
				<Type>UInt32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>LocalModuleIdentList.Uint32ModuleIdent</Name>
				<Type>UInt32</Type>
			</LocalVariables>
			<TestStep Name="Toggle_LOC_EXT">
				<!--Flag for InitGlobalVariables for default XPaths of local or external file-->
				<SetVariable Target="LocalModuleIdentList.LocExt_InitToggle">false</SetVariable>
				<WriteLine Id="0" Level="Output">Checking for modules within ESI...</WriteLine>
			</TestStep>
			<TestStep Name="SkipSoE">
				<!--Skip Test if SoE Device-->
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Mailbox.SoE</Value1>
						<Value2>true</Value2>
						<SkipCase Id="1">Test skipped for SoE Devices.</SkipCase>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="InitGlobalVariables">
				<!--Init global XPaths-->
				<CallTestFunction Name="InitGlobalVariablesForModuleODTest">
					<Parameter>LocalModuleIdentList.LocExt_InitToggle</Parameter>
				</CallTestFunction>
			</TestStep>
			<TestStep Name="INIT_RESULT">
				<!--"LocalModuleIdentList.result" = true-->
				<SetVariable Target="LocalModuleIdentList.result">true</SetVariable>
			</TestStep>
			<TestStep Name="INIT_LOOP_COUNTER">
				<!--"LocalModuleIdentList.int32LoopCounter" = 1, not starting with list index [0]-->
				<SetVariable Target="LocalModuleIdentList.int32LoopCounter">1</SetVariable>
			</TestStep>
			<TestStep Name="InitModuleArray">
				<!--Array of found ModuleIdents-->
				<InitArray TargetArray="AllLocalModuleIdents.Uint32Array"></InitArray>
			</TestStep>
			<TestStep Name="DataTypeLoopStart">
				<!--__Loop START for LOCAL Modules__-->
				<Compare>
					<Equal>
						<Value1>loc_XPathModuleIdent</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>DumpTestResult</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CREATE_XPATH_FOR_DT_ELEMENT">
				<SetVariable Target="LocalModuleIdentList.loc_XPathDtTmp" Param0="loc_XPathModuleIdent" Param1="LocalModuleIdentList.int32LoopCounter">{0}[{1}]/Type/@ModuleIdent</SetVariable>
			</TestStep>
			<TestStep Name="CHECK_IF_LAST_ELEMENT">
				<GetXmlValue Markup="false" ReturnValue="LocalModuleIdentList.strXmlValue">
					<XPath Param0="LocalModuleIdentList.loc_XPathDtTmp">{0}</XPath>
				</GetXmlValue>
				<Compare>
					<Equal>
						<Value1>LocalModuleIdentList.strXmlValue</Value1>
						<Value2>null</Value2>
						<GotoStep>DumpTestResult</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>LocalModuleIdentList.strXmlValue</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>DumpTestResult</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<SetVariable Target="LocalModuleIdentList.AtLeastOneModuleFound">true</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="2" Level="Verbose" Param0="LocalModuleIdentList.loc_XPathDtTmp">{0}</WriteLine>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<GetXmlValue Markup="false" ReturnValue="LocalModuleIdentList.Uint32ModuleIdent">
					<XPath Param0="LocalModuleIdentList.loc_XPathDtTmp">{0}</XPath>
				</GetXmlValue>
				<Compare>
					<Equal>
						<Value1>LocalModuleIdentList.Uint32ModuleIdent</Value1>
						<Value2>0</Value2>
						<WriteLine Id="3" Level="Output" Param0="LocalModuleIdentList.int32LoopCounter" Param1="LocalModuleIdentList.strXmlValue">Module[{0}]: Ident: {1} - "Empty"</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>LocalModuleIdentList.Uint32ModuleIdent</Value1>
						<Value2>0</Value2>
						<GotoStep>HandleEmptySlots</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="4" Level="Output" Param0="LocalModuleIdentList.int32LoopCounter" Param1="LocalModuleIdentList.strXmlValue">Module[{0}]: Ident: {1}</WriteLine>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="HandleEmptySlots">
				<!--SKIP If module Ident equals 0x0-->
				<Compare>
					<Equal>
						<Value1>LocalModuleIdentList.Uint32ModuleIdent</Value1>
						<Value2>0</Value2>
						<GotoStep>DataTypeLoopEnd</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="AddModuleIdentToArray">
				<AddArrayItem TargetArray="AllLocalModuleIdents.Uint32Array">LocalModuleIdentList.Uint32ModuleIdent</AddArrayItem>
			</TestStep>
			<TestStep Name="DataTypeLoopEnd">
				<!--__END of "DataTypeLoopStart", Increment loop counter__-->
				<SetVariable Target="LocalModuleIdentList.int32LoopCounter">LocalModuleIdentList.int32LoopCounter + 1</SetVariable>
				<!--Goto Loop start-->
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>DataTypeLoopStart</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="DumpTestResult">
				<!--Dump Test case LocalModuleIdentList.result-->
				<SizeOf UInt32Var="LocalModuleIdentList.uint32Length">AllLocalModuleIdents.Uint32Array</SizeOf>
			</TestStep>
			<TestStep>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="5" Level="Output" Param0="AllLocalModuleIdents.Uint32Array">Array of found local ModuleIdents: {0}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="6" Level="Output" Param0="LocalModuleIdentList.uint32Length">Number of real modules: {0}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="7" Level="Output" Param0="((LocalModuleIdentList.int32LoopCounter - 1) - LocalModuleIdentList.uint32Length)">Number of "Empty" modules: {0}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>LocalModuleIdentList.AtLeastOneModuleFound</Value1>
						<Value2>false</Value2>
						<SkipCase Id="8">No modules found.</SkipCase>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>LocalModuleIdentList.result</Value1>
						<Value2>true</Value2>
						<ReturnSuccess Id="9">Test successful.</ReturnSuccess>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>LocalModuleIdentList.result</Value1>
						<Value2>false</Value2>
						<RaiseError Id="10">Test failed.</RaiseError>
					</Equal>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction Name="PdoElementsToArray_gen" FunctionId="20901">
			<?MAX_OUTPUT_ID 4?>
			<!--Create a Uint16 Array of defined Pdo Indices-->
			<Parameter>
				<Name>PdoElementsToArray.Flag</Name>
				<Type>Bool</Type>
				<Comment>Flag to switch between Pdos (RxPdo - true, TxPdo - false)</Comment>
			</Parameter>
			<Parameter>
				<Name>PdoElementsToArray.XmlFileXPath</Name>
				<Type>String</Type>
				<Comment>XPath of XML file (local, external)</Comment>
			</Parameter>
			<Parameter>
				<Name>PdoElementsToArray.ModuleXPath</Name>
				<Type>String</Type>
				<Comment>XPath of Module</Comment>
			</Parameter>
			<Parameter>
				<Name>PdoElementsToArray.ModuleCount</Name>
				<Type>Int32</Type>
				<Comment>Module Count for XPath string</Comment>
			</Parameter>
			<Parameter>
				<Name>PdoElementsToArray.PdoIndex</Name>
				<Type>Int32</Type>
				<!--Zero based index of the PDO-->
				<Comment>Pdo Count for XPath string</Comment>
			</Parameter>
			<LocalVariables>
				<Name>PdoElementsToArray.Cnt</Name>
				<Type>UInt16</Type>
				<!--temp counter variable-->
			</LocalVariables>
			<LocalVariables>
				<Name>xxx_ADD_BEGIN_xxx</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>strXmlValue.PdoElementsToArray.String</Name>
				<Type>String</Type>
				<!--Pdo index String-->
			</LocalVariables>
			<LocalVariables>
				<Name>strXmlValue.PdoElementsToArray.Uint16</Name>
				<Type>UInt16</Type>
				<!--Pdo index Uint16-->
			</LocalVariables>
			<LocalVariables>
				<Name>strXmlValue.PdoElementsToArray.ExcludeIndexString</Name>
				<Type>String</Type>
				<!--Pdo Index String-->
			</LocalVariables>
			<LocalVariables>
				<Name>PdoElementsToArray.TempXPath</Name>
				<Type>String</Type>
				<!--Temp XPath-->
			</LocalVariables>
			<LocalVariables>
				<Name>xxx_ADD_END_xxx</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<OutParameter>
				<Name>PdoElementsToArray.ui16Arr</Name>
				<Type>ArrayOfUInt16</Type>
			</OutParameter>
			<TestStep>
				<!--Reset PdoIndex for Array-->
				<SetVariable Target="PdoElementsToArray.PdoIndex">1</SetVariable>
			</TestStep>
			<TestStep>
				<!--Switch Between Pdos-->
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>debug_msg</Value2>
						<WriteLine Id="0" Level="Output" Param0="PdoElementsToArray.Flag">PdoElementsToArray.Flag = {0}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>PdoElementsToArray.Flag</Value1>
						<Value2>false</Value2>
						<GotoStep>XPath_TXPDO</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="XPath_RXPDO">
				<!--Build XPath for RxPdo elements-->
				<SetVariable Target="PdoElementsToArray.TempXPath" Param0="PdoElementsToArray.ModuleXPath" Param1="PdoElementsToArray.ModuleCount">{0}[{1}]/RxPdo</SetVariable>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>LOOPSTART_PDO</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="XPath_TXPDO">
				<!--Build XPath for TxPdo elements-->
				<SetVariable Target="PdoElementsToArray.TempXPath" Param0="PdoElementsToArray.ModuleXPath" Param1="PdoElementsToArray.ModuleCount">{0}[{1}]/TxPdo</SetVariable>
			</TestStep>
			<TestStep Name="LOOPSTART_PDO">
				<!--Check if Pdo elements are defined -->
				<GetXmlValue FileName="PdoElementsToArray.XmlFileXPath" Markup="false" ReturnValue="strXmlValue.PdoElementsToArray.String">
					<XPath Param0="PdoElementsToArray.TempXPath" Param1="PdoElementsToArray.PdoIndex">{0}[{1}]</XPath>
				</GetXmlValue>
				<Compare>
					<Equal>
						<Value1>strXmlValue.PdoElementsToArray.String</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>END</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValue.PdoElementsToArray.String</Value1>
						<Value2>null</Value2>
						<GotoStep>END</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<SetVariable Target="PdoElementsToArray.Cnt">1</SetVariable>
			</TestStep>
			<TestStep Name="LOOPSTART">
				<!--Check if Loop finished-->
				<GetXmlValue FileName="PdoElementsToArray.XmlFileXPath" Markup="false" ReturnValue="strXmlValue.PdoElementsToArray.ExcludeIndexString">
					<XPath Param0="PdoElementsToArray.TempXPath" Param1="PdoElementsToArray.PdoIndex" Param2="PdoElementsToArray.Cnt">{0}[{1}]/Index[{2}]</XPath>
				</GetXmlValue>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>debug_msg</Value2>
						<WriteLine Id="1" Level="Output" Param0="strXmlValue.PdoElementsToArray.ExcludeIndexString">Value of "strXmlValue.PdoElementsToArray.ExcludeIndexString": {0}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValue.PdoElementsToArray.ExcludeIndexString</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>INCREMENT_PDO</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValue.PdoElementsToArray.ExcludeIndexString</Value1>
						<Value2>null</Value2>
						<GotoStep>INCREMENT_PDO</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<GetXmlValue FileName="PdoElementsToArray.XmlFileXPath" Markup="false" ReturnValue="strXmlValue.PdoElementsToArray.Uint16">
					<XPath Param0="PdoElementsToArray.TempXPath" Param1="PdoElementsToArray.PdoIndex" Param2="PdoElementsToArray.Cnt">{0}[{1}]/Index[{2}]</XPath>
				</GetXmlValue>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>debug_msg</Value2>
						<WriteLine Id="2" Level="Output" Param0="strXmlValue.PdoElementsToArray.Uint16">Value of "strXmlValue.PdoElementsToArray.Uint16": {0}</WriteLine>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="ADDITEM">
				<!--Copy current Pdo index to array-->
				<AddArrayItem TargetArray="PdoElementsToArray.ui16Arr">strXmlValue.PdoElementsToArray.Uint16</AddArrayItem>
			</TestStep>
			<TestStep>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>debug_msg</Value2>
						<WriteLine Id="3" Level="Output" Param0="PdoElementsToArray.ui16Arr">Value of "PdoElementsToArray.ui16Arr": {0}</WriteLine>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="INCREMENT_INDEX">
				<!--Increment Index counter-->
				<SetVariable Target="PdoElementsToArray.Cnt">PdoElementsToArray.Cnt +1</SetVariable>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>LOOPSTART</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="INCREMENT_PDO">
				<!--Increment Pdo Counter-->
				<SetVariable Target="PdoElementsToArray.PdoIndex">PdoElementsToArray.PdoIndex+1</SetVariable>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>LOOPSTART_PDO</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="END">
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<Return Id="4"></Return>
					</Equal>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction Name="PdoExcludeElementsToArray_gen" FunctionId="20902">
			<?MAX_OUTPUT_ID 1?>
			<!--Create a Uint16 Array of defined Exclude elements-->
			<Parameter>
				<Name>PdoElementsToArray.Flag</Name>
				<Type>Bool</Type>
				<Comment>Flag to switch between Pdos (RxPdo - true, TxPdo - false)</Comment>
			</Parameter>
			<Parameter>
				<Name>ExcludeElementsToArray.XmlFileXPath</Name>
				<Type>String</Type>
				<Comment>XPath of XML file (local, external)</Comment>
			</Parameter>
			<Parameter>
				<Name>ExcludeElementsToArray.ModuleXPath</Name>
				<Type>String</Type>
				<Comment>XPath of Module</Comment>
			</Parameter>
			<Parameter>
				<Name>ExcludeElementsToArray.ModuleCount</Name>
				<Type>Int32</Type>
				<Comment>Module Count for XPath string</Comment>
			</Parameter>
			<Parameter>
				<Name>ExcludeElementsToArray.Index</Name>
				<Type>Int32</Type>
				<!--Zero based index of the Exclude elements-->
				<Comment>Exclude Count for XPath string</Comment>
			</Parameter>
			<LocalVariables>
				<Name>ExcludeElementsToArray.Cnt</Name>
				<Type>UInt16</Type>
				<!--temp counter variable-->
			</LocalVariables>
			<LocalVariables>
				<Name>xxx_ADD_BEGIN_xxx</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>strXmlValue.ExcludeElementsToArray.String</Name>
				<Type>String</Type>
				<!--Pdo-->
			</LocalVariables>
			<LocalVariables>
				<Name>strXmlValue.ExcludeElementsToArray.Uint16</Name>
				<Type>UInt16</Type>
				<!--Pdo Index-->
			</LocalVariables>
			<LocalVariables>
				<Name>ExcludeElementsToArray.TempXPath</Name>
				<Type>String</Type>
				<!--Temp XPath-->
			</LocalVariables>
			<LocalVariables>
				<Name>xxx_ADD_END_xxx</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<OutParameter>
				<Name>ExcludeElementsToArray.ui16Arr</Name>
				<Type>ArrayOfUInt16</Type>
			</OutParameter>
			<TestStep>
				<!--Init Array-->
				<InitArray TargetArray="ExcludeElementsToArray.ui16Arr"></InitArray>
			</TestStep>
			<TestStep>
				<!--Increase obtained list index to XPath index-->
				<SetVariable Target="ExcludeElementsToArray.Index">ExcludeElementsToArray.Index + 1</SetVariable>
			</TestStep>
			<TestStep>
				<!--Switch Between Pdos-->
				<Compare>
					<Equal>
						<Value1>PdoElementsToArray.Flag</Value1>
						<Value2>false</Value2>
						<GotoStep>XPath_TXPDO</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="XPath_RXPDO">
				<!--Build XPath for RxPdo elements-->
				<SetVariable Target="ExcludeElementsToArray.TempXPath" Param0="ExcludeElementsToArray.ModuleXPath" Param1="ExcludeElementsToArray.ModuleCount">{0}[{1}]/RxPdo</SetVariable>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>CHECK_EXCLUDE</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="XPath_TXPDO">
				<!--Build XPath for TxPdo elements-->
				<SetVariable Target="ExcludeElementsToArray.TempXPath" Param0="ExcludeElementsToArray.ModuleXPath" Param1="ExcludeElementsToArray.ModuleCount">{0}[{1}]/TxPdo</SetVariable>
			</TestStep>
			<TestStep Name="CHECK_EXCLUDE">
				<!--Check if Exclude elements are defined -->
				<GetXmlValue FileName="ExcludeElementsToArray.XmlFileXPath" Markup="false" ReturnValue="strXmlValue.ExcludeElementsToArray.String">
					<XPath Param0="ExcludeElementsToArray.TempXPath" Param1="ExcludeElementsToArray.Index">{0}[{1}]/Exclude</XPath>
				</GetXmlValue>
				<Compare>
					<Equal>
						<Value1>strXmlValue.ExcludeElementsToArray.String</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>END</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValue.ExcludeElementsToArray.String</Value1>
						<Value2>null</Value2>
						<GotoStep>END</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Init "ExcludeElementsToArray.Cnt" == 1-->
				<SetVariable Target="ExcludeElementsToArray.Cnt">1</SetVariable>
			</TestStep>
			<TestStep Name="LOOPSTART">
				<!--Check if Loop finished-->
				<GetXmlValue FileName="ExcludeElementsToArray.XmlFileXPath" Markup="false" ReturnValue="strXmlValue.ExcludeElementsToArray.String">
					<XPath Param0="ExcludeElementsToArray.TempXPath" Param1="ExcludeElementsToArray.Index" Param2="ExcludeElementsToArray.Cnt">{0}[{1}]/Exclude[{2}]</XPath>
				</GetXmlValue>
				<Compare>
					<Equal>
						<Value1>strXmlValue.ExcludeElementsToArray.String</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>END</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>strXmlValue.ExcludeElementsToArray.String</Value1>
						<Value2>null</Value2>
						<GotoStep>END</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<GetXmlValue FileName="ExcludeElementsToArray.XmlFileXPath" Markup="false" ReturnValue="strXmlValue.ExcludeElementsToArray.Uint16">
					<XPath Param0="ExcludeElementsToArray.TempXPath" Param1="ExcludeElementsToArray.Index" Param2="ExcludeElementsToArray.Cnt">{0}[{1}]/Exclude[{2}]</XPath>
				</GetXmlValue>
			</TestStep>
			<TestStep>
				<!--Copy current Exclude index to array-->
				<AddArrayItem TargetArray="ExcludeElementsToArray.ui16Arr">strXmlValue.ExcludeElementsToArray.Uint16</AddArrayItem>
			</TestStep>
			<TestStep Name="INCREMENT_COUNT">
				<!--Increment counter-->
				<SetVariable Target="ExcludeElementsToArray.Cnt">ExcludeElementsToArray.Cnt +1</SetVariable>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>LOOPSTART</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="END">
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>debug_msg</Value2>
						<WriteLine Id="0" Level="Output" Param0="ExcludeElementsToArray.ui16Arr">Elements of "ExcludeElementsToArray.ui16Arr": {0}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<Return Id="1"></Return>
					</Equal>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction Name="ReadEepromDataWordWise" FunctionId="2001">
			<?MAX_OUTPUT_ID 3?>
			<Description>
				<PreCondition>None</PreCondition>
				<Action>Reads the EEPROM data word wise via the SII</Action>
				<PostCondition>None</PostCondition>
				<References>
					<Reference Specification="ETG1000.6"></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>ReadEepromData.Int32WordLength</Name>
				<Type>Int32</Type>
				<Comment>No of words to be read</Comment>
			</Parameter>
			<Parameter>
				<Name>ReadEepromData.UInt16StartAddress</Name>
				<Type>UInt16</Type>
				<Comment>Start address</Comment>
			</Parameter>
			<LocalVariables>
				<Name>ReadEepromData.ByteAssignValue</Name>
				<Type>Byte</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>ReadEepromData.UInt16TmpData</Name>
				<Type>UInt16</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>ReadEepromData.Count</Name>
				<Type>Int32</Type>
			</LocalVariables>
			<OutParameter>
				<Name>ReadEepromData.ArrayUInt16Data</Name>
				<Type>ArrayOfUInt16</Type>
				<Comment>Return array</Comment>
			</OutParameter>
			<TestStep Name="SetEEPROmAssignValueToECAT">
				<SetVariable Target="ReadEepromData.ByteAssignValue">00</SetVariable>
			</TestStep>
			<TestStep Name="AssignEEPROMToECAT">
				<WriteEscData Source="ReadEepromData.ByteAssignValue">
					<Address>#x500</Address>
				</WriteEscData>
				<RaiseErrorOnFailure Id="0">Failed to assign EEPROM to ECAT</RaiseErrorOnFailure>
			</TestStep>
			<TestStep Name="ReadEepromValue">
				<ReadEEProm Target="ReadEepromData.UInt16TmpData">
					<Address>ReadEepromData.UInt16StartAddress</Address>
					<Length>2</Length>
				</ReadEEProm>
				<RaiseErrorOnFailure Id="1" Param0="ReadEepromData.UInt16StartAddress">TestFunction ReadEepronData: Failed to read data at address 0x{0:x4}</RaiseErrorOnFailure>
			</TestStep>
			<TestStep Name="AddValueToArray">
				<AddArrayItem TargetArray="ReadEepromData.ArrayUInt16Data">ReadEepromData.UInt16TmpData</AddArrayItem>
				<RaiseErrorOnFailure Id="2">Failed to add array item</RaiseErrorOnFailure>
			</TestStep>
			<TestStep Name="IncrementStartAddress">
				<SetVariable Target="ReadEepromData.UInt16StartAddress">ReadEepromData.UInt16StartAddress+1</SetVariable>
			</TestStep>
			<TestStep Name="IncrementReadCount">
				<SetVariable Target="ReadEepromData.Count">ReadEepromData.Count+1</SetVariable>
				<Compare>
					<NotEqual>
						<Value1>ReadEepromData.Count</Value1>
						<Value2>ReadEepromData.Int32WordLength</Value2>
						<GotoStep>ReadEepromValue</GotoStep>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="SetAssignValueBackToPDI">
				<SetVariable Target="ReadEepromData.ByteAssignValue">1</SetVariable>
			</TestStep>
			<TestStep Name="AssignEEPROMToPDI">
				<WriteEscData Source="ReadEepromData.ByteAssignValue">
					<Address>#x500</Address>
				</WriteEscData>
				<RaiseErrorOnFailure Id="3">Failed to assign EEPROM back to PDI</RaiseErrorOnFailure>
			</TestStep>
		</TestFunction>
		<TestFunction Name="RxCheckPdSmDefaultSize" FunctionId="2101">
			<?MAX_OUTPUT_ID 13?>
			<LocalVariables>
				<Name>RxCheckPdSmDefaultSize.Uint32CheckedSM</Name>
				<Type>UInt32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>RxCheckPdSmDefaultSize.uint32EntriesTotalBitLen</Name>
				<Type>UInt32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>RxCheckPdSmDefaultSize.uint16CurrSm</Name>
				<Type>UInt16</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>RxCheckPdSmDefaultSize.int32CurrEntry</Name>
				<Type>Int32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>RxCheckPdSmDefaultSize.int32SavedIndex</Name>
				<Type>Int32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>RxCheckPdSmDefaultSize.arrCheckedSM</Name>
				<Type>ArrayOfUInt16</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>RxCheckPdSmDefaultSize.int32CurrPdo</Name>
				<Type>Int32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>RxCheckPdSmDefaultSize.boolSMTested</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>RxCheckPdSmDefaultSize.boolEntriesFound</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>RxCheckPdSmDefaultSize.uint16Errors</Name>
				<Type>UInt16</Type>
			</LocalVariables>
			<OutParameter>
				<Name>RxCheckPdSmDefaultSize.uint16AllErrors</Name>
				<Type>UInt16</Type>
			</OutParameter>
			<TestStep Name="CheckRxPdoCount">
				<Compare>
					<Equal>
						<Value1>DeviceDescr.RxPdo.Count</Value1>
						<Value2>0</Value2>
						<Return Id="0">RxCheckPdSmDefaultSize: Device does not have RxPDO entr(y/ies).</Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CheckEntryExistence">
				<Compare>
					<Equal>
						<Value1>DeviceDescr.RxPdo[RxCheckPdSmDefaultSize.int32CurrPdo].Entry.Count</Value1>
						<Value2>0</Value2>
						<GotoStep>IncrementSavedIndexCheckNextSm</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="SetEntriesFound">
				<SetVariable Target="RxCheckPdSmDefaultSize.boolEntriesFound">true</SetVariable>
			</TestStep>
			<TestStep Name="GetPdoDefaultSm">
				<Description Id="1" Level="Verbose" Param0="DeviceDescr.RxPdo[RxCheckPdSmDefaultSize.int32CurrPdo].Index">RxCheckPdSmDefaultSize: Checking default size of assigned PDO Object 0x{0:x4}.</Description>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.RxPdo[RxCheckPdSmDefaultSize.int32CurrPdo].Sm</Value1>
						<Value2>null</Value2>
						<GotoStep>CheckIfMandatory</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="GetSm">
				<SetVariable Target="RxCheckPdSmDefaultSize.uint16CurrSm">DeviceDescr.RxPdo[RxCheckPdSmDefaultSize.int32CurrPdo].Sm</SetVariable>
			</TestStep>
			<TestStep Name="CheckSmAlreadyTested">
				<CallTestFunction Name="CheckItemInArray">
					<Parameter>RxCheckPdSmDefaultSize.arrCheckedSM</Parameter>
					<Parameter>RxCheckPdSmDefaultSize.uint16CurrSm</Parameter>
					<OutParameter>RxCheckPdSmDefaultSize.boolSMTested</OutParameter>
				</CallTestFunction>
			</TestStep>
			<TestStep Name="CheckSmIsValid">
				<Compare>
					<GreaterOrEqual>
						<Value1>RxCheckPdSmDefaultSize.uint16CurrSm</Value1>
						<Value2>DeviceDescr.SM.Count</Value2>
						<GotoStep>WriteErrorNotExists</GotoStep>
					</GreaterOrEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>RxCheckPdSmDefaultSize.boolSMTested</Value1>
						<Value2>true</Value2>
						<WriteLine Id="2" Level="Verbose" Param0="RxCheckPdSmDefaultSize.uint16CurrSm">RxCheckPdSmDefaultSize: Sync manager {0} already checked. </WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>RxCheckPdSmDefaultSize.boolSMTested</Value1>
						<Value2>true</Value2>
						<GotoStep>IncrementSavedIndexCheckNextSm</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>DeviceDescr.SM[RxCheckPdSmDefaultSize.uint16CurrSm]</Value1>
						<Value2>Outputs</Value2>
						<GotoStep>WriteErrorWrongSmDesc</GotoStep>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.SM[RxCheckPdSmDefaultSize.uint16CurrSm].DefaultSize</Value1>
						<Value2>null</Value2>
						<GotoStep>AddToCheckedSmAndCheckNext</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>DeviceDescr.RxPdo[RxCheckPdSmDefaultSize.int32CurrPdo].Entry.Count</Value1>
						<Value2>0</Value2>
						<GotoStep>SaveCurrIndexAtStart</GotoStep>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>IncrementPdoIndex</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="SaveCurrIndexAtStart">
				<SetVariable Target="RxCheckPdSmDefaultSize.int32SavedIndex">RxCheckPdSmDefaultSize.int32CurrPdo</SetVariable>
			</TestStep>
			<TestStep Name="WriteDescPdoAssign">
				<Compare>
					<Equal>
						<Value1>RxCheckPdSmDefaultSize.int32CurrEntry</Value1>
						<Value2>0</Value2>
						<WriteLine Id="3" Level="Verbose" Param0="DeviceDescr.RxPdo[RxCheckPdSmDefaultSize.int32CurrPdo].Index" Param1="DeviceDescr.RxPdo[RxCheckPdSmDefaultSize.int32CurrPdo].Sm">RxCheckPdSmDefaultSize: PDO Object 0x{0:x4} is assigned to SM {1}.</WriteLine>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CheckCounts">
				<Compare>
					<GreaterOrEqual>
						<Value1>RxCheckPdSmDefaultSize.int32CurrPdo</Value1>
						<Value2>DeviceDescr.RxPdo.Count</Value2>
						<GotoStep>AddSmToTestedArray</GotoStep>
					</GreaterOrEqual>
				</Compare>
				<Compare>
					<GreaterOrEqual>
						<Value1>RxCheckPdSmDefaultSize.int32CurrEntry</Value1>
						<Value2>DeviceDescr.RxPdo[RxCheckPdSmDefaultSize.int32CurrPdo].Entry.Count</Value2>
						<GotoStep>IncrementPdoIndex</GotoStep>
					</GreaterOrEqual>
				</Compare>
			</TestStep>
			<TestStep Name="AddToTotalBitLen">
				<SetVariable Target="RxCheckPdSmDefaultSize.uint32EntriesTotalBitLen">RxCheckPdSmDefaultSize.uint32EntriesTotalBitLen+DeviceDescr.RxPdo[RxCheckPdSmDefaultSize.int32CurrPdo].Entry[RxCheckPdSmDefaultSize.int32CurrEntry].BitLen</SetVariable>
			</TestStep>
			<TestStep Name="CheckForGap">
				<Compare>
					<Equal>
						<Value1>DeviceDescr.RxPdo[RxCheckPdSmDefaultSize.int32CurrPdo].Entry[RxCheckPdSmDefaultSize.int32CurrEntry].Index</Value1>
						<Value2>0</Value2>
						<WriteLine Id="4" Level="Verbose" Param0="DeviceDescr.RxPdo[RxCheckPdSmDefaultSize.int32CurrPdo].Index" Param1="RxCheckPdSmDefaultSize.int32CurrEntry" Param2="DeviceDescr.RxPdo[RxCheckPdSmDefaultSize.int32CurrPdo].Entry[RxCheckPdSmDefaultSize.int32CurrEntry].BitLen" Param3="RxCheckPdSmDefaultSize.uint32EntriesTotalBitLen">RxCheckPdSmDefaultSize: PDO 0x{0:x4}:{1} is gap entry ({2}). Total Bit Length: {3}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.RxPdo[RxCheckPdSmDefaultSize.int32CurrPdo].Entry[RxCheckPdSmDefaultSize.int32CurrEntry].Index</Value1>
						<Value2>0</Value2>
						<GotoStep>IncrementEntryIndex</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="WriteEntryBitLen">
				<WriteLine Id="5" Level="Verbose" Param0="DeviceDescr.RxPdo[RxCheckPdSmDefaultSize.int32CurrPdo].Index" Param1="RxCheckPdSmDefaultSize.int32CurrEntry" Param2="DeviceDescr.RxPdo[RxCheckPdSmDefaultSize.int32CurrPdo].Entry[RxCheckPdSmDefaultSize.int32CurrEntry].BitLen" Param3="RxCheckPdSmDefaultSize.uint32EntriesTotalBitLen">RxCheckPdSmDefaultSize: PDO Entry 0x{0:x4}:{1} has a Bit Length of {2} Bit. Total Bit Length: {3}</WriteLine>
			</TestStep>
			<TestStep Name="IncrementEntryIndex">
				<SetVariable Target="RxCheckPdSmDefaultSize.int32CurrEntry">RxCheckPdSmDefaultSize.int32CurrEntry+1</SetVariable>
			</TestStep>
			<TestStep Name="CheckEntryCount">
				<Compare>
					<Lower>
						<Value1>RxCheckPdSmDefaultSize.int32CurrEntry</Value1>
						<Value2>DeviceDescr.RxPdo[RxCheckPdSmDefaultSize.int32CurrPdo].Entry.Count</Value2>
						<GotoStep>WriteDescPdoAssign</GotoStep>
					</Lower>
				</Compare>
			</TestStep>
			<TestStep Name="IncrementPdoIndex">
				<SetVariable Target="RxCheckPdSmDefaultSize.int32CurrPdo">RxCheckPdSmDefaultSize.int32CurrPdo+1</SetVariable>
			</TestStep>
			<TestStep Name="ResetEntryIndex">
				<SetVariable Target="RxCheckPdSmDefaultSize.int32CurrEntry">0</SetVariable>
			</TestStep>
			<TestStep Name="CheckPdoCount">
				<Compare>
					<GreaterOrEqual>
						<Value1>RxCheckPdSmDefaultSize.int32CurrPdo</Value1>
						<Value2>DeviceDescr.RxPdo.Count</Value2>
						<GotoStep>AddSmToTestedArray</GotoStep>
					</GreaterOrEqual>
				</Compare>
			</TestStep>
			<TestStep Name="ValidateSm">
				<Compare>
					<NotEqual>
						<Value1>DeviceDescr.SM[RxCheckPdSmDefaultSize.uint16CurrSm]</Value1>
						<Value2>Outputs</Value2>
						<GotoStep>WriteErrorWrongSmDesc</GotoStep>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.SM[RxCheckPdSmDefaultSize.uint16CurrSm].DefaultSize</Value1>
						<Value2>null</Value2>
						<GotoStep>AddToCheckedSmAndCheckNext</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.RxPdo[RxCheckPdSmDefaultSize.int32CurrPdo].Sm</Value1>
						<Value2>null</Value2>
						<GotoStep>IncrementPdoIndex</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.RxPdo[RxCheckPdSmDefaultSize.int32CurrPdo].Sm</Value1>
						<Value2>RxCheckPdSmDefaultSize.uint16CurrSm</Value2>
						<GotoStep>WriteDescPdoAssign</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>DeviceDescr.RxPdo[RxCheckPdSmDefaultSize.int32CurrPdo].Sm</Value1>
						<Value2>RxCheckPdSmDefaultSize.uint16CurrSm</Value2>
						<GotoStep>IncrementPdoIndex</GotoStep>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="AddSmToTestedArray">
				<AddArrayItem TargetArray="RxCheckPdSmDefaultSize.arrCheckedSM">RxCheckPdSmDefaultSize.uint16CurrSm</AddArrayItem>
			</TestStep>
			<TestStep Name="CheckBitSizeSm">
				<SetVariable Target="RxCheckPdSmDefaultSize.uint32EntriesTotalBitLen">RxCheckPdSmDefaultSize.uint32EntriesTotalBitLen+7</SetVariable>
			</TestStep>
			<TestStep Name="RoundBitSize">
				<SetVariable Target="RxCheckPdSmDefaultSize.uint32EntriesTotalBitLen">RxCheckPdSmDefaultSize.uint32EntriesTotalBitLen/8</SetVariable>
			</TestStep>
			<TestStep Name="CheckSyncManager">
				<Compare>
					<Equal>
						<Value1>DeviceDescr.SM[RxCheckPdSmDefaultSize.uint16CurrSm].DefaultSize</Value1>
						<Value2>null</Value2>
						<GotoStep>AddToCheckedSmAndCheckNext</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>RxCheckPdSmDefaultSize.uint32EntriesTotalBitLen</Value1>
						<Value2>DeviceDescr.SM[RxCheckPdSmDefaultSize.uint16CurrSm].DefaultSize</Value2>
						<WriteLine Id="6" Level="Output" Param0="RxCheckPdSmDefaultSize.uint16CurrSm" Param1="RxCheckPdSmDefaultSize.uint32EntriesTotalBitLen" Param2="DeviceDescr.SM[RxCheckPdSmDefaultSize.uint16CurrSm].DefaultSize">RxCheckPdSmDefaultSize: Sync Manager {0} has the right Default Size ({2}).</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>RxCheckPdSmDefaultSize.uint32EntriesTotalBitLen</Value1>
						<Value2>DeviceDescr.SM[RxCheckPdSmDefaultSize.uint16CurrSm].DefaultSize</Value2>
						<WriteLine Id="7" Level="Error" Param0="RxCheckPdSmDefaultSize.uint16CurrSm" Param1="RxCheckPdSmDefaultSize.uint32EntriesTotalBitLen" Param2="DeviceDescr.SM[RxCheckPdSmDefaultSize.uint16CurrSm].DefaultSize">RxCheckPdSmDefaultSize: Sync Manager {0} default size({2}) is wrong (shall be {1}).</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>RxCheckPdSmDefaultSize.uint32EntriesTotalBitLen</Value1>
						<Value2>DeviceDescr.SM[RxCheckPdSmDefaultSize.uint16CurrSm].DefaultSize</Value2>
						<SetVariable Target="RxCheckPdSmDefaultSize.uint16AllErrors">RxCheckPdSmDefaultSize.uint16AllErrors+1</SetVariable>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<SetVariable Target="RxCheckPdSmDefaultSize.uint32EntriesTotalBitLen">0</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="IncrementSavedIndexCheckNextSm">
				<SetVariable Target="RxCheckPdSmDefaultSize.int32SavedIndex">RxCheckPdSmDefaultSize.int32SavedIndex+1</SetVariable>
			</TestStep>
			<TestStep Name="SetToNextPdo">
				<SetVariable Target="RxCheckPdSmDefaultSize.int32CurrPdo">RxCheckPdSmDefaultSize.int32SavedIndex</SetVariable>
			</TestStep>
			<TestStep Name="CheckIfFinished">
				<Compare>
					<Lower>
						<Value1>RxCheckPdSmDefaultSize.int32SavedIndex</Value1>
						<Value2>DeviceDescr.RxPdo.Count</Value2>
						<GotoStep>CheckEntryExistence</GotoStep>
					</Lower>
				</Compare>
			</TestStep>
			<TestStep Name="ResetPdoIndexForFinish">
				<SetVariable Target="RxCheckPdSmDefaultSize.int32CurrPdo">0</SetVariable>
			</TestStep>
			<TestStep Name="CheckRemaining">
				<CallTestFunction Name="CheckRemainingSm">
					<Parameter>true</Parameter>
					<Parameter>RxCheckPdSmDefaultSize.arrCheckedSM</Parameter>
					<OutParameter>RxCheckPdSmDefaultSize.uint16Errors</OutParameter>
				</CallTestFunction>
			</TestStep>
			<TestStep Name="AddErrorCount">
				<SetVariable Target="RxCheckPdSmDefaultSize.uint16AllErrors">RxCheckPdSmDefaultSize.uint16AllErrors+RxCheckPdSmDefaultSize.uint16Errors</SetVariable>
			</TestStep>
			<TestStep Name="ReturnResult">
				<SizeOf UInt32Var="RxCheckPdSmDefaultSize.Uint32CheckedSM">RxCheckPdSmDefaultSize.arrCheckedSM</SizeOf>
				<Compare>
					<Equal>
						<Value1>RxCheckPdSmDefaultSize.boolEntriesFound</Value1>
						<Value2>false</Value2>
						<SkipCase Id="8">Skipped case: No entry found.</SkipCase>
					</Equal>
				</Compare>
				<Compare>
					<Greater>
						<Value1>RxCheckPdSmDefaultSize.Uint32CheckedSM</Value1>
						<Value2>0</Value2>
						<Return Id="9" Param0="RxCheckPdSmDefaultSize.Uint32CheckedSM">RxCheckPdSmDefaultSize: Checked {0} assigned sync manager.</Return>
					</Greater>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<Return Id="10">RxCheckPdSmDefaultSize: No assigned sync managers found.</Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="WriteErrorWrongSmDesc">
				<SetVariable Target="RxCheckPdSmDefaultSize.uint16AllErrors">RxCheckPdSmDefaultSize.uint16AllErrors+1</SetVariable>
				<WriteLine Id="11" Level="Error" Param0="RxCheckPdSmDefaultSize.uint16CurrSm" Param1="DeviceDescr.SM[RxCheckPdSmDefaultSize.uint16CurrSm]">RxCheckPdSmDefaultSize: Sync Manager {0} ({1}) has the wrong description.</WriteLine>
			</TestStep>
			<TestStep Name="AddToCheckedSmAndCheckNext">
				<AddArrayItem TargetArray="RxCheckPdSmDefaultSize.arrCheckedSM">RxCheckPdSmDefaultSize.uint16CurrSm</AddArrayItem>
			</TestStep>
			<TestStep Name="ResetTotalBitLen">
				<SetVariable Target="RxCheckPdSmDefaultSize.uint32EntriesTotalBitLen">0</SetVariable>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>IncrementSavedIndexCheckNextSm</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="WriteErrorNotExists">
				<SetVariable Target="RxCheckPdSmDefaultSize.uint16AllErrors">RxCheckPdSmDefaultSize.uint16AllErrors+1</SetVariable>
				<WriteLine Id="12" Level="Error" Param0="RxCheckPdSmDefaultSize.uint16CurrSm">RxCheckPdSmDefaultSize: Sync Manager {0} is assigned but does not exist.</WriteLine>
			</TestStep>
			<TestStep Name="AddToCheckedSmAndCheckNext2">
				<AddArrayItem TargetArray="RxCheckPdSmDefaultSize.arrCheckedSM">RxCheckPdSmDefaultSize.uint16CurrSm</AddArrayItem>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>IncrementSavedIndexCheckNextSm</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CheckIfMandatory">
				<Compare>
					<Equal>
						<Value1>DeviceDescr.RxPdo[RxCheckPdSmDefaultSize.int32CurrPdo].Mandatory</Value1>
						<Value2>false</Value2>
						<GotoStep>IncrementSavedIndexCheckNextSm</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="WriteErrorIsMandatory">
				<SetVariable Target="RxCheckPdSmDefaultSize.uint16AllErrors">RxCheckPdSmDefaultSize.uint16AllErrors+1</SetVariable>
				<WriteLine Id="13" Level="Error" Param0="DeviceDescr.RxPdo[RxCheckPdSmDefaultSize.int32CurrPdo].Index">RxCheckPdSmDefaultSize: Sync Manager of Pdo 0x{0:x4} is mandatory but not assigned.</WriteLine>
			</TestStep>
			<TestStep Name="CheckNextPdo">
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>IncrementSavedIndexCheckNextSm</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction Name="RxPdoElementsToArray" FunctionId="2201">
			<?MAX_OUTPUT_ID 1?>
			<!--Create a Uint16 Array of defined RxPdo Indices-->
			<LocalVariables>
				<Name>RxPdoElementsToArray.Cnt</Name>
				<Type>UInt16</Type>
				<!--temp counter variable-->
			</LocalVariables>
			<OutParameter>
				<Name>RxPdoElementsToArray.ui16Arr</Name>
				<Type>ArrayOfUInt16</Type>
			</OutParameter>
			<TestStep>
				<!--Check if RxPdo elements are defined -->
				<Compare>
					<Equal>
						<Value1>DeviceDescr.RxPdo.Count</Value1>
						<Value2>0</Value2>
						<Return Id="0"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<SetVariable Target="RxPdoElementsToArray.Cnt">0</SetVariable>
			</TestStep>
			<TestStep Name="LOOPSTART">
				<!--Check if Loop finished-->
				<Compare>
					<GreaterOrEqual>
						<Value1>RxPdoElementsToArray.Cnt</Value1>
						<Value2>DeviceDescr.RxPdo.Count</Value2>
						<Return Id="1"></Return>
					</GreaterOrEqual>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Copy current RxPdo index to array-->
				<AddArrayItem TargetArray="RxPdoElementsToArray.ui16Arr">DeviceDescr.RxPdo[RxPdoElementsToArray.Cnt].Index</AddArrayItem>
			</TestStep>
			<TestStep>
				<!--Increment counter-->
				<SetVariable Target="RxPdoElementsToArray.Cnt">RxPdoElementsToArray.Cnt +1</SetVariable>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>LOOPSTART</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction Name="SetEsmTimeouts" FunctionId="2402">
			<?MAX_OUTPUT_ID 2?>
			<TestStep Name="SetPreOpTimeout">
				<CallTestFunction Name="SetPreOpTimeout">
					<Parameter>Settings.bAll_debugMsg</Parameter>
					<OutParameter>preOPTimeout</OutParameter>
				</CallTestFunction>
			</TestStep>
			<TestStep Name="SetSafeOpTimeout">
				<CallTestFunction Name="SetSafeOpTimeout">
					<Parameter>Settings.bAll_debugMsg</Parameter>
					<OutParameter>safeOPTimeout</OutParameter>
				</CallTestFunction>
			</TestStep>
			<TestStep Name="SetBackSafeOpTimeout">
				<CallTestFunction Name="SetBackSafeOpTimeout">
					<Parameter>Settings.bAll_debugMsg</Parameter>
					<OutParameter>backSafeOPTimeout</OutParameter>
				</CallTestFunction>
			</TestStep>
			<TestStep Name="SetBackInitTimeout">
				<CallTestFunction Name="SetBackInitTimeout">
					<Parameter>Settings.bAll_debugMsg</Parameter>
					<OutParameter>backInitTimeout</OutParameter>
				</CallTestFunction>
			</TestStep>
			<TestStep Name="WriteTimeoutsToLogger">
				<WriteLine Id="0" Level="Verbose" Param0="preOPTimeout" Param1="safeOPTimeout" Param2="backSafeOPTimeout" Param3="backInitTimeout">ESM timeouts in [ms] | preOPTimeout = {0} | safeOPTimeout = {1} | backSafeOPTimeout = {2} | backInitTimeout = {3}</WriteLine>
			</TestStep>
			<TestStep Name="CHECK_IF_TIMEOUTS_OVERWRITTEN_BY_SETTINS">
				<Compare>
					<Equal>
						<Value1>Settings.bAll_esm_overwriteTimeouts</Value1>
						<Value2>false</Value2>
						<Return Id="1"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="overwrite_preOPTimeout">
				<!--Set ESI timeout values

Init-> PreOp
Boot->Init-->
				<SetVariable Target="preOPTimeout">Settings.int32_all_esm_preOPTimeout</SetVariable>
			</TestStep>
			<TestStep Name="overwrite_safeOPTimeout">
				<!--SafeOp -> Op
PreOp -> SafeOp-->
				<SetVariable Target="safeOPTimeout">Settings.int32_all_esm_safeOPTimeout</SetVariable>
			</TestStep>
			<TestStep Name="overwrite_backSafeOPTimeout">
				<!--Op -> Safeop-->
				<SetVariable Target="backSafeOPTimeout">Settings.int32_all_esm_backSafeOPTimeout</SetVariable>
			</TestStep>
			<TestStep Name="overwrite_backInitTimeout">
				<!--Op/SafeOp->Init
SafeOp->Preop-->
				<SetVariable Target="backInitTimeout">Settings.int32_all_esm_backInitTimeout</SetVariable>
				<Compare>
					<Equal>
						<Value1>Settings.bAll_debugMsg</Value1>
						<Value2>true</Value2>
						<WriteLine Id="2" Param0="Settings.int32_all_esm_preOPTimeout" Param1="Settings.int32_all_esm_safeOPTimeout" Param2="Settings.int32_all_esm_backSafeOPTimeout" Param3="Settings.int32_all_esm_backInitTimeout">ESM Timeouts (partly) overwritten by settings dialog value | preOPTimeout = {0} | safeOPTimeout = {1} | backSafeOPTimeout = {2} | backInitTimeout = {3}</WriteLine>
					</Equal>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction Name="SetMbxTimeouts" FunctionId="2301">
			<?MAX_OUTPUT_ID 1?>
			<TestStep>
				<SetVariable Target="mbxResTimeout">3000</SetVariable>
			</TestStep>
			<TestStep>
				<SetVariable Target="mbxReqTimeout">1000</SetVariable>
			</TestStep>
			<TestStep>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Info</Value1>
						<Value2>false</Value2>
						<Return Id="0" Param0="DeviceDescr.Info">Device:Info {0}. The default timeouts will be used</Return>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Info.Mailbox</Value1>
						<Value2>false</Value2>
						<Return Id="1" Param0="DeviceDescr.Info.Mailbox">Device:Info:Mailbox {0}. The default timeouts will be used</Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<SetVariable Target="mbxResTimeout">DeviceDescr.Info.Mailbox.ResponseTimeout</SetVariable>
			</TestStep>
			<TestStep>
				<SetVariable Target="mbxReqTimeout">DeviceDescr.Info.Mailbox.RequestTimeout</SetVariable>
			</TestStep>
		</TestFunction>
		<TestFunction Name="SetStateMachTimeouts" FunctionId="2401">
			<?MAX_OUTPUT_ID 1?>
			<TestStep>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Info</Value1>
						<Value2>false</Value2>
						<Return Id="0"></Return>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Info.StateMachine.Timeout</Value1>
						<Value2>false</Value2>
						<Return Id="1"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<SetVariable Target="t_preopTimeout">DeviceDescr.Info.StateMachine.Timeout.PreopTimeout</SetVariable>
			</TestStep>
		</TestFunction>
		<TestFunction Name="TxCheckPdSmDefaultSize" FunctionId="2501">
			<?MAX_OUTPUT_ID 13?>
			<LocalVariables>
				<Name>TxCheckPdSmDefaultSize.Uint32CheckedSM</Name>
				<Type>UInt32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>TxCheckPdSmDefaultSize.uint32EntriesTotalBitLen</Name>
				<Type>UInt32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>TxCheckPdSmDefaultSize.uint16CurrSm</Name>
				<Type>UInt16</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>TxCheckPdSmDefaultSize.int32CurrEntry</Name>
				<Type>Int32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>TxCheckPdSmDefaultSize.int32SavedIndex</Name>
				<Type>Int32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>TxCheckPdSmDefaultSize.arrCheckedSM</Name>
				<Type>ArrayOfUInt16</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>TxCheckPdSmDefaultSize.int32CurrPdo</Name>
				<Type>Int32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>TxCheckPdSmDefaultSize.boolSMTested</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>TxCheckPdSmDefaultSize.boolEntriesFound</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>TxCheckPdSmDefaultSize.uint16Errors</Name>
				<Type>UInt16</Type>
			</LocalVariables>
			<OutParameter>
				<Name>TxCheckPdSmDefaultSize.uint16AllErrors</Name>
				<Type>UInt16</Type>
			</OutParameter>
			<TestStep Name="CheckTxPdoCount">
				<Compare>
					<Equal>
						<Value1>DeviceDescr.TxPdo.Count</Value1>
						<Value2>0</Value2>
						<Return Id="0">TxCheckPdSmDefaultSize: Device does not have TxPDO entr(y/ies).</Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CheckEntryExistence">
				<Compare>
					<Equal>
						<Value1>DeviceDescr.TxPdo[TxCheckPdSmDefaultSize.int32CurrPdo].Entry.Count</Value1>
						<Value2>0</Value2>
						<GotoStep>IncrementSavedIndexCheckNextSm</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="SetEntriesFound">
				<SetVariable Target="TxCheckPdSmDefaultSize.boolEntriesFound">true</SetVariable>
			</TestStep>
			<TestStep Name="GetPdoDefaultSm">
				<Description Id="1" Level="Verbose" Param0="DeviceDescr.TxPdo[TxCheckPdSmDefaultSize.int32CurrPdo].Index">TxCheckPdSmDefaultSize: Checking default size of assigned PDO Object 0x{0:x4}.</Description>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.TxPdo[TxCheckPdSmDefaultSize.int32CurrPdo].Sm</Value1>
						<Value2>null</Value2>
						<GotoStep>CheckIfMandatory</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="GetSm">
				<SetVariable Target="TxCheckPdSmDefaultSize.uint16CurrSm">DeviceDescr.TxPdo[TxCheckPdSmDefaultSize.int32CurrPdo].Sm</SetVariable>
			</TestStep>
			<TestStep Name="CheckSmAlreadyTested">
				<CallTestFunction Name="CheckItemInArray">
					<Parameter>TxCheckPdSmDefaultSize.arrCheckedSM</Parameter>
					<Parameter>TxCheckPdSmDefaultSize.uint16CurrSm</Parameter>
					<OutParameter>TxCheckPdSmDefaultSize.boolSMTested</OutParameter>
				</CallTestFunction>
			</TestStep>
			<TestStep Name="CheckSmIsValid">
				<Compare>
					<GreaterOrEqual>
						<Value1>TxCheckPdSmDefaultSize.uint16CurrSm</Value1>
						<Value2>DeviceDescr.SM.Count</Value2>
						<GotoStep>WriteErrorNotExists</GotoStep>
					</GreaterOrEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>TxCheckPdSmDefaultSize.boolSMTested</Value1>
						<Value2>true</Value2>
						<WriteLine Id="2" Level="Verbose" Param0="TxCheckPdSmDefaultSize.uint16CurrSm">TxCheckPdSmDefaultSize: Sync manager {0} already checked.</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>TxCheckPdSmDefaultSize.boolSMTested</Value1>
						<Value2>true</Value2>
						<GotoStep>IncrementSavedIndexCheckNextSm</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>DeviceDescr.SM[TxCheckPdSmDefaultSize.uint16CurrSm]</Value1>
						<Value2>Inputs</Value2>
						<GotoStep>WriteErrorWrongSmDesc</GotoStep>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.SM[TxCheckPdSmDefaultSize.uint16CurrSm].DefaultSize</Value1>
						<Value2>null</Value2>
						<GotoStep>AddToCheckedSmAndCheckNext</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>DeviceDescr.TxPdo[TxCheckPdSmDefaultSize.int32CurrPdo].Entry.Count</Value1>
						<Value2>0</Value2>
						<GotoStep>SaveCurrIndexAtStart</GotoStep>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>IncrementPdoIndex</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="SaveCurrIndexAtStart">
				<SetVariable Target="TxCheckPdSmDefaultSize.int32SavedIndex">TxCheckPdSmDefaultSize.int32CurrPdo</SetVariable>
			</TestStep>
			<TestStep Name="WriteDescPdoAssign">
				<Compare>
					<Equal>
						<Value1>TxCheckPdSmDefaultSize.int32CurrEntry</Value1>
						<Value2>0</Value2>
						<WriteLine Id="3" Level="Verbose" Param0="DeviceDescr.TxPdo[TxCheckPdSmDefaultSize.int32CurrPdo].Index" Param1="DeviceDescr.TxPdo[TxCheckPdSmDefaultSize.int32CurrPdo].Sm">TxCheckPdSmDefaultSize: PDO Object 0x{0:x4} is assigned to SM {1}.</WriteLine>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CheckCounts">
				<Compare>
					<GreaterOrEqual>
						<Value1>TxCheckPdSmDefaultSize.int32CurrPdo</Value1>
						<Value2>DeviceDescr.TxPdo.Count</Value2>
						<GotoStep>AddSmToTestedArray</GotoStep>
					</GreaterOrEqual>
				</Compare>
				<Compare>
					<GreaterOrEqual>
						<Value1>TxCheckPdSmDefaultSize.int32CurrEntry</Value1>
						<Value2>DeviceDescr.TxPdo[TxCheckPdSmDefaultSize.int32CurrPdo].Entry.Count</Value2>
						<GotoStep>IncrementPdoIndex</GotoStep>
					</GreaterOrEqual>
				</Compare>
			</TestStep>
			<TestStep Name="AddToTotalBitLen">
				<SetVariable Target="TxCheckPdSmDefaultSize.uint32EntriesTotalBitLen">TxCheckPdSmDefaultSize.uint32EntriesTotalBitLen+DeviceDescr.TxPdo[TxCheckPdSmDefaultSize.int32CurrPdo].Entry[TxCheckPdSmDefaultSize.int32CurrEntry].BitLen</SetVariable>
			</TestStep>
			<TestStep Name="CheckForGap">
				<Compare>
					<Equal>
						<Value1>DeviceDescr.TxPdo[TxCheckPdSmDefaultSize.int32CurrPdo].Entry[TxCheckPdSmDefaultSize.int32CurrEntry].Index</Value1>
						<Value2>0</Value2>
						<WriteLine Id="4" Level="Verbose" Param0="DeviceDescr.TxPdo[TxCheckPdSmDefaultSize.int32CurrPdo].Index" Param1="TxCheckPdSmDefaultSize.int32CurrEntry" Param2="DeviceDescr.TxPdo[TxCheckPdSmDefaultSize.int32CurrPdo].Entry[TxCheckPdSmDefaultSize.int32CurrEntry].BitLen" Param3="TxCheckPdSmDefaultSize.uint32EntriesTotalBitLen">TxCheckPdSmDefaultSize: PDO 0x{0:x4}:{1} is gap entry ({2}). Total Bit Length: {3}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.TxPdo[TxCheckPdSmDefaultSize.int32CurrPdo].Entry[TxCheckPdSmDefaultSize.int32CurrEntry].Index</Value1>
						<Value2>0</Value2>
						<GotoStep>IncrementEntryIndex</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="WriteEntryBitLen">
				<WriteLine Id="5" Level="Verbose" Param0="DeviceDescr.TxPdo[TxCheckPdSmDefaultSize.int32CurrPdo].Index" Param1="TxCheckPdSmDefaultSize.int32CurrEntry" Param2="DeviceDescr.TxPdo[TxCheckPdSmDefaultSize.int32CurrPdo].Entry[TxCheckPdSmDefaultSize.int32CurrEntry].BitLen" Param3="TxCheckPdSmDefaultSize.uint32EntriesTotalBitLen">TxCheckPdSmDefaultSize: PDO Entry 0x{0:x4}:{1} has a Bit Length of {2} Bit. Total Bit Length: {3}</WriteLine>
			</TestStep>
			<TestStep Name="IncrementEntryIndex">
				<SetVariable Target="TxCheckPdSmDefaultSize.int32CurrEntry">TxCheckPdSmDefaultSize.int32CurrEntry+1</SetVariable>
			</TestStep>
			<TestStep Name="CheckEntryCount">
				<Compare>
					<Lower>
						<Value1>TxCheckPdSmDefaultSize.int32CurrEntry</Value1>
						<Value2>DeviceDescr.TxPdo[TxCheckPdSmDefaultSize.int32CurrPdo].Entry.Count</Value2>
						<GotoStep>WriteDescPdoAssign</GotoStep>
					</Lower>
				</Compare>
			</TestStep>
			<TestStep Name="IncrementPdoIndex">
				<SetVariable Target="TxCheckPdSmDefaultSize.int32CurrPdo">TxCheckPdSmDefaultSize.int32CurrPdo+1</SetVariable>
			</TestStep>
			<TestStep Name="ResetEntryIndex">
				<SetVariable Target="TxCheckPdSmDefaultSize.int32CurrEntry">0</SetVariable>
			</TestStep>
			<TestStep Name="CheckPdoCount">
				<Compare>
					<GreaterOrEqual>
						<Value1>TxCheckPdSmDefaultSize.int32CurrPdo</Value1>
						<Value2>DeviceDescr.TxPdo.Count</Value2>
						<GotoStep>AddSmToTestedArray</GotoStep>
					</GreaterOrEqual>
				</Compare>
			</TestStep>
			<TestStep Name="ValidateSm">
				<Compare>
					<NotEqual>
						<Value1>DeviceDescr.SM[TxCheckPdSmDefaultSize.uint16CurrSm]</Value1>
						<Value2>Inputs</Value2>
						<GotoStep>WriteErrorWrongSmDesc</GotoStep>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.SM[TxCheckPdSmDefaultSize.uint16CurrSm].DefaultSize</Value1>
						<Value2>null</Value2>
						<GotoStep>AddToCheckedSmAndCheckNext</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.TxPdo[TxCheckPdSmDefaultSize.int32CurrPdo].Sm</Value1>
						<Value2>null</Value2>
						<GotoStep>IncrementPdoIndex</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.TxPdo[TxCheckPdSmDefaultSize.int32CurrPdo].Sm</Value1>
						<Value2>TxCheckPdSmDefaultSize.uint16CurrSm</Value2>
						<GotoStep>WriteDescPdoAssign</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>DeviceDescr.TxPdo[TxCheckPdSmDefaultSize.int32CurrPdo].Sm</Value1>
						<Value2>TxCheckPdSmDefaultSize.uint16CurrSm</Value2>
						<GotoStep>IncrementPdoIndex</GotoStep>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="AddSmToTestedArray">
				<AddArrayItem TargetArray="TxCheckPdSmDefaultSize.arrCheckedSM">TxCheckPdSmDefaultSize.uint16CurrSm</AddArrayItem>
			</TestStep>
			<TestStep Name="CheckBitSizeSm">
				<SetVariable Target="TxCheckPdSmDefaultSize.uint32EntriesTotalBitLen">TxCheckPdSmDefaultSize.uint32EntriesTotalBitLen+7</SetVariable>
			</TestStep>
			<TestStep Name="RoundBitSize">
				<SetVariable Target="TxCheckPdSmDefaultSize.uint32EntriesTotalBitLen">TxCheckPdSmDefaultSize.uint32EntriesTotalBitLen/8</SetVariable>
			</TestStep>
			<TestStep Name="CheckSyncManager">
				<Compare>
					<Equal>
						<Value1>DeviceDescr.SM[TxCheckPdSmDefaultSize.uint16CurrSm].DefaultSize</Value1>
						<Value2>null</Value2>
						<GotoStep>AddToCheckedSmAndCheckNext</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>TxCheckPdSmDefaultSize.uint32EntriesTotalBitLen</Value1>
						<Value2>DeviceDescr.SM[TxCheckPdSmDefaultSize.uint16CurrSm].DefaultSize</Value2>
						<WriteLine Id="6" Level="Output" Param0="TxCheckPdSmDefaultSize.uint16CurrSm" Param1="TxCheckPdSmDefaultSize.uint32EntriesTotalBitLen" Param2="DeviceDescr.SM[TxCheckPdSmDefaultSize.uint16CurrSm].DefaultSize">TxCheckPdSmDefaultSize: Sync Manager {0} has the right Default Size ({2}).</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>TxCheckPdSmDefaultSize.uint32EntriesTotalBitLen</Value1>
						<Value2>DeviceDescr.SM[TxCheckPdSmDefaultSize.uint16CurrSm].DefaultSize</Value2>
						<WriteLine Id="7" Level="Error" Param0="TxCheckPdSmDefaultSize.uint16CurrSm" Param1="TxCheckPdSmDefaultSize.uint32EntriesTotalBitLen" Param2="DeviceDescr.SM[TxCheckPdSmDefaultSize.uint16CurrSm].DefaultSize">TxCheckPdSmDefaultSize: Sync Manager {0} default size({2}) is wrong (due to the default mapped PDOs it shall be {1}).</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>TxCheckPdSmDefaultSize.uint32EntriesTotalBitLen</Value1>
						<Value2>DeviceDescr.SM[TxCheckPdSmDefaultSize.uint16CurrSm].DefaultSize</Value2>
						<SetVariable Target="TxCheckPdSmDefaultSize.uint16AllErrors">TxCheckPdSmDefaultSize.uint16AllErrors+1</SetVariable>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<SetVariable Target="TxCheckPdSmDefaultSize.uint32EntriesTotalBitLen">0</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="IncrementSavedIndexCheckNextSm">
				<SetVariable Target="TxCheckPdSmDefaultSize.int32SavedIndex">TxCheckPdSmDefaultSize.int32SavedIndex+1</SetVariable>
			</TestStep>
			<TestStep Name="SetToNextPdo">
				<SetVariable Target="TxCheckPdSmDefaultSize.int32CurrPdo">TxCheckPdSmDefaultSize.int32SavedIndex</SetVariable>
			</TestStep>
			<TestStep Name="CheckIfFinished">
				<Compare>
					<Lower>
						<Value1>TxCheckPdSmDefaultSize.int32SavedIndex</Value1>
						<Value2>DeviceDescr.TxPdo.Count</Value2>
						<GotoStep>CheckEntryExistence</GotoStep>
					</Lower>
				</Compare>
			</TestStep>
			<TestStep Name="ResetPdoIndexForFinish">
				<SetVariable Target="TxCheckPdSmDefaultSize.int32CurrPdo">0</SetVariable>
			</TestStep>
			<TestStep Name="CheckRemaining">
				<CallTestFunction Name="CheckRemainingSm">
					<Parameter>false</Parameter>
					<Parameter>TxCheckPdSmDefaultSize.arrCheckedSM</Parameter>
					<OutParameter>TxCheckPdSmDefaultSize.uint16Errors</OutParameter>
				</CallTestFunction>
			</TestStep>
			<TestStep Name="AddErrorCount">
				<SetVariable Target="TxCheckPdSmDefaultSize.uint16AllErrors">TxCheckPdSmDefaultSize.uint16AllErrors+TxCheckPdSmDefaultSize.uint16Errors</SetVariable>
			</TestStep>
			<TestStep Name="ReturnResult">
				<SizeOf UInt32Var="TxCheckPdSmDefaultSize.Uint32CheckedSM">TxCheckPdSmDefaultSize.arrCheckedSM</SizeOf>
				<Compare>
					<Equal>
						<Value1>TxCheckPdSmDefaultSize.boolEntriesFound</Value1>
						<Value2>false</Value2>
						<SkipCase Id="8">Skipped case: No entry found.</SkipCase>
					</Equal>
				</Compare>
				<Compare>
					<Greater>
						<Value1>TxCheckPdSmDefaultSize.Uint32CheckedSM</Value1>
						<Value2>0</Value2>
						<Return Id="9" Param0="TxCheckPdSmDefaultSize.Uint32CheckedSM">TxCheckPdSmDefaultSize: Checked {0} assigned sync manager.</Return>
					</Greater>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<Return Id="10">TxCheckPdSmDefaultSize: No assigned sync managers found.</Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="WriteErrorWrongSmDesc">
				<SetVariable Target="TxCheckPdSmDefaultSize.uint16AllErrors">TxCheckPdSmDefaultSize.uint16AllErrors+1</SetVariable>
				<WriteLine Id="11" Level="Error" Param0="TxCheckPdSmDefaultSize.uint16CurrSm" Param1="DeviceDescr.SM[TxCheckPdSmDefaultSize.uint16CurrSm]">TxCheckPdSmDefaultSize: Sync Manager {0} ({1}) has the wrong description.</WriteLine>
			</TestStep>
			<TestStep Name="AddToCheckedSmAndCheckNext">
				<AddArrayItem TargetArray="TxCheckPdSmDefaultSize.arrCheckedSM">TxCheckPdSmDefaultSize.uint16CurrSm</AddArrayItem>
			</TestStep>
			<TestStep Name="ResetTotalBitLen">
				<SetVariable Target="TxCheckPdSmDefaultSize.uint32EntriesTotalBitLen">0</SetVariable>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>IncrementSavedIndexCheckNextSm</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="WriteErrorNotExists">
				<SetVariable Target="TxCheckPdSmDefaultSize.uint16AllErrors">TxCheckPdSmDefaultSize.uint16AllErrors+1</SetVariable>
				<WriteLine Id="12" Level="Error" Param0="TxCheckPdSmDefaultSize.uint16CurrSm">TxCheckPdSmDefaultSize: Sync Manager {0} is assigned but does not exist.</WriteLine>
			</TestStep>
			<TestStep Name="AddToCheckedSmAndCheckNext2">
				<AddArrayItem TargetArray="TxCheckPdSmDefaultSize.arrCheckedSM">TxCheckPdSmDefaultSize.uint16CurrSm</AddArrayItem>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>IncrementSavedIndexCheckNextSm</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CheckIfMandatory">
				<Compare>
					<Equal>
						<Value1>DeviceDescr.TxPdo[TxCheckPdSmDefaultSize.int32CurrPdo].Mandatory</Value1>
						<Value2>false</Value2>
						<GotoStep>IncrementSavedIndexCheckNextSm</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="WriteErrorIsMandatory">
				<SetVariable Target="TxCheckPdSmDefaultSize.uint16AllErrors">TxCheckPdSmDefaultSize.uint16AllErrors+1</SetVariable>
				<WriteLine Id="13" Level="Error" Param0="DeviceDescr.TxPdo[TxCheckPdSmDefaultSize.int32CurrPdo].Index">TxCheckPdSmDefaultSize: Sync Manager of Pdo 0x{0:x4} is mandatory but not assigned.</WriteLine>
			</TestStep>
			<TestStep Name="CheckNextPdo">
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>IncrementSavedIndexCheckNextSm</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction Name="TxPdoElementsToArray" FunctionId="2601">
			<?MAX_OUTPUT_ID 1?>
			<!--Create a Uint16 Array of defined TxPdo Indices-->
			<LocalVariables>
				<Name>TxPdoElementsToArray.Cnt</Name>
				<Type>UInt16</Type>
				<!--temp counter variable-->
			</LocalVariables>
			<OutParameter>
				<Name>TxPdoElementsToArray.ui16Arr</Name>
				<Type>ArrayOfUInt16</Type>
			</OutParameter>
			<TestStep>
				<!--Check if TxPdo elements are defined -->
				<Compare>
					<Equal>
						<Value1>DeviceDescr.TxPdo.Count</Value1>
						<Value2>0</Value2>
						<Return Id="0"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<SetVariable Target="TxPdoElementsToArray.Cnt">0</SetVariable>
			</TestStep>
			<TestStep Name="LOOPSTART">
				<!--Check if Loop finished-->
				<Compare>
					<GreaterOrEqual>
						<Value1>TxPdoElementsToArray.Cnt</Value1>
						<Value2>DeviceDescr.TxPdo.Count</Value2>
						<Return Id="1"></Return>
					</GreaterOrEqual>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Copy current TxPdo index to array-->
				<AddArrayItem TargetArray="TxPdoElementsToArray.ui16Arr">DeviceDescr.TxPdo[TxPdoElementsToArray.Cnt].Index</AddArrayItem>
			</TestStep>
			<TestStep>
				<!--Increment counter-->
				<SetVariable Target="TxPdoElementsToArray.Cnt">TxPdoElementsToArray.Cnt +1</SetVariable>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>LOOPSTART</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction Name="ValidateObjectInfoType" FunctionId="2701">
			<?MAX_OUTPUT_ID 2?>
			<Description>
				<Purpose>Check if the defined info values are matching the corresponding DataType</Purpose>
				<PreCondition>The xPath shall reference a valid info element</PreCondition>
				<Action>1. Get 'DefaultData'
2. Get 'MinData'
3. Get 'MaxData'
4. Get 'DefaultValue'
5. Get 'MinValue'
6. Get 'MaxValue'
7. Get 'DefaultString'</Action>
				<PostCondition>1. 'DefaultData' shall not exceed the used DataType
2. 'MinData' shall not exceed the used DataType
3. 'MaxData' shall not exceed the used DataType
4. 'DefaultValue' shall not exceed the used DataType and shall only used for DataType with a fixed length
5. 'MinValue' shall not exceed the used DataType and shall only used for DataType with a fixed length
6. 'MaxValue' shall not exceed the used DataType and shall only used for DataType with a fixed length
7. 'DefaultString' shall not exceed the used DataType and shall only used for STRING(n)</PostCondition>
				<References>
					<Reference Specification="ETG.2000"></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>ValidateObjectInfoType.xInfoPath</Name>
				<Type>String</Type>
				<Comment>xPath of the Info element</Comment>
			</Parameter>
			<Parameter>
				<Name>ValidateObjectInfoType.xmlFile</Name>
				<Type>String</Type>
				<Comment>xml file contains the object description</Comment>
			</Parameter>
			<Parameter>
				<Name>ValidateObjectInfoType.DataType</Name>
				<Type>String</Type>
				<Comment>DataType of the related to the info element</Comment>
			</Parameter>
			<Parameter>
				<Name>ValidateObjectInfoType.InfoString</Name>
				<Type>String</Type>
				<Comment>first part of logger information</Comment>
			</Parameter>
			<LocalVariables>
				<Name>ValidateObjectInfoType.TypeBitSize</Name>
				<Type>Int32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>ValidateObjectInfoType.xPathDT</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>ValidateObjectInfoType.strXmlValue</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>ValidateObjectInfoType.TmpInfoString</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>ValidateObjectInfoType.TmpResult</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>ValidateObjectInfoType.TmpValue</Name>
				<Type>Int64</Type>
			</LocalVariables>
			<OutParameter>
				<Name>ValidateObjectInfoType.Result</Name>
				<Type>Bool</Type>
			</OutParameter>
			<TestStep Name="INIT_RESULT">
				<SetVariable Target="ValidateObjectInfoType.Result">true</SetVariable>
			</TestStep>
			<TestStep Name="CreateDataTypeXPath">
				<RegexReplace OutputString="ValidateObjectInfoType.xPathDT">
					<Pattern>(/Objects/Object.*)</Pattern>
					<InputString>ValidateObjectInfoType.xInfoPath</InputString>
					<ReplacementString>/DataTypes/DataType</ReplacementString>
				</RegexReplace>
			</TestStep>
			<TestStep Name="GET_OBJ_BITSIZE">
				<CallTestFunction Name="DataTypeName.GetBitSize">
					<Parameter>ValidateObjectInfoType.DataType</Parameter>
					<Parameter>ValidateObjectInfoType.xmlFile</Parameter>
					<Parameter>ValidateObjectInfoType.xPathDT</Parameter>
					<OutParameter>ValidateObjectInfoType.TypeBitSize</OutParameter>
				</CallTestFunction>
				<!--No Size/DataType found => Update Result-->
				<Compare>
					<Lower>
						<Value1>ValidateObjectInfoType.TypeBitSize</Value1>
						<Value2>0</Value2>
						<SetVariable Target="ValidateObjectInfoType.Result">false</SetVariable>
					</Lower>
				</Compare>
				<!--No Size/DataType found => Dump an Error-->
				<Compare>
					<Lower>
						<Value1>ValidateObjectInfoType.TypeBitSize</Value1>
						<Value2>0</Value2>
						<WriteLine Id="0" Level="Error" Param0="ValidateObjectInfoType.DataType" Param1="ValidateObjectInfoType.xmlFile" Param2="ValidateObjectInfoType.xPathDT">DataType {0} not found (file '{1}', path '{2}').</WriteLine>
					</Lower>
				</Compare>
				<!--No Size/DataType found => Return-->
				<Compare>
					<Lower>
						<Value1>ValidateObjectInfoType.TypeBitSize</Value1>
						<Value2>0</Value2>
						<Return Id="1"></Return>
					</Lower>
				</Compare>
			</TestStep>
			<TestStep Name="CHECK_DEFAULT_DATA">
				<GetXmlValue FileName="ValidateObjectInfoType.xmlFile" Markup="false" ReturnValue="ValidateObjectInfoType.strXmlValue">
					<XPath Param0="ValidateObjectInfoType.xInfoPath">{0}/DefaultData</XPath>
				</GetXmlValue>
				<!--skip if no default data is defined-->
				<Compare>
					<Equal>
						<Value1>ValidateObjectInfoType.strXmlValue</Value1>
						<Value2>null</Value2>
						<GotoStep>CHECK_MIN_DATA</GotoStep>
					</Equal>
				</Compare>
				<!--Create InfoString-->
				<Compare>
					<NotEqual>
						<Value1>ValidateObjectInfoType.strXmlValue</Value1>
						<Value2>null</Value2>
						<SetVariable Target="ValidateObjectInfoType.TmpInfoString" Param0="ValidateObjectInfoType.InfoString">{0}.DefaultData</SetVariable>
					</NotEqual>
				</Compare>
				<!--call "CheckObjectInfoData"-->
				<Compare>
					<NotEqual>
						<Value1>ValidateObjectInfoType.strXmlValue</Value1>
						<Value2>null</Value2>
						<CallTestFunction Name="CheckObjectInfoData">
							<!--Object Type-->
							<Parameter>ValidateObjectInfoType.DataType</Parameter>
							<!--Object BitSize-->
							<Parameter>ValidateObjectInfoType.TypeBitSize</Parameter>
							<!--Object default Data-->
							<Parameter>ValidateObjectInfoType.strXmlValue</Parameter>
							<!--First part of the error or warning-->
							<Parameter>ValidateObjectInfoType.TmpInfoString</Parameter>
							<OutParameter>ValidateObjectInfoType.TmpResult</OutParameter>
						</CallTestFunction>
					</NotEqual>
				</Compare>
				<!--Update result if functions failes-->
				<Compare>
					<Equal>
						<Value1>ValidateObjectInfoType.TmpResult</Value1>
						<Value2>false</Value2>
						<SetVariable Target="ValidateObjectInfoType.Result">false</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CHECK_MIN_DATA">
				<GetXmlValue FileName="ValidateObjectInfoType.xmlFile" Markup="false" ReturnValue="ValidateObjectInfoType.strXmlValue">
					<XPath Param0="ValidateObjectInfoType.xInfoPath">{0}/MinData</XPath>
				</GetXmlValue>
				<!--skip if no min data is defined-->
				<Compare>
					<Equal>
						<Value1>ValidateObjectInfoType.strXmlValue</Value1>
						<Value2>null</Value2>
						<GotoStep>CHECK_MAX_DATA</GotoStep>
					</Equal>
				</Compare>
				<!--Create InfoString-->
				<Compare>
					<NotEqual>
						<Value1>ValidateObjectInfoType.strXmlValue</Value1>
						<Value2>null</Value2>
						<SetVariable Target="ValidateObjectInfoType.TmpInfoString" Param0="ValidateObjectInfoType.InfoString">{0}.MinData</SetVariable>
					</NotEqual>
				</Compare>
				<!--call "CheckObjectInfoData"-->
				<Compare>
					<NotEqual>
						<Value1>ValidateObjectInfoType.strXmlValue</Value1>
						<Value2>null</Value2>
						<CallTestFunction Name="CheckObjectInfoData">
							<!--Object Type-->
							<Parameter>ValidateObjectInfoType.DataType</Parameter>
							<!--Object BitSize-->
							<Parameter>ValidateObjectInfoType.TypeBitSize</Parameter>
							<!--Object default Data-->
							<Parameter>ValidateObjectInfoType.strXmlValue</Parameter>
							<!--First part of the error or warning-->
							<Parameter>ValidateObjectInfoType.TmpInfoString</Parameter>
							<OutParameter>ValidateObjectInfoType.TmpResult</OutParameter>
						</CallTestFunction>
					</NotEqual>
				</Compare>
				<!--Update result if functions failes-->
				<Compare>
					<Equal>
						<Value1>ValidateObjectInfoType.TmpResult</Value1>
						<Value2>false</Value2>
						<SetVariable Target="ValidateObjectInfoType.Result">false</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CHECK_MAX_DATA">
				<GetXmlValue FileName="ValidateObjectInfoType.xmlFile" Markup="false" ReturnValue="ValidateObjectInfoType.strXmlValue">
					<XPath Param0="ValidateObjectInfoType.xInfoPath">{0}/MaxData</XPath>
				</GetXmlValue>
				<!--skip if no min data is defined-->
				<Compare>
					<Equal>
						<Value1>ValidateObjectInfoType.strXmlValue</Value1>
						<Value2>null</Value2>
						<GotoStep>CHECK_DEFAULT_STRING</GotoStep>
					</Equal>
				</Compare>
				<!--Create InfoString-->
				<Compare>
					<NotEqual>
						<Value1>ValidateObjectInfoType.strXmlValue</Value1>
						<Value2>null</Value2>
						<SetVariable Target="ValidateObjectInfoType.TmpInfoString" Param0="ValidateObjectInfoType.InfoString">{0}.MaxData</SetVariable>
					</NotEqual>
				</Compare>
				<!--call "CheckObjectInfoData"-->
				<Compare>
					<NotEqual>
						<Value1>ValidateObjectInfoType.strXmlValue</Value1>
						<Value2>null</Value2>
						<CallTestFunction Name="CheckObjectInfoData">
							<!--Object Type-->
							<Parameter>ValidateObjectInfoType.DataType</Parameter>
							<!--Object BitSize-->
							<Parameter>ValidateObjectInfoType.TypeBitSize</Parameter>
							<!--Object default Data-->
							<Parameter>ValidateObjectInfoType.strXmlValue</Parameter>
							<!--First part of the error or warning-->
							<Parameter>ValidateObjectInfoType.TmpInfoString</Parameter>
							<OutParameter>ValidateObjectInfoType.TmpResult</OutParameter>
						</CallTestFunction>
					</NotEqual>
				</Compare>
				<!--Update result if functions failes-->
				<Compare>
					<Equal>
						<Value1>ValidateObjectInfoType.TmpResult</Value1>
						<Value2>false</Value2>
						<SetVariable Target="ValidateObjectInfoType.Result">false</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CHECK_DEFAULT_STRING">
				<GetXmlValue FileName="ValidateObjectInfoType.xmlFile" Markup="false" ReturnValue="ValidateObjectInfoType.strXmlValue">
					<XPath Param0="ValidateObjectInfoType.xInfoPath">{0}/DefaultString</XPath>
				</GetXmlValue>
				<!--skip if no DefaultString is defined-->
				<Compare>
					<Equal>
						<Value1>ValidateObjectInfoType.strXmlValue</Value1>
						<Value2>null</Value2>
						<GotoStep>CHECK_DEFAULT_VALUE</GotoStep>
					</Equal>
				</Compare>
				<!--Create InfoString-->
				<Compare>
					<NotEqual>
						<Value1>ValidateObjectInfoType.strXmlValue</Value1>
						<Value2>null</Value2>
						<SetVariable Target="ValidateObjectInfoType.TmpInfoString" Param0="ValidateObjectInfoType.InfoString">{0}.DefaultString</SetVariable>
					</NotEqual>
				</Compare>
				<!--call "CheckObjectInfoString"-->
				<Compare>
					<NotEqual>
						<Value1>ValidateObjectInfoType.strXmlValue</Value1>
						<Value2>null</Value2>
						<CallTestFunction Name="CheckObjectInfoString">
							<!--Object Type-->
							<Parameter>ValidateObjectInfoType.DataType</Parameter>
							<!--Object BitSize-->
							<Parameter>ValidateObjectInfoType.TypeBitSize</Parameter>
							<!--Object default Data-->
							<Parameter>ValidateObjectInfoType.strXmlValue</Parameter>
							<!--First part of the error or warning-->
							<Parameter>ValidateObjectInfoType.TmpInfoString</Parameter>
							<OutParameter>ValidateObjectInfoType.TmpResult</OutParameter>
						</CallTestFunction>
					</NotEqual>
				</Compare>
				<!--Update result if functions failes-->
				<Compare>
					<Equal>
						<Value1>ValidateObjectInfoType.TmpResult</Value1>
						<Value2>false</Value2>
						<SetVariable Target="ValidateObjectInfoType.Result">false</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CHECK_DEFAULT_VALUE">
				<GetXmlValue FileName="ValidateObjectInfoType.xmlFile" Markup="false" ReturnValue="ValidateObjectInfoType.TmpValue">
					<XPath Param0="ValidateObjectInfoType.xInfoPath">{0}/DefaultValue</XPath>
				</GetXmlValue>
				<!--skip if no DefaultValue is defined-->
				<Compare>
					<Equal>
						<Value1>ValidateObjectInfoType.TmpValue</Value1>
						<Value2>null</Value2>
						<GotoStep>CHECK_MIN_VALUE</GotoStep>
					</Equal>
				</Compare>
				<!--Create InfoString-->
				<Compare>
					<NotEqual>
						<Value1>ValidateObjectInfoType.TmpValue</Value1>
						<Value2>null</Value2>
						<SetVariable Target="ValidateObjectInfoType.TmpInfoString" Param0="ValidateObjectInfoType.InfoString">{0}.DefaultValue</SetVariable>
					</NotEqual>
				</Compare>
				<!--call "CheckObjectInfoData"-->
				<Compare>
					<NotEqual>
						<Value1>ValidateObjectInfoType.TmpValue</Value1>
						<Value2>null</Value2>
						<CallTestFunction Name="CheckObjectInfoValue">
							<!--Object Type-->
							<Parameter>ValidateObjectInfoType.DataType</Parameter>
							<!--Object BitSize-->
							<Parameter>ValidateObjectInfoType.TypeBitSize</Parameter>
							<!--Object default value-->
							<Parameter>ValidateObjectInfoType.TmpValue</Parameter>
							<!--First part of the error or warning-->
							<Parameter>ValidateObjectInfoType.TmpInfoString</Parameter>
							<OutParameter>ValidateObjectInfoType.TmpResult</OutParameter>
						</CallTestFunction>
					</NotEqual>
				</Compare>
				<!--Update result if functions failes-->
				<Compare>
					<Equal>
						<Value1>ValidateObjectInfoType.TmpResult</Value1>
						<Value2>false</Value2>
						<SetVariable Target="ValidateObjectInfoType.Result">false</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CHECK_MIN_VALUE">
				<GetXmlValue FileName="ValidateObjectInfoType.xmlFile" Markup="false" ReturnValue="ValidateObjectInfoType.TmpValue">
					<XPath Param0="ValidateObjectInfoType.xInfoPath">{0}/MinValue</XPath>
				</GetXmlValue>
				<!--skip if no MinValue is defined-->
				<Compare>
					<Equal>
						<Value1>ValidateObjectInfoType.TmpValue</Value1>
						<Value2>null</Value2>
						<GotoStep>CHECK_MAX_VALUE</GotoStep>
					</Equal>
				</Compare>
				<!--Create InfoString-->
				<Compare>
					<NotEqual>
						<Value1>ValidateObjectInfoType.TmpValue</Value1>
						<Value2>null</Value2>
						<SetVariable Target="ValidateObjectInfoType.TmpInfoString" Param0="ValidateObjectInfoType.InfoString">{0}.MinValue</SetVariable>
					</NotEqual>
				</Compare>
				<!--call "CheckObjectInfoData"-->
				<Compare>
					<NotEqual>
						<Value1>ValidateObjectInfoType.TmpValue</Value1>
						<Value2>null</Value2>
						<CallTestFunction Name="CheckObjectInfoValue">
							<!--Object Type-->
							<Parameter>ValidateObjectInfoType.DataType</Parameter>
							<!--Object BitSize-->
							<Parameter>ValidateObjectInfoType.TypeBitSize</Parameter>
							<!--Object min value-->
							<Parameter>ValidateObjectInfoType.TmpValue</Parameter>
							<!--First part of the error or warning-->
							<Parameter>ValidateObjectInfoType.TmpInfoString</Parameter>
							<OutParameter>ValidateObjectInfoType.TmpResult</OutParameter>
						</CallTestFunction>
					</NotEqual>
				</Compare>
				<!--Update result if functions failes-->
				<Compare>
					<Equal>
						<Value1>ValidateObjectInfoType.TmpResult</Value1>
						<Value2>false</Value2>
						<SetVariable Target="ValidateObjectInfoType.Result">false</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CHECK_MAX_VALUE">
				<GetXmlValue FileName="ValidateObjectInfoType.xmlFile" Markup="false" ReturnValue="ValidateObjectInfoType.TmpValue">
					<XPath Param0="ValidateObjectInfoType.xInfoPath">{0}/MaxValue</XPath>
				</GetXmlValue>
				<!--skip if no MinValue is defined-->
				<Compare>
					<Equal>
						<Value1>ValidateObjectInfoType.TmpValue</Value1>
						<Value2>null</Value2>
						<Return Id="2"></Return>
					</Equal>
				</Compare>
				<!--Create InfoString-->
				<Compare>
					<NotEqual>
						<Value1>ValidateObjectInfoType.TmpValue</Value1>
						<Value2>null</Value2>
						<SetVariable Target="ValidateObjectInfoType.TmpInfoString" Param0="ValidateObjectInfoType.InfoString">{0}.MaxValue</SetVariable>
					</NotEqual>
				</Compare>
				<!--call "CheckObjectInfoValue"-->
				<Compare>
					<NotEqual>
						<Value1>ValidateObjectInfoType.TmpValue</Value1>
						<Value2>null</Value2>
						<CallTestFunction Name="CheckObjectInfoValue">
							<!--Object Type-->
							<Parameter>ValidateObjectInfoType.DataType</Parameter>
							<!--Object BitSize-->
							<Parameter>ValidateObjectInfoType.TypeBitSize</Parameter>
							<!--Object max Value-->
							<Parameter>ValidateObjectInfoType.TmpValue</Parameter>
							<!--First part of the error or warning-->
							<Parameter>ValidateObjectInfoType.TmpInfoString</Parameter>
							<OutParameter>ValidateObjectInfoType.TmpResult</OutParameter>
						</CallTestFunction>
					</NotEqual>
				</Compare>
				<!--Update result if functions failes-->
				<Compare>
					<Equal>
						<Value1>ValidateObjectInfoType.TmpResult</Value1>
						<Value2>false</Value2>
						<SetVariable Target="ValidateObjectInfoType.Result">false</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction Name="ValidateSubItemElements" FunctionId="2801">
			<?MAX_OUTPUT_ID 5?>
			<Description>
				<Purpose>Check the SubItem elements of an object definition</Purpose>
				<PreCondition>The XPath shall reference a SubItem</PreCondition>
				<Action>1. Get SubItem.Name
2. Call 'ValidateObjectInfoType" if SubItem.Info is defined</Action>
				<PostCondition>1. A Name shall be used which is defined in the corresponding DataType definition
2. see 'ValidateObjectInfoType' </PostCondition>
				<References>
					<Reference Specification="ETG.2000"></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>ValidateSubItemElements.xSubItemPath</Name>
				<Type>String</Type>
				<Comment>base xPath of the SubItem elements</Comment>
			</Parameter>
			<Parameter>
				<Name>ValidateSubItemElements.xmlFile</Name>
				<Type>String</Type>
				<Comment>xml file contains the object description</Comment>
			</Parameter>
			<Parameter>
				<Name>ValidateSubItemElements.DataType</Name>
				<Type>String</Type>
				<Comment>DataType of the parent object</Comment>
			</Parameter>
			<Parameter>
				<Name>ValidateSubItemElements.InfoString</Name>
				<Type>String</Type>
				<Comment>first part of logger information</Comment>
			</Parameter>
			<LocalVariables>
				<Name>ValidateSubItemElements.NumberOfSubItems</Name>
				<Type>Int32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>ValidateSubItemElements.Loopcounter</Name>
				<Type>Int32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>ValidateSubItemElements.xTmpSubItemPath</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>ValidateSubItemElements.xPathDT</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>ValidateSubItemElements.strXmlValue</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>ValidateSubItemElements.SubItemName</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>ValidateSubItemElements.SubItemDataType</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>ValidateSubItemElements.TmpResult</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>ValidateSubItemElements.strTmpInfo</Name>
				<Type>String</Type>
			</LocalVariables>
			<OutParameter>
				<Name>ValidateSubItemElements.Result</Name>
				<Type>Bool</Type>
			</OutParameter>
			<TestStep Name="INIT_RESULT">
				<SetVariable Target="ValidateSubItemElements.Result">true</SetVariable>
			</TestStep>
			<TestStep Name="INIT_LOOP_COUNTER">
				<SetVariable Target="ValidateSubItemElements.Loopcounter">1</SetVariable>
			</TestStep>
			<TestStep Name="CreateDataTypeXPath">
				<RegexReplace OutputString="ValidateSubItemElements.xPathDT">
					<Pattern>(/Objects/Object.*)</Pattern>
					<InputString>ValidateSubItemElements.xSubItemPath</InputString>
					<ReplacementString>/DataTypes/DataType</ReplacementString>
				</RegexReplace>
			</TestStep>
			<TestStep Name="GET_NUMBER_OF_SUBITEMS">
				<CallTestFunction Name="XmlFile.GetNumberOfElements">
					<Parameter>ValidateSubItemElements.xSubItemPath</Parameter>
					<Parameter>ValidateSubItemElements.xmlFile</Parameter>
					<OutParameter>ValidateSubItemElements.NumberOfSubItems</OutParameter>
				</CallTestFunction>
				<Compare>
					<Lower>
						<Value1>ValidateSubItemElements.NumberOfSubItems</Value1>
						<Value2>0</Value2>
						<Return Id="0"></Return>
					</Lower>
				</Compare>
			</TestStep>
			<TestStep Name="LOOP_START">
				<Compare>
					<Lower>
						<Value1>ValidateSubItemElements.NumberOfSubItems</Value1>
						<Value2>ValidateSubItemElements.Loopcounter</Value2>
						<Return Id="1"></Return>
					</Lower>
				</Compare>
			</TestStep>
			<TestStep Name="CREATE_TMP_SUBITEM_PATH">
				<SetVariable Target="ValidateSubItemElements.xTmpSubItemPath" Param0="ValidateSubItemElements.xSubItemPath" Param1="ValidateSubItemElements.Loopcounter">{0}[{1}]</SetVariable>
			</TestStep>
			<TestStep Name="GET_SUBITEM_NAME">
				<GetXmlValue FileName="ValidateSubItemElements.xmlFile" Markup="false" ReturnValue="ValidateSubItemElements.SubItemName">
					<XPath Param0="ValidateSubItemElements.xTmpSubItemPath">{0}/Name</XPath>
				</GetXmlValue>
			</TestStep>
			<TestStep Name="CHECK_SUBITEM_NAME">
				<!--dump error if no name is defined-->
				<Compare>
					<Equal>
						<Value1>ValidateSubItemElements.SubItemName</Value1>
						<Value2>null</Value2>
						<WriteLine Id="2" Level="Error" Param0="ValidateSubItemElements.InfoString" Param1="(ValidateSubItemElements.Loopcounter - 1)">{0}.Info.SubItem[{1}].Name shall be defined.</WriteLine>
					</Equal>
				</Compare>
				<!--update result if no name is defined-->
				<Compare>
					<Equal>
						<Value1>ValidateSubItemElements.SubItemName</Value1>
						<Value2>null</Value2>
						<SetVariable Target="ValidateSubItemElements.Result">false</SetVariable>
					</Equal>
				</Compare>
				<!--goto "LOOP_END" if no name is defined-->
				<Compare>
					<Equal>
						<Value1>ValidateSubItemElements.SubItemName</Value1>
						<Value2>null</Value2>
						<GotoStep>LOOP_END</GotoStep>
					</Equal>
				</Compare>
				<!--dump error if name is empty-->
				<Compare>
					<Equal>
						<Value1>ValidateSubItemElements.SubItemName</Value1>
						<Value2>EmptyString</Value2>
						<WriteLine Id="3" Level="Error" Param0="ValidateSubItemElements.InfoString" Param1="(ValidateSubItemElements.Loopcounter - 1)">{0}.Info.SubItem[{1}].Name shall not be empty.</WriteLine>
					</Equal>
				</Compare>
				<!--update Result if  name is empty-->
				<Compare>
					<Equal>
						<Value1>ValidateSubItemElements.SubItemName</Value1>
						<Value2>EmptyString</Value2>
						<SetVariable Target="ValidateSubItemElements.Result">false</SetVariable>
					</Equal>
				</Compare>
				<!--goto "LOOP_END" if name is empty-->
				<Compare>
					<Equal>
						<Value1>ValidateSubItemElements.SubItemName</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>LOOP_END</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CREATE_TMP_INFO_TEXT">
				<SetVariable Target="ValidateSubItemElements.strTmpInfo" Param0="ValidateSubItemElements.InfoString" Param1="ValidateSubItemElements.SubItemName">{0}.SubItem '{1}'</SetVariable>
			</TestStep>
			<TestStep Name="GET_SUBITEM_DATATYPE">
				<CallTestFunction Name="GetSubItemDataType">
					<Parameter>ValidateSubItemElements.SubItemName</Parameter>
					<Parameter>ValidateSubItemElements.DataType</Parameter>
					<Parameter>ValidateSubItemElements.xPathDT</Parameter>
					<Parameter>ValidateSubItemElements.xmlFile</Parameter>
					<OutParameter>ValidateSubItemElements.SubItemDataType</OutParameter>
				</CallTestFunction>
				<WriteLine Id="4" Level="Verbose" Param0="ValidateSubItemElements.strTmpInfo" Param1="ValidateSubItemElements.SubItemDataType">{0} DataType '{1}'.</WriteLine>
				<!--dump error if SubItem was not found in DataType-->
				<Compare>
					<Equal>
						<Value1>ValidateSubItemElements.SubItemDataType</Value1>
						<Value2>EmptyString</Value2>
						<WriteLine Id="5" Level="Error" Param0="ValidateSubItemElements.strTmpInfo" Param1="ValidateSubItemElements.DataType">{0} shall be defined in {1}.</WriteLine>
					</Equal>
				</Compare>
				<!--update Result if SubItem was not found in DataType-->
				<Compare>
					<Equal>
						<Value1>ValidateSubItemElements.SubItemDataType</Value1>
						<Value2>EmptyString</Value2>
						<SetVariable Target="ValidateSubItemElements.Result">false</SetVariable>
					</Equal>
				</Compare>
				<!--goto "LOOP_END" if SubItem was not found in DataType-->
				<Compare>
					<Equal>
						<Value1>ValidateSubItemElements.SubItemDataType</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>LOOP_END</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CREATE_SUBITEM_INFO_PATH">
				<SetVariable Target="ValidateSubItemElements.xTmpSubItemPath" Param0="ValidateSubItemElements.xTmpSubItemPath">{0}/Info</SetVariable>
			</TestStep>
			<TestStep Name="CHECK_INFO_ELEMENT">
				<CallTestFunction Name="ValidateObjectInfoType">
					<Parameter>ValidateSubItemElements.xTmpSubItemPath</Parameter>
					<Parameter>ValidateSubItemElements.xmlFile</Parameter>
					<Parameter>ValidateSubItemElements.SubItemDataType</Parameter>
					<Parameter>ValidateSubItemElements.strTmpInfo</Parameter>
					<OutParameter>ValidateSubItemElements.TmpResult</OutParameter>
				</CallTestFunction>
				<Compare>
					<Equal>
						<Value1>ValidateSubItemElements.TmpResult</Value1>
						<Value2>false</Value2>
						<SetVariable Target="ValidateSubItemElements.Result">false</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="LOOP_END">
				<SetVariable Target="ValidateSubItemElements.Loopcounter">ValidateSubItemElements.Loopcounter + 1</SetVariable>
				<Compare>
					<GreaterOrEqual>
						<Value1>ValidateSubItemElements.NumberOfSubItems</Value1>
						<Value2>ValidateSubItemElements.Loopcounter</Value2>
						<GotoStep>LOOP_START</GotoStep>
					</GreaterOrEqual>
				</Compare>
			</TestStep>
		</TestFunction>
	</TestFunctions>
	<TestGroups>
		<TestGroup GroupId="1" Name="General ESI plausibility ">
			<Comment>Checks the general plausibility of the EtherCAT Slave Information File</Comment>
			<TestCase Name="Secondary Vendor ID" CaseId="1">
				<?MAX_OUTPUT_ID 2?>
				<Description>
					<PreCondition>Get Vendor ID from ESI file</PreCondition>
					<Action>Check if Vendor ID is an secondary Vendor ID (highest nibble = 0xE)</Action>
					<PostCondition>Error if device has a secondary Vendor ID</PostCondition>
					<ProposalForSolution>Use own EtherCAT Vendor ID. One can apply for an EtherCAT Vendor ID at www.ethercat.org</ProposalForSolution>
					<References>
						<Reference Specification="ETG.1000" Chapter=""></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep>
					<!--Get Vendor ID from ESI file-->
					<Description Id="0" Level="Verbose">Get Vendor ID from ESI file</Description>
					<GetBits Target="byteVal1" Source="DeviceDescr.VendorId">
						<Offset>28</Offset>
						<Length>4</Length>
					</GetBits>
					<Compare>
						<Equal>
							<Value1>byteVal1</Value1>
							<Value2>#xE</Value2>
							<RaiseError Id="1" Param0="byteVal1" Param1="DeviceDescr.VendorId">Invallid Vendor ID | The Vendor ID read from the ESI file (0x{1:x}) is a secondary Vendor ID. It is used for embedded EtherCAT communication modules and cannot be certified.</RaiseError>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<!--Successful-->
					<WriteLine Id="2" Param0="DeviceDescr.VendorId" Level="Success">Successful || Valid Vendor ID in ESI file (0x{0:x})</WriteLine>
				</TestStep>
			</TestCase>
			<TestCase Name="Device.RevisionNo" CaseId="2">
				<?MAX_OUTPUT_ID 2?>
				<Comment>Check if ESI uses DeviceDescr.RevisionNo</Comment>
				<Description>
					<Purpose>The ESI attribute Device.RevisionNo should be used. It is recommended to use for better product version handling.</Purpose>
					<PreCondition>ESI file available</PreCondition>
					<Action>Check if Device:RevisionNo is used.</Action>
					<PostCondition>Throw warning if not used.</PostCondition>
					<References>
						<Reference Specification="ETG.2000" Chapter=""></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="START">
					<SetVariable Target="elementName">Device:RevisionNo</SetVariable>
					<WriteLine Id="0" Level="Output" Param0="elementName">Check for element {0}</WriteLine>
				</TestStep>
				<TestStep>
					<Compare>
						<NotEqual>
							<Value1>DeviceDescr.RevisionNo</Value1>
							<Value2>null</Value2>
							<ReturnSuccess Id="1" Param0="elementName">Success | ESI element {0} is used. </ReturnSuccess>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="WARNING">
					<WriteLine Id="2" Level="Warning" Param0="elementName">ESI element {0} is empty and is recommended to be used.</WriteLine>
				</TestStep>
			</TestCase>
			<TestCase Name="ESI Port Type Consistency" CaseId="3">
				<?MAX_OUTPUT_ID 24?>
				<Comment>Checks port type configuration (MII/LVDS) of the DuT's ESI elements for consistency</Comment>
				<Description>
					<Purpose>Check ESI elements for port type descriptions (Device@Physics and Device:Info:Port) for consistency of the port type configuration (MII/LVDS).
ESI attribute Device@Physics is mandatory, ESI element Device:Info:Port is optional.
Note that  port 0 shall always be the IN port.</Purpose>
					<PreCondition>ESI file available</PreCondition>
					<Action>- Check attribute Device@Physics if port 0 is configured (first character is not a blank).
- Check attribute Device@Phyisics for further configured ports
- Check if element Device:Info:Port is used
- Check all elements Device:Info:Port if configuration is equal to element Device:Physics</Action>
					<PostCondition>Error if port 0 is not configured or Device@Phyiscs is not used at all
Error if port configurations are not equal</PostCondition>
					<References>
						<Reference Specification="ETG.2000" Chapter=""></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="START">
					<SetVariable Target="elementName">Device:Physics</SetVariable>
					<WriteLine Id="0" Level="Output" Param0="elementName">Scan ESI for {0}</WriteLine>
				</TestStep>
				<TestStep Name="INIT">
					<SetVariable Target="index2max">DeviceDescr.Physics.Count</SetVariable>
					<Compare>
						<Equal>
							<Value1>index2max</Value1>
							<Value2>0</Value2>
							<RaiseError Id="1">Device:Physics is empty</RaiseError>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="INIT_PHYSICSTOGGLE">
					<SetVariable Target="boolVar">false</SetVariable>
				</TestStep>
				<TestStep>
					<SetVariable Target="index2">0</SetVariable>
					<WriteLine Id="2" Level="Verbose" Param0="index2max" Param1="elementName">{1} contains {0} ports.</WriteLine>
				</TestStep>
				<TestStep Name="CHECKPHYSICS">
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Physics[index2]</Value1>
							<Value2>K</Value2>
							<SetVariable Target="boolVar">true</SetVariable>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Physics[index2]</Value1>
							<Value2>K</Value2>
							<GotoStep>K</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Physics[index2]</Value1>
							<Value2>Y</Value2>
							<SetVariable Target="boolVar">true</SetVariable>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Physics[index2]</Value1>
							<Value2>Y</Value2>
							<GotoStep>Y</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Physics[index2]</Value1>
							<Value2>H</Value2>
							<SetVariable Target="boolVar">true</SetVariable>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Physics[index2]</Value1>
							<Value2>H</Value2>
							<GotoStep>H</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Physics[index2]</Value1>
							<Value2>" "</Value2>
							<SetVariable Target="boolVar">true</SetVariable>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Physics[index2]</Value1>
							<Value2>" "</Value2>
							<GotoStep>BLANK</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>0</Value1>
							<Value2>0</Value2>
							<SetVariable Target="boolVar">false</SetVariable>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>0</Value1>
							<Value2>0</Value2>
							<RaiseError Id="3" Param0="index2" Param1="DeviceDescr.Physics[index2]">DeviceDescr.Physics[{0}] = '{1}' is not evaluated.</RaiseError>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="Y">
					<SetVariable Target="tmpString">MII</SetVariable>
					<WriteLine Id="4" Level="Verbose" Param0="index2" Param1="tmpString">Device:Physics[{0}]:Type = {1}</WriteLine>
					<Compare>
						<NotEqual>
							<Value1>1</Value1>
							<Value2>0</Value2>
							<GotoStep>NEXT</GotoStep>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="H">
					<SetVariable Target="tmpString">MII - Fast Hot Connect</SetVariable>
					<WriteLine Id="5" Level="Verbose" Param0="index2" Param1="tmpString">Device:Physics[{0}]:Type = {1}</WriteLine>
					<Compare>
						<NotEqual>
							<Value1>1</Value1>
							<Value2>0</Value2>
							<GotoStep>NEXT</GotoStep>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="K">
					<SetVariable Target="tmpString">LVDS Type</SetVariable>
					<WriteLine Id="6" Level="Verbose" Param0="index2" Param1="tmpString">Device:Physics[{0}]:Type = {1}</WriteLine>
					<Compare>
						<NotEqual>
							<Value1>1</Value1>
							<Value2>0</Value2>
							<GotoStep>NEXT</GotoStep>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="BLANK">
					<SetVariable Target="tmpString">NONE</SetVariable>
					<WriteLine Id="7" Level="Verbose" Param0="index2" Param1="tmpString">Device:Physics[{0}]:Type = {1}</WriteLine>
					<Compare>
						<Equal>
							<Value1>index2</Value1>
							<Value2>0</Value2>
							<RaiseError Id="8">Port 0 in Device:Physics is not defined. Port 0 must be either of type MII or LVDS (character Y,H or K respectively)</RaiseError>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="NEXT">
					<SetVariable Target="index2">index2+1</SetVariable>
					<Compare>
						<GreaterOrEqual>
							<Value1>index2</Value1>
							<Value2>index2max</Value2>
							<GotoStep>SUCCESS</GotoStep>
						</GreaterOrEqual>
					</Compare>
					<Compare>
						<GreaterOrEqual>
							<Value1>0</Value1>
							<Value2>0</Value2>
							<GotoStep>CHECKPHYSICS</GotoStep>
						</GreaterOrEqual>
					</Compare>
				</TestStep>
				<TestStep Name="SUCCESS">
					<Compare>
						<Equal>
							<Value1>boolVar</Value1>
							<Value2>false</Value2>
							<RaiseError Id="9" Param0="elementName" Param1="DeviceDescr.Physics">ESI element {0} '{1}' is invalid.</RaiseError>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>boolVar</Value1>
							<Value2>true</Value2>
							<WriteLine Id="10" Level="Output" Param0="elementName">ESI element {0} is checked.</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="STARTPORT">
					<SetVariable Target="elementName">Device:Info:Port</SetVariable>
					<WriteLine Id="11" Level="Verbose" Param0="elementName">Scan ESI for {0}</WriteLine>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Info</Value1>
							<Value2>false</Value2>
							<WriteLine Id="12">ESI element Device:Info is empty.</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Info</Value1>
							<Value2>false</Value2>
							<GotoStep>END</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="INITPORT">
					<SetVariable Target="indexmax">DeviceDescr.Info.Port.Count</SetVariable>
					<WriteLine Id="13" Level="Verbose" Param0="indexmax" Param1="elementName">{1} contains {0} ports.</WriteLine>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Info.Port.Count</Value1>
							<Value2>0</Value2>
							<WriteLine Id="14">No elements Device:Info:Port defined.</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Info.Port.Count</Value1>
							<Value2>0</Value2>
							<GotoStep>END</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<SetVariable Target="index">0</SetVariable>
					<Compare>
						<NotEqual>
							<Value1>indexmax</Value1>
							<Value2>index2max</Value2>
							<RaiseError Id="15">Port number in ESI element Device:Phyics not equal to ESI element Device:Info:Ports</RaiseError>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="CHECKPORT">
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Info.Port[index].Type</Value1>
							<Value2>0</Value2>
							<GotoStep>NONE</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Info.Port[index].Type</Value1>
							<Value2>2</Value2>
							<GotoStep>LVDS</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Info.Port[index].Type</Value1>
							<Value2>3</Value2>
							<GotoStep>MII</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>0</Value1>
							<Value2>0</Value2>
							<GotoStep>NEXTTYPE</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="MII">
					<SetVariable Target="tmpString">MII</SetVariable>
					<WriteLine Id="16" Level="Verbose" Param0="index" Param1="tmpString">Device:Info:Port[{0}]:Type = {1}</WriteLine>
				</TestStep>
				<TestStep>
					<!--"Y" is valid-->
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Physics[index]</Value1>
							<Value2>Y</Value2>
							<GotoStep>NEXTTYPE</GotoStep>
						</Equal>
					</Compare>
					<!--"H" is valid-->
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Physics[index]</Value1>
							<Value2>H</Value2>
							<GotoStep>NEXTTYPE</GotoStep>
						</Equal>
					</Compare>
					<!--Dump an error for all other types-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<RaiseError Id="17">Port type of Device:Info:Port is not equal to corresponding port type in Device:Physics</RaiseError>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>NEXTTYPE</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="LVDS">
					<SetVariable Target="tmpString">LVDS Type</SetVariable>
					<WriteLine Id="18" Level="Verbose" Param0="index" Param1="tmpString">Device:Info:Port[{0}]:Type = {1}</WriteLine>
				</TestStep>
				<TestStep>
					<Compare>
						<NotEqual>
							<Value1>DeviceDescr.Physics[index]</Value1>
							<Value2>K</Value2>
							<RaiseError Id="19">Port type of Device:Info:Port is not equal to corresponding port type in Device:Physics</RaiseError>
						</NotEqual>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>1</Value1>
							<Value2>0</Value2>
							<GotoStep>NEXTTYPE</GotoStep>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="NONE">
					<SetVariable Target="tmpString">NONE</SetVariable>
					<WriteLine Id="20" Level="Verbose" Param0="index" Param1="tmpString">Device:Info:Port[{0}]:Type = {1}</WriteLine>
				</TestStep>
				<TestStep>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Physics[index]</Value1>
							<Value2>Y</Value2>
							<RaiseError Id="21">Port type of Device:Info:Port is not equal to corresponding port type in Device:Physics</RaiseError>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Physics[index]</Value1>
							<Value2>K</Value2>
							<RaiseError Id="22">Port type of Device:Info:Port is not equal to corresponding port type in Device:Physics</RaiseError>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>index</Value1>
							<Value2>0</Value2>
							<RaiseError Id="23">Port 0 in Device:Info:Ports must be either of type MII or LVDS</RaiseError>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="NEXTTYPE">
					<SetVariable Target="index">index+1</SetVariable>
					<Compare>
						<GreaterOrEqual>
							<Value1>index</Value1>
							<Value2>indexmax</Value2>
							<GotoStep>END</GotoStep>
						</GreaterOrEqual>
					</Compare>
					<Compare>
						<GreaterOrEqual>
							<Value1>1</Value1>
							<Value2>1</Value2>
							<GotoStep>CHECKPORT</GotoStep>
						</GreaterOrEqual>
					</Compare>
				</TestStep>
				<TestStep Name="END">
					<WriteLine Id="24" Level="Success" Param0="elementName">Success | Port configuration elements in ESI are valid.</WriteLine>
				</TestStep>
			</TestCase>
			<TestCase Name="Number of Offline Dictionaries" CaseId="4">
				<?MAX_OUTPUT_ID 4?>
				<Comment>Check for maximum number of element Device.Profiles (max = 1).</Comment>
				<Description>
					<Purpose>Not more than one object dictionary on one slave can be handled by the CoE or SoE services. Therefore, only one object dictionary makes sense. Test if only one element Device:Profile in ESI.</Purpose>
					<PreCondition>ESI file available.</PreCondition>
					<Action>Check the DuT's profiles in ESI (Device:Profile)</Action>
					<PostCondition>Warning if number of Device.Profiles is greater than 1. </PostCondition>
					<References>
						<Reference Specification="ETG.2000" Chapter=""></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="START">
					<WriteLine Id="0" Level="Output">Check ESI element Device:Profile:Count</WriteLine>
				</TestStep>
				<TestStep Name="INIT">
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Profile.Count</Value1>
							<Value2>0</Value2>
							<SkipCase Id="1">Case skipped because of empty element: Device:Profile</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CHECK">
					<Compare>
						<Greater>
							<Value1>DeviceDescr.Profile.Count</Value1>
							<Value2>1</Value2>
							<RaiseWarning Id="2">ESI contains more than one device profile.</RaiseWarning>
						</Greater>
					</Compare>
					<Compare>
						<Greater>
							<Value1>DeviceDescr.Profile.Count</Value1>
							<Value2>1</Value2>
							<Return Id="3"></Return>
						</Greater>
					</Compare>
				</TestStep>
				<TestStep Name="SUCCESS">
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Profile.Count</Value1>
							<Value2>1</Value2>
							<ReturnSuccess Id="4">Success | ESI contains only one device profile.</ReturnSuccess>
						</Equal>
					</Compare>
				</TestStep>
			</TestCase>
			<!--Case 5 (PDO Upload/Config/Assign) removed, it is allowed to support PDO upload and PDO assign/Config at the same time-->
			<TestCase Name="Device:Name" CaseId="6">
				<?MAX_OUTPUT_ID 4?>
				<Comment>The ESI element Device.Name shall not be empty</Comment>
				<Description>
					<Purpose>The ESI element Device.Name shall not be empty</Purpose>
					<PreCondition>ESI file available.</PreCondition>
					<Action>Scan the DuT's ESI for Device.Name</Action>
					<PostCondition>The Value shall not be empty</PostCondition>
					<References>
						<Reference Specification="ETG.2000" Chapter=""></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="START">
					<GetXmlValue ReturnValue="strXmlValue" Markup="true" FileName="EmptyString">
						<XPath>Name</XPath>
					</GetXmlValue>
				</TestStep>
				<TestStep Name="CHECK_IF_DEFINED">
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<RaiseError Id="0">ESI 'Device.Name' shall be defined</RaiseError>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<Return Id="1"></Return>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CHECK_IF_NOT_EMPTY">
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<RaiseError Id="2">ESI 'Device.Name' shall not be empty</RaiseError>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<Return Id="3"></Return>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="SUCCESS">
					<WriteLine Id="4" Level="Success">ESI 'Device.Name' is defined and not empty. Test case passed.</WriteLine>
				</TestStep>
			</TestCase>
			<TestCase Name="Device:HideType" CaseId="7">
				<?MAX_OUTPUT_ID 6?>
				<Comment>The ESI element Device.HideType shall not be empty</Comment>
				<Description>
					<Purpose>The ESI element Device.HideType shall not be empty</Purpose>
					<PreCondition>ESI file available.</PreCondition>
					<Action>Scan the DuT's ESI for Device.HideType</Action>
					<PostCondition>The Value shall not be empty</PostCondition>
					<References>
						<Reference Specification="ETG.2000" Chapter=""></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="INIT_LOOP_COUNTER">
					<!--"DeviceType.HideType.LoopCounter" = 1-->
					<SetVariable Target="Device.HideType.LoopCounter">1</SetVariable>
				</TestStep>
				<TestStep Name="INIT_RESULT">
					<SetVariable Target="result">true</SetVariable>
				</TestStep>
				<TestStep Name="SKIP_IF_NO_HIDE_TYPE_DEFINED">
					<Compare>
						<LowerOrEqual>
							<Value1>DeviceDescr.HideType.Count</Value1>
							<Value2>0</Value2>
							<SkipCase Id="0">No 'HideType' element defined. Skip Test.</SkipCase>
						</LowerOrEqual>
					</Compare>
				</TestStep>
				<TestStep Name="LOOP_START">
					<SetVariable Target="XPathTmp" Param0="Device.HideType.LoopCounter">HideType[{0}]</SetVariable>
				</TestStep>
				<TestStep Name="START">
					<GetXmlValue ReturnValue="strXmlValue" Markup="true" FileName="EmptyString">
						<XPath Param0="XPathTmp">{0}</XPath>
					</GetXmlValue>
					<WriteLine Id="1" Level="Verbose" Param0="(Device.HideType.LoopCounter - 1)" Param1="strXmlValue">Device.HideType[{0}] '{1}'.</WriteLine>
				</TestStep>
				<TestStep Name="CHECK_IF_DEFINED">
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>LOOP_END</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CHECK_IF_NOT_EMPTY">
					<Compare>
						<NotEqual>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>LOOP_END</GotoStep>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="GET_PRODUCT_CODE">
					<GetXmlValue ReturnValue="strXmlValue" Markup="true" FileName="EmptyString">
						<XPath Param0="XPathTmp">{0}/@ProductCode</XPath>
					</GetXmlValue>
					<WriteLine Id="2" Level="Verbose" Param0="(Device.HideType.LoopCounter - 1)" Param1="strXmlValue">Device.HideType[{0}]@ProductCode '{1}'.</WriteLine>
				</TestStep>
				<TestStep Name="CHECK_IF_PRODUCT_CODE_DEFINED">
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>GET_REVISION_NUMBER_CODE</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CHECK_IF_PRODUCT_CODE_IS_NOT_EMPTY">
					<Compare>
						<NotEqual>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>LOOP_END</GotoStep>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="GET_REVISION_NUMBER_CODE">
					<GetXmlValue ReturnValue="strXmlValue" Markup="true" FileName="EmptyString">
						<XPath Param0="XPathTmp">{0}/@RevisionNo</XPath>
					</GetXmlValue>
					<WriteLine Id="3" Level="Verbose" Param0="(Device.HideType.LoopCounter - 1)" Param1="strXmlValue">Device.HideType[{0}]@RevisionNo '{1}'.</WriteLine>
				</TestStep>
				<TestStep Name="CHECK_IF_REVISION_NUMBER_DEFINED">
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>DUMP_ERROR</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CHECK_IF_REVISION_NUMBER_IS_NOT_EMPTY">
					<Compare>
						<NotEqual>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>LOOP_END</GotoStep>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="DUMP_ERROR">
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="4" Level="Error" Param0="(Device.HideType.LoopCounter - 1)">Device.HideType[{0}] shall not be empty.</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="LOOP_END">
					<SetVariable Target="Device.HideType.LoopCounter">Device.HideType.LoopCounter + 1</SetVariable>
					<Compare>
						<LowerOrEqual>
							<Value1>Device.HideType.LoopCounter</Value1>
							<Value2>DeviceDescr.HideType.Count</Value2>
							<GotoStep>LOOP_START</GotoStep>
						</LowerOrEqual>
					</Compare>
				</TestStep>
				<TestStep Name="END">
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>true</Value2>
							<ReturnSuccess Id="5">Device.HideType definition valid.</ReturnSuccess>
						</Equal>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>result</Value1>
							<Value2>true</Value2>
							<RaiseError Id="6"></RaiseError>
						</NotEqual>
					</Compare>
				</TestStep>
			</TestCase>
			<TestCase Name="Device:GroupType" CaseId="8">
				<?MAX_OUTPUT_ID 4?>
				<Comment>The ESI element Device.GroupType shall not be empty</Comment>
				<Description>
					<Purpose>The ESI element Device.GroupType shall not be empty</Purpose>
					<PreCondition>ESI file available.</PreCondition>
					<Action>Scan the DuT's ESI for Device.GroupType</Action>
					<PostCondition>The Value shall not be empty</PostCondition>
					<References>
						<Reference Specification="ETG.2000" Chapter=""></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="START">
					<GetXmlValue ReturnValue="strXmlValue" Markup="true" FileName="EmptyString">
						<XPath>GroupType</XPath>
					</GetXmlValue>
				</TestStep>
				<TestStep Name="CHECK_IF_DEFINED">
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<RaiseError Id="0">Device.GroupType shall be defined.</RaiseError>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<Return Id="1"></Return>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CHECK_IF_EMPTY">
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<RaiseError Id="2">Device.GroupType shall not be empty.</RaiseError>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<Return Id="3"></Return>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="END">
					<WriteLine Id="4" Level="Success">Device.GroupType definition valid.</WriteLine>
				</TestStep>
			</TestCase>
			<TestCase Name="Device:Mailbox:DataLinkLayer" CaseId="9">
				<?MAX_OUTPUT_ID 2?>
				<Comment>The ESI element Mailbox@DataLinkLayer shall be true.</Comment>
				<Description>
					<Purpose>The ESI element Mailbox@DataLinkLayer (Indication that resilient mailobx layer supported) shall be true </Purpose>
					<PreCondition>ESI file available. Slave support mailbox protocol (element Mailbox available)</PreCondition>
					<Action>Search Mailbox@DataLinkLayer in ESI file</Action>
					<PostCondition>Mailbox@DataLinkLayer shall be TRUE</PostCondition>
					<References>
						<Reference Specification="ETG.2000" Chapter=""></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="CHECK_IF_MAILBOX_SUPPORTED">
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Mailbox</Value1>
							<Value2>False</Value2>
							<SkipCase Id="0">SKIP | Slave does not have the element Mailbox.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CHECK_IF_SUPPORTED">
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Mailbox.DataLinkLayer</Value1>
							<Value2>False</Value2>
							<RaiseError Id="1" Param0="DeviceDescr.Mailbox.DataLinkLayer">Mailbox@DataLinkLayer shall be supported | Expected = TRUE; read = {0:b}</RaiseError>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="SUCCESS">
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Mailbox.DataLinkLayer</Value1>
							<Value2>True</Value2>
							<ReturnSuccess Id="2" Param0="DeviceDescr.Mailbox.DataLinkLayer">SUCCESS | Mailbox@DataLinkLayer = {0:b}.</ReturnSuccess>
						</Equal>
					</Compare>
				</TestStep>
			</TestCase>
		</TestGroup>
		<TestGroup GroupId="2" Name="Comparison ESI to SII">
			<Comment>Reads data of the Slave Information Interface and compares it against the xml elements of the EtherCAT Slave Information File</Comment>
			<TestCase Name="Vendor ID" CaseId="1">
				<?MAX_OUTPUT_ID 4?>
				<Description>
					<Purpose>Compare the Vendor ID of the E²PROM (Word address: 0x0008) with the xml element //Vendor/Id.</Purpose>
					<PreCondition>- The DuT is online available</PreCondition>
					<Action>-Reads the VendorId of the EEPROM data via the SII
-Comparison of the read data to the corresponding ESI element /EtherCATInfo/Vendor/Id.</Action>
					<PostCondition>-Throws an error if reading of EEPROM data fails
-Throws an error if values are unequal</PostCondition>
					<References>
						<Reference Chapter="" Specification="ETG 2000"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="CheckSlavesOfflineState">
					<!--Check if slave is added offline.-->
					<Compare>
						<Equal>
							<Value1>Offline</Value1>
							<Value2>true</Value2>
							<SkipCase Id="0">DuT is in offline mode and therefore no EtherCAT communication possible</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<CallTestFunction Name="AssignEEPROMToECAT"></CallTestFunction>
				</TestStep>
				<TestStep>
					<ReadEEProm Target="uInt32Val">
						<Address>#x0008</Address>
						<Length>4</Length>
					</ReadEEProm>
					<RaiseErrorOnFailure Id="1">Failed to read E²PROM!</RaiseErrorOnFailure>
					<WriteLine Id="2" Param0="uInt32Val" Param1="DeviceDescr.VendorId" Level="Verbose">VendorID EEprom :0x{0:x} VendorID Device Descr:0x{1:x}</WriteLine>
					<Compare>
						<NotEqual>
							<Value1>uInt32Val</Value1>
							<Value2>DeviceDescr.VendorId</Value2>
							<RaiseError Id="3" Param0="uInt32Val" Param1="DeviceDescr.VendorId">Vendor ID EEProm (0x{0:x}) is unequal to the Vendor ID (0x{1:x}) of the EtherCAT Slave Information File</RaiseError>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep>
					<CallTestFunction Name="AssignEEPROMToPDI"></CallTestFunction>
				</TestStep>
				<TestStep>
					<WriteLine Id="4" Level="Success">Comparison of VendorID values succeeded</WriteLine>
				</TestStep>
			</TestCase>
			<TestCase Name="Product Code" CaseId="2">
				<?MAX_OUTPUT_ID 4?>
				<Description>
					<Purpose>Compare the Product Code of the E²PROM (Word address: 0x000A) with the xml element //Device/Type/@ProductCode.</Purpose>
					<PreCondition>- The DuT is online available
- The ESI file provides the mandatory element Product Code</PreCondition>
					<Action>-Reads the Product Code of the EEPROM data via the SII
-Comparison of the read data to the corresponding ESI element //Device/Type/ProductCode</Action>
					<PostCondition>-Throws an error if reading of EEPROM data fails
-Throws an error if values are unequal</PostCondition>
					<References>
						<Reference Chapter="" Specification="ETG 2000"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="CheckSlavesOfflineState">
					<!--Check if slave is added offline.-->
					<Compare>
						<Equal>
							<Value1>Offline</Value1>
							<Value2>true</Value2>
							<SkipCase Id="0">DuT is in offline mode and therefore no EtherCAT communication possible</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<CallTestFunction Name="AssignEEPROMToECAT"></CallTestFunction>
				</TestStep>
				<TestStep>
					<ReadEEProm Target="uInt32Val">
						<Address>#x000a</Address>
						<Length>4</Length>
					</ReadEEProm>
					<RaiseErrorOnFailure Id="1">Failed to read register!</RaiseErrorOnFailure>
					<WriteLine Id="2" Param0="uInt32Val" Param1="DeviceDescr.ProductCode" Level="Verbose">Product Code EEprom :0x{0:x} Product Code Device Descr:0x{1:x}</WriteLine>
					<Compare>
						<NotEqual>
							<Value1>uInt32Val</Value1>
							<Value2>DeviceDescr.ProductCode</Value2>
							<RaiseError Id="3" Param0="uInt32Val" Param1="DeviceDescr.ProductCode">Product Code EEProm (0x{0:x}) is unequal to the Product Code (0x{1:x}) of the EtherCAT Slave Information File</RaiseError>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep>
					<CallTestFunction Name="AssignEEPROMToPDI"></CallTestFunction>
				</TestStep>
				<TestStep>
					<WriteLine Id="4" Level="Success">Comparison of Product Code values succeeded</WriteLine>
				</TestStep>
			</TestCase>
			<TestCase Name="Revision Number" CaseId="3">
				<?MAX_OUTPUT_ID 4?>
				<Description>
					<Purpose>Compare the Revision Number of the E²PROM (Word address: 0x000C) with the xml element //Device/Type/@RevisionNo.</Purpose>
					<PreCondition>- The DuT is online available
- The ESI file provides the RevisionNo attribute</PreCondition>
					<Action>-Reads the Product Code of the EEPROM data via the SII
-Comparison of the read data to the corresponding ESI element //Device/Type/@RevisionNo.</Action>
					<PostCondition>-Throws an error if reading of EEPROM data fails
-Throws an error if values are unequal</PostCondition>
					<References>
						<Reference Chapter="" Specification="ETG 2000"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="CheckSlavesOfflineState">
					<!--Check if slave is added offline.-->
					<Compare>
						<Equal>
							<Value1>Offline</Value1>
							<Value2>true</Value2>
							<SkipCase Id="0">DuT is in offline mode and therefore no EtherCAT communication possible</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<CallTestFunction Name="AssignEEPROMToECAT"></CallTestFunction>
				</TestStep>
				<TestStep>
					<ReadEEProm Target="uInt32Val">
						<Address>#x000c</Address>
						<Length>4</Length>
					</ReadEEProm>
					<RaiseErrorOnFailure Id="1">Failed to read register!</RaiseErrorOnFailure>
					<WriteLine Id="2" Param0="uInt32Val" Param1="DeviceDescr.RevisionNo" Level="Verbose">RevisionNo EEprom :0x{0:x} RevisionNo Device Descr:0x{1:x}</WriteLine>
					<Compare>
						<NotEqual>
							<Value1>uInt32Val</Value1>
							<Value2>DeviceDescr.RevisionNo</Value2>
							<RaiseError Id="3" Param0="uInt32Val" Param1="DeviceDescr.RevisionNo">RevisionNo EEProm (0x{0:x}) is unequal to the RevisionNo (0x{1:x}) of the EtherCAT Slave Information File</RaiseError>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep>
					<CallTestFunction Name="AssignEEPROMToPDI"></CallTestFunction>
				</TestStep>
				<TestStep>
					<WriteLine Id="4" Level="Success">Comparison of Revision No. values succeeded</WriteLine>
				</TestStep>
			</TestCase>
			<TestCase Name="Serial Number" CaseId="4">
				<?MAX_OUTPUT_ID 5?>
				<Description>
					<Purpose>Compare the Serial Number of the E²PROM (Word address: 0x000E) with the xml element //Device/Type/@SerialNo.</Purpose>
					<PreCondition>- The DuT is online available
- The ESI file provides the SerialNo attribute</PreCondition>
					<Action>-Reads the Product Code of the EEPROM data via the SII
-Comparison of the read data to the corresponding ESI element //Device/Type/@SerialNo.</Action>
					<PostCondition>-Throws an error if reading of EEPROM data fails
-Throws an error if values are unequal</PostCondition>
					<References>
						<Reference Chapter="" Specification="ETG 2000"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="CheckSlavesOfflineState">
					<!--Check if slave is added offline.-->
					<Compare>
						<Equal>
							<Value1>Offline</Value1>
							<Value2>true</Value2>
							<SkipCase Id="0">DuT is in offline mode and therefore no EtherCAT communication possible</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.SerialNo</Value1>
							<Value2>null</Value2>
							<SkipCase Id="1">SerialNo is not defined</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<CallTestFunction Name="AssignEEPROMToECAT"></CallTestFunction>
				</TestStep>
				<TestStep>
					<ReadEEProm Target="uInt32Val">
						<Address>#x000e</Address>
						<Length>4</Length>
					</ReadEEProm>
					<RaiseErrorOnFailure Id="2">Failed to read register!</RaiseErrorOnFailure>
					<WriteLine Id="3" Param0="uInt32Val" Param1="DeviceDescr.SerialNo">SerialNo EEprom :{0:d} SerialNo Device Descr:{1:d}</WriteLine>
					<Compare>
						<NotEqual>
							<Value1>uInt32Val</Value1>
							<Value2>DeviceDescr.SerialNo</Value2>
							<RaiseWarning Id="4" Param0="uInt32Val" Param1="DeviceDescr.SerialNo">SerialNo EEProm ({0:d}) is unequal to the SerialNo ({1:d}) of the EtherCAT Slave Information File</RaiseWarning>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep>
					<CallTestFunction Name="AssignEEPROMToPDI"></CallTestFunction>
				</TestStep>
				<TestStep>
					<WriteLine Id="5" Level="Success">Comparison of Serial No. values succeeded</WriteLine>
				</TestStep>
			</TestCase>
			<TestCase Name="Mailbox Protocols" CaseId="5">
				<?MAX_OUTPUT_ID 16?>
				<Description>
					<Purpose>Compare the named protocols of the E²PROM (Word address: 0x001C) with the xml element //Device/Mailbox.</Purpose>
					<PreCondition>- The DuT is online available
- The ESI file provides at least the mailbox element //Device/Mailbox</PreCondition>
					<Action>-Read the supported mailbox protocols of the EEPROM data via the SII
-Comparison of the read data to the corresponding ESI elements if specified (//Device/Mailbox)</Action>
					<PostCondition>-Throws an error if reading of EEPROM data fails
-Throws an error if at least one compared value is unequal</PostCondition>
					<References>
						<Reference Chapter="" Specification="ETG 2000"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="CheckSlavesOfflineState">
					<!--Check if slave is added offline.-->
					<Compare>
						<Equal>
							<Value1>Offline</Value1>
							<Value2>true</Value2>
							<SkipCase Id="0">DuT is in offline mode and therefore no EtherCAT communication possible</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<CallTestFunction Name="AssignEEPROMToECAT"></CallTestFunction>
				</TestStep>
				<TestStep>
					<ReadEEProm Target="uInt32Val">
						<Address>#x001c</Address>
						<Length>4</Length>
					</ReadEEProm>
					<RaiseErrorOnFailure Id="1">Failed to read register!</RaiseErrorOnFailure>
					<WriteLine Id="2" Param0="uInt32Val">EEProm Data Address 0x001C: 0x{0:x}</WriteLine>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Mailbox</Value1>
							<Value2>false</Value2>
							<Return Id="3">Device does not support mailbox communication</Return>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<GetBits Source="uInt32Val" Target="boolVar">
						<Offset>2</Offset>
						<Length>1</Length>
					</GetBits>
					<WriteLine Id="4" Param1="boolVar" Param0="DeviceDescr.Mailbox.CoE">DeviceDescription: Device:Mailbox:CoE {0} EEProm CoE support : {1}</WriteLine>
					<Compare>
						<NotEqual>
							<Value1>boolVar</Value1>
							<Value2>DeviceDescr.Mailbox.CoE</Value2>
							<RaiseError Id="5">Named protocol of EEProm (Address 0x001c) is different to the protocol of the EtherCAT Slave Information File (CoE)</RaiseError>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep>
					<GetBits Source="uInt32Val" Target="boolVar">
						<Offset>0</Offset>
						<Length>1</Length>
					</GetBits>
					<WriteLine Id="6" Param1="boolVar" Param0="DeviceDescr.Mailbox.AoE">DeviceDescription: Device:Mailbox:AoE {0} EEProm AoE support : {1}</WriteLine>
					<Compare>
						<NotEqual>
							<Value1>boolVar</Value1>
							<Value2>DeviceDescr.Mailbox.AoE</Value2>
							<RaiseError Id="7">Named protocol of EEProm (Address 0x001c) is different to the protocol of the EtherCAT Slave Information File (AoE)</RaiseError>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep>
					<GetBits Source="uInt32Val" Target="boolVar">
						<Offset>1</Offset>
						<Length>1</Length>
					</GetBits>
					<WriteLine Id="8" Param1="boolVar" Param0="DeviceDescr.Mailbox.EoE">DeviceDescription: Device:Mailbox:EoE {0} EEProm EoE support : {1}</WriteLine>
					<Compare>
						<NotEqual>
							<Value1>boolVar</Value1>
							<Value2>DeviceDescr.Mailbox.EoE</Value2>
							<RaiseError Id="9">Named protocol of EEProm (Address 0x001c) is different to the protocol of the EtherCAT Slave Information File (EoE)</RaiseError>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep>
					<GetBits Source="uInt32Val" Target="boolVar">
						<Offset>4</Offset>
						<Length>1</Length>
					</GetBits>
					<WriteLine Id="10" Param1="boolVar" Param0="DeviceDescr.Mailbox.SoE">DeviceDescription: Device:Mailbox:SoE {0} EEProm SoE support : {1}</WriteLine>
					<Compare>
						<NotEqual>
							<Value1>boolVar</Value1>
							<Value2>DeviceDescr.Mailbox.SoE</Value2>
							<RaiseError Id="11">Named protocol of EEProm (Address 0x001c) is different to the protocol of the EtherCAT Slave Information File (SoE)</RaiseError>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep>
					<GetBits Source="uInt32Val" Target="boolVar">
						<Offset>3</Offset>
						<Length>1</Length>
					</GetBits>
					<WriteLine Id="12" Param1="boolVar" Param0="DeviceDescr.Mailbox.FoE">DeviceDescription: Device:Mailbox:FoE {0} EEProm FoE support : {1}</WriteLine>
					<Compare>
						<NotEqual>
							<Value1>boolVar</Value1>
							<Value2>DeviceDescr.Mailbox.FoE</Value2>
							<RaiseError Id="13">Named protocol of EEProm (Address 0x001c) is different to the protocol of the EtherCAT Slave Information File (FoE)</RaiseError>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep>
					<GetBits Source="uInt32Val" Target="boolVar">
						<Offset>5</Offset>
						<Length>1</Length>
					</GetBits>
					<WriteLine Id="14" Param1="boolVar" Param0="DeviceDescr.Mailbox.VoE">DeviceDescription: Device:Mailbox:VoE {0} EEProm VoE support : {1}</WriteLine>
					<Compare>
						<NotEqual>
							<Value1>boolVar</Value1>
							<Value2>DeviceDescr.Mailbox.VoE</Value2>
							<RaiseError Id="15">Named protocol of EEProm (Address 0x001c) is different to the protocol of the EtherCAT Slave Information File (VoE)</RaiseError>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep>
					<CallTestFunction Name="AssignEEPROMToPDI"></CallTestFunction>
				</TestStep>
				<TestStep>
					<WriteLine Id="16" Level="Success">Comparison of the named protocol values succeeded</WriteLine>
				</TestStep>
			</TestCase>
			<TestCase Name="E²PROM Size" CaseId="6">
				<?MAX_OUTPUT_ID 6?>
				<Description>
					<Purpose>Compare the size of the E²PROM (Word address: 0x003E) with the defined size in the ESI file //Device/Eeprom/ByteSize.</Purpose>
					<PreCondition>- The DuT is online available</PreCondition>
					<Action>-Read the supported mailbox protocols of the EEPROM data via the SII
-Comparison of the read data to the corresponding ESI elements if specified //Device/Eeprom/ByteSize</Action>
					<PostCondition>-Throws an error if reading of EEPROM data fails
-Throws an error if readed E²PROM size is greater than specified size in ESI</PostCondition>
					<References>
						<Reference Chapter="" Specification="ETG 2000"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="CheckSlavesOfflineState">
					<!--Check if slave is added offline.-->
					<Compare>
						<Equal>
							<Value1>Offline</Value1>
							<Value2>true</Value2>
							<SkipCase Id="0">DuT is in offline mode and therefore no EtherCAT communication possible</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Eeprom</Value1>
							<Value2>false</Value2>
							<SkipCase Id="1">The element EtherCATInfo:Descriptions:Devices:Device:Eeprom is not defined</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Eeprom.ByteSize</Value1>
							<Value2>null</Value2>
							<SkipCase Id="2">The element EtherCATInfo:Descriptions:Devices:Device:Eeprom:ByteSize is not defined</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<SetVariable Target="uInt16Val">#x003e</SetVariable>
				</TestStep>
				<TestStep>
					<CallTestFunction Name="AssignEEPROMToECAT"></CallTestFunction>
				</TestStep>
				<TestStep>
					<ReadEEProm Target="int32Val">
						<Address>uInt16Val</Address>
						<Length>2</Length>
					</ReadEEProm>
					<RaiseErrorOnFailure Id="3">Failed to read E²PROM!</RaiseErrorOnFailure>
				</TestStep>
				<TestStep>
					<SetVariable Target="int32Val">(int32Val+1)*128</SetVariable>
					<WriteLine Id="4" Param0="int32Val" Param1="DeviceDescr.Eeprom.ByteSize"> E²PROMSize E²PROM :{0:d} Byte  E²PROMSize Device Descr:{1:d} Byte</WriteLine>
					<Compare>
						<Greater>
							<Value1>int32Val</Value1>
							<Value2>DeviceDescr.Eeprom.ByteSize</Value2>
							<RaiseError Id="5">E²PROMSize  E²PROM is greater than the  E²PROMSize of the EtherCAT Slave Information File</RaiseError>
						</Greater>
					</Compare>
				</TestStep>
				<TestStep>
					<CallTestFunction Name="AssignEEPROMToPDI"></CallTestFunction>
				</TestStep>
				<TestStep>
					<WriteLine Id="6" Level="Success">Comparison of EEPROM size values succeeded</WriteLine>
				</TestStep>
			</TestCase>
			<TestCase Name="E²PROM Data" CaseId="7">
				<?MAX_OUTPUT_ID 6?>
				<Description>
					<Purpose>Compare the complete E²PROM data with the element //Device/Eeprom/ConfigData.</Purpose>
					<PreCondition>- The DuT is online available</PreCondition>
					<Action>-Gets the full EEPROM data via the SII
-Comparison of the read data to the corresponding ESI element //Device/Eeprom/ConfigData.</Action>
					<PostCondition>-Throws an error if reading of EEPROM data fails
-Throws an error if values are unequal.</PostCondition>
					<References>
						<Reference Chapter="" Specification="ETG 2000"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="CheckSlavesOfflineState">
					<!--Check if slave is added offline.-->
					<Compare>
						<Equal>
							<Value1>Offline</Value1>
							<Value2>true</Value2>
							<SkipCase Id="0">DuT is in offline mode and therefore no EtherCAT communication possible</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Eeprom</Value1>
							<Value2>false</Value2>
							<SkipCase Id="1">The element EtherCATInfo:Descriptions:Devices:Device:Eeprom is not defined</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<SizeOf UInt32Var="uInt32Val">DeviceDescr.Eeprom.Data</SizeOf>
					<Compare>
						<Equal>
							<Value1>uInt32Val</Value1>
							<Value2>0</Value2>
							<SkipCase Id="2">The element EtherCATInfo:Descriptions:Devices:Device:Eeprom:Data  is not defined</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<CallTestFunction Name="GetEEPROMData">
						<Parameter>0US</Parameter>
						<Parameter>uInt32Val</Parameter>
						<OutParameter>byteArr</OutParameter>
					</CallTestFunction>
					<RaiseErrorOnFailure Id="3">Failed to read E²PROM!</RaiseErrorOnFailure>
				</TestStep>
				<TestStep>
					<Description Id="4" Level="Verbose" Param0="DeviceDescr.Eeprom.Data">DeviceDescr.Eeprom.Data : {0}</Description>
					<Compare>
						<NotEqual>
							<Value1>DeviceDescr.Eeprom.Data</Value1>
							<Value2>byteArr</Value2>
							<RaiseError Id="5">elements are unequal </RaiseError>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep>
					<WriteLine Id="6" Level="Success">Comparison of EEPROM data succeeded</WriteLine>
				</TestStep>
			</TestCase>
			<TestCase Name="E²PROM ConfigData" CaseId="8">
				<?MAX_OUTPUT_ID 19?>
				<Description>
					<Purpose>The intention is to compare the ESI EEPROM Config Data at:  /EtherCATInfo/Descriptions/Devices/Device/Eeprom/ConfigData with the first 7 words of the SIII data.</Purpose>
					<PreCondition>- The DuT is online available
- The ESI file provides an Eeprom element</PreCondition>
					<Action>-Read the first seven words of the EEPROM data via the SII
-Comparison of the read data to the corresponding ESI element (Device:Eeprom:ConfigData) wordwise</Action>
					<PostCondition>-Throws an error if reading of EEPROM data fails
-Not matching words are leading to an error except the word for the Station Alias
-The Station Alias at the Device:Eeeprom:ConfigData element should be 0x0000 otherwise a warning is thrown</PostCondition>
					<References>
						<Reference Chapter="" Specification="ETG 2000"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="CheckSlavesOfflineState">
					<!--Check if slave is added offline.-->
					<Compare>
						<Equal>
							<Value1>Offline</Value1>
							<Value2>true</Value2>
							<SkipCase Id="0">DuT is in offline mode and therefore no EtherCAT communication possible</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckForEepromElement">
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Eeprom</Value1>
							<Value2>false</Value2>
							<SkipCase Id="1">The element EtherCATInfo:Descriptions:Devices:Device:Eeprom is not defined</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckSize">
					<SizeOf UInt32Var="uInt32Val">DeviceDescr.Eeprom.ConfigData</SizeOf>
					<Compare>
						<Equal>
							<Value1>uInt32Val</Value1>
							<Value2>0</Value2>
							<SkipCase Id="2">The element EtherCATInfo:Descriptions:Devices:Device:Eeprom:ConfigData  is not defined</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>uInt32Val</Value1>
							<Value2>14</Value2>
							<RaiseError Id="3" Param0="uInt32Val">DeviceDescr.Eeprom.ConfigData has to be size of 14</RaiseError>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="ReadEepromData">
					<CallTestFunction Name="GetEEPROMData">
						<Parameter>0US</Parameter>
						<Parameter>uInt32Val</Parameter>
						<OutParameter>byteArr</OutParameter>
					</CallTestFunction>
					<RaiseErrorOnFailure Id="4">Failed to read E²PROM!</RaiseErrorOnFailure>
				</TestStep>
				<TestStep Name="GetPdiControlEEPROM">
					<GetBits Source="byteArr" Target="uint16_temp_sii_data">
						<Offset>0</Offset>
						<Length>16</Length>
					</GetBits>
				</TestStep>
				<TestStep Name="GetPdiControlEsi">
					<GetBits Source="DeviceDescr.Eeprom.ConfigData" Target="uint16_temp_esi_data">
						<Offset>0</Offset>
						<Length>16</Length>
					</GetBits>
					<RaiseErrorOnFailure Id="5">Failed to get PDI Control of ESI Eeprom/ConfigData element</RaiseErrorOnFailure>
					<Compare>
						<NotEqual>
							<Value1>uint16_temp_sii_data</Value1>
							<Value2>uint16_temp_esi_data</Value2>
							<RaiseError Id="6" Param0="uint16_temp_sii_data" Param1="uint16_temp_esi_data">The PDI Control data of the EEPROM (word address 0) '0x{0:x4}' is not matching to the corresponding data part at the DeviceType:EEPROM:ConfigData value '0x{1:x4}'.</RaiseError>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="GetPdiConfigEEPROM">
					<GetBits Source="byteArr" Target="uint16_temp_sii_data">
						<Offset>16</Offset>
						<Length>16</Length>
					</GetBits>
				</TestStep>
				<TestStep Name="GetPdiConfigEsi">
					<GetBits Source="DeviceDescr.Eeprom.ConfigData" Target="uint16_temp_esi_data">
						<Offset>16</Offset>
						<Length>16</Length>
					</GetBits>
					<RaiseErrorOnFailure Id="7">Failed to get PDI Configuration of ESI Eeprom/ConfigData element</RaiseErrorOnFailure>
					<Compare>
						<NotEqual>
							<Value1>uint16_temp_sii_data</Value1>
							<Value2>uint16_temp_esi_data</Value2>
							<RaiseError Id="8" Param0="uint16_temp_sii_data" Param1="uint16_temp_esi_data">The PDI Configuration data of the EEPROM (word address 1) '0x{0:x4}' is not matching to the corresponding data part at the DeviceType:EEPROM:ConfigData value '0x{1:x4}'.</RaiseError>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="GetSyncImpulseLenEEPROM">
					<GetBits Source="byteArr" Target="uint16_temp_sii_data">
						<Offset>32</Offset>
						<Length>16</Length>
					</GetBits>
				</TestStep>
				<TestStep Name="GetSyncImpulseLenEsi">
					<GetBits Source="DeviceDescr.Eeprom.ConfigData" Target="uint16_temp_esi_data">
						<Offset>32</Offset>
						<Length>16</Length>
					</GetBits>
					<RaiseErrorOnFailure Id="9">Failed to get theSyncImpulseLen of ESI Eeprom/ConfigData element</RaiseErrorOnFailure>
					<Compare>
						<NotEqual>
							<Value1>uint16_temp_sii_data</Value1>
							<Value2>uint16_temp_esi_data</Value2>
							<RaiseError Id="10" Param0="uint16_temp_sii_data" Param1="uint16_temp_esi_data">The SyncImpulseLen data of the EEPROM (word address 2) '0x{0:x4}' is not matching to the corresponding data part at the DeviceType:EEPROM:ConfigData value '0x{1:x4}'.</RaiseError>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="GetPdiConfiguration2EEPROM">
					<GetBits Source="byteArr" Target="uint16_temp_sii_data">
						<Offset>48</Offset>
						<Length>16</Length>
					</GetBits>
				</TestStep>
				<TestStep Name="GetPdiConfiguration2Esi">
					<GetBits Source="DeviceDescr.Eeprom.ConfigData" Target="uint16_temp_esi_data">
						<Offset>48</Offset>
						<Length>16</Length>
					</GetBits>
					<RaiseErrorOnFailure Id="11">Failed to get PDI Configuration 2 of ESI Eeprom/ConfigData element</RaiseErrorOnFailure>
					<Compare>
						<NotEqual>
							<Value1>uint16_temp_sii_data</Value1>
							<Value2>uint16_temp_esi_data</Value2>
							<RaiseError Id="12" Param0="uint16_temp_sii_data" Param1="uint16_temp_esi_data">The PDI Configuration2 data of the EEPROM (word address 3) '0x{0:x4}' is not matching to the corresponding data part at the DeviceType:EEPROM:ConfigData value '0x{1:x4}'.</RaiseError>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="GetEsiStationAlias">
					<GetBits Source="DeviceDescr.Eeprom.ConfigData" Target="uint16_temp_esi_data">
						<Offset>64</Offset>
						<Length>16</Length>
					</GetBits>
					<RaiseErrorOnFailure Id="13">Failed to get Station Alias of ESI Eeprom/ConfigData element</RaiseErrorOnFailure>
					<Compare>
						<NotEqual>
							<Value1>uint16_temp_esi_data</Value1>
							<Value2>0</Value2>
							<RaiseWarning Id="14" Param0="uint16_temp_esi_data">The value for Configured Station Alias in the element Eeprom:ConfigData should be 0x0000 (read 0x{0:x4}) as the Configured Station Alias value normally is changed by the user using a master/configuration tool if necessary.</RaiseWarning>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="GetPdiReserved1EEPROM">
					<GetBits Source="byteArr" Target="uint16_temp_sii_data">
						<Offset>80</Offset>
						<Length>16</Length>
					</GetBits>
				</TestStep>
				<TestStep Name="GetReserved1Esi">
					<GetBits Source="DeviceDescr.Eeprom.ConfigData" Target="uint16_temp_esi_data">
						<Offset>80</Offset>
						<Length>16</Length>
					</GetBits>
					<RaiseErrorOnFailure Id="15">Failed to get the reserved part of ESI Eeprom/ConfigData element</RaiseErrorOnFailure>
					<Compare>
						<NotEqual>
							<Value1>uint16_temp_sii_data</Value1>
							<Value2>uint16_temp_esi_data</Value2>
							<RaiseError Id="16" Param0="uint16_temp_sii_data" Param1="uint16_temp_esi_data">The Reserved data of the EEPROM (word address 5) '0x{0:x4}' is not matching to the corresponding data part at the DeviceType:EEPROM:ConfigData value '0x{1:x4}'.</RaiseError>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="GetReserved2EEPROM">
					<GetBits Source="byteArr" Target="uint16_temp_sii_data">
						<Offset>96</Offset>
						<Length>16</Length>
					</GetBits>
				</TestStep>
				<TestStep Name="GetReserved2Esi">
					<GetBits Source="DeviceDescr.Eeprom.ConfigData" Target="uint16_temp_esi_data">
						<Offset>96</Offset>
						<Length>16</Length>
					</GetBits>
					<RaiseErrorOnFailure Id="17">Failed to get the reserved part of ESI Eeprom/ConfigData element</RaiseErrorOnFailure>
					<Compare>
						<NotEqual>
							<Value1>uint16_temp_sii_data</Value1>
							<Value2>uint16_temp_esi_data</Value2>
							<RaiseError Id="18" Param0="uint16_temp_sii_data" Param1="uint16_temp_esi_data">The Reserved data of the EEPROM (word address 6) '0x{0:x4}' is not matching to the corresponding data part at the DeviceType:EEPROM:ConfigData value '0x{1:x4}'.</RaiseError>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="WriteSuccess">
					<WriteLine Id="19" Level="Success">Comparison of EEPROM ConfigData to the corresponding ESI element succeeded</WriteLine>
				</TestStep>
			</TestCase>
			<TestCase Name="E²PROM BootStrap" CaseId="9">
				<?MAX_OUTPUT_ID 8?>
				<Description>
					<Purpose>Compare the E²PROM data (0x0014:0x0017) with the xml element //Device/Eeprom/BootStrap.</Purpose>
					<PreCondition>- The DuT is online available
- The ESI file provides the //Device/Eeprom/BootStrap element.</PreCondition>
					<Action>-Read the supported mailbox protocols of the EEPROM data via the SII
-Comparison of the read data to the corresponding ESI element //Device/Eeprom/BootStrap if specified.</Action>
					<PostCondition>-Throws an error if reading of EEPROM data fails
-Throws an error if values are unequal.</PostCondition>
					<References>
						<Reference Chapter="" Specification="ETG 2000"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="CheckSlavesOfflineState">
					<!--Check if slave is added offline.-->
					<Compare>
						<Equal>
							<Value1>Offline</Value1>
							<Value2>true</Value2>
							<SkipCase Id="0">DuT is in offline mode and therefore no EtherCAT communication possible</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Eeprom</Value1>
							<Value2>false</Value2>
							<SkipCase Id="1">The element EtherCATInfo:Descriptions:Devices:Device:Eeprom is not defined</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<SizeOf UInt32Var="uInt32Val">DeviceDescr.Eeprom.BootStrap</SizeOf>
					<Compare>
						<Equal>
							<Value1>uInt32Val</Value1>
							<Value2>0</Value2>
							<SkipCase Id="2">The element EtherCATInfo:Descriptions:Devices:Device:Eeprom:BootStrap is not defined</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>uInt32Val</Value1>
							<Value2>4</Value2>
							<RaiseError Id="3" Param0="uInt32Val">Invalid word length of HexBin value of  DeviceDescr.Eeprom.BootStrap element. Expected word length 4, read {0}</RaiseError>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep>
					<CallTestFunction Name="ReadEepromDataWordWise">
						<Parameter>4</Parameter>
						<Parameter>#x14</Parameter>
						<OutParameter>arrayOfUint16_eepromData</OutParameter>
					</CallTestFunction>
					<RaiseErrorOnFailure Id="4">Failed to read E²PROM!</RaiseErrorOnFailure>
				</TestStep>
				<TestStep>
					<Compare>
						<NotEqual>
							<Value1>DeviceDescr.Eeprom.BootStrap</Value1>
							<Value2>arrayOfUint16_eepromData</Value2>
							<RaiseError Id="5" Param0="DeviceDescr.Eeprom.BootStrap" Param1="arrayOfUint16_eepromData">The BootStrap data of the ESI file '{0}' does not match to the BootStrap data of the EEPROM '{1}'</RaiseError>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep>
					<WriteLine Id="6" Level="Verbose" Param0="arrayOfUint16_eepromData">EEPROM BootStrap data: {0}</WriteLine>
					<WriteLine Id="7" Level="Verbose" Param0="DeviceDescr.Eeprom.BootStrap">ESI BootStrap data: {0}</WriteLine>
					<WriteLine Id="8" Level="Success">Comparison of EEPROM BootStrap succeeded</WriteLine>
				</TestStep>
			</TestCase>
			<TestCase Name="E²PROM General Category" CaseId="10">
				<?MAX_OUTPUT_ID 28?>
				<Description>
					<Purpose>Check the E²PROM for General Category and compare its content with the corresponding XML elements (e.g. //Device/Mailbox/CoE,FoE,EoE; //Device/@Physics).</Purpose>
					<PreCondition>- The DuT is online available
- The EEPROM contains a general category
- ESI contains at least one general category (e.g. //Device/Mailbox or //Device/@Physics)</PreCondition>
					<Action>- Comparison if the EEPROM General Category data is specified
- Comparison of General Categories to specified ESI elements</Action>
					<PostCondition>- Throws an error if EEPROM does not contain the General Category
- Throws an error if categories are unequal</PostCondition>
					<References>
						<Reference Specification="ETG.2000"></Reference>
						<Reference Specification="ETG.2010"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="CheckSlavesOfflineState">
					<!--Check if slave is added offline.-->
					<Compare>
						<Equal>
							<Value1>Offline</Value1>
							<Value2>true</Value2>
							<SkipCase Id="0">DuT is in offline mode and therefore no EtherCAT communication possible</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Eeprom</Value1>
							<Value2>false</Value2>
							<SkipCase Id="1">The element EtherCATInfo:Descriptions:Devices:Device:Eeprom is not defined.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<Compare>
						<Equal>
							<Value1>EEPROM.CatGeneral</Value1>
							<Value2>false</Value2>
							<RaiseError Id="2">E²PROM does not contain the General Category.</RaiseError>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckGroupType">
					<Compare>
						<Equal>
							<Value1>EEPROM.CatGeneral.GroupIdx</Value1>
							<Value2>0</Value2>
							<GotoStep>CheckImage</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Greater>
							<Value1>EEPROM.CatGeneral.GroupIdx</Value1>
							<Value2>EEPROM.CatString.Count</Value2>
							<RaiseError Id="3" Param0="EEPROM.CatGeneral.GroupIdx" Param1="EEPROM.CatString.Count">Group Type index to Strings ({0}) is higher than the max index.</RaiseError>
						</Greater>
					</Compare>
				</TestStep>
				<TestStep Name="GetGroupTypeESI">
					<GetXmlValue ReturnValue="StringCurrXPathValue" Markup="true">
						<XPath>GroupType</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>EEPROM.CatString.Count</Value1>
							<Value2>0</Value2>
							<GotoStep>CheckImage</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>StringCurrXPathValue</Value1>
							<Value2>null</Value2>
							<RaiseError Id="4">GroupType not found in ESI.</RaiseError>
						</Equal>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>StringCurrXPathValue</Value1>
							<Value2>EEPROM.CatString[EEPROM.CatGeneral.GroupIdx-1]</Value2>
							<RaiseError Id="5" Param0="EEPROM.CatString[EEPROM.CatGeneral.GroupIdx-1]" Param1="StringCurrXPathValue">GroupType of EEPROM ({0}) is unequal to element of ESI ({1}).</RaiseError>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="CheckImage">
					<Compare>
						<Equal>
							<Value1>EEPROM.CatGeneral.ImgIdx</Value1>
							<Value2>0</Value2>
							<GotoStep>CheckOrder</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Greater>
							<Value1>EEPROM.CatGeneral.ImgIdx</Value1>
							<Value2>EEPROM.CatString.Count</Value2>
							<RaiseError Id="6" Param0="EEPROM.CatGeneral.ImgIdx" Param1="EEPROM.CatString.Count">Image index to Strings ({0}) is higher than the max index.</RaiseError>
						</Greater>
					</Compare>
				</TestStep>
				<TestStep Name="CheckOrder">
					<Compare>
						<Equal>
							<Value1>EEPROM.CatGeneral.OrderIdx</Value1>
							<Value2>0</Value2>
							<GotoStep>CheckSoEChannels</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Greater>
							<Value1>EEPROM.CatGeneral.OrderIdx</Value1>
							<Value2>EEPROM.CatString.Count</Value2>
							<RaiseError Id="7" Param0="EEPROM.CatGeneral.OrderIdx" Param1="EEPROM.CatString.Count">Order index to Strings ({0}) is higher than the max index.</RaiseError>
						</Greater>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>EEPROM.CatString[EEPROM.CatGeneral.OrderIdx-1]</Value1>
							<Value2>DeviceDescr.Type</Value2>
							<RaiseError Id="8" Param0="EEPROM.CatString[EEPROM.CatGeneral.OrderIdx-1]" Param1="DeviceDescr.Type">Order ID of EEPROM ({0}) is unequal to element of ESI ({1}).</RaiseError>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="CheckSoEChannels">
					<Compare>
						<Greater>
							<Value1>EEPROM.CatGeneral.SoEChannels</Value1>
							<Value2>EEPROM.CatString.Count</Value2>
							<RaiseError Id="9" Param0="EEPROM.CatGeneral.SoEChannels" Param1="EEPROM.CatString.Count">SoE Channels index to Strings ({0}) is higher than the max index.</RaiseError>
						</Greater>
					</Compare>
				</TestStep>
				<TestStep Name="CheckName">
					<Compare>
						<Equal>
							<Value1>EEPROM.CatGeneral.NameIdx</Value1>
							<Value2>0</Value2>
							<GotoStep>CheckPort0</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Greater>
							<Value1>EEPROM.CatGeneral.NameIdx</Value1>
							<Value2>EEPROM.CatString.Count</Value2>
							<RaiseError Id="10" Param0="EEPROM.CatGeneral.NameIdx" Param1="EEPROM.CatString.Count">Name index to Strings ({0}) is higher than the max index.</RaiseError>
						</Greater>
					</Compare>
				</TestStep>
				<TestStep Name="IncrementCount">
					<SetVariable Target="count">count+1</SetVariable>
				</TestStep>
				<TestStep Name="GetNameXPath">
					<GetXmlValue ReturnValue="StringCurrXPathValue" Markup="false">
						<XPath Param0="count">Name[position()={0}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>EEPROM.CatString.Count</Value1>
							<Value2>0</Value2>
							<GotoStep>CheckPort0</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>StringCurrXPathValue</Value1>
							<Value2>null</Value2>
							<RaiseError Id="11" Param0="EEPROM.CatString[EEPROM.CatGeneral.NameIdx-1]" Param1="EEPROM.CatGeneral.NameIdx-1">Name (EEPROM String Category Index '{1}') of DuT ({0}) not found in ESI.</RaiseError>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>StringCurrXPathValue</Value1>
							<Value2>EEPROM.CatString[EEPROM.CatGeneral.NameIdx-1]</Value2>
							<GotoStep>CheckPort0</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="DetailedCompare">
					<CallTestFunction Name="DetailedStringCompare">
						<Parameter>StringCurrXPathValue</Parameter>
						<Parameter>EEPROM.CatString[EEPROM.CatGeneral.NameIdx-1]</Parameter>
						<OutParameter>boolVar</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>boolVar</Value1>
							<Value2>false</Value2>
							<GotoStep>IncrementCount</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckPort0">
					<Compare>
						<Equal>
							<Value1>EEPROM.CatGeneral.PhysicalPort0</Value1>
							<Value2>EBUS</Value2>
							<GotoStep>CheckPort1</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>EEPROM.CatGeneral.PhysicalPort0</Value1>
							<Value2>MII</Value2>
							<GotoStep>CheckPort1</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>EEPROM.CatGeneral.PhysicalPort0</Value1>
							<Value2>NotUsed</Value2>
							<GotoStep>CheckPort1</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>EEPROM.CatGeneral.PhysicalPort0</Value1>
							<Value2>Reserved</Value2>
							<GotoStep>CheckPort1</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="12" Level="Warning" Param0="EEPROM.CatGeneral.PhysicalPort0">Invalid value ({0}) of PhysicalPort0.</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckPort1">
					<Compare>
						<Equal>
							<Value1>EEPROM.CatGeneral.PhysicalPort1</Value1>
							<Value2>EBUS</Value2>
							<GotoStep>CheckPort2</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>EEPROM.CatGeneral.PhysicalPort1</Value1>
							<Value2>MII</Value2>
							<GotoStep>CheckPort2</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>EEPROM.CatGeneral.PhysicalPort1</Value1>
							<Value2>NotUsed</Value2>
							<GotoStep>CheckPort2</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>EEPROM.CatGeneral.PhysicalPort1</Value1>
							<Value2>Reserved</Value2>
							<GotoStep>CheckPort2</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="13" Level="Warning" Param0="EEPROM.CatGeneral.PhysicalPort1">Invalid value ({0}) of PhysicalPort1.</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckPort2">
					<Compare>
						<Equal>
							<Value1>EEPROM.CatGeneral.PhysicalPort2</Value1>
							<Value2>EBUS</Value2>
							<GotoStep>CheckPort3</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>EEPROM.CatGeneral.PhysicalPort2</Value1>
							<Value2>MII</Value2>
							<GotoStep>CheckPort3</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>EEPROM.CatGeneral.PhysicalPort2</Value1>
							<Value2>NotUsed</Value2>
							<GotoStep>CheckPort3</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>EEPROM.CatGeneral.PhysicalPort2</Value1>
							<Value2>Reserved</Value2>
							<GotoStep>CheckPort3</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="14" Level="Warning" Param0="EEPROM.CatGeneral.PhysicalPort2">Invalid value ({0}) of PhysicalPort2.</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckPort3">
					<Compare>
						<Equal>
							<Value1>EEPROM.CatGeneral.PhysicalPort3</Value1>
							<Value2>EBUS</Value2>
							<GotoStep>CheckCoE</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>EEPROM.CatGeneral.PhysicalPort3</Value1>
							<Value2>MII</Value2>
							<GotoStep>CheckCoE</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>EEPROM.CatGeneral.PhysicalPort3</Value1>
							<Value2>NotUsed</Value2>
							<GotoStep>CheckCoE</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>EEPROM.CatGeneral.PhysicalPort3</Value1>
							<Value2>Reserved</Value2>
							<GotoStep>CheckCoE</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="15" Level="Warning" Param0="EEPROM.CatGeneral.PhysicalPort3">Invalid value ({0}) of PhysicalPort3.</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckCoE">
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Mailbox.CoE</Value1>
							<Value2>false</Value2>
							<GotoStep>CheckFoE</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>EEPROM.CatGeneral.CoEDetails.EnableSDO</Value1>
							<Value2>DeviceDescr.Mailbox.CoE</Value2>
							<RaiseError Id="16" Param0="EEPROM.CatGeneral.CoEDetails.EnableSDOInfo" Param1="DeviceDescr.Mailbox.CoE">Sdo property of EEPROM ({0}) is unequal to property of ESI ({1}).</RaiseError>
						</NotEqual>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>EEPROM.CatGeneral.CoEDetails.EnableSDOInfo</Value1>
							<Value2>DeviceDescr.Mailbox.CoE.SdoInfo</Value2>
							<RaiseError Id="17" Param0="EEPROM.CatGeneral.CoEDetails.EnableSDOInfo" Param1="DeviceDescr.Mailbox.CoE.SdoInfo">SdoInfo property of EEPROM ({0}) is unequal to property of ESI ({1}).</RaiseError>
						</NotEqual>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>EEPROM.CatGeneral.CoEDetails.EnablePDOAssign</Value1>
							<Value2>DeviceDescr.Mailbox.CoE.PdoAssign</Value2>
							<RaiseError Id="18" Param0="EEPROM.CatGeneral.CoEDetails.EnablePDOAssign" Param1="DeviceDescr.Mailbox.CoE.PdoAssign">PdoAssign property of EEPROM ({0}) is unequal to property of ESI ({1}).</RaiseError>
						</NotEqual>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>EEPROM.CatGeneral.CoEDetails.EnablePDOConfiguration</Value1>
							<Value2>DeviceDescr.Mailbox.CoE.PdoConfig</Value2>
							<RaiseError Id="19" Param0="EEPROM.CatGeneral.CoEDetails.EnablePDOConfiguration" Param1="DeviceDescr.Mailbox.CoE.PdoConfig">PdoConfiguration property of EEPROM ({0}) is unequal to property of ESI ({1}).</RaiseError>
						</NotEqual>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>EEPROM.CatGeneral.CoEDetails.EnableUploadAtStartup</Value1>
							<Value2>DeviceDescr.Mailbox.CoE.PdoUpload</Value2>
							<RaiseError Id="20" Param0="EEPROM.CatGeneral.CoEDetails.EnableUploadAtStartup" Param1="DeviceDescr.Mailbox.CoE.PdoUpload">PdoUpload property of EEPROM ({0}) is unequal to property of ESI ({1}).</RaiseError>
						</NotEqual>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>EEPROM.CatGeneral.CoEDetails.EnableSDOCompleteAccess</Value1>
							<Value2>DeviceDescr.Mailbox.CoE.CompleteAccess</Value2>
							<RaiseError Id="21" Param0="EEPROM.CatGeneral.CoEDetails.EnableSDOCompleteAccess" Param1="DeviceDescr.Mailbox.CoE.CompleteAccess">CompleteAccess property of EEPROM ({0}) is unequal to property of ESI ({1}).</RaiseError>
						</NotEqual>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>EEPROM.CatGeneral.DS402Channels</Value1>
							<Value2>null</Value2>
							<GotoStep>CheckFoE</GotoStep>
						</NotEqual>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>EEPROM.CatGeneral.DS402Channels</Value1>
							<Value2>DeviceDescr.Mailbox.CoE.DS402Channels</Value2>
							<RaiseError Id="22" Param0="EEPROM.CatGeneral.DS402Channels" Param1="DeviceDescr.Mailbox.CoE.DS402Channels">DS402 Channels of EEPROM ({0}) is unequal to property of ESI ({1}).</RaiseError>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="CheckFoE">
					<Compare>
						<NotEqual>
							<Value1>EEPROM.CatGeneral.FoEDetails</Value1>
							<Value2>DeviceDescr.Mailbox.FoE</Value2>
							<RaiseError Id="23" Param0="EEPROM.CatGeneral.FoEDetails" Param1="DeviceDescr.Mailbox.FoE">FoE property of EEPROM ({0}) is unequal to property of ESI ({1}).</RaiseError>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="CheckEoE">
					<Compare>
						<NotEqual>
							<Value1>EEPROM.CatGeneral.EoEDetails</Value1>
							<Value2>DeviceDescr.Mailbox.EoE</Value2>
							<RaiseError Id="24" Param0="EEPROM.CatGeneral.EoEDetails" Param1="DeviceDescr.Mailbox.EoE">EoE property of EEPROM ({0}) is unequal to property of ESI ({1}).</RaiseError>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="CheckLRW">
					<Compare>
						<Equal>
							<Value1>DeviceDescr.UseLrdLwr</Value1>
							<Value2>null</Value2>
							<GotoStep>CheckSafeOp</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.UseLrdLwr</Value1>
							<Value2>null</Value2>
							<GotoStep>CheckSafeOp</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>EEPROM.CatGeneral.Flags.EnableNotLRW</Value1>
							<Value2>DeviceDescr.UseLrdLwr</Value2>
							<WriteLine Id="25" Level="Warning" Param0="EEPROM.CatGeneral.Flags.EnableNotLRW" Param1="DeviceDescr.UseLrdLwr">Logical ReadWrite value of EEPROM ({0}) is unequal to property of ESI ({1}).</WriteLine>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="CheckSafeOp">
					<Compare>
						<Equal>
							<Value1>DeviceDescr.TcCfgModeSafeOp</Value1>
							<Value2>null</Value2>
							<GotoStep>CheckCurrentEBus</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>EEPROM.CatGeneral.Flags.EnableSafeOp</Value1>
							<Value2>DeviceDescr.TcCfgModeSafeOp</Value2>
							<WriteLine Id="26" Level="Warning" Param0="EEPROM.CatGeneral.Flags.EnableSafeOp" Param1="DeviceDescr.TcCfgModeSafeOp">ConfigMode in SafeOp value of EEPROM ({0}) is unequal to property of ESI ({1}).</WriteLine>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="CheckCurrentEBus">
					<GetXmlValue ReturnValue="StringCurrXPathValue" Markup="false">
						<XPath>Info/Electrical/EBusCurrent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>StringCurrXPathValue</Value1>
							<Value2>null</Value2>
							<GotoStep>ReturnSucc</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<SetVariable Target="int32XPathValue">StringCurrXPathValue</SetVariable>
					<Compare>
						<NotEqual>
							<Value1>int32XPathValue</Value1>
							<Value2>EEPROM.CatGeneral.CurrentOnEBus</Value2>
							<RaiseError Id="27" Param0="EEPROM.CatGeneral.CurrentOnEBus" Param1="int32XPathValue">Current value on EBus of EEPROM ({0}mA) is unequal to property of ESI ({1}mA).</RaiseError>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="ReturnSucc">
					<WriteLine Id="28" Level="Success">Comparison of the EEPROM General category succeeded</WriteLine>
				</TestStep>
			</TestCase>
			<TestCase Name="E²PROM FMMU Categories" CaseId="11">
				<?MAX_OUTPUT_ID 7?>
				<Description>
					<Purpose>Check the E²PROM for FMMU categories and compares its content with the xml element //Device/Fmmu.</Purpose>
					<PreCondition>- The DuT is online available
- The register contains FMMU categories</PreCondition>
					<Action>-Comparison of the FMMUs categories in register to specified FMMU elements in ESI</Action>
					<PostCondition>-Throws an error if reading of EEPROM data fails
-Throws an error if EEPROM does not contain a FMMU category
-Throws an error if supported EEPROM FMMU categories are lower than number of Device:FMMU elements</PostCondition>
					<References>
						<Reference Chapter="" Specification="ETG 2000"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="CheckSlavesOfflineState">
					<!--Check if slave is added offline.-->
					<Compare>
						<Equal>
							<Value1>Offline</Value1>
							<Value2>true</Value2>
							<SkipCase Id="0">DuT is in offline mode and therefore no EtherCAT communication possible</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<ReadEscData Target="byteVal1">
						<Address>#x0004</Address>
					</ReadEscData>
					<RaiseErrorOnFailure Id="1">Failed to read register!</RaiseErrorOnFailure>
					<Compare>
						<Equal>
							<Value1>byteVal1</Value1>
							<Value2>0</Value2>
							<SkipCase Id="2">Number of supported FMMUs = 0</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Fmmu.Count</Value1>
							<Value2>0</Value2>
							<SkipCase Id="3">Number of FMMU xml elements = 0</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>EEPROM.CatFMMU</Value1>
							<Value2>false</Value2>
							<RaiseError Id="4">Can't find a E²PROM category for FMMU!</RaiseError>
						</Equal>
					</Compare>
					<Compare>
						<Lower>
							<Value1>byteVal1</Value1>
							<Value2>EEPROM.CatFMMU.Count</Value2>
							<RaiseError Id="5" Param0="byteVal1" Param1="DeviceDescr.Fmmu.Count">Number of supported FMMUs in register 0x0004 ({0:d}) are lower than number of Device:FMMU elements ({1:d})</RaiseError>
						</Lower>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>DeviceDescr.Fmmu.Count</Value1>
							<Value2>EEPROM.CatFMMU.Count</Value2>
							<RaiseError Id="6" Param0="DeviceDescr.Fmmu.Count" Param1="EEPROM.CatFMMU.Count">Number of Device:FMMU elements of the EtherCAT Slave Information File ({0:d}) are unequal to the number of E²PROM categories ({1:d})</RaiseError>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="next">
					<CallFunction>CheckFMMUCat</CallFunction>
				</TestStep>
				<TestStep>
					<SetVariable Target="index">index+1</SetVariable>
				</TestStep>
				<TestStep>
					<Compare>
						<Lower>
							<Value1>index</Value1>
							<Value2>EEPROM.CatFMMU.Count</Value2>
							<GotoStep>next</GotoStep>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep>
					<WriteLine Id="7" Level="Success">Comparison of the EEPROM FMMU categories succeeded</WriteLine>
				</TestStep>
			</TestCase>
			<TestCase Name="E²PROM SyncM Categories" CaseId="12">
				<?MAX_OUTPUT_ID 7?>
				<Description>
					<Purpose>Check the E²PROM for sync manager categories and compares its content with the xml element //Device/Sm.</Purpose>
					<PreCondition>- The DuT is online available
- The eeprom contains a sync manager category</PreCondition>
					<Action>-Comparison of the SM categories in EEPROM to specified SM elements in ESI //Device/Sm.</Action>
					<PostCondition>-Throws an error if reading of EEPROM data fails
-Throws an error if EEPROM does not contain a sync manager category
-Throws an error if supported EEPROM SM categories are lower than number of //Device/Sm elements</PostCondition>
					<References>
						<Reference Chapter="" Specification="ETG 2000"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="CheckSlavesOfflineState">
					<!--Check if slave is added offline.-->
					<Compare>
						<Equal>
							<Value1>Offline</Value1>
							<Value2>true</Value2>
							<SkipCase Id="0">DuT is in offline mode and therefore no EtherCAT communication possible</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="GetSMCount">
					<CallTestFunction Name="GetNonVirtualSmCount">
						<OutParameter>nonVirtualSmCount</OutParameter>
					</CallTestFunction>
				</TestStep>
				<TestStep>
					<ReadEscData Target="byteVal1">
						<Address>#x0005</Address>
					</ReadEscData>
					<RaiseErrorOnFailure Id="1">Failed to read register!</RaiseErrorOnFailure>
					<Compare>
						<Equal>
							<Value1>byteVal1</Value1>
							<Value2>0</Value2>
							<SkipCase Id="2">Number of supported SM = 0</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.SM.Count</Value1>
							<Value2>0</Value2>
							<SkipCase Id="3">Number of SM xml elements = 0</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>EEPROM.CatSyncMan</Value1>
							<Value2>false</Value2>
							<RaiseError Id="4">Can't find a E²PROM category for SM!</RaiseError>
						</Equal>
					</Compare>
					<Compare>
						<Lower>
							<Value1>byteVal1</Value1>
							<Value2>nonVirtualSmCount</Value2>
							<RaiseError Id="5" Param0="byteVal1" Param1="nonVirtualSmCount">Number of supported SM in register 0x0004 ({0:d}) are lower than number of Device:SM elements ({1:d})</RaiseError>
						</Lower>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>DeviceDescr.SM.Count</Value1>
							<Value2>EEPROM.CatSyncMan.Count</Value2>
							<RaiseError Id="6" Param0="DeviceDescr.SM.Count" Param1="EEPROM.CatSyncMan.Count">Number of Device:SyncManager elements of the EtherCAT Slave Information File ({0:d}) are unequal to the number of E²PROM categories ({1:d})</RaiseError>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="LoopStart">
					<CallFunction>CheckSMCat</CallFunction>
				</TestStep>
				<TestStep>
					<SetVariable Target="index">index+1</SetVariable>
				</TestStep>
				<TestStep Name="LoopEnd">
					<Compare>
						<Lower>
							<Value1>index</Value1>
							<Value2>EEPROM.CatSyncMan.Count</Value2>
							<GotoStep>LoopStart</GotoStep>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep>
					<WriteLine Id="7" Level="Success">Comparison of the EEPROM SM categories succeeded</WriteLine>
				</TestStep>
			</TestCase>
			<TestCase Name="E²PROM RXPDO Categories" CaseId="13">
				<?MAX_OUTPUT_ID 8?>
				<Description>
					<Purpose>Check the E²PROM for RxPDO categories and compares its content with the xml element //Device/RxPdo.</Purpose>
					<PreCondition>- The DuT is online available
- The EEPROM contains RxPDO categories
- The DuT has RxPDO elements //Device/RxPdo.</PreCondition>
					<Action>-Comparison of the RxPDO categories in EEPROM to specified RxPDO elements //Device/RxPdo in ESI</Action>
					<PostCondition>-Throws an error if reading of EEPROM data fails
-Throws an error if EEPROM RxPDO count does not match to specified RxPDO count in ESI //Device/RxPdo.
-Throws an error if categories are unequal</PostCondition>
					<References>
						<Reference Chapter="" Specification="ETG 2000"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="CheckSlavesOfflineState">
					<!--Check if slave is added offline.-->
					<Compare>
						<Equal>
							<Value1>Offline</Value1>
							<Value2>true</Value2>
							<SkipCase Id="0">DuT is in offline mode and therefore no EtherCAT communication possible</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<Compare>
						<Equal>
							<Value1>ProcessData</Value1>
							<Value2>false</Value2>
							<SkipCase Id="1">Device does not support process data</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.RxPdo.Count</Value1>
							<Value2>0</Value2>
							<SkipCase Id="2">Number of supported RxPdos in the EtherCAT Slave Information File = 0</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Mailbox.CoE</Value1>
							<Value2>true</Value2>
							<SkipCase Id="3">EEPROM category for RxPdo is not mandatory, because device supports CoE</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Mailbox.SoE</Value1>
							<Value2>true</Value2>
							<SkipCase Id="4">EEPROM category for RxPdo is not mandatory, because device supports SoE</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckFixed">
					<Compare>
						<NotEqual>
							<Value1>DeviceDescr.RxPdo.Count</Value1>
							<Value2>EEPROM.CatRXPdo.Count</Value2>
							<RaiseError Id="5" Param0="DeviceDescr.RxPdo.Count" Param1="EEPROM.CatRXPdo.Count">Number of Device:RxPdo elements of the EtherCAT Slave Information File ({0:d}) are unequal to the number of E²PROM categories ({1:d})</RaiseError>
						</NotEqual>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.RxPdo[index].Fixed</Value1>
							<Value2>false</Value2>
							<WriteLine Id="6" Param0="index">EEPROM category for RxPdo[{0:d}] is not mandatory, because the fixed attribute of this RxPdo is not set in the EtherCAT Slave Information File</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.RxPdo[index].Fixed</Value1>
							<Value2>false</Value2>
							<GotoStep>Increment</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<GreaterOrEqual>
							<Value1>index</Value1>
							<Value2>EEPROM.CatRXPdo.Count</Value2>
							<RaiseError Id="7" Param0="index">Can't find a E²PROM category for RxPdo[{0}]!</RaiseError>
						</GreaterOrEqual>
					</Compare>
				</TestStep>
				<TestStep>
					<CallFunction>CheckRxPdoCat</CallFunction>
				</TestStep>
				<TestStep Name="Increment">
					<SetVariable Target="index">index+1</SetVariable>
				</TestStep>
				<TestStep>
					<Compare>
						<Lower>
							<Value1>index</Value1>
							<Value2>EEPROM.CatRXPdo.Count</Value2>
							<GotoStep>CheckFixed</GotoStep>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep>
					<WriteLine Id="8" Level="Success">Comparison of the EEPROM RXPdo categories succeeded</WriteLine>
				</TestStep>
			</TestCase>
			<TestCase Name="E²PROM TXPDO Categories" CaseId="14">
				<?MAX_OUTPUT_ID 8?>
				<Description>
					<Purpose>Check the E²PROM for TxPDO categories and compares its content with the xml element //Device/TxPdo.</Purpose>
					<PreCondition>- The DuT is online available
- The EEPROM contains TxPDO categories
- The DuT has TxPDO elements //Device/TxPdo.</PreCondition>
					<Action>-Comparison of the TxPDO categories in EEPROM to specified TxPDO elements //Device/TxPdo in ESI</Action>
					<PostCondition>-Throws an error if reading of EEPROM data fails
-Throws an error if EEPROM TxPDO count does not match to specified TxPDO count in ESI //Device/TxPdo.
-Throws an error if categories are unequal</PostCondition>
					<References>
						<Reference Chapter="" Specification="ETG 2000"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="CheckSlavesOfflineState">
					<!--Check if slave is added offline.-->
					<Compare>
						<Equal>
							<Value1>Offline</Value1>
							<Value2>true</Value2>
							<SkipCase Id="0">DuT is in offline mode and therefore no EtherCAT communication possible</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<Compare>
						<Equal>
							<Value1>ProcessData</Value1>
							<Value2>false</Value2>
							<SkipCase Id="1">Device does not support process data</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.TxPdo.Count</Value1>
							<Value2>0</Value2>
							<SkipCase Id="2">Number of supported TxPdos in the EtherCAT Slave Information File = 0</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Mailbox.CoE</Value1>
							<Value2>true</Value2>
							<SkipCase Id="3">EEPROM category for TxPdo is not mandatory, because device supports CoE</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Mailbox.SoE</Value1>
							<Value2>true</Value2>
							<SkipCase Id="4">EEPROM category for TxPdo is not mandatory, because device supports SoE</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckFixed">
					<Compare>
						<NotEqual>
							<Value1>DeviceDescr.TxPdo.Count</Value1>
							<Value2>EEPROM.CatTXPdo.Count</Value2>
							<RaiseError Id="5" Param0="DeviceDescr.TxPdo.Count" Param1="EEPROM.CatTXPdo.Count">Number of Device:TxPdo elements of the EtherCAT Slave Information File ({0:d}) are unequal to the number of E²PROM categories ({1:d})</RaiseError>
						</NotEqual>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.TxPdo[index].Fixed</Value1>
							<Value2>false</Value2>
							<WriteLine Id="6" Param0="index">EEPROM category for TxPdo[{0:d}] is not mandatory, because the fixed attribute of this TxPdo is not set in the EtherCAT Slave Information File</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.TxPdo[index].Fixed</Value1>
							<Value2>false</Value2>
							<GotoStep>Increment</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<GreaterOrEqual>
							<Value1>index</Value1>
							<Value2>EEPROM.CatTXPdo.Count</Value2>
							<RaiseError Id="7" Param0="index">Can't find a E²PROM category for TxPdo[{0}]!</RaiseError>
						</GreaterOrEqual>
					</Compare>
				</TestStep>
				<TestStep>
					<CallFunction>CheckTxPdoCat</CallFunction>
				</TestStep>
				<TestStep Name="Increment">
					<SetVariable Target="index">index+1</SetVariable>
				</TestStep>
				<TestStep>
					<Compare>
						<Lower>
							<Value1>index</Value1>
							<Value2>EEPROM.CatTXPdo.Count</Value2>
							<GotoStep>CheckFixed</GotoStep>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep>
					<WriteLine Id="8" Level="Success">Comparison of the EEPROM TXPdo categories succeeded</WriteLine>
				</TestStep>
			</TestCase>
		</TestGroup>
		<TestGroup GroupId="3" Name="Comparison ESI to ESC Register">
			<Comment>Reads data of ESC register and compares it with the xml elements</Comment>
			<TestCase Name="DpRamSize" CaseId="1">
				<?MAX_OUTPUT_ID 7?>
				<Comment>Info: Compare the xml element Info:EtherCATController:DpramSize with Esc register 0x006\nError: If values are unequal.</Comment>
				<TestStep Name="CheckSlavesOfflineState">
					<!--Check if slave is added offline.-->
					<Compare>
						<Equal>
							<Value1>Offline</Value1>
							<Value2>true</Value2>
							<SkipCase Id="0">DuT is in offline mode and therefore no EtherCAT communication possible</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<Compare>
						<Equal>
							<Value1>false</Value1>
							<Value2>DeviceDescr.Info</Value2>
							<SkipCase Id="1">DeviceDescr.Info  is not defined</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>false</Value1>
							<Value2>DeviceDescr.Info.EtherCATController</Value2>
							<SkipCase Id="2">DeviceDescr.Info.EtherCATController is not defined</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>null</Value1>
							<Value2>DeviceDescr.Info.EtherCATController.DpramSize</Value2>
							<SkipCase Id="3">DeviceDescr.Info.EtherCATController.DpramSize is not defined</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<ReadEscData Target="byteVal1">
						<Address>#x0006</Address>
					</ReadEscData>
					<RaiseErrorOnFailure Id="4">Failed to read register!</RaiseErrorOnFailure>
					<WriteLine Id="5" Param0="byteVal1" Param1="DeviceDescr.Info.EtherCATController.DpramSize">RAM size Register 0x0006: 0x{0:x}  Device Descr:0x{1:x}</WriteLine>
					<Compare>
						<NotEqual>
							<Value1>byteVal1</Value1>
							<Value2>DeviceDescr.Info.EtherCATController.DpramSize/1024</Value2>
							<RaiseError Id="6" Param0="DeviceDescr.Info.EtherCATController.DpramSize" Param1="byteVal1">DpramSize of the ESI ({0} Byte) does not match to the value of Register 0x06 ({1}KByte)</RaiseError>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep>
					<WriteLine Id="7" Level="Success">Comparison of the DpramSize values succeeded</WriteLine>
				</TestStep>
			</TestCase>
			<TestCase Name="FmmuCount" CaseId="2">
				<?MAX_OUTPUT_ID 7?>
				<Comment>Info: Compare the xml element Info:EtherCATController:FmmuCount with register 0x0004\nError: If values are unequal.</Comment>
				<TestStep Name="CheckSlavesOfflineState">
					<!--Check if slave is added offline.-->
					<Compare>
						<Equal>
							<Value1>Offline</Value1>
							<Value2>true</Value2>
							<SkipCase Id="0">DuT is in offline mode and therefore no EtherCAT communication possible</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<Compare>
						<Equal>
							<Value1>false</Value1>
							<Value2>DeviceDescr.Info</Value2>
							<SkipCase Id="1">DeviceDescr.Info  is not defined</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>false</Value1>
							<Value2>DeviceDescr.Info.EtherCATController</Value2>
							<SkipCase Id="2">DeviceDescr.Info.EtherCATController is not defined</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>null</Value1>
							<Value2>DeviceDescr.Info.EtherCATController.FmmuCount</Value2>
							<SkipCase Id="3">DeviceDescr.Info.EtherCATController.FmmuCount is not defined</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<ReadEscData Target="byteVal1">
						<Address>#x0004</Address>
					</ReadEscData>
					<RaiseErrorOnFailure Id="4">Failed to read register!</RaiseErrorOnFailure>
				</TestStep>
				<TestStep>
					<WriteLine Id="5" Param0="byteVal1" Param1="DeviceDescr.Info.EtherCATController.FmmuCount">FMMU supported Register 0x0004: {0:d}  Device Descr: {1:d}</WriteLine>
					<Compare>
						<NotEqual>
							<Value1>byteVal1</Value1>
							<Value2>DeviceDescr.Info.EtherCATController.FmmuCount</Value2>
							<RaiseError Id="6" Param0="byteVal1" Param1="DeviceDescr.Info.EtherCATController.FmmuCount">FMMU supported Register 0x0004: {0:d}  EtherCATInfo:Descriptions:Devices:Device:Info:EtherCATController.FmmuCount: {1:d}</RaiseError>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep>
					<WriteLine Id="7" Level="Success">Comparison of the FmmuCount values succeeded</WriteLine>
				</TestStep>
			</TestCase>
			<TestCase Name="Number of Fmmu" CaseId="3">
				<?MAX_OUTPUT_ID 3?>
				<Comment>Info: Compare the number of xml elements EtherCATInfo:Descriptions:Devices:Device:FMMU with register 0x0004\nError: If values are unequal.</Comment>
				<TestStep Name="CheckSlavesOfflineState">
					<!--Check if slave is added offline.-->
					<Compare>
						<Equal>
							<Value1>Offline</Value1>
							<Value2>true</Value2>
							<SkipCase Id="0">DuT is in offline mode and therefore no EtherCAT communication possible</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<ReadEscData Target="byteVal1">
						<Address>#x0004</Address>
					</ReadEscData>
					<RaiseErrorOnFailure Id="1">Failed to read register!</RaiseErrorOnFailure>
					<Compare>
						<Lower>
							<Value1>byteVal1</Value1>
							<Value2>DeviceDescr.Fmmu.Count</Value2>
							<RaiseError Id="2" Param0="byteVal1" Param1="DeviceDescr.Fmmu.Count">FMMU supported Register 0x0004: {0:d}  Number of FMMUs in Device Descr: {1:d}</RaiseError>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep>
					<WriteLine Id="3" Level="Success">Comparison of the number of FMMUs succeeded</WriteLine>
				</TestStep>
			</TestCase>
			<TestCase Name="SmCount" CaseId="4">
				<?MAX_OUTPUT_ID 6?>
				<Comment>Info: Compare the xml element Info:EtherCATController:SmCount with register 0x0005\nError: If values are unequal.</Comment>
				<TestStep Name="CheckSlavesOfflineState">
					<!--Check if slave is added offline.-->
					<Compare>
						<Equal>
							<Value1>Offline</Value1>
							<Value2>true</Value2>
							<SkipCase Id="0">DuT is in offline mode and therefore no EtherCAT communication possible</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<Compare>
						<Equal>
							<Value1>false</Value1>
							<Value2>DeviceDescr.Info</Value2>
							<SkipCase Id="1">DeviceDescr.Info  is not defined</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>false</Value1>
							<Value2>DeviceDescr.Info.EtherCATController</Value2>
							<SkipCase Id="2">DeviceDescr.Info.EtherCATController is not defined</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>null</Value1>
							<Value2>DeviceDescr.Info.EtherCATController.SmCount</Value2>
							<SkipCase Id="3">DeviceDescr.Info.EtherCATController.SmCount is not defined</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<ReadEscData Target="byteVal1">
						<Address>#x0005</Address>
					</ReadEscData>
					<RaiseErrorOnFailure Id="4">Failed to read register!</RaiseErrorOnFailure>
				</TestStep>
				<TestStep>
					<Compare>
						<NotEqual>
							<Value1>byteVal1</Value1>
							<Value2>DeviceDescr.Info.EtherCATController.SmCount</Value2>
							<RaiseError Id="5" Param0="byteVal1" Param1="DeviceDescr.Info.EtherCATController.SmCount">Sm supported  {0:d} (register 0x0005)  Device Descr: {1:d}</RaiseError>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep>
					<WriteLine Id="6" Level="Success">Comparison of the SmCount values succeeded</WriteLine>
				</TestStep>
			</TestCase>
			<TestCase Name="Number of Sm" CaseId="5">
				<?MAX_OUTPUT_ID 4?>
				<Comment>Info: Compare the number of xml elements EtherCATInfo:Descriptions:Devices:Device:Sm with register 0x0005\nError: If values are unequal.</Comment>
				<TestStep Name="CheckSlavesOfflineState">
					<!--Check if slave is added offline.-->
					<Compare>
						<Equal>
							<Value1>Offline</Value1>
							<Value2>true</Value2>
							<SkipCase Id="0">DuT is in offline mode and therefore no EtherCAT communication possible</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="GetSMCount">
					<CallTestFunction Name="GetNonVirtualSmCount">
						<OutParameter>nonVirtualSmCount</OutParameter>
					</CallTestFunction>
				</TestStep>
				<TestStep>
					<ReadEscData Target="byteVal1">
						<Address>#x0005</Address>
					</ReadEscData>
					<RaiseErrorOnFailure Id="1">Failed to read register!</RaiseErrorOnFailure>
					<WriteLine Id="2" Param0="byteVal1" Param1="DeviceDescr.SM.Count">Sm supported Register 0x0005: {0:d} | Number of non virtual Sm in ESI: {1:d}</WriteLine>
					<Compare>
						<Lower>
							<Value1>byteVal1</Value1>
							<Value2>nonVirtualSmCount</Value2>
							<RaiseError Id="3" Param0="byteVal1" Param1="nonVirtualSmCount">Sm supported {0:d} (register 0x0005) Sm defined in EtherCAT Slave Information File {1:d}  </RaiseError>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep>
					<WriteLine Id="4" Level="Success">Comparison of the number of SMs succeeded</WriteLine>
				</TestStep>
			</TestCase>
			<TestCase Name="PortType" CaseId="6">
				<?MAX_OUTPUT_ID 13?>
				<Comment>Info: Compare the xml element Info:Port with register 0x0007\nError: If values are unequal.</Comment>
				<TestStep Name="CheckSlavesOfflineState">
					<!--Check if slave is added offline.-->
					<Compare>
						<Equal>
							<Value1>Offline</Value1>
							<Value2>true</Value2>
							<SkipCase Id="0">DuT is in offline mode and therefore no EtherCAT communication possible</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Info</Value1>
							<Value2>false</Value2>
							<SkipCase Id="1">The element Device:Info is not defined</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Info.Port.Count</Value1>
							<Value2>0</Value2>
							<SkipCase Id="2">The element Device:Info:Port is not defined</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<SetVariable Target="index">0</SetVariable>
				</TestStep>
				<TestStep>
					<ReadEscData Target="byteVal1">
						<Address>#x7</Address>
					</ReadEscData>
					<ReturnOnFailure Id="3">Failed to read register!</ReturnOnFailure>
				</TestStep>
				<TestStep>
					<GetBits Source="byteVal1" Target="byteVal2">
						<Offset>0</Offset>
						<Length>2</Length>
					</GetBits>
					<WriteLine Id="4" Param0="byteVal1">0x0007 = 0x{0:x4}</WriteLine>
					<WriteLine Id="5" Param0="byteVal2" Param1="DeviceDescr.Info.Port[index].Type" Param2="index">Register 0x:0007 Bits 1:0 =  {0} | EtherCATInfo:Descriptions:Devices:Info:Port[{2}].Type: {1}</WriteLine>
					<Compare>
						<NotEqual>
							<Value1>byteVal2</Value1>
							<Value2>DeviceDescr.Info.Port[index].Type</Value2>
							<RaiseError Id="6" Param0="index">Comparision of port[{0}] type failed.</RaiseError>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep>
					<SetVariable Target="index">index+1</SetVariable>
				</TestStep>
				<TestStep>
					<Compare>
						<GreaterOrEqual>
							<Value1>index</Value1>
							<Value2>DeviceDescr.Info.Port.Count</Value2>
							<GotoStep>end</GotoStep>
						</GreaterOrEqual>
					</Compare>
				</TestStep>
				<TestStep>
					<GetBits Source="byteVal1" Target="byteVal2">
						<Offset>2</Offset>
						<Length>2</Length>
					</GetBits>
					<WriteLine Id="7" Param0="byteVal2" Param1="DeviceDescr.Info.Port[index].Type" Param2="index">Register 0x:0007 Bits 3:2 = {0} | EtherCATInfo:Descriptions:Devices:Info:Port[{2}].Type: {1}</WriteLine>
					<Compare>
						<NotEqual>
							<Value1>byteVal2</Value1>
							<Value2>DeviceDescr.Info.Port[index].Type</Value2>
							<RaiseError Id="8" Param0="index">Comparision of port[{0}] type failed.</RaiseError>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep>
					<SetVariable Target="index">index+1</SetVariable>
				</TestStep>
				<TestStep>
					<Compare>
						<GreaterOrEqual>
							<Value1>index</Value1>
							<Value2>DeviceDescr.Info.Port.Count</Value2>
							<GotoStep>end</GotoStep>
						</GreaterOrEqual>
					</Compare>
				</TestStep>
				<TestStep>
					<GetBits Source="byteVal1" Target="byteVal2">
						<Offset>4</Offset>
						<Length>2</Length>
					</GetBits>
					<WriteLine Id="9" Param0="byteVal2" Param1="DeviceDescr.Info.Port[index].Type" Param2="index">Register 0x:0007 Bits 5:4 =  {0} | EtherCATInfo:Descriptions:Devices:Info:Port[{2}].Type: {1}</WriteLine>
					<Compare>
						<NotEqual>
							<Value1>byteVal2</Value1>
							<Value2>DeviceDescr.Info.Port[index].Type</Value2>
							<RaiseError Id="10" Param0="index">Comparision of port[{0}] type failed.</RaiseError>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep>
					<SetVariable Target="index">index+1</SetVariable>
				</TestStep>
				<TestStep>
					<Compare>
						<GreaterOrEqual>
							<Value1>index</Value1>
							<Value2>DeviceDescr.Info.Port.Count</Value2>
							<GotoStep>end</GotoStep>
						</GreaterOrEqual>
					</Compare>
				</TestStep>
				<TestStep>
					<GetBits Source="byteVal1" Target="byteVal2">
						<Offset>6</Offset>
						<Length>2</Length>
					</GetBits>
					<WriteLine Id="11" Param0="byteVal2" Param1="DeviceDescr.Info.Port[index].Type" Param2="index">Register 0x:0007 Bits 7:6  =  {0} | EtherCATInfo:Descriptions:Devices:Info:Port[{2}].Type: {1}</WriteLine>
					<Compare>
						<NotEqual>
							<Value1>byteVal2</Value1>
							<Value2>DeviceDescr.Info.Port[index].Type</Value2>
							<RaiseError Id="12" Param0="index">Comparision of port[{0}] type failed.</RaiseError>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="end">
					<WriteLine Id="13" Level="Success">Comparison of the PortType values succeeded</WriteLine>
				</TestStep>
			</TestCase>
		</TestGroup>
		<TestGroup GroupId="4" Name="Comparison ESI to online OD">
			<Comment>Reads data of the online object dictionary and compares it against the xml elements of the EtherCAT Slave Information File.</Comment>
			<TestCase Name="ESI OD Identity Info" CaseId="1">
				<?MAX_OUTPUT_ID 21?>
				<Comment>Comparison of the DuT's ESI file and the CoE online dictionary identity object 0x1018.</Comment>
				<Description>
					<Purpose>Comparison of the identity (Vendor ID, Product Code, Revision Number, Serial Number) in the ESI file and the CoE identity object 0x1018 of the online OD.</Purpose>
					<PreCondition>ESI file and online OD available.</PreCondition>
					<Action>- Check if mailbox communication is supported. If true, upload entries from object 0x1018.
- Compare object entries with the corresponding entries for VendorID, ProductCode, RevisionNo and SerialNo of the DuT's ESI according to following relation:
   Object entry 0x1018:1 vs. ESI element Vendor:VendorId
   Object entry 0x1018:2 vs. ESI element Device:Type:ProductCode
   Object entry 0x1018:3 vs. ESI element Device:Type:RevisionNo
   Object entry 0x1018:4 vs. ESI element Device:Type:SerialNo</Action>
					<PostCondition>Error if entries for VendorID or ProductCode are not equal.
Warning if entries for RevisionNo or SerialNo are not equal.</PostCondition>
					<References>
						<Reference Specification="ETG.2000" Chapter=""></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="CheckCoeSupport">
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Mailbox</Value1>
							<Value2>false</Value2>
							<SkipCase Id="0">Device does not support mailbox communication</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Mailbox.CoE</Value1>
							<Value2>false</Value2>
							<SkipCase Id="1">Device does not support CoE</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="Reset">
					<CallTestFunction Name="Reset"></CallTestFunction>
				</TestStep>
				<TestStep Name="GetStateMachineTimeouts">
					<CallTestFunction Name="SetStateMachTimeouts"></CallTestFunction>
				</TestStep>
				<TestStep Name="GoToPreOp">
					<RunToState Timeout="t_preopTimeout">
						<State>PREOP</State>
					</RunToState>
					<RaiseErrorOnFailure Id="2">Failed to go to PreOP!</RaiseErrorOnFailure>
				</TestStep>
				<TestStep>
					<SetVariable Target="index">#x1018</SetVariable>
				</TestStep>
				<TestStep>
					<SetVariable Target="index2max">4</SetVariable>
				</TestStep>
				<TestStep>
					<SetVariable Target="subIdx">1</SetVariable>
				</TestStep>
				<TestStep>
					<SetVariable Target="errcount">0</SetVariable>
					<WriteLine Id="3" Level="Output" Param0="index">Check CoE object entries of 0x{0:x4}</WriteLine>
				</TestStep>
				<TestStep Name="NextObject">
					<UploadCoEObject>
						<Index>index</Index>
						<SubIndex>subIdx</SubIndex>
						<DataVar>tmpUInt32</DataVar>
						<BitLen>32</BitLen>
						<AbortCode>sdoAbortCode</AbortCode>
						<AbortMessage>abortMessage</AbortMessage>
					</UploadCoEObject>
					<RaiseErrorOnFailure Id="4" Param0="index" Param1="subIdx">Failed to upload mandatory CoE object 0x{0:x4}:{1}</RaiseErrorOnFailure>
					<Compare>
						<NotEqual>
							<Value1>sdoAbortCode</Value1>
							<Value2>0</Value2>
							<RaiseWarning Id="5" Param0="index" Param1="subIdx" Param2="abortMessage">Failed to upload 0x{0:x4}:{1:d} ({2}) </RaiseWarning>
						</NotEqual>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>sdoAbortCode</Value1>
							<Value2>0</Value2>
							<GotoStep>IncrementIndex</GotoStep>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep>
					<Compare>
						<Equal>
							<Value1>subIdx</Value1>
							<Value2>1</Value2>
							<GotoStep>SI1</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>subIdx</Value1>
							<Value2>2</Value2>
							<GotoStep>SI2</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>subIdx</Value1>
							<Value2>3</Value2>
							<GotoStep>SI3</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>subIdx</Value1>
							<Value2>4</Value2>
							<GotoStep>SI4</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>0</Value1>
							<Value2>0</Value2>
							<GotoStep>IncrementIndex</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="SI1">
					<SetVariable Target="elementName">Vendor:VendorID</SetVariable>
					<WriteLine Id="6" Level="Verbose" Param0="index" Param1="subIdx" Param2="tmpUInt32" Param3="DeviceDescr.VendorId">CoE object 0x{0:x4}:{1} Data = 0x{2:x8} | ESI VendorId = 0x{3:x8}</WriteLine>
					<Compare>
						<NotEqual>
							<Value1>tmpUInt32</Value1>
							<Value2>DeviceDescr.VendorId</Value2>
							<GotoStep>ERROR</GotoStep>
						</NotEqual>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>0</Value1>
							<Value2>1</Value2>
							<GotoStep>IncrementIndex</GotoStep>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="SI2">
					<SetVariable Target="elementName">Device:Type:ProductCode</SetVariable>
					<WriteLine Id="7" Level="Verbose" Param0="index" Param1="subIdx" Param2="tmpUInt32" Param3="DeviceDescr.ProductCode">CoE object 0x{0:x4}:{1} Data = 0x{2:x8} | ESI ProductCode = 0x{3:x8}</WriteLine>
					<Compare>
						<NotEqual>
							<Value1>tmpUInt32</Value1>
							<Value2>DeviceDescr.ProductCode</Value2>
							<GotoStep>ERROR</GotoStep>
						</NotEqual>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>0</Value1>
							<Value2>1</Value2>
							<GotoStep>IncrementIndex</GotoStep>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="SI3">
					<SetVariable Target="elementName">Device:Type:RevisionNo</SetVariable>
					<WriteLine Id="8" Level="Verbose" Param0="index" Param1="subIdx" Param2="tmpUInt32" Param3="DeviceDescr.RevisionNo">CoE object 0x{0:x4}:{1} Data = 0x{2:x8} | ESI RevisionNo = 0x{3:x8}</WriteLine>
					<Compare>
						<Equal>
							<Value1>tmpUInt32</Value1>
							<Value2>DeviceDescr.RevisionNo</Value2>
							<GotoStep>IncrementIndex</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<WriteLine Id="9" Level="Warning" Param0="index" Param1="subIdx" Param2="elementName">CoE object entry 0x{0:x4}:{1} not equal to corresponding ESI element {2}</WriteLine>
					<Compare>
						<NotEqual>
							<Value1>0</Value1>
							<Value2>1</Value2>
							<Return Id="10"></Return>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="SI4">
					<SetVariable Target="elementName">Device:Type:SerialNo</SetVariable>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.SerialNo</Value1>
							<Value2>null</Value2>
							<GotoStep>SI4notavailable</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>tmpUInt32</Value1>
							<Value2>DeviceDescr.SerialNo</Value2>
							<GotoStep>SI4equal</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>1</Value1>
							<Value2>1</Value2>
							<GotoStep>SI4unequal</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="SI4notavailable">
					<WriteLine Id="11" Level="Verbose" Param0="index" Param1="subIdx" Param2="tmpUInt32">CoE object 0x{0:x4}:{1} Data = 0x{2:x8} | ESI SerialNo = not available.</WriteLine>
				</TestStep>
				<TestStep>
					<CallTestFunction Name="AssignEEPROMToECAT"></CallTestFunction>
				</TestStep>
				<TestStep>
					<ReadEEProm Target="uInt32Val">
						<Address>#x000e</Address>
						<Length>4</Length>
					</ReadEEProm>
					<RaiseErrorOnFailure Id="12">Failed to read register!</RaiseErrorOnFailure>
				</TestStep>
				<TestStep>
					<WriteLine Id="13" Level="Verbose" Param0="uInt32Val">INFO: SerialNo on EEPROM: 0x{0:x8}</WriteLine>
					<Compare>
						<Equal>
							<Value1>1</Value1>
							<Value2>1</Value2>
							<GotoStep>IncrementIndex</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="SI4equal">
					<WriteLine Id="14" Level="Verbose" Param0="index" Param1="subIdx" Param2="tmpUInt32" Param3="DeviceDescr.SerialNo">CoE object 0x{0:x4}:{1} Data = 0x{2:x8} | ESI SerialNo = 0x{3:x8}</WriteLine>
					<Compare>
						<Equal>
							<Value1>1</Value1>
							<Value2>1</Value2>
							<GotoStep>IncrementIndex</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="SI4unequal">
					<WriteLine Id="15" Level="Verbose" Param0="index" Param1="subIdx" Param2="tmpUInt32" Param3="DeviceDescr.SerialNo">CoE object 0x{0:x4}:{1} Data = 0x{2:x8} | ESI SerialNo = 0x{3:x8}</WriteLine>
					<Compare>
						<NotEqual>
							<Value1>0</Value1>
							<Value2>DeviceDescr.SerialNo</Value2>
							<GotoStep>ERROR</GotoStep>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep>
					<WriteLine Id="16" Level="Warning" Param0="index" Param1="subIdx" Param2="elementName">CoE object entry 0x{0:x4}:{1} not equal to corresponding ESI element {2}</WriteLine>
					<Compare>
						<NotEqual>
							<Value1>0</Value1>
							<Value2>1</Value2>
							<Return Id="17"></Return>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="ERROR">
					<SetVariable Target="errcount">errcount+1</SetVariable>
					<WriteLine Id="18" Level="Error" Param0="index" Param1="subIdx" Param2="elementName">CoE object entry 0x{0:x4}:{1} not equal to corresponding ESI element {2}</WriteLine>
				</TestStep>
				<TestStep>
					<Compare>
						<Equal>
							<Value1>1</Value1>
							<Value2>1</Value2>
							<RaiseError Id="19"></RaiseError>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="IncrementIndex">
					<SetVariable Target="subIdx">subIdx+1</SetVariable>
					<Compare>
						<LowerOrEqual>
							<Value1>subIdx</Value1>
							<Value2>index2max</Value2>
							<GotoStep>NextObject</GotoStep>
						</LowerOrEqual>
					</Compare>
				</TestStep>
				<TestStep Name="END">
					<Compare>
						<NotEqual>
							<Value1>errcount</Value1>
							<Value2>0</Value2>
							<RaiseError Id="20"></RaiseError>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep>
					<WriteLine Id="21" Level="Success" Param0="elementName">Success | Essential entries of CoE identity object 0x1018 correspond to related ESI elements.</WriteLine>
				</TestStep>
			</TestCase>
		</TestGroup>
		<TestGroup GroupId="5" Name="Obsolete ESI Elements ">
			<Comment>ESI elements which are marked as obsolete in the ETG.2000 ESI specification shall not be used.</Comment>
			<TestCase Name="Vendor:Image16x14" CaseId="1">
				<?MAX_OUTPUT_ID 3?>
				<Comment>The ESI element Vendor:Image16x14 is obsolete.</Comment>
				<Description>
					<Purpose>The ESI element Vendor:Image16x14 is obsolete and shall not be used. </Purpose>
					<PreCondition>ESI file available.</PreCondition>
					<Action>Scan the DuT's ESI for Vendor:Image16x14</Action>
					<PostCondition>Warning if element is used.</PostCondition>
					<References>
						<Reference Specification="ETG.2000" Chapter=""></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="START">
					<SetVariable Target="elementName">element Vendor:Image16x14</SetVariable>
					<WriteLine Id="0" Level="Output" Param0="elementName">Scan ESI for {0}</WriteLine>
				</TestStep>
				<TestStep Name="CHECK">
					<Compare>
						<NotEqual>
							<Value1>DeviceDescr.Vendor.Image16x14</Value1>
							<Value2>null</Value2>
							<RaiseWarning Id="1" Param0="elementName">ESI {0} is obsolete and shall not be used.</RaiseWarning>
						</NotEqual>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>DeviceDescr.Vendor.Image16x14</Value1>
							<Value2>null</Value2>
							<Return Id="2"></Return>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="SUCCESS">
					<WriteLine Id="3" Level="Success" Param0="elementName">ESI {0} not used. Test case passed.</WriteLine>
				</TestStep>
			</TestCase>
			<TestCase Name="Vendor@UniqueName" CaseId="2">
				<?MAX_OUTPUT_ID 3?>
				<Comment>The ESI attribute Vendor@UniqueName is obsolete.</Comment>
				<Description>
					<Purpose>The ESI attribute Vendor@UniqueName is obsolete and shall not be used. </Purpose>
					<PreCondition>ESI file available.</PreCondition>
					<Action>Scan the DuT's ESI for Vendor@UniqueName</Action>
					<PostCondition>Warning if attribute is used.</PostCondition>
					<References>
						<Reference Specification="ETG.2000" Chapter=""></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="START">
					<SetVariable Target="elementName">attribute Vendor@UniqueName</SetVariable>
					<WriteLine Id="0" Level="Output" Param0="elementName">Scan ESI for {0}</WriteLine>
				</TestStep>
				<TestStep Name="CHECK">
					<Compare>
						<NotEqual>
							<Value1>DeviceDescr.Vendor.UniqueName</Value1>
							<Value2>null</Value2>
							<RaiseWarning Id="1" Param0="elementName">ESI {0} is obsolete and shall not be used.</RaiseWarning>
						</NotEqual>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>DeviceDescr.Vendor.UniqueName</Value1>
							<Value2>null</Value2>
							<Return Id="2"></Return>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="SUCCESS">
					<WriteLine Id="3" Level="Success" Param0="elementName">ESI {0} not used. Test case passed.</WriteLine>
				</TestStep>
			</TestCase>
			<TestCase Name="Group:Image16x14" CaseId="3">
				<?MAX_OUTPUT_ID 3?>
				<Comment>The ESI element Group:Image16x14 is obsolete.</Comment>
				<Description>
					<Purpose>The ESI element Group:Image16x14 is obsolete and shall not be used. </Purpose>
					<PreCondition>ESI file available.</PreCondition>
					<Action>Scan the DuT's ESI for Group:Image16x14</Action>
					<PostCondition>Warning if element is used.</PostCondition>
					<References>
						<Reference Specification="ETG.2000" Chapter=""></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="START">
					<SetVariable Target="elementName">element Group:Image16x14</SetVariable>
					<WriteLine Id="0" Level="Output" Param0="elementName">Scan ESI for {0}</WriteLine>
				</TestStep>
				<TestStep Name="CHECK">
					<Compare>
						<NotEqual>
							<Value1>DeviceDescr.Group.Image16x14</Value1>
							<Value2>null</Value2>
							<RaiseWarning Id="1" Param0="elementName">ESI {0} is obsolete and shall not be used.</RaiseWarning>
						</NotEqual>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>DeviceDescr.Group.Image16x14</Value1>
							<Value2>null</Value2>
							<Return Id="2"></Return>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="SUCCESS">
					<WriteLine Id="3" Level="Success" Param0="elementName">ESI {0} not used. Test case passed.</WriteLine>
				</TestStep>
			</TestCase>
			<TestCase Name="Device:Image16x14" CaseId="4">
				<?MAX_OUTPUT_ID 3?>
				<Comment>The ESI element Device:Image16x14 is obsolete.</Comment>
				<Description>
					<Purpose>The ESI element Device:Image16x14 is obsolete and shall not be used. </Purpose>
					<PreCondition>ESI file available.</PreCondition>
					<Action>Scan the DuT's ESI for Device:Image16x14</Action>
					<PostCondition>Warning if element is used.</PostCondition>
					<References>
						<Reference Specification="ETG.2000" Chapter=""></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="START">
					<SetVariable Target="elementName">element Device:Image16x14</SetVariable>
					<WriteLine Id="0" Level="Output" Param0="elementName">Scan ESI for {0}</WriteLine>
				</TestStep>
				<TestStep Name="CHECK">
					<Compare>
						<NotEqual>
							<Value1>DeviceDescr.Image16x14</Value1>
							<Value2>null</Value2>
							<RaiseWarning Id="1" Param0="elementName">ESI {0} is obsolete and shall not be used.</RaiseWarning>
						</NotEqual>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>DeviceDescr.Image16x14</Value1>
							<Value2>null</Value2>
							<Return Id="2"></Return>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="SUCCESS">
					<WriteLine Id="3" Level="Success" Param0="elementName">ESI {0} not used. Test case passed.</WriteLine>
				</TestStep>
			</TestCase>
			<TestCase Name="Device:Type@TcCfgModeSafeOp" CaseId="6">
				<?MAX_OUTPUT_ID 4?>
				<Comment>The ESI attribute Device:Type@TcCfgModeSafeOp is obsolete.</Comment>
				<Description>
					<Purpose>The ESI attribute Device:Type@TcCfgModeSafeOp is obsolete and shall not be used. </Purpose>
					<PreCondition>ESI file available.</PreCondition>
					<Action>Scan the DuT's ESI for Device:Type@TcCfgModeSafeOp</Action>
					<PostCondition>Warning if attribute is used.</PostCondition>
					<References>
						<Reference Specification="ETG.2000" Chapter=""></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="START">
					<SetVariable Target="elementName">attribute Device:Type@TcCfgModeSafeOp</SetVariable>
					<WriteLine Id="0" Level="Output" Param0="elementName">Scan ESI for {0}</WriteLine>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Type</Value1>
							<Value2>null</Value2>
							<SkipCase Id="1">Case skipped because of empty element: Device:Type</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CHECK">
					<Compare>
						<NotEqual>
							<Value1>DeviceDescr.TcCfgModeSafeOp</Value1>
							<Value2>null</Value2>
							<RaiseWarning Id="2" Param0="elementName">ESI {0} is obsolete and shall not be used.</RaiseWarning>
						</NotEqual>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>DeviceDescr.TcCfgModeSafeOp</Value1>
							<Value2>null</Value2>
							<Return Id="3"></Return>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="SUCCESS">
					<WriteLine Id="4" Level="Success" Param0="elementName">ESI {0} not used. Test case passed.</WriteLine>
				</TestStep>
			</TestCase>
			<TestCase Name="Device:HideType@ProductRevision" CaseId="7">
				<?MAX_OUTPUT_ID 4?>
				<Comment>The ESI attribute Device:HideType@ProductRevision is obsolete.</Comment>
				<Description>
					<Purpose>The ESI attribute Device:HideType@ProductRevision is obsolete and shall not be used. </Purpose>
					<PreCondition>ESI file available.</PreCondition>
					<Action>Scan the DuT's ESI for Device:HideType@ProductRevision</Action>
					<PostCondition>Warning if attribute is used.</PostCondition>
					<References>
						<Reference Specification="ETG.2000" Chapter=""></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="START">
					<SetVariable Target="elementName">attribute Device:HideType[a]@ProductRevision</SetVariable>
					<WriteLine Id="0" Level="Output" Param0="elementName">Scan ESI for {0}</WriteLine>
				</TestStep>
				<TestStep Name="INIT">
					<SetVariable Target="errcount">0</SetVariable>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.HideType.Count</Value1>
							<Value2>0</Value2>
							<SkipCase Id="1">Case skipped because of empty element: Device:AlternativeType</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<SetVariable Target="indexmax">DeviceDescr.HideType.Count</SetVariable>
				</TestStep>
				<TestStep>
					<SetVariable Target="index">0</SetVariable>
				</TestStep>
				<TestStep Name="CHECK">
					<Compare>
						<Equal>
							<Value1>DeviceDescr.HideType[index].ProductRevision</Value1>
							<Value2>null</Value2>
							<GotoStep>NEXT</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="WARNING">
					<SetVariable Target="errcount">errcount+1</SetVariable>
					<WriteLine Id="2" Level="Warning" Param0="elementName" Param1="index">ESI {0} (a={1}) is obsolete and shall not be used.</WriteLine>
				</TestStep>
				<TestStep Name="NEXT">
					<SetVariable Target="index">index+1</SetVariable>
				</TestStep>
				<TestStep>
					<Compare>
						<GreaterOrEqual>
							<Value1>index</Value1>
							<Value2>indexmax</Value2>
							<GotoStep>END</GotoStep>
						</GreaterOrEqual>
					</Compare>
				</TestStep>
				<TestStep>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>CHECK</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="END">
					<Compare>
						<Greater>
							<Value1>errcount</Value1>
							<Value2>0</Value2>
							<Return Id="3">Test case finished with warnings.</Return>
						</Greater>
					</Compare>
				</TestStep>
				<TestStep>
					<WriteLine Id="4" Level="Success" Param0="elementName">ESI {0} not used. Test case passed.</WriteLine>
				</TestStep>
			</TestCase>
			<TestCase Name="Device:Profile@Channel" CaseId="8">
				<?MAX_OUTPUT_ID 4?>
				<Comment>The ESI attribute Device:Profile@Channel is obsolete.</Comment>
				<Description>
					<Purpose>The ESI attribute Device:Profile@Channel is obsolete and shall not be used. </Purpose>
					<PreCondition>ESI file available.</PreCondition>
					<Action>Scan the DuT's ESI for Device:Profile@Channel</Action>
					<PostCondition>Warning if attribute is used.</PostCondition>
					<References>
						<Reference Specification="ETG.2000" Chapter=""></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="START">
					<SetVariable Target="elementName">attribute Device:Profile[a]@Channel</SetVariable>
					<WriteLine Id="0" Level="Output" Param0="elementName">Scan ESI for {0}</WriteLine>
				</TestStep>
				<TestStep Name="INIT">
					<SetVariable Target="errcount">0</SetVariable>
				</TestStep>
				<TestStep>
					<SetVariable Target="indexmax">DeviceDescr.Profile.Count</SetVariable>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Profile.Count</Value1>
							<Value2>0</Value2>
							<SkipCase Id="1">Case skipped because of empty element: Device.Profile</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<SetVariable Target="index">0</SetVariable>
				</TestStep>
				<TestStep Name="CHECK">
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Profile[index].Channel</Value1>
							<Value2>null</Value2>
							<GotoStep>NEXT</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<SetVariable Target="errcount">errcount+1</SetVariable>
					<WriteLine Id="2" Level="Warning" Param0="elementName" Param1="index">ESI {0} (a={1}) is obsolete and shall not be used.</WriteLine>
				</TestStep>
				<TestStep Name="NEXT">
					<SetVariable Target="index">index+1</SetVariable>
				</TestStep>
				<TestStep>
					<Compare>
						<GreaterOrEqual>
							<Value1>index</Value1>
							<Value2>indexmax</Value2>
							<GotoStep>END</GotoStep>
						</GreaterOrEqual>
					</Compare>
				</TestStep>
				<TestStep>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>CHECK</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="END">
					<Compare>
						<Greater>
							<Value1>errcount</Value1>
							<Value2>0</Value2>
							<Return Id="3">Test case finished with warnings.</Return>
						</Greater>
					</Compare>
				</TestStep>
				<TestStep>
					<WriteLine Id="4" Level="Success" Param0="elementName">ESI {0} not used. Test case passed.</WriteLine>
				</TestStep>
			</TestCase>
			<TestCase Name="Device:Fmmu@OpOnly" CaseId="9">
				<?MAX_OUTPUT_ID 4?>
				<Comment>The ESI attribute Device:Fmmu@OpOnly is obsolete.</Comment>
				<Description>
					<Purpose>The ESI attribute Device:Fmmu@OpOnly is obsolete and shall not be used. </Purpose>
					<PreCondition>ESI file available.</PreCondition>
					<Action>Scan the DuT's ESI for Device:Fmmu@OpOnly</Action>
					<PostCondition>Warning if attribute is used.</PostCondition>
					<References>
						<Reference Specification="ETG.2000" Chapter=""></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="START">
					<SetVariable Target="elementName">attribute Device:Fmmu[a]@OpOnly</SetVariable>
					<WriteLine Id="0" Level="Output" Param0="elementName">Scan ESI for {0}</WriteLine>
				</TestStep>
				<TestStep Name="INIT">
					<SetVariable Target="errcount">0</SetVariable>
				</TestStep>
				<TestStep>
					<SetVariable Target="indexmax">DeviceDescr.Fmmu.Count</SetVariable>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Fmmu.Count</Value1>
							<Value2>0</Value2>
							<SkipCase Id="1">Case skipped because of empty element: Device:Fmmu</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<SetVariable Target="index">0</SetVariable>
				</TestStep>
				<TestStep Name="CHECK">
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Fmmu[index].OpOnly</Value1>
							<Value2>null</Value2>
							<GotoStep>NEXT</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<SetVariable Target="errcount">errcount+1</SetVariable>
					<WriteLine Id="2" Level="Warning" Param0="elementName" Param1="index">ESI {0} (a={1}) is obsolete and shall not be used.</WriteLine>
				</TestStep>
				<TestStep Name="NEXT">
					<SetVariable Target="index">index+1</SetVariable>
				</TestStep>
				<TestStep>
					<Compare>
						<GreaterOrEqual>
							<Value1>index</Value1>
							<Value2>indexmax</Value2>
							<GotoStep>END</GotoStep>
						</GreaterOrEqual>
					</Compare>
				</TestStep>
				<TestStep>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>CHECK</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="END">
					<Compare>
						<Greater>
							<Value1>errcount</Value1>
							<Value2>0</Value2>
							<Return Id="3">Test case finished with warnings.</Return>
						</Greater>
					</Compare>
				</TestStep>
				<TestStep>
					<WriteLine Id="4" Level="Success" Param0="elementName">ESI {0} not used. Test case passed.</WriteLine>
				</TestStep>
			</TestCase>
			<TestCase Name="Device:Sm@OneByteMode" CaseId="10">
				<?MAX_OUTPUT_ID 4?>
				<Comment>The ESI attribute Device:Sm@OneByteMode is obsolete.</Comment>
				<Description>
					<Purpose>The ESI attribute Device:Sm@OneByteMode is obsolete and shall not be used. </Purpose>
					<PreCondition>ESI file available.</PreCondition>
					<Action>Scan the DuT's ESI for Device:Sm@OneByteMode</Action>
					<PostCondition>Warning if attribute is used.</PostCondition>
					<References>
						<Reference Specification="ETG.2000" Chapter=""></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="START">
					<SetVariable Target="elementName">attribute Device:Sm[a]@OneByteMode</SetVariable>
					<WriteLine Id="0" Level="Output" Param0="elementName">Scan ESI for {0}</WriteLine>
				</TestStep>
				<TestStep Name="INIT">
					<SetVariable Target="errcount">0</SetVariable>
				</TestStep>
				<TestStep>
					<SetVariable Target="indexmax">DeviceDescr.SM.Count</SetVariable>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.SM.Count</Value1>
							<Value2>0</Value2>
							<SkipCase Id="1">Case skipped because of empty element: Device:Sm</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<SetVariable Target="index">0</SetVariable>
				</TestStep>
				<TestStep Name="CHECK">
					<Compare>
						<Equal>
							<Value1>DeviceDescr.SM[index].OneByteMode</Value1>
							<Value2>null</Value2>
							<GotoStep>NEXT</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<SetVariable Target="errcount">errcount+1</SetVariable>
					<WriteLine Id="2" Level="Warning" Param0="elementName" Param1="index">ESI {0} (a={1}) is obsolete and shall not be used.</WriteLine>
				</TestStep>
				<TestStep Name="NEXT">
					<SetVariable Target="index">index+1</SetVariable>
				</TestStep>
				<TestStep>
					<Compare>
						<GreaterOrEqual>
							<Value1>index</Value1>
							<Value2>indexmax</Value2>
							<GotoStep>END</GotoStep>
						</GreaterOrEqual>
					</Compare>
				</TestStep>
				<TestStep>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>CHECK</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="END">
					<Compare>
						<Greater>
							<Value1>errcount</Value1>
							<Value2>0</Value2>
							<Return Id="3">Test case finished with warnings.</Return>
						</Greater>
					</Compare>
				</TestStep>
				<TestStep>
					<WriteLine Id="4" Level="Success" Param0="elementName">ESI {0} not used. Test case passed.</WriteLine>
				</TestStep>
			</TestCase>
			<TestCase Name="Device:Sm@Wachdog" CaseId="11">
				<?MAX_OUTPUT_ID 4?>
				<Comment>The ESI attribute Device:Sm@Wachdog is obsolete.</Comment>
				<Description>
					<Purpose>The ESI attribute Device:Sm@Wachdog is obsolete and shall not be used. </Purpose>
					<PreCondition>ESI file available.</PreCondition>
					<Action>Scan the DuT's ESI for Device:Sm@Wachdog</Action>
					<PostCondition>Warning if attribute is used.</PostCondition>
					<References>
						<Reference Specification="ETG.2000" Chapter=""></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="START">
					<SetVariable Target="elementName">attribute Device:Sm[a]@Wachdog</SetVariable>
					<WriteLine Id="0" Level="Output" Param0="elementName">Scan ESI for {0}</WriteLine>
				</TestStep>
				<TestStep Name="INIT">
					<SetVariable Target="errcount">0</SetVariable>
				</TestStep>
				<TestStep>
					<SetVariable Target="indexmax">DeviceDescr.SM.Count</SetVariable>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.SM.Count</Value1>
							<Value2>0</Value2>
							<SkipCase Id="1">Case skipped because of empty element: Device:Sm</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<SetVariable Target="index">0</SetVariable>
				</TestStep>
				<TestStep Name="CHECK">
					<Compare>
						<Equal>
							<Value1>DeviceDescr.SM[index].Watchdog</Value1>
							<Value2>null</Value2>
							<GotoStep>NEXT</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<SetVariable Target="errcount">errcount+1</SetVariable>
					<WriteLine Id="2" Level="Warning" Param0="elementName" Param1="index">ESI {0} (a={1}) is obsolete and shall not be used.</WriteLine>
				</TestStep>
				<TestStep Name="NEXT">
					<SetVariable Target="index">index+1</SetVariable>
				</TestStep>
				<TestStep>
					<Compare>
						<GreaterOrEqual>
							<Value1>index</Value1>
							<Value2>indexmax</Value2>
							<GotoStep>END</GotoStep>
						</GreaterOrEqual>
					</Compare>
				</TestStep>
				<TestStep>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>CHECK</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="END">
					<Compare>
						<Greater>
							<Value1>errcount</Value1>
							<Value2>0</Value2>
							<Return Id="3">Test case finished with warnings.</Return>
						</Greater>
					</Compare>
				</TestStep>
				<TestStep>
					<WriteLine Id="4" Level="Success" Param0="elementName">ESI {0} not used. Test case passed.</WriteLine>
				</TestStep>
			</TestCase>
			<TestCase Name="Device:Sm@FixedAssignment" CaseId="12">
				<?MAX_OUTPUT_ID 4?>
				<Comment>The ESI attribute Device:Sm@FixedAssignment is obsolete.</Comment>
				<Description>
					<Purpose>The ESI attribute Device:Sm@FixedAssignment is obsolete and shall not be used. </Purpose>
					<PreCondition>ESI file available.</PreCondition>
					<Action>Scan the DuT's ESI for Device:Sm@FixedAssignment</Action>
					<PostCondition>Warning if attribute is used.</PostCondition>
					<References>
						<Reference Specification="ETG.2000" Chapter=""></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="START">
					<SetVariable Target="elementName">attribute Device:Sm[a]@FixedAssignment</SetVariable>
					<WriteLine Id="0" Level="Output" Param0="elementName">Scan ESI for {0}</WriteLine>
				</TestStep>
				<TestStep Name="INIT">
					<SetVariable Target="errcount">0</SetVariable>
				</TestStep>
				<TestStep>
					<SetVariable Target="indexmax">DeviceDescr.SM.Count</SetVariable>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.SM.Count</Value1>
							<Value2>0</Value2>
							<SkipCase Id="1">Case skipped because of empty element: Device:Sm</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<SetVariable Target="index">0</SetVariable>
				</TestStep>
				<TestStep Name="CHECK">
					<Compare>
						<Equal>
							<Value1>DeviceDescr.SM[index].FixedAssignment</Value1>
							<Value2>null</Value2>
							<GotoStep>NEXT</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<SetVariable Target="errcount">errcount+1</SetVariable>
					<WriteLine Id="2" Level="Warning" Param0="elementName" Param1="index">ESI {0} (a={1}) is obsolete and shall not be used.</WriteLine>
				</TestStep>
				<TestStep Name="NEXT">
					<SetVariable Target="index">index+1</SetVariable>
				</TestStep>
				<TestStep>
					<Compare>
						<GreaterOrEqual>
							<Value1>index</Value1>
							<Value2>indexmax</Value2>
							<GotoStep>END</GotoStep>
						</GreaterOrEqual>
					</Compare>
				</TestStep>
				<TestStep>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>CHECK</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="END">
					<Compare>
						<Greater>
							<Value1>errcount</Value1>
							<Value2>0</Value2>
							<Return Id="3">Test case finished with warnings.</Return>
						</Greater>
					</Compare>
				</TestStep>
				<TestStep>
					<WriteLine Id="4" Level="Success" Param0="elementName">ESI {0} not used. Test case passed.</WriteLine>
				</TestStep>
			</TestCase>
			<TestCase Name="Device:RxPdo@PdoOrder" CaseId="13">
				<?MAX_OUTPUT_ID 4?>
				<Comment>The ESI attribute Device:RxPdo@PdoOrder is obsolete.</Comment>
				<Description>
					<Purpose>The ESI attribute Device:RxPdo@PdoOrder is obsolete and shall not be used. </Purpose>
					<PreCondition>ESI file available.</PreCondition>
					<Action>Scan the DuT's ESI for Device:RxPdo@PdoOrder</Action>
					<PostCondition>Warning if attribute is used.</PostCondition>
					<References>
						<Reference Specification="ETG.2000" Chapter=""></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="START">
					<SetVariable Target="elementName">attribute Device:RxPdo[a]@PdoOrder</SetVariable>
					<WriteLine Id="0" Level="Output" Param0="elementName">Scan ESI for {0}</WriteLine>
				</TestStep>
				<TestStep Name="INIT">
					<SetVariable Target="errcount">0</SetVariable>
				</TestStep>
				<TestStep>
					<SetVariable Target="indexmax">DeviceDescr.RxPdo.Count</SetVariable>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.RxPdo.Count</Value1>
							<Value2>0</Value2>
							<SkipCase Id="1">Case skipped because of empty element: Device:RxPdo</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<SetVariable Target="index">0</SetVariable>
				</TestStep>
				<TestStep Name="CHECK">
					<Compare>
						<Equal>
							<Value1>DeviceDescr.RxPdo[index].PdoOrder</Value1>
							<Value2>null</Value2>
							<GotoStep>NEXT</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<SetVariable Target="errcount">errcount+1</SetVariable>
					<WriteLine Id="2" Level="Warning" Param0="elementName" Param1="index">ESI {0} (a={1}) is obsolete and shall not be used.</WriteLine>
				</TestStep>
				<TestStep Name="NEXT">
					<SetVariable Target="index">index+1</SetVariable>
				</TestStep>
				<TestStep>
					<Compare>
						<GreaterOrEqual>
							<Value1>index</Value1>
							<Value2>indexmax</Value2>
							<GotoStep>END</GotoStep>
						</GreaterOrEqual>
					</Compare>
				</TestStep>
				<TestStep>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>CHECK</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="END">
					<Compare>
						<Greater>
							<Value1>errcount</Value1>
							<Value2>0</Value2>
							<Return Id="3">Test case finished with warnings.</Return>
						</Greater>
					</Compare>
				</TestStep>
				<TestStep>
					<WriteLine Id="4" Level="Success" Param0="elementName">ESI {0} not used. Test case passed.</WriteLine>
				</TestStep>
			</TestCase>
			<TestCase Name="Device:TxPdo@PdoOrder" CaseId="14">
				<?MAX_OUTPUT_ID 4?>
				<Comment>The ESI attribute Device:TxPdo@PdoOrder is obsolete.</Comment>
				<Description>
					<Purpose>The ESI attribute Device:TxPdo@PdoOrder is obsolete and shall not be used. </Purpose>
					<PreCondition>ESI file available.</PreCondition>
					<Action>Scan the DuT's ESI for Device:TxPdo@PdoOrder</Action>
					<PostCondition>Warning if attribute is used.</PostCondition>
					<References>
						<Reference Specification="ETG.2000" Chapter=""></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="START">
					<SetVariable Target="elementName">attribute Device:TxPdo[a]@PdoOrder</SetVariable>
					<WriteLine Id="0" Level="Output" Param0="elementName">Scan ESI for {0}</WriteLine>
				</TestStep>
				<TestStep Name="INIT">
					<SetVariable Target="errcount">0</SetVariable>
				</TestStep>
				<TestStep>
					<SetVariable Target="indexmax">DeviceDescr.TxPdo.Count</SetVariable>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.TxPdo.Count</Value1>
							<Value2>0</Value2>
							<SkipCase Id="1">Case skipped because of empty element: Device:RxPdo</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<SetVariable Target="index">0</SetVariable>
				</TestStep>
				<TestStep Name="CHECK">
					<Compare>
						<Equal>
							<Value1>DeviceDescr.TxPdo[index].PdoOrder</Value1>
							<Value2>null</Value2>
							<GotoStep>NEXT</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<SetVariable Target="errcount">errcount+1</SetVariable>
					<WriteLine Id="2" Level="Warning" Param0="elementName" Param1="index">ESI {0} (a={1}) is obsolete and shall not be used.</WriteLine>
				</TestStep>
				<TestStep Name="NEXT">
					<SetVariable Target="index">index+1</SetVariable>
				</TestStep>
				<TestStep>
					<Compare>
						<GreaterOrEqual>
							<Value1>index</Value1>
							<Value2>indexmax</Value2>
							<GotoStep>END</GotoStep>
						</GreaterOrEqual>
					</Compare>
				</TestStep>
				<TestStep>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>CHECK</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="END">
					<Compare>
						<Greater>
							<Value1>errcount</Value1>
							<Value2>0</Value2>
							<Return Id="3">Test case finished with warnings.</Return>
						</Greater>
					</Compare>
				</TestStep>
				<TestStep>
					<WriteLine Id="4" Level="Success" Param0="elementName">ESI {0} not used. Test case passed.</WriteLine>
				</TestStep>
			</TestCase>
			<TestCase Name="Device:Mailbox:CoE:Object" CaseId="15">
				<?MAX_OUTPUT_ID 5?>
				<Comment>The ESI element Device:Mailbox:CoE:Object is obsolete.</Comment>
				<Description>
					<Purpose>The ESI element Device:Mailbox:CoE:Object is obsolete and shall not be used. </Purpose>
					<PreCondition>ESI file available.</PreCondition>
					<Action>Scan the DuT's ESI for Device:Mailbox:CoE:Object</Action>
					<PostCondition>Warning if element is used.</PostCondition>
					<References>
						<Reference Specification="ETG.2000" Chapter=""></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="START">
					<SetVariable Target="elementName">element Device:Mailbox:CoE:Object</SetVariable>
					<WriteLine Id="0" Level="Output" Param0="elementName">Scan ESI for {0}</WriteLine>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Mailbox</Value1>
							<Value2>false</Value2>
							<SkipCase Id="1">Case skipped because of empty element: Device.Mailbox</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Mailbox.CoE</Value1>
							<Value2>false</Value2>
							<SkipCase Id="2">Case skipped because of empty element: Device:Mailbox:CoE</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CHECK">
					<Compare>
						<NotEqual>
							<Value1>DeviceDescr.Mailbox.CoE.Object.Count</Value1>
							<Value2>0</Value2>
							<RaiseWarning Id="3" Param0="elementName">ESI {0} is obsolete and shall not be used.</RaiseWarning>
						</NotEqual>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>DeviceDescr.Mailbox.CoE.Object.Count</Value1>
							<Value2>0</Value2>
							<Return Id="4">Test case finished with warnings.</Return>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="END">
					<WriteLine Id="5" Level="Success" Param0="elementName">ESI {0} not used. Test case passed.</WriteLine>
				</TestStep>
			</TestCase>
			<TestCase Name="Device:Mailbox:CoE:InitCmd@Fixed" CaseId="16">
				<?MAX_OUTPUT_ID 6?>
				<Comment>The ESI attribute Device:Mailbox:CoE@InitCmd:Fixed is obsolete.</Comment>
				<Description>
					<Purpose>The ESI attribute Device:Mailbox:CoE:InitCmd@Fixed is obsolete and shall not be used. </Purpose>
					<PreCondition>ESI file available.</PreCondition>
					<Action>Scan the DuT's ESI for Device:Mailbox:CoE@InitCmd:Fixed</Action>
					<PostCondition>Warning if attribute is used.</PostCondition>
					<References>
						<Reference Specification="ETG.2000" Chapter=""></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="START">
					<SetVariable Target="elementName">attribute Device:Mailbox:CoE:InitCmd[a]@Fixed</SetVariable>
					<WriteLine Id="0" Level="Output" Param0="elementName">Scan ESI for {0}</WriteLine>
				</TestStep>
				<TestStep Name="INIT">
					<SetVariable Target="errcount">0</SetVariable>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Mailbox</Value1>
							<Value2>false</Value2>
							<SkipCase Id="1">Case skipped because of empty element: Device:Mailbox</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Mailbox.CoE</Value1>
							<Value2>false</Value2>
							<SkipCase Id="2">Case skipped because of empty element: Device:Mailbox:CoE</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Mailbox.CoE.InitCmd.Count</Value1>
							<Value2>0</Value2>
							<SkipCase Id="3">Case skipped because of empty element: Device:Mailbox:CoE:InitCmd</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<SetVariable Target="indexmax">DeviceDescr.Mailbox.CoE.InitCmd.Count</SetVariable>
				</TestStep>
				<TestStep>
					<SetVariable Target="index">0</SetVariable>
				</TestStep>
				<TestStep Name="CHECK">
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Mailbox.CoE.InitCmd[index].Fixed</Value1>
							<Value2>null</Value2>
							<GotoStep>NEXT</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="WARNING">
					<SetVariable Target="errcount">errcount+1</SetVariable>
					<WriteLine Id="4" Level="Warning" Param0="elementName" Param1="index">ESI {0} (a={1}) is obsolete and shall not be used.</WriteLine>
				</TestStep>
				<TestStep Name="NEXT">
					<SetVariable Target="index">index+1</SetVariable>
				</TestStep>
				<TestStep>
					<Compare>
						<GreaterOrEqual>
							<Value1>index</Value1>
							<Value2>indexmax</Value2>
							<GotoStep>END</GotoStep>
						</GreaterOrEqual>
					</Compare>
				</TestStep>
				<TestStep>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>CHECK</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="END">
					<Compare>
						<Greater>
							<Value1>errcount</Value1>
							<Value2>0</Value2>
							<Return Id="5">Test case finished with warnings.</Return>
						</Greater>
					</Compare>
				</TestStep>
				<TestStep>
					<WriteLine Id="6" Level="Success" Param0="elementName">ESI {0} not used. Test case passed.</WriteLine>
				</TestStep>
			</TestCase>
			<TestCase Name="Device:Mailbox:CoE@DS402Channels" CaseId="17">
				<?MAX_OUTPUT_ID 5?>
				<Comment>The ESI attribute Device:Mailbox:CoE@DS402Channels is obsolete.</Comment>
				<Description>
					<Purpose>The ESI attribute Device:Mailbox:CoE@DS402Channels is obsolete and shall not be used. </Purpose>
					<PreCondition>ESI file available.</PreCondition>
					<Action>Scan the DuT's ESI for Device:Mailbox:CoE@DS402Channels</Action>
					<PostCondition>Warning if attribute is used.</PostCondition>
					<References>
						<Reference Specification="ETG.2000" Chapter=""></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="START">
					<SetVariable Target="elementName">attribute Device:Mailbox:CoE@DS402Channels</SetVariable>
					<WriteLine Id="0" Level="Output" Param0="elementName">Scan ESI for {0}</WriteLine>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Mailbox</Value1>
							<Value2>false</Value2>
							<SkipCase Id="1">Case skipped because of empty element: Device.Mailbox</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Mailbox.CoE</Value1>
							<Value2>false</Value2>
							<SkipCase Id="2">Case skippped because of empty element: Device:Mailbox:CoE</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CHECK">
					<Compare>
						<NotEqual>
							<Value1>DeviceDescr.Mailbox.CoE.DS402Channels</Value1>
							<Value2>null</Value2>
							<RaiseWarning Id="3" Param0="elementName">ESI {0} is obsolete and shall not be used.</RaiseWarning>
						</NotEqual>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>DeviceDescr.Mailbox.CoE.DS402Channels</Value1>
							<Value2>null</Value2>
							<Return Id="4">Test case finished with warnings.</Return>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="END">
					<WriteLine Id="5" Level="Success" Param0="elementName">ESI {0} not used. Test case passed.</WriteLine>
				</TestStep>
			</TestCase>
			<TestCase Name="Device:Dc:OpMode:Sm:SyncType" CaseId="18">
				<?MAX_OUTPUT_ID 5?>
				<Comment>The ESI element Device:Dc:OpMode:Sm:SyncType is obsolete.</Comment>
				<Description>
					<Purpose>The ESI element Device:Dc:OpMode:Sm:SyncType is obsolete and shall not be used. </Purpose>
					<PreCondition>ESI file available.</PreCondition>
					<Action>Scan the DuT's ESI for Device:Dc:OpMode:Sm:SyncType</Action>
					<PostCondition>Warning if element is used.</PostCondition>
					<References>
						<Reference Specification="ETG.2000" Chapter=""></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="START">
					<SetVariable Target="elementName">element Device:Dc:OpMode[a]:Sm[b]:SyncType</SetVariable>
					<WriteLine Id="0" Level="Output" Param0="elementName">Scan ESI for {0}</WriteLine>
				</TestStep>
				<TestStep Name="INIT">
					<SetVariable Target="errcount">0</SetVariable>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.DC</Value1>
							<Value2>false</Value2>
							<SkipCase Id="1">Case skipped because of empty element: Device:Dc</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<SetVariable Target="index">0</SetVariable>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.DC.OpMode.Count</Value1>
							<Value2>0</Value2>
							<SkipCase Id="2">Case skipped because of empty element: Device:Dc:OpMode</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<SetVariable Target="indexmax">DeviceDescr.DC.OpMode.Count</SetVariable>
				</TestStep>
				<TestStep Name="CHECK">
					<SetVariable Target="index2max">DeviceDescr.DC.OpMode[index].Sm.Count</SetVariable>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.DC.OpMode[index].Sm.Count</Value1>
							<Value2>0</Value2>
							<GotoStep>NEXT</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<SetVariable Target="index2">0</SetVariable>
				</TestStep>
				<TestStep Name="CHECK2">
					<Compare>
						<Equal>
							<Value1>DeviceDescr.DC.OpMode[index].Sm[index2].SyncType</Value1>
							<Value2>null</Value2>
							<GotoStep>NEXT2</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<SetVariable Target="errcount">errcount+1</SetVariable>
					<WriteLine Id="3" Level="Warning" Param0="elementName" Param1="index" Param2="index2">ESI {0} (a={1}, b={2}) is obsolete and shall not be used.</WriteLine>
				</TestStep>
				<TestStep Name="NEXT2">
					<SetVariable Target="index2">index2+1</SetVariable>
				</TestStep>
				<TestStep>
					<Compare>
						<GreaterOrEqual>
							<Value1>index2</Value1>
							<Value2>index2max</Value2>
							<GotoStep>NEXT</GotoStep>
						</GreaterOrEqual>
					</Compare>
				</TestStep>
				<TestStep>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>CHECK2</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="NEXT">
					<SetVariable Target="index">index+1</SetVariable>
				</TestStep>
				<TestStep>
					<Compare>
						<GreaterOrEqual>
							<Value1>index</Value1>
							<Value2>indexmax</Value2>
							<GotoStep>END</GotoStep>
						</GreaterOrEqual>
					</Compare>
				</TestStep>
				<TestStep>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>CHECK</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="END">
					<Compare>
						<Greater>
							<Value1>errcount</Value1>
							<Value2>0</Value2>
							<Return Id="4">Test case finished with warnings.</Return>
						</Greater>
					</Compare>
				</TestStep>
				<TestStep>
					<WriteLine Id="5" Level="Success" Param0="elementName">ESI {0} not used. Test case passed.</WriteLine>
				</TestStep>
			</TestCase>
			<TestCase Name="Device:Dc:OpMode:Sm:CycleTime" CaseId="19">
				<?MAX_OUTPUT_ID 5?>
				<Comment>The ESI element Device:Dc:OpMode:Sm:CycleTime is obsolete.</Comment>
				<Description>
					<Purpose>The ESI element Device:Dc:OpMode:Sm:CycleTime is obsolete and shall not be used. </Purpose>
					<PreCondition>ESI file available.</PreCondition>
					<Action>Scan the DuT's ESI for Device:Dc:OpMode:Sm:CycleTime</Action>
					<PostCondition>Warning if element is used.</PostCondition>
					<References>
						<Reference Specification="ETG.2000" Chapter=""></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="START">
					<SetVariable Target="elementName">element Device:Dc:OpMode[a]:Sm[b]:CycleTime</SetVariable>
					<WriteLine Id="0" Level="Output" Param0="elementName">Scan ESI for {0}</WriteLine>
				</TestStep>
				<TestStep Name="INIT">
					<SetVariable Target="errcount">0</SetVariable>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.DC</Value1>
							<Value2>false</Value2>
							<SkipCase Id="1">Case skipped because of empty element: Device:Dc</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<SetVariable Target="index">0</SetVariable>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.DC.OpMode.Count</Value1>
							<Value2>0</Value2>
							<SkipCase Id="2">Case skipped because of empty element: Device:Dc:OpMode</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<SetVariable Target="indexmax">DeviceDescr.DC.OpMode.Count</SetVariable>
				</TestStep>
				<TestStep Name="CHECK">
					<SetVariable Target="index2max">DeviceDescr.DC.OpMode[index].Sm.Count</SetVariable>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.DC.OpMode[index].Sm.Count</Value1>
							<Value2>0</Value2>
							<GotoStep>NEXT</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<SetVariable Target="index2">0</SetVariable>
				</TestStep>
				<TestStep Name="CHECK2">
					<Compare>
						<Equal>
							<Value1>DeviceDescr.DC.OpMode[index].Sm[index2].CycleTime</Value1>
							<Value2>null</Value2>
							<GotoStep>NEXT2</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<SetVariable Target="errcount">errcount+1</SetVariable>
					<WriteLine Id="3" Level="Warning" Param0="elementName" Param1="index" Param2="index2">ESI {0} (a={1}, b={2}) is obsolete and shall not be used.</WriteLine>
				</TestStep>
				<TestStep Name="NEXT2">
					<SetVariable Target="index2">index2+1</SetVariable>
				</TestStep>
				<TestStep>
					<Compare>
						<GreaterOrEqual>
							<Value1>index2</Value1>
							<Value2>index2max</Value2>
							<GotoStep>NEXT</GotoStep>
						</GreaterOrEqual>
					</Compare>
				</TestStep>
				<TestStep>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>CHECK2</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="NEXT">
					<SetVariable Target="index">index+1</SetVariable>
				</TestStep>
				<TestStep>
					<Compare>
						<GreaterOrEqual>
							<Value1>index</Value1>
							<Value2>indexmax</Value2>
							<GotoStep>END</GotoStep>
						</GreaterOrEqual>
					</Compare>
				</TestStep>
				<TestStep>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>CHECK</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="END">
					<Compare>
						<Greater>
							<Value1>errcount</Value1>
							<Value2>0</Value2>
							<Return Id="4">Test case finished with warnings.</Return>
						</Greater>
					</Compare>
				</TestStep>
				<TestStep>
					<WriteLine Id="5" Level="Success" Param0="elementName">ESI {0} not used. Test case passed.</WriteLine>
				</TestStep>
			</TestCase>
			<TestCase Name="Device:Dc:OpMode:Sm:CycleTime:Factor" CaseId="20">
				<?MAX_OUTPUT_ID 5?>
				<Comment>The ESI element Device:Dc:OpMode:Sm:CycleTime:Factor is obsolete.</Comment>
				<Description>
					<Purpose>The ESI element Device:Dc:OpMode:Sm:CycleTime:Factor is obsolete and shall not be used. </Purpose>
					<PreCondition>ESI file available.</PreCondition>
					<Action>Scan the DuT's ESI for Device:Dc:OpMode:Sm:CycleTime:Factor</Action>
					<PostCondition>Warning if element is used.</PostCondition>
					<References>
						<Reference Specification="ETG.2000" Chapter=""></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="START">
					<SetVariable Target="elementName">element Device:Dc:OpMode[a]:Sm[b]:CycleTime:Factor</SetVariable>
					<WriteLine Id="0" Level="Output" Param0="elementName">Scan ESI for {0}</WriteLine>
				</TestStep>
				<TestStep Name="INIT">
					<SetVariable Target="errcount">0</SetVariable>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.DC</Value1>
							<Value2>false</Value2>
							<SkipCase Id="1">Case skipped because of empty element: Device:Dc</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<SetVariable Target="index">0</SetVariable>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.DC.OpMode.Count</Value1>
							<Value2>0</Value2>
							<SkipCase Id="2">Case skipped because of empty element: Device:Dc:OpMode</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<SetVariable Target="indexmax">DeviceDescr.DC.OpMode.Count</SetVariable>
				</TestStep>
				<TestStep Name="CHECK">
					<SetVariable Target="index2max">DeviceDescr.DC.OpMode[index].Sm.Count</SetVariable>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.DC.OpMode[index].Sm.Count</Value1>
							<Value2>0</Value2>
							<GotoStep>NEXT</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<SetVariable Target="index2">0</SetVariable>
				</TestStep>
				<TestStep Name="CHECK2">
					<Compare>
						<NotEqual>
							<Value1>DeviceDescr.DC.OpMode[index].Sm[index2].CycleTime</Value1>
							<Value2>0</Value2>
							<GotoStep>NEXT2</GotoStep>
						</NotEqual>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>DeviceDescr.DC.OpMode[index].Sm[index2].CycleTime.Factor</Value1>
							<Value2>null</Value2>
							<GotoStep>WARNING</GotoStep>
						</NotEqual>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>0</Value1>
							<Value2>1</Value2>
							<GotoStep>NEXT2</GotoStep>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="WARNING">
					<SetVariable Target="errcount">errcount+1</SetVariable>
					<WriteLine Id="3" Level="Warning" Param0="elementName" Param1="index" Param2="index2">ESI {0} (a={1}, b={2}) is obsolete and shall not be used.</WriteLine>
				</TestStep>
				<TestStep Name="NEXT2">
					<SetVariable Target="index2">index2+1</SetVariable>
				</TestStep>
				<TestStep>
					<Compare>
						<GreaterOrEqual>
							<Value1>index2</Value1>
							<Value2>index2max</Value2>
							<GotoStep>NEXT</GotoStep>
						</GreaterOrEqual>
					</Compare>
				</TestStep>
				<TestStep>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>CHECK2</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="NEXT">
					<SetVariable Target="index">index+1</SetVariable>
				</TestStep>
				<TestStep>
					<Compare>
						<GreaterOrEqual>
							<Value1>index</Value1>
							<Value2>indexmax</Value2>
							<GotoStep>END</GotoStep>
						</GreaterOrEqual>
					</Compare>
				</TestStep>
				<TestStep>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>CHECK</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="END">
					<Compare>
						<Greater>
							<Value1>errcount</Value1>
							<Value2>0</Value2>
							<Return Id="4">Test case finished with warnings.</Return>
						</Greater>
					</Compare>
				</TestStep>
				<TestStep>
					<WriteLine Id="5" Level="Success" Param0="elementName">ESI {0} not used. Test case passed.</WriteLine>
				</TestStep>
			</TestCase>
			<TestCase Name="Device:Dc:OpMode:Sm:ShiftTime" CaseId="21">
				<?MAX_OUTPUT_ID 5?>
				<Comment>The ESI element Device:Dc:OpMode:Sm:ShiftTime is obsolete.</Comment>
				<Description>
					<Purpose>The ESI element Device:Dc:OpMode:Sm:ShiftTime is obsolete and shall not be used. </Purpose>
					<PreCondition>ESI file available.</PreCondition>
					<Action>Scan the DuT's ESI for Device:Dc:OpMode:Sm:ShiftTime</Action>
					<PostCondition>Warning if element is used.</PostCondition>
					<References>
						<Reference Specification="ETG.2000" Chapter=""></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="START">
					<SetVariable Target="elementName">element Device:Dc:OpMode[a]:Sm[b]:ShiftTime</SetVariable>
					<WriteLine Id="0" Level="Output" Param0="elementName">Scan ESI for {0}</WriteLine>
				</TestStep>
				<TestStep Name="INIT">
					<SetVariable Target="errcount">0</SetVariable>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.DC</Value1>
							<Value2>false</Value2>
							<SkipCase Id="1">Case skipped because of empty element: Device:Dc</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<SetVariable Target="index">0</SetVariable>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.DC.OpMode.Count</Value1>
							<Value2>0</Value2>
							<SkipCase Id="2">Case skipped because of empty element: Device:Dc:OpMode</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<SetVariable Target="indexmax">DeviceDescr.DC.OpMode.Count</SetVariable>
				</TestStep>
				<TestStep Name="CHECK">
					<SetVariable Target="index2max">DeviceDescr.DC.OpMode[index].Sm.Count</SetVariable>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.DC.OpMode[index].Sm.Count</Value1>
							<Value2>0</Value2>
							<GotoStep>NEXT</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<SetVariable Target="index2">0</SetVariable>
				</TestStep>
				<TestStep Name="CHECK2">
					<Compare>
						<Equal>
							<Value1>DeviceDescr.DC.OpMode[index].Sm[index2].ShiftTime</Value1>
							<Value2>null</Value2>
							<GotoStep>NEXT2</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<SetVariable Target="errcount">errcount+1</SetVariable>
					<WriteLine Id="3" Level="Warning" Param0="elementName" Param1="index" Param2="index2">ESI {0} (a={1}, b={2}) is obsolete and shall not be used.</WriteLine>
				</TestStep>
				<TestStep Name="NEXT2">
					<SetVariable Target="index2">index2+1</SetVariable>
				</TestStep>
				<TestStep>
					<Compare>
						<GreaterOrEqual>
							<Value1>index2</Value1>
							<Value2>index2max</Value2>
							<GotoStep>NEXT</GotoStep>
						</GreaterOrEqual>
					</Compare>
				</TestStep>
				<TestStep>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>CHECK2</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="NEXT">
					<SetVariable Target="index">index+1</SetVariable>
				</TestStep>
				<TestStep>
					<Compare>
						<GreaterOrEqual>
							<Value1>index</Value1>
							<Value2>indexmax</Value2>
							<GotoStep>END</GotoStep>
						</GreaterOrEqual>
					</Compare>
				</TestStep>
				<TestStep>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>CHECK</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="END">
					<Compare>
						<Greater>
							<Value1>errcount</Value1>
							<Value2>0</Value2>
							<Return Id="4">Test case finished with warnings.</Return>
						</Greater>
					</Compare>
				</TestStep>
				<TestStep>
					<WriteLine Id="5" Level="Success" Param0="elementName">ESI {0} not used. Test case passed.</WriteLine>
				</TestStep>
			</TestCase>
			<TestCase Name="Device:Dc:OpMode:Sm:ShiftTime:MinAfterSync" CaseId="22">
				<?MAX_OUTPUT_ID 5?>
				<Comment>The ESI element Device:Dc:OpMode:Sm:ShiftTime:MinAfterSync is obsolete.</Comment>
				<Description>
					<Purpose>The ESI element Device:Dc:OpMode:Sm:ShiftTime:MinAfterSync is obsolete and shall not be used. </Purpose>
					<PreCondition>ESI file available.</PreCondition>
					<Action>Scan the DuT's ESI for Device:Dc:OpMode:Sm:ShiftTime:MinAfterSync</Action>
					<PostCondition>Warning if element is used.</PostCondition>
					<References>
						<Reference Specification="ETG.2000" Chapter=""></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="START">
					<SetVariable Target="elementName">element Device:Dc:OpMode[a]:Sm[b]:ShiftTime:MinAfterSync</SetVariable>
					<WriteLine Id="0" Level="Output" Param0="elementName">Scan ESI for {0}</WriteLine>
				</TestStep>
				<TestStep Name="INIT">
					<SetVariable Target="errcount">0</SetVariable>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.DC</Value1>
							<Value2>false</Value2>
							<SkipCase Id="1">Case skipped because of empty element: Device:Dc</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<SetVariable Target="index">0</SetVariable>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.DC.OpMode.Count</Value1>
							<Value2>0</Value2>
							<SkipCase Id="2">Case skipped because of empty element: Device:Dc:OpMode</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<SetVariable Target="indexmax">DeviceDescr.DC.OpMode.Count</SetVariable>
				</TestStep>
				<TestStep Name="CHECK">
					<SetVariable Target="index2max">DeviceDescr.DC.OpMode[index].Sm.Count</SetVariable>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.DC.OpMode[index].Sm.Count</Value1>
							<Value2>0</Value2>
							<GotoStep>NEXT</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<SetVariable Target="index2">0</SetVariable>
				</TestStep>
				<TestStep Name="CHECK2">
					<Compare>
						<NotEqual>
							<Value1>DeviceDescr.DC.OpMode[index].Sm[index2].ShiftTime</Value1>
							<Value2>0</Value2>
							<GotoStep>NEXT2</GotoStep>
						</NotEqual>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>DeviceDescr.DC.OpMode[index].Sm[index2].ShiftTime.MinAfterSync</Value1>
							<Value2>null</Value2>
							<GotoStep>WARNING</GotoStep>
						</NotEqual>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>0</Value1>
							<Value2>1</Value2>
							<GotoStep>NEXT2</GotoStep>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="WARNING">
					<SetVariable Target="errcount">errcount+1</SetVariable>
					<WriteLine Id="3" Level="Warning" Param0="elementName" Param1="index" Param2="index2">ESI {0} (a={1}, b={2}) is obsolete and shall not be used.</WriteLine>
				</TestStep>
				<TestStep Name="NEXT2">
					<SetVariable Target="index2">index2+1</SetVariable>
				</TestStep>
				<TestStep>
					<Compare>
						<GreaterOrEqual>
							<Value1>index2</Value1>
							<Value2>index2max</Value2>
							<GotoStep>NEXT</GotoStep>
						</GreaterOrEqual>
					</Compare>
				</TestStep>
				<TestStep>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>CHECK2</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="NEXT">
					<SetVariable Target="index">index+1</SetVariable>
				</TestStep>
				<TestStep>
					<Compare>
						<GreaterOrEqual>
							<Value1>index</Value1>
							<Value2>indexmax</Value2>
							<GotoStep>END</GotoStep>
						</GreaterOrEqual>
					</Compare>
				</TestStep>
				<TestStep>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>CHECK</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="END">
					<Compare>
						<Greater>
							<Value1>errcount</Value1>
							<Value2>0</Value2>
							<Return Id="4">Test case finished with warnings.</Return>
						</Greater>
					</Compare>
				</TestStep>
				<TestStep>
					<WriteLine Id="5" Level="Success" Param0="elementName">ESI {0} not used. Test case passed.</WriteLine>
				</TestStep>
			</TestCase>
			<TestCase Name="Device:Dc:OpMode:Sm:ShiftTime:MinBeforeFrame" CaseId="23">
				<?MAX_OUTPUT_ID 5?>
				<Comment>The ESI element Device:Dc:OpMode:Sm:ShiftTime:MinBeforeFrame is obsolete.</Comment>
				<Description>
					<Purpose>The ESI element Device:Dc:OpMode:Sm:ShiftTime:MinBeforeFrame is obsolete and shall not be used. </Purpose>
					<PreCondition>ESI file available.</PreCondition>
					<Action>Scan the DuT's ESI for Device:Dc:OpMode:Sm:ShiftTime:MinBeforeFrame</Action>
					<PostCondition>Warning if element is used.</PostCondition>
					<References>
						<Reference Specification="ETG.2000" Chapter=""></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="START">
					<SetVariable Target="elementName">element Device:Dc:OpMode[a]:Sm[b]:ShiftTime:MinBeforeFrame</SetVariable>
					<WriteLine Id="0" Level="Output" Param0="elementName">Scan ESI for {0}</WriteLine>
				</TestStep>
				<TestStep Name="INIT">
					<SetVariable Target="errcount">0</SetVariable>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.DC</Value1>
							<Value2>false</Value2>
							<SkipCase Id="1">Case skipped because of empty element: Device:Dc</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<SetVariable Target="index">0</SetVariable>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.DC.OpMode.Count</Value1>
							<Value2>0</Value2>
							<SkipCase Id="2">Case skipped because of empty element: Device:Dc:OpMode</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<SetVariable Target="indexmax">DeviceDescr.DC.OpMode.Count</SetVariable>
				</TestStep>
				<TestStep Name="CHECK">
					<SetVariable Target="index2max">DeviceDescr.DC.OpMode[index].Sm.Count</SetVariable>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.DC.OpMode[index].Sm.Count</Value1>
							<Value2>0</Value2>
							<GotoStep>NEXT</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<SetVariable Target="index2">0</SetVariable>
				</TestStep>
				<TestStep Name="CHECK2">
					<Compare>
						<NotEqual>
							<Value1>DeviceDescr.DC.OpMode[index].Sm[index2].ShiftTime</Value1>
							<Value2>0</Value2>
							<GotoStep>NEXT2</GotoStep>
						</NotEqual>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>DeviceDescr.DC.OpMode[index].Sm[index2].ShiftTime.MinBeforeFrame</Value1>
							<Value2>null</Value2>
							<GotoStep>WARNING</GotoStep>
						</NotEqual>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>0</Value1>
							<Value2>1</Value2>
							<GotoStep>NEXT2</GotoStep>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="WARNING">
					<SetVariable Target="errcount">errcount+1</SetVariable>
					<WriteLine Id="3" Level="Warning" Param0="elementName" Param1="index" Param2="index2">ESI {0} (a={1}, b={2}) is obsolete and shall not be used.</WriteLine>
				</TestStep>
				<TestStep Name="NEXT2">
					<SetVariable Target="index2">index2+1</SetVariable>
				</TestStep>
				<TestStep>
					<Compare>
						<GreaterOrEqual>
							<Value1>index2</Value1>
							<Value2>index2max</Value2>
							<GotoStep>NEXT</GotoStep>
						</GreaterOrEqual>
					</Compare>
				</TestStep>
				<TestStep>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>CHECK2</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="NEXT">
					<SetVariable Target="index">index+1</SetVariable>
				</TestStep>
				<TestStep>
					<Compare>
						<GreaterOrEqual>
							<Value1>index</Value1>
							<Value2>indexmax</Value2>
							<GotoStep>END</GotoStep>
						</GreaterOrEqual>
					</Compare>
				</TestStep>
				<TestStep>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>CHECK</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="END">
					<Compare>
						<Greater>
							<Value1>errcount</Value1>
							<Value2>0</Value2>
							<Return Id="4">Test case finished with warnings.</Return>
						</Greater>
					</Compare>
				</TestStep>
				<TestStep>
					<WriteLine Id="5" Level="Success" Param0="elementName">ESI {0} not used. Test case passed.</WriteLine>
				</TestStep>
			</TestCase>
			<TestCase Name="Device:Profile:Dictionary:Object:Flags:Transition" CaseId="24">
				<?MAX_OUTPUT_ID 7?>
				<Comment>The ESI element Device:Profile:Dictionary:Object:Flags:Transition is obsolete.</Comment>
				<Description>
					<Purpose>The ESI element Device:Profile:Dictionary:Object:Flags:Transition is obsolete and shall not be used. </Purpose>
					<PreCondition>ESI file available.</PreCondition>
					<Action>Scan the DuT's ESI for Device:Profile:Dictionary:Object:Flags:Transition</Action>
					<PostCondition>Warning if element is used.</PostCondition>
					<References>
						<Reference Specification="ETG.2000" Chapter=""></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="START">
					<SetVariable Target="elementName">element Device:Profile[a]:Dictionary:Objects:Object[b]:Flags:Transition</SetVariable>
					<WriteLine Id="0" Level="Output" Param0="elementName">Scan ESI for {0}</WriteLine>
				</TestStep>
				<TestStep Name="INIT">
					<SetVariable Target="errcount">0</SetVariable>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Profile.Count</Value1>
							<Value2>0</Value2>
							<SkipCase Id="1">Case skipped because of empty element: Device:Profile</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Dictionary</Value1>
							<Value2>false</Value2>
							<SkipCase Id="2">Case skipped because of empty element: Device:Profile:Dictionary</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<SetVariable Target="index">0</SetVariable>
				</TestStep>
				<TestStep>
					<SetVariable Target="indexmax">DeviceDescr.Profile.Count</SetVariable>
					<WriteLine Id="3" Level="Verbose" Param0="indexmax">{0} Profiles found</WriteLine>
				</TestStep>
				<TestStep Name="CHECK">
					<SetVariable Target="index2">0</SetVariable>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Profile[index].Dictionary</Value1>
							<Value2>null</Value2>
							<GotoStep>NEXT</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Profile[index].Dictionary.Objects.Count</Value1>
							<Value2>0</Value2>
							<GotoStep>NEXT</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<SetVariable Target="index2max">DeviceDescr.Profile[index].Dictionary.Objects.Count</SetVariable>
					<WriteLine Id="4" Level="Verbose" Param0="index" Param1="index2max">{1} Objects in Profile {0} found</WriteLine>
				</TestStep>
				<TestStep Name="CHECK2">
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Profile[index].Dictionary.Object[index2].Flags</Value1>
							<Value2>false</Value2>
							<GotoStep>NEXT2</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Profile[index].Dictionary.Object[index2].Flags.Transition</Value1>
							<Value2>null</Value2>
							<GotoStep>NEXT2</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="WARNING">
					<SetVariable Target="errcount">errcount+1</SetVariable>
					<WriteLine Id="5" Level="Warning" Param0="elementName" Param1="index" Param2="index2">ESI {0} (a={1}, b={2}) is obsolete and shall not be used.</WriteLine>
				</TestStep>
				<TestStep Name="NEXT2">
					<SetVariable Target="index2">index2+1</SetVariable>
				</TestStep>
				<TestStep>
					<Compare>
						<GreaterOrEqual>
							<Value1>index2</Value1>
							<Value2>index2max</Value2>
							<GotoStep>NEXT</GotoStep>
						</GreaterOrEqual>
					</Compare>
				</TestStep>
				<TestStep>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>CHECK2</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="NEXT">
					<SetVariable Target="index">index+1</SetVariable>
				</TestStep>
				<TestStep>
					<Compare>
						<GreaterOrEqual>
							<Value1>index</Value1>
							<Value2>indexmax</Value2>
							<GotoStep>END</GotoStep>
						</GreaterOrEqual>
					</Compare>
				</TestStep>
				<TestStep>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>CHECK</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="END">
					<Compare>
						<Greater>
							<Value1>errcount</Value1>
							<Value2>0</Value2>
							<Return Id="6">Test case finished with warnings.</Return>
						</Greater>
					</Compare>
				</TestStep>
				<TestStep>
					<WriteLine Id="7" Level="Success" Param0="elementName">ESI {0} not used. Test case passed.</WriteLine>
				</TestStep>
			</TestCase>
			<TestCase Name="Device:Profile:Dictionary:DataType:SubItem:DefaultString" CaseId="25">
				<?MAX_OUTPUT_ID 8?>
				<Comment>The ESI element Device:Profile:Dictionary:DataType:SubItem:DefaultString is obsolete.</Comment>
				<Description>
					<Purpose>The ESI element Device:Profile:Dictionary:DataType:SubItem:DefaultString is obsolete and shall not be used. </Purpose>
					<PreCondition>ESI file available.</PreCondition>
					<Action>Scan the DuT's ESI for Device:Profile:Dictionary:DataType:SubItem:DefaultString</Action>
					<PostCondition>Warning if element is used.</PostCondition>
					<References>
						<Reference Specification="ETG.2000" Chapter=""></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="START">
					<SetVariable Target="elementName">element Device:Profile[a]:Dictionary:DataTypes:DataType[b]:SubItem[c]:DefaultString</SetVariable>
					<WriteLine Id="0" Level="Output" Param0="elementName">Scan ESI for {0}</WriteLine>
				</TestStep>
				<TestStep Name="INIT">
					<SetVariable Target="errcount">0</SetVariable>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Profile.Count</Value1>
							<Value2>0</Value2>
							<SkipCase Id="1">Case skipped because of empty element: Device:Profile</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Dictionary</Value1>
							<Value2>false</Value2>
							<SkipCase Id="2">Case skipped because of empty element: Device:Profile:Dictionary</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<SetVariable Target="index">0</SetVariable>
				</TestStep>
				<TestStep>
					<SetVariable Target="indexmax">DeviceDescr.Profile.Count</SetVariable>
					<WriteLine Id="3" Level="Verbose" Param0="indexmax">{0} Profiles found</WriteLine>
				</TestStep>
				<TestStep Name="CHECK">
					<SetVariable Target="index2">0</SetVariable>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Profile[index].Dictionary</Value1>
							<Value2>null</Value2>
							<GotoStep>NEXT</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Profile[index].Dictionary.DataTypes.Count</Value1>
							<Value2>0</Value2>
							<GotoStep>NEXT</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<SetVariable Target="index2max">DeviceDescr.Profile[index].Dictionary.DataTypes.Count</SetVariable>
					<WriteLine Id="4" Level="Verbose" Param0="index" Param1="index2max">{1} DataTypes in Profile {0} found</WriteLine>
				</TestStep>
				<TestStep Name="CHECK2">
					<SetVariable Target="index3">0</SetVariable>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Profile[index].Dictionary.DataType[index2].SubItem.Count</Value1>
							<Value2>0</Value2>
							<GotoStep>NEXT2</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<SetVariable Target="index3max">DeviceDescr.Profile[index].Dictionary.DataType[index2].SubItem.Count</SetVariable>
					<WriteLine Id="5" Level="Verbose" Param0="index" Param1="index2" Param2="index3max">{2} SubItems in DataType {1} of Profile {0} found</WriteLine>
				</TestStep>
				<TestStep Name="CHECK3">
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Profile[index].Dictionary.DataType[index2].SubItem[index3].DefaultString</Value1>
							<Value2>null</Value2>
							<GotoStep>NEXT3</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="WARNING">
					<SetVariable Target="errcount">errcount+1</SetVariable>
					<WriteLine Id="6" Level="Warning" Param0="elementName" Param1="index" Param2="index2" Param3="index3">ESI {0} (a={1}, b={2}, c={3}) is obsolete and shall not be used.</WriteLine>
				</TestStep>
				<TestStep Name="NEXT3">
					<SetVariable Target="index3">index3+1</SetVariable>
				</TestStep>
				<TestStep>
					<Compare>
						<Lower>
							<Value1>index3</Value1>
							<Value2>index3max</Value2>
							<GotoStep>CHECK3</GotoStep>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep Name="NEXT2">
					<SetVariable Target="index2">index2+1</SetVariable>
				</TestStep>
				<TestStep>
					<Compare>
						<Lower>
							<Value1>index2</Value1>
							<Value2>index2max</Value2>
							<GotoStep>CHECK2</GotoStep>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep Name="NEXT">
					<SetVariable Target="index">index+1</SetVariable>
				</TestStep>
				<TestStep>
					<Compare>
						<Lower>
							<Value1>index</Value1>
							<Value2>indexmax</Value2>
							<GotoStep>CHECK</GotoStep>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep Name="END">
					<Compare>
						<Greater>
							<Value1>errcount</Value1>
							<Value2>0</Value2>
							<Return Id="7">Test case finished with warnings.</Return>
						</Greater>
					</Compare>
				</TestStep>
				<TestStep>
					<WriteLine Id="8" Level="Success" Param0="elementName">ESI {0} not used. Test case passed.</WriteLine>
				</TestStep>
			</TestCase>
			<TestCase Name="Device:Profile:Dictionary:DataType:SubItem:DefaultData" CaseId="26">
				<?MAX_OUTPUT_ID 8?>
				<Comment>The ESI element Device:Profile:Dictionary:DataType:SubItem:DefaultData is obsolete.</Comment>
				<Description>
					<Purpose>The ESI element Device:Profile:Dictionary:DataType:SubItem:DefaultData is obsolete and shall not be used. </Purpose>
					<PreCondition>ESI file available.</PreCondition>
					<Action>Scan the DuT's ESI for Device:Profile:Dictionary:DataType:SubItem:DefaultData</Action>
					<PostCondition>Warning if element is used.</PostCondition>
					<References>
						<Reference Specification="ETG.2000" Chapter=""></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="START">
					<SetVariable Target="elementName">element Device:Profile[a]:Dictionary:DataTypes:DataType[b]:SubItem[c]:DefaultData</SetVariable>
					<WriteLine Id="0" Level="Output" Param0="elementName">Scan ESI for {0}</WriteLine>
				</TestStep>
				<TestStep Name="INIT">
					<SetVariable Target="errcount">0</SetVariable>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Profile.Count</Value1>
							<Value2>0</Value2>
							<SkipCase Id="1">Case skipped because of empty element: Device:Profile</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Dictionary</Value1>
							<Value2>false</Value2>
							<SkipCase Id="2">Case skipped because of empty element: Device:Profile:Dictionary</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<SetVariable Target="index">0</SetVariable>
				</TestStep>
				<TestStep>
					<SetVariable Target="indexmax">DeviceDescr.Profile.Count</SetVariable>
					<WriteLine Id="3" Level="Verbose" Param0="indexmax">{0} Profiles found</WriteLine>
				</TestStep>
				<TestStep Name="CHECK">
					<SetVariable Target="index2">0</SetVariable>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Profile[index].Dictionary</Value1>
							<Value2>null</Value2>
							<GotoStep>NEXT</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Profile[index].Dictionary.DataTypes.Count</Value1>
							<Value2>0</Value2>
							<GotoStep>NEXT</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<SetVariable Target="index2max">DeviceDescr.Profile[index].Dictionary.DataTypes.Count</SetVariable>
					<WriteLine Id="4" Level="Verbose" Param0="index" Param1="index2max">{1} DataTypes in Profile {0} found</WriteLine>
				</TestStep>
				<TestStep Name="CHECK2">
					<SetVariable Target="index3">0</SetVariable>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Profile[index].Dictionary.DataType[index2].SubItem.Count</Value1>
							<Value2>0</Value2>
							<GotoStep>NEXT2</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<SetVariable Target="index3max">DeviceDescr.Profile[index].Dictionary.DataType[index2].SubItem.Count</SetVariable>
					<WriteLine Id="5" Level="Verbose" Param0="index" Param1="index2" Param2="index3max">{2} SubItems in DataType {1} of Profile {0} found</WriteLine>
				</TestStep>
				<TestStep Name="CHECK3">
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Profile[index].Dictionary.DataType[index2].SubItem[index3].DefaultData</Value1>
							<Value2>null</Value2>
							<GotoStep>NEXT3</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="WARNING">
					<SetVariable Target="errcount">errcount+1</SetVariable>
					<WriteLine Id="6" Level="Warning" Param0="elementName" Param1="index" Param2="index2" Param3="index3">ESI {0} (a={1}, b={2}, c={3}) is obsolete and shall not be used.</WriteLine>
				</TestStep>
				<TestStep Name="NEXT3">
					<SetVariable Target="index3">index3+1</SetVariable>
				</TestStep>
				<TestStep>
					<Compare>
						<Lower>
							<Value1>index3</Value1>
							<Value2>index3max</Value2>
							<GotoStep>CHECK3</GotoStep>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep Name="NEXT2">
					<SetVariable Target="index2">index2+1</SetVariable>
				</TestStep>
				<TestStep>
					<Compare>
						<Lower>
							<Value1>index2</Value1>
							<Value2>index2max</Value2>
							<GotoStep>CHECK2</GotoStep>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep Name="NEXT">
					<SetVariable Target="index">index+1</SetVariable>
				</TestStep>
				<TestStep>
					<Compare>
						<Lower>
							<Value1>index</Value1>
							<Value2>indexmax</Value2>
							<GotoStep>CHECK</GotoStep>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep Name="END">
					<Compare>
						<Greater>
							<Value1>errcount</Value1>
							<Value2>0</Value2>
							<Return Id="7">Test case finished with warnings.</Return>
						</Greater>
					</Compare>
				</TestStep>
				<TestStep>
					<WriteLine Id="8" Level="Success" Param0="elementName">ESI {0} not used. Test case passed.</WriteLine>
				</TestStep>
			</TestCase>
			<TestCase Name="Device:Profile:Dictionary:DataType:SubItem:MinValue" CaseId="27">
				<?MAX_OUTPUT_ID 8?>
				<Comment>The ESI element Device:Profile:Dictionary:DataType:SubItem:MinValue is obsolete.</Comment>
				<Description>
					<Purpose>The ESI element Device:Profile:Dictionary:DataType:SubItem:MinValue is obsolete and shall not be used. </Purpose>
					<PreCondition>ESI file available.</PreCondition>
					<Action>Scan the DuT's ESI for Device:Profile:Dictionary:DataType:SubItem:MinValue</Action>
					<PostCondition>Warning if element is used.</PostCondition>
					<References>
						<Reference Specification="ETG.2000" Chapter=""></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="START">
					<SetVariable Target="elementName">element Device:Profile[a]:Dictionary:DataTypes:DataType[b]:SubItem[c]:MinValue</SetVariable>
					<WriteLine Id="0" Level="Output" Param0="elementName">Scan ESI for {0}</WriteLine>
				</TestStep>
				<TestStep Name="INIT">
					<SetVariable Target="errcount">0</SetVariable>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Profile.Count</Value1>
							<Value2>0</Value2>
							<SkipCase Id="1">Case skipped because of empty element: Device:Profile</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Dictionary</Value1>
							<Value2>false</Value2>
							<SkipCase Id="2">Case skipped because of empty element: Device:Profile:Dictionary</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<SetVariable Target="index">0</SetVariable>
				</TestStep>
				<TestStep>
					<SetVariable Target="indexmax">DeviceDescr.Profile.Count</SetVariable>
					<WriteLine Id="3" Level="Verbose" Param0="indexmax">{0} Profiles found</WriteLine>
				</TestStep>
				<TestStep Name="CHECK">
					<SetVariable Target="index2">0</SetVariable>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Profile[index].Dictionary</Value1>
							<Value2>null</Value2>
							<GotoStep>NEXT</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Profile[index].Dictionary.DataTypes.Count</Value1>
							<Value2>0</Value2>
							<GotoStep>NEXT</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<SetVariable Target="index2max">DeviceDescr.Profile[index].Dictionary.DataTypes.Count</SetVariable>
					<WriteLine Id="4" Level="Verbose" Param0="index" Param1="index2max">{1} DataTypes in Profile {0} found</WriteLine>
				</TestStep>
				<TestStep Name="CHECK2">
					<SetVariable Target="index3">0</SetVariable>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Profile[index].Dictionary.DataType[index2].SubItem.Count</Value1>
							<Value2>0</Value2>
							<GotoStep>NEXT2</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<SetVariable Target="index3max">DeviceDescr.Profile[index].Dictionary.DataType[index2].SubItem.Count</SetVariable>
					<WriteLine Id="5" Level="Verbose" Param0="index" Param1="index2" Param2="index3max">{2} SubItems in DataType {1} of Profile {0} found</WriteLine>
				</TestStep>
				<TestStep Name="CHECK3">
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Profile[index].Dictionary.DataType[index2].SubItem[index3].MinValue</Value1>
							<Value2>null</Value2>
							<GotoStep>NEXT3</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="WARNING">
					<SetVariable Target="errcount">errcount+1</SetVariable>
					<WriteLine Id="6" Level="Warning" Param0="elementName" Param1="index" Param2="index2" Param3="index3">ESI {0} (a={1}, b={2}, c={3}) is obsolete and shall not be used.</WriteLine>
				</TestStep>
				<TestStep Name="NEXT3">
					<SetVariable Target="index3">index3+1</SetVariable>
				</TestStep>
				<TestStep>
					<Compare>
						<Lower>
							<Value1>index3</Value1>
							<Value2>index3max</Value2>
							<GotoStep>CHECK3</GotoStep>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep Name="NEXT2">
					<SetVariable Target="index2">index2+1</SetVariable>
				</TestStep>
				<TestStep>
					<Compare>
						<Lower>
							<Value1>index2</Value1>
							<Value2>index2max</Value2>
							<GotoStep>CHECK2</GotoStep>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep Name="NEXT">
					<SetVariable Target="index">index+1</SetVariable>
				</TestStep>
				<TestStep>
					<Compare>
						<Lower>
							<Value1>index</Value1>
							<Value2>indexmax</Value2>
							<GotoStep>CHECK</GotoStep>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep Name="END">
					<Compare>
						<Greater>
							<Value1>errcount</Value1>
							<Value2>0</Value2>
							<Return Id="7">Test case finished with warnings.</Return>
						</Greater>
					</Compare>
				</TestStep>
				<TestStep>
					<WriteLine Id="8" Level="Success" Param0="elementName">ESI {0} not used. Test case passed.</WriteLine>
				</TestStep>
			</TestCase>
			<TestCase Name="Device:Profile:Dictionary:DataType:SubItem:MaxValue" CaseId="28">
				<?MAX_OUTPUT_ID 8?>
				<Comment>The ESI element Device:Profile:Dictionary:DataType:SubItem:MaxValue is obsolete.</Comment>
				<Description>
					<Purpose>The ESI element Device:Profile:Dictionary:DataType:SubItem:MaxValue is obsolete and shall not be used. </Purpose>
					<PreCondition>ESI file available.</PreCondition>
					<Action>Scan the DuT's ESI for Device:Profile:Dictionary:DataType:SubItem:MaxValue</Action>
					<PostCondition>Warning if element is used.</PostCondition>
					<References>
						<Reference Specification="ETG.2000" Chapter=""></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="START">
					<SetVariable Target="elementName">element Device:Profile[a]:Dictionary:DataTypes:DataType[b]:SubItem[c]:MaxValue</SetVariable>
					<WriteLine Id="0" Level="Output" Param0="elementName">Scan ESI for {0}</WriteLine>
				</TestStep>
				<TestStep Name="INIT">
					<SetVariable Target="errcount">0</SetVariable>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Profile.Count</Value1>
							<Value2>0</Value2>
							<SkipCase Id="1">Case skipped because of empty element: Device:Profile</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Dictionary</Value1>
							<Value2>false</Value2>
							<SkipCase Id="2">Case skipped because of empty element: Device:Profile:Dictionary</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<SetVariable Target="index">0</SetVariable>
				</TestStep>
				<TestStep>
					<SetVariable Target="indexmax">DeviceDescr.Profile.Count</SetVariable>
					<WriteLine Id="3" Level="Verbose" Param0="indexmax">{0} Profiles found</WriteLine>
				</TestStep>
				<TestStep Name="CHECK">
					<SetVariable Target="index2">0</SetVariable>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Profile[index].Dictionary</Value1>
							<Value2>null</Value2>
							<GotoStep>NEXT</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Profile[index].Dictionary.DataTypes.Count</Value1>
							<Value2>0</Value2>
							<GotoStep>NEXT</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<SetVariable Target="index2max">DeviceDescr.Profile[index].Dictionary.DataTypes.Count</SetVariable>
					<WriteLine Id="4" Level="Verbose" Param0="index" Param1="index2max">{1} DataTypes in Profile {0} found</WriteLine>
				</TestStep>
				<TestStep Name="CHECK2">
					<SetVariable Target="index3">0</SetVariable>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Profile[index].Dictionary.DataType[index2].SubItem.Count</Value1>
							<Value2>0</Value2>
							<GotoStep>NEXT2</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<SetVariable Target="index3max">DeviceDescr.Profile[index].Dictionary.DataType[index2].SubItem.Count</SetVariable>
					<WriteLine Id="5" Level="Verbose" Param0="index" Param1="index2" Param2="index3max">{2} SubItems in DataType {1} of Profile {0} found</WriteLine>
				</TestStep>
				<TestStep Name="CHECK3">
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Profile[index].Dictionary.DataType[index2].SubItem[index3].MaxValue</Value1>
							<Value2>null</Value2>
							<GotoStep>NEXT3</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="WARNING">
					<SetVariable Target="errcount">errcount+1</SetVariable>
					<WriteLine Id="6" Level="Warning" Param0="elementName" Param1="index" Param2="index2" Param3="index3">ESI {0} (a={1}, b={2}, c={3}) is obsolete and shall not be used.</WriteLine>
				</TestStep>
				<TestStep Name="NEXT3">
					<SetVariable Target="index3">index3+1</SetVariable>
				</TestStep>
				<TestStep>
					<Compare>
						<Lower>
							<Value1>index3</Value1>
							<Value2>index3max</Value2>
							<GotoStep>CHECK3</GotoStep>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep Name="NEXT2">
					<SetVariable Target="index2">index2+1</SetVariable>
				</TestStep>
				<TestStep>
					<Compare>
						<Lower>
							<Value1>index2</Value1>
							<Value2>index2max</Value2>
							<GotoStep>CHECK2</GotoStep>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep Name="NEXT">
					<SetVariable Target="index">index+1</SetVariable>
				</TestStep>
				<TestStep>
					<Compare>
						<Lower>
							<Value1>index</Value1>
							<Value2>indexmax</Value2>
							<GotoStep>CHECK</GotoStep>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep Name="END">
					<Compare>
						<Greater>
							<Value1>errcount</Value1>
							<Value2>0</Value2>
							<Return Id="7">Test case finished with warnings.</Return>
						</Greater>
					</Compare>
				</TestStep>
				<TestStep>
					<WriteLine Id="8" Level="Success" Param0="elementName">ESI {0} not used. Test case passed.</WriteLine>
				</TestStep>
			</TestCase>
			<TestCase Name="Device:Profile:Dictionary:DataType:SubItem:DefaultValue" CaseId="29">
				<?MAX_OUTPUT_ID 8?>
				<Comment>The ESI element Device:Profile:Dictionary:DataType:SubItem:DefaultValue is obsolete.</Comment>
				<Description>
					<Purpose>The ESI element Device:Profile:Dictionary:DataType:SubItem:DefaultValue is obsolete and shall not be used. </Purpose>
					<PreCondition>ESI file available.</PreCondition>
					<Action>Scan the DuT's ESI for Device:Profile:Dictionary:DataType:SubItem:DefaultValue</Action>
					<PostCondition>Warning if element is used.</PostCondition>
					<References>
						<Reference Specification="ETG.2000" Chapter=""></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="START">
					<SetVariable Target="elementName">element Device:Profile[a]:Dictionary:DataTypes:DataType[b]:SubItem[c]:DefaultValue</SetVariable>
					<WriteLine Id="0" Level="Output" Param0="elementName">Scan ESI for {0}</WriteLine>
				</TestStep>
				<TestStep Name="INIT">
					<SetVariable Target="errcount">0</SetVariable>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Profile.Count</Value1>
							<Value2>0</Value2>
							<SkipCase Id="1">Case skipped because of empty element: Device:Profile</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Dictionary</Value1>
							<Value2>false</Value2>
							<SkipCase Id="2">Case skipped because of empty element: Device:Profile:Dictionary</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<SetVariable Target="index">0</SetVariable>
				</TestStep>
				<TestStep>
					<SetVariable Target="indexmax">DeviceDescr.Profile.Count</SetVariable>
					<WriteLine Id="3" Level="Verbose" Param0="indexmax">{0} Profiles found</WriteLine>
				</TestStep>
				<TestStep Name="CHECK">
					<SetVariable Target="index2">0</SetVariable>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Profile[index].Dictionary</Value1>
							<Value2>null</Value2>
							<GotoStep>NEXT</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Profile[index].Dictionary.DataTypes.Count</Value1>
							<Value2>0</Value2>
							<GotoStep>NEXT</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<SetVariable Target="index2max">DeviceDescr.Profile[index].Dictionary.DataTypes.Count</SetVariable>
					<WriteLine Id="4" Level="Verbose" Param0="index" Param1="index2max">{1} DataTypes in Profile {0} found</WriteLine>
				</TestStep>
				<TestStep Name="CHECK2">
					<SetVariable Target="index3">0</SetVariable>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Profile[index].Dictionary.DataType[index2].SubItem.Count</Value1>
							<Value2>0</Value2>
							<GotoStep>NEXT2</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<SetVariable Target="index3max">DeviceDescr.Profile[index].Dictionary.DataType[index2].SubItem.Count</SetVariable>
					<WriteLine Id="5" Level="Verbose" Param0="index" Param1="index2" Param2="index3max">{2} SubItems in DataType {1} of Profile {0} found</WriteLine>
				</TestStep>
				<TestStep Name="CHECK3">
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Profile[index].Dictionary.DataType[index2].SubItem[index3].DefaultValue</Value1>
							<Value2>null</Value2>
							<GotoStep>NEXT3</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="WARNING">
					<SetVariable Target="errcount">errcount+1</SetVariable>
					<WriteLine Id="6" Level="Warning" Param0="elementName" Param1="index" Param2="index2" Param3="index3">ESI {0} (a={1}, b={2}, c={3}) is obsolete and shall not be used.</WriteLine>
				</TestStep>
				<TestStep Name="NEXT3">
					<SetVariable Target="index3">index3+1</SetVariable>
				</TestStep>
				<TestStep>
					<Compare>
						<Lower>
							<Value1>index3</Value1>
							<Value2>index3max</Value2>
							<GotoStep>CHECK3</GotoStep>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep Name="NEXT2">
					<SetVariable Target="index2">index2+1</SetVariable>
				</TestStep>
				<TestStep>
					<Compare>
						<Lower>
							<Value1>index2</Value1>
							<Value2>index2max</Value2>
							<GotoStep>CHECK2</GotoStep>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep Name="NEXT">
					<SetVariable Target="index">index+1</SetVariable>
				</TestStep>
				<TestStep>
					<Compare>
						<Lower>
							<Value1>index</Value1>
							<Value2>indexmax</Value2>
							<GotoStep>CHECK</GotoStep>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep Name="END">
					<Compare>
						<Greater>
							<Value1>errcount</Value1>
							<Value2>0</Value2>
							<Return Id="7">Test case finished with warnings.</Return>
						</Greater>
					</Compare>
				</TestStep>
				<TestStep>
					<WriteLine Id="8" Level="Success" Param0="elementName">ESI {0} not used. Test case passed.</WriteLine>
				</TestStep>
			</TestCase>
			<TestCase Name="Device:Profile:Dictionary:DataType:SubItem:Xml" CaseId="30">
				<?MAX_OUTPUT_ID 8?>
				<Comment>The ESI element Device:Profile:Dictionary:DataType:SubItem:Xml is obsolete.</Comment>
				<Description>
					<Purpose>The ESI element Device:Profile:Dictionary:DataType:SubItem:Xml is obsolete and shall not be used. </Purpose>
					<PreCondition>ESI file available.</PreCondition>
					<Action>Scan the DuT's ESI for Device:Profile:Dictionary:DataType:SubItem:Xml</Action>
					<PostCondition>Warning if element is used.</PostCondition>
					<References>
						<Reference Specification="ETG.2000" Chapter=""></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="START">
					<SetVariable Target="elementName">element Device:Profile[a]:Dictionary:DataTypes:DataType[b]:SubItem[c]:Xml</SetVariable>
					<WriteLine Id="0" Level="Output" Param0="elementName">Scan ESI for {0}</WriteLine>
				</TestStep>
				<TestStep Name="INIT">
					<SetVariable Target="errcount">0</SetVariable>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Profile.Count</Value1>
							<Value2>0</Value2>
							<SkipCase Id="1">Case skipped because of empty element: Device:Profile</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Dictionary</Value1>
							<Value2>false</Value2>
							<SkipCase Id="2">Case skipped because of empty element: Device:Profile:Dictionary</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<SetVariable Target="index">0</SetVariable>
				</TestStep>
				<TestStep>
					<SetVariable Target="indexmax">DeviceDescr.Profile.Count</SetVariable>
					<WriteLine Id="3" Level="Verbose" Param0="indexmax">{0} Profiles found</WriteLine>
				</TestStep>
				<TestStep Name="CHECK">
					<SetVariable Target="index2">0</SetVariable>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Profile[index].Dictionary</Value1>
							<Value2>null</Value2>
							<GotoStep>NEXT</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Profile[index].Dictionary.DataTypes.Count</Value1>
							<Value2>0</Value2>
							<GotoStep>NEXT</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<SetVariable Target="index2max">DeviceDescr.Profile[index].Dictionary.DataTypes.Count</SetVariable>
					<WriteLine Id="4" Level="Verbose" Param0="index" Param1="index2max">{1} DataTypes in Profile {0} found</WriteLine>
				</TestStep>
				<TestStep Name="CHECK2">
					<SetVariable Target="index3">0</SetVariable>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Profile[index].Dictionary.DataType[index2].SubItem.Count</Value1>
							<Value2>0</Value2>
							<GotoStep>NEXT2</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<SetVariable Target="index3max">DeviceDescr.Profile[index].Dictionary.DataType[index2].SubItem.Count</SetVariable>
					<WriteLine Id="5" Level="Verbose" Param0="index" Param1="index2" Param2="index3max">{2} SubItems in DataType {1} of Profile {0} found</WriteLine>
				</TestStep>
				<TestStep Name="CHECK3">
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Profile[index].Dictionary.DataType[index2].SubItem[index3].Xml</Value1>
							<Value2>null</Value2>
							<GotoStep>NEXT3</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="WARNING">
					<SetVariable Target="errcount">errcount+1</SetVariable>
					<WriteLine Id="6" Level="Warning" Param0="elementName" Param1="index" Param2="index2" Param3="index3">ESI {0} (a={1}, b={2}, c={3}) is obsolete and shall not be used.</WriteLine>
				</TestStep>
				<TestStep Name="NEXT3">
					<SetVariable Target="index3">index3+1</SetVariable>
				</TestStep>
				<TestStep>
					<Compare>
						<Lower>
							<Value1>index3</Value1>
							<Value2>index3max</Value2>
							<GotoStep>CHECK3</GotoStep>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep Name="NEXT2">
					<SetVariable Target="index2">index2+1</SetVariable>
				</TestStep>
				<TestStep>
					<Compare>
						<Lower>
							<Value1>index2</Value1>
							<Value2>index2max</Value2>
							<GotoStep>CHECK2</GotoStep>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep Name="NEXT">
					<SetVariable Target="index">index+1</SetVariable>
				</TestStep>
				<TestStep>
					<Compare>
						<Lower>
							<Value1>index</Value1>
							<Value2>indexmax</Value2>
							<GotoStep>CHECK</GotoStep>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep Name="END">
					<Compare>
						<Greater>
							<Value1>errcount</Value1>
							<Value2>0</Value2>
							<Return Id="7">Test case finished with warnings.</Return>
						</Greater>
					</Compare>
				</TestStep>
				<TestStep>
					<WriteLine Id="8" Level="Success" Param0="elementName">ESI {0} not used. Test case passed.</WriteLine>
				</TestStep>
			</TestCase>
		</TestGroup>
		<TestGroup GroupId="6" Name="Reserved ESI Elements ">
			<Comment>ESI elements which are marked as reserved for future use in the ETG.2000 ESI specification shall not be used.</Comment>
			<TestCase Name="Device:Type@DownloadModuleList" CaseId="1">
				<?MAX_OUTPUT_ID 4?>
				<Comment>The ESI attribute Device:Type@DownloadModuleList is reserved for future use.</Comment>
				<Description>
					<Purpose>The ESI attribute Device:Type@DownloadModuleList is reserved for future use and shall not be used.</Purpose>
					<PreCondition>ESI file available.</PreCondition>
					<Action>Scan the DuT's ESI for Device:Type@DownloadModuleList</Action>
					<PostCondition>Warning if attribute is used.</PostCondition>
					<References>
						<Reference Specification="ETG.2000" Chapter=""></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="START">
					<SetVariable Target="elementName">attribute Device:Type@DownloadModuleList</SetVariable>
					<WriteLine Id="0" Level="Output" Param0="elementName">Scan ESI for {0}</WriteLine>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Type</Value1>
							<Value2>null</Value2>
							<SkipCase Id="1">Case skipped because of empty element: Device:Type</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CHECK">
					<Compare>
						<NotEqual>
							<Value1>DeviceDescr.Type.DownloadModuleList</Value1>
							<Value2>null</Value2>
							<RaiseWarning Id="2" Param0="elementName">ESI {0} is reserved for future use and shall not be used.</RaiseWarning>
						</NotEqual>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>DeviceDescr.Type.DownloadModuleList</Value1>
							<Value2>null</Value2>
							<Return Id="3"></Return>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="SUCCESS">
					<WriteLine Id="4" Level="Success" Param0="elementName">ESI {0} not used. Test case passed.</WriteLine>
				</TestStep>
			</TestCase>
			<TestCase Name="Device:AlternativeType" CaseId="2">
				<?MAX_OUTPUT_ID 3?>
				<Comment>The ESI element Device:AlternativeType is reserved for future use.</Comment>
				<Description>
					<Purpose>The ESI element Device:AlternativeType is reserved for future use and shall not be used.</Purpose>
					<PreCondition>ESI file available.</PreCondition>
					<Action>Scan the DuT's ESI for Device:AlternativeType</Action>
					<PostCondition>Warning if element is used.</PostCondition>
					<References>
						<Reference Specification="ETG.2000" Chapter=""></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="START">
					<SetVariable Target="elementName">element Device:AlternativeType</SetVariable>
					<WriteLine Id="0" Level="Output" Param0="elementName">Scan ESI for {0}</WriteLine>
				</TestStep>
				<TestStep Name="CHECK">
					<Compare>
						<Equal>
							<Value1>DeviceDescr.AlternativeType.Count</Value1>
							<Value2>0</Value2>
							<GotoStep>END</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="WARNING">
					<WriteLine Id="1" Level="Warning" Param0="elementName" Param1="errcount">ESI {0} is reserved for future use and shall not be used.</WriteLine>
				</TestStep>
				<TestStep>
					<Compare>
						<Equal>
							<Value1>1</Value1>
							<Value2>1</Value2>
							<Return Id="2"></Return>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="END">
					<WriteLine Id="3" Level="Success" Param0="elementName">ESI {0} not used. Test case passed.</WriteLine>
				</TestStep>
			</TestCase>
			<TestCase Name="Device:Su@DependOnInputState" CaseId="3">
				<?MAX_OUTPUT_ID 4?>
				<Comment>The ESI attribute Device:Su@DependOnInputState is reserved for future use.</Comment>
				<Description>
					<Purpose>The ESI attribute Device:Su@DependOnInputState is reserved for future use and shall not be used.</Purpose>
					<PreCondition>ESI file available.</PreCondition>
					<Action>Scan the DuT's ESI for Device:Su@DependOnInputState</Action>
					<PostCondition>Warning if attribute is used.</PostCondition>
					<References>
						<Reference Specification="ETG.2000" Chapter=""></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="START">
					<SetVariable Target="elementName">attribute Device:Su[a]@DependOnInputState</SetVariable>
					<WriteLine Id="0" Level="Output" Param0="elementName">Scan ESI for {0}</WriteLine>
				</TestStep>
				<TestStep Name="INIT">
					<SetVariable Target="errcount">0</SetVariable>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Su.Count</Value1>
							<Value2>0</Value2>
							<SkipCase Id="1">Case skipped because of empty element: Device:Su</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<SetVariable Target="indexmax">DeviceDescr.Su.Count</SetVariable>
				</TestStep>
				<TestStep>
					<SetVariable Target="index">0</SetVariable>
				</TestStep>
				<TestStep Name="CHECK">
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Su[index].DependOnInputState</Value1>
							<Value2>null</Value2>
							<GotoStep>NEXT</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="WARNING">
					<SetVariable Target="errcount">errcount+1</SetVariable>
					<WriteLine Id="2" Level="Warning" Param0="elementName" Param1="index">ESI {0} (a={1}) is reserved for future use and shall not be used.</WriteLine>
				</TestStep>
				<TestStep Name="NEXT">
					<SetVariable Target="index">index+1</SetVariable>
				</TestStep>
				<TestStep>
					<Compare>
						<GreaterOrEqual>
							<Value1>index</Value1>
							<Value2>indexmax</Value2>
							<GotoStep>END</GotoStep>
						</GreaterOrEqual>
					</Compare>
				</TestStep>
				<TestStep>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>CHECK</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="END">
					<Compare>
						<Greater>
							<Value1>errcount</Value1>
							<Value2>0</Value2>
							<Return Id="3">Test case finished with warnings.</Return>
						</Greater>
					</Compare>
				</TestStep>
				<TestStep>
					<WriteLine Id="4" Level="Success" Param0="elementName">ESI {0} not used. Test case passed.</WriteLine>
				</TestStep>
			</TestCase>
			<TestCase Name="Device:Mailbox@RealTimeMode" CaseId="4">
				<?MAX_OUTPUT_ID 4?>
				<Comment>The ESI attribute Device:Mailbox@RealTimeMode is reserved for future use.</Comment>
				<Description>
					<Purpose>The ESI attribute Device:Mailbox@RealTimeMode is reserved for future use and shall not be used.</Purpose>
					<PreCondition>ESI file available.</PreCondition>
					<Action>Scan the DuT's ESI for Device:Mailbox@RealTimeMode</Action>
					<PostCondition>Warning if attribute is used.</PostCondition>
					<References>
						<Reference Specification="ETG.2000" Chapter=""></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="START">
					<SetVariable Target="elementName">attribute Device:Mailbox@RealTimeMode</SetVariable>
					<WriteLine Id="0" Level="Output" Param0="elementName">Scan ESI for {0}</WriteLine>
				</TestStep>
				<TestStep Name="CHECK">
					<Compare>
						<NotEqual>
							<Value1>DeviceDescr.Mailbox</Value1>
							<Value2>true</Value2>
							<SkipCase Id="1">Case skipped because of empty element: Device:Mailbox</SkipCase>
						</NotEqual>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>DeviceDescr.Mailbox.RealTimeMode</Value1>
							<Value2>null</Value2>
							<RaiseWarning Id="2" Param0="elementName">ESI {0} is reserved for future use and shall not be used.</RaiseWarning>
						</NotEqual>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>DeviceDescr.Mailbox.RealTimeMode</Value1>
							<Value2>null</Value2>
							<Return Id="3"></Return>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="SUCCESS">
					<WriteLine Id="4" Level="Success" Param0="elementName">ESI {0} not used. Test case passed.</WriteLine>
				</TestStep>
			</TestCase>
			<TestCase Name="Device:Dc:OpMode:ShiftTimeSync1:Factor" CaseId="5">
				<?MAX_OUTPUT_ID 5?>
				<Comment>The ESI element Device:Dc:OpMode:ShiftTimeSync1:Factor is reserved for future use.</Comment>
				<Description>
					<Purpose>The ESI element Device:Dc:OpMode:ShiftTimeSync1:Factor is reserved for future use and shall not be used.</Purpose>
					<PreCondition>ESI file available.</PreCondition>
					<Action>Scan the DuT's ESI for Device:Dc:OpMode:ShiftTimeSync1:Factor</Action>
					<PostCondition>Warning if element is used.</PostCondition>
					<References>
						<Reference Specification="ETG.2000" Chapter=""></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="START">
					<SetVariable Target="elementName">element Device:Dc:OpMode[a]:ShiftTimeSync1:Factor</SetVariable>
					<WriteLine Id="0" Level="Output" Param0="elementName">Scan ESI for {0}</WriteLine>
				</TestStep>
				<TestStep Name="INIT">
					<SetVariable Target="errcount">0</SetVariable>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.DC</Value1>
							<Value2>false</Value2>
							<SkipCase Id="1">Case skipped because of empty element: Device:Dc</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.DC.OpMode.Count</Value1>
							<Value2>0</Value2>
							<SkipCase Id="2">Case skipped because of empty element: Device:Dc:OpMode</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<SetVariable Target="indexmax">DeviceDescr.DC.OpMode.Count</SetVariable>
				</TestStep>
				<TestStep>
					<SetVariable Target="index">0</SetVariable>
				</TestStep>
				<TestStep Name="CHECK">
					<Compare>
						<NotEqual>
							<Value1>DeviceDescr.DC.OpMode[index].ShiftTimeSync1</Value1>
							<Value2>0</Value2>
							<GotoStep>NEXT</GotoStep>
						</NotEqual>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>DeviceDescr.DC.OpMode[index].ShiftTimeSync1.Factor</Value1>
							<Value2>null</Value2>
							<GotoStep>WARNING</GotoStep>
						</NotEqual>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>1</Value1>
							<Value2>0</Value2>
							<GotoStep>NEXT</GotoStep>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="WARNING">
					<SetVariable Target="errcount">errcount+1</SetVariable>
					<WriteLine Id="3" Level="Warning" Param0="elementName" Param1="index">ESI {0} (a={1}) is reserved for future use and shall not be used.</WriteLine>
				</TestStep>
				<TestStep Name="NEXT">
					<SetVariable Target="index">index+1</SetVariable>
				</TestStep>
				<TestStep>
					<Compare>
						<GreaterOrEqual>
							<Value1>index</Value1>
							<Value2>indexmax</Value2>
							<GotoStep>END</GotoStep>
						</GreaterOrEqual>
					</Compare>
				</TestStep>
				<TestStep>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>CHECK</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="END">
					<Compare>
						<Greater>
							<Value1>errcount</Value1>
							<Value2>0</Value2>
							<Return Id="4">Test case finished with warnings.</Return>
						</Greater>
					</Compare>
				</TestStep>
				<TestStep>
					<WriteLine Id="5" Level="Success" Param0="elementName">ESI {0} not used. Test case passed.</WriteLine>
				</TestStep>
			</TestCase>
			<TestCase Name="Device:Profile:Dictionary:DataType:SubItem:DisplayName" CaseId="6">
				<?MAX_OUTPUT_ID 8?>
				<Comment>The ESI element Device:Profile:Dictionary:DataType:SubItem:DisplayName is reserved for future use.</Comment>
				<Description>
					<Purpose>The ESI element Device:Profile:Dictionary:DataType:SubItem:DisplayName is reserved for future use and shall not be used.</Purpose>
					<PreCondition>ESI file available.</PreCondition>
					<Action>Scan the DuT's ESI for Device:Profile:Dictionary:DataType:SubItem:DisplayName</Action>
					<PostCondition>Warning if element is used.</PostCondition>
					<References>
						<Reference Specification="ETG.2000" Chapter=""></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="START">
					<SetVariable Target="elementName">element Device:Profile[a]:Dictionary:DataTypes:DataType[b]:SubItem[c]:DisplayName</SetVariable>
					<WriteLine Id="0" Level="Output" Param0="elementName">Scan ESI for {0}</WriteLine>
				</TestStep>
				<TestStep Name="INIT">
					<SetVariable Target="errcount">0</SetVariable>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Profile.Count</Value1>
							<Value2>0</Value2>
							<SkipCase Id="1">Case skipped because of empty element: Device:Profile</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Dictionary</Value1>
							<Value2>false</Value2>
							<SkipCase Id="2">Case skipped because of empty element: Device:Profile:Dictionary</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<SetVariable Target="index">0</SetVariable>
				</TestStep>
				<TestStep>
					<SetVariable Target="indexmax">DeviceDescr.Profile.Count</SetVariable>
					<WriteLine Id="3" Level="Verbose" Param0="indexmax">{0} Profiles found</WriteLine>
				</TestStep>
				<TestStep Name="CHECK">
					<SetVariable Target="index2">0</SetVariable>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Profile[index].Dictionary</Value1>
							<Value2>null</Value2>
							<GotoStep>NEXT</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Profile[index].Dictionary.DataTypes.Count</Value1>
							<Value2>0</Value2>
							<GotoStep>NEXT</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<SetVariable Target="index2max">DeviceDescr.Profile[index].Dictionary.DataTypes.Count</SetVariable>
					<WriteLine Id="4" Level="Verbose" Param0="index" Param1="index2max">{1} DataTypes in Profile {0} found</WriteLine>
				</TestStep>
				<TestStep Name="CHECK2">
					<SetVariable Target="index3">0</SetVariable>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Profile[index].Dictionary.DataType[index2].SubItem.Count</Value1>
							<Value2>0</Value2>
							<GotoStep>NEXT2</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<SetVariable Target="index3max">DeviceDescr.Profile[index].Dictionary.DataType[index2].SubItem.Count</SetVariable>
					<WriteLine Id="5" Level="Verbose" Param0="index" Param1="index2" Param2="index3max">{2} SubItems in DataType {1} of Profile {0} found</WriteLine>
				</TestStep>
				<TestStep Name="CHECK3">
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Profile[index].Dictionary.DataType[index2].SubItem[index3].DisplayName.Count</Value1>
							<Value2>0</Value2>
							<GotoStep>NEXT3</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="WARNING">
					<SetVariable Target="errcount">errcount+1</SetVariable>
					<WriteLine Id="6" Level="Warning" Param0="elementName" Param1="index" Param2="index2" Param3="index3">ESI {0} (a={1}, b={2}, c={3}) is reserved for future use and shall not be used.</WriteLine>
				</TestStep>
				<TestStep Name="NEXT3">
					<SetVariable Target="index3">index3+1</SetVariable>
				</TestStep>
				<TestStep>
					<Compare>
						<Lower>
							<Value1>index3</Value1>
							<Value2>index3max</Value2>
							<GotoStep>CHECK3</GotoStep>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep Name="NEXT2">
					<SetVariable Target="index2">index2+1</SetVariable>
				</TestStep>
				<TestStep>
					<Compare>
						<Lower>
							<Value1>index2</Value1>
							<Value2>index2max</Value2>
							<GotoStep>CHECK2</GotoStep>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep Name="NEXT">
					<SetVariable Target="index">index+1</SetVariable>
				</TestStep>
				<TestStep>
					<Compare>
						<Lower>
							<Value1>index</Value1>
							<Value2>indexmax</Value2>
							<GotoStep>CHECK</GotoStep>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep Name="END">
					<Compare>
						<Greater>
							<Value1>errcount</Value1>
							<Value2>0</Value2>
							<Return Id="7">Test case finished with warnings.</Return>
						</Greater>
					</Compare>
				</TestStep>
				<TestStep>
					<WriteLine Id="8" Level="Success" Param0="elementName">ESI {0} not used. Test case passed.</WriteLine>
				</TestStep>
			</TestCase>
			<TestCase Name="Device:Profile:Dictionary:DataTypes:DataType:Index" CaseId="7">
				<?MAX_OUTPUT_ID 2?>
				<Comment>The ESI element 'Device.Profile.Dictionary.DataTypes.DataType.Index' is reserved for future use.</Comment>
				<Description>
					<Purpose>The ESI element 'Device.Profile.Dictionary.DataTypes.DataType.Index' is reserved for future use and shall not be used.</Purpose>
					<PreCondition>ESI file available.</PreCondition>
					<Action>Scan the DuT's ESI for Device.Profile.Dictionary.DataTypes.DataType.Index</Action>
					<PostCondition>Warning if attribute is used.</PostCondition>
					<References>
						<Reference Specification="ETG.2000" Chapter=""></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="INIT_VARIABLES">
					<CallTestFunction Name="InitGlobalVariablesForDataTypeTest"></CallTestFunction>
				</TestStep>
				<TestStep Name="INIT_LOOP_COUNTER">
					<!--"DataType.Index.LoopCounter" = 1-->
					<SetVariable Target="DataType.Index.LoopCounter">1</SetVariable>
				</TestStep>
				<TestStep Name="LOOP_START">
					<SetVariable Target="XPathTmp" Param0="XPathDt" Param1="DataType.Index.LoopCounter">{0}[{1}]/Index</SetVariable>
				</TestStep>
				<TestStep Name="START">
					<GetXmlValue ReturnValue="strXmlValue" Markup="true" FileName="XmlFile">
						<XPath Param0="XPathTmp">{0}</XPath>
					</GetXmlValue>
				</TestStep>
				<TestStep Name="CHECK">
					<Compare>
						<NotEqual>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<RaiseWarning Id="0">ESI 'Device.Profile.Dictionary.DataTypes.DataType.Index' is reserved for future use and shall not be used.</RaiseWarning>
						</NotEqual>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<Return Id="1"></Return>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="LOOP_END">
					<SetVariable Target="DataType.Index.LoopCounter">DataType.Index.LoopCounter + 1</SetVariable>
					<Compare>
						<LowerOrEqual>
							<Value1>DataType.Index.LoopCounter</Value1>
							<Value2>NumberOfElements</Value2>
							<GotoStep>LOOP_START</GotoStep>
						</LowerOrEqual>
					</Compare>
				</TestStep>
				<TestStep Name="SUCCESS">
					<WriteLine Id="2" Level="Success">ESI 'Device.Profile.Dictionary.DataTypes.DataType.Index' not used. Test case passed.</WriteLine>
				</TestStep>
			</TestCase>
			<TestCase Name="Device:InfoType:DeviceFeature" CaseId="8">
				<?MAX_OUTPUT_ID 3?>
				<Comment>The ESI attribute 'Device.InfoType.DeviceFeature' is reserved for future use.</Comment>
				<Description>
					<Purpose>The ESI attribute 'Device.InfoType.DeviceFeature' is reserved for future use and shall not be used.</Purpose>
					<PreCondition>ESI file available.</PreCondition>
					<Action>Scan the DuT's ESI for 'Device.InfoType.DeviceFeature'</Action>
					<PostCondition>Warning if attribute is used.</PostCondition>
					<References>
						<Reference Specification="ETG.2000" Chapter=""></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="CHECK_ESI_AVAILABLE">
					<Compare>
						<Equal>
							<Value1>DeviceDescr.FileName</Value1>
							<Value2>null</Value2>
							<SkipCase Id="0">No ESI assigned to the DuT</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="START">
					<GetXmlValue ReturnValue="strXmlValue" Markup="true" FileName="EmptyString">
						<XPath>Info/DeviceFeature</XPath>
					</GetXmlValue>
				</TestStep>
				<TestStep Name="CHECK">
					<Compare>
						<NotEqual>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<RaiseWarning Id="1">ESI 'Device.InfoType.DeviceFeature' is reserved for future use and shall not be used.</RaiseWarning>
						</NotEqual>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<Return Id="2"></Return>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="SUCCESS">
					<WriteLine Id="3" Level="Success">ESI 'Device.InfoType.DeviceFeature' not used. Test case passed.</WriteLine>
				</TestStep>
			</TestCase>
		</TestGroup>
		<TestGroup GroupId="7" Name="RxPdo Tests">
			<Comment>Check the correct usage and values of the RxPDO elements</Comment>
			<TestCase Name="Check Attributes" CaseId="1">
				<?MAX_OUTPUT_ID 18?>
				<Description>
					<Purpose>Correct usage of the RxPdo attributes</Purpose>
					<PreCondition>The device description contains at least one RxPDO element.</PreCondition>
					<Action>1. @Su
2. @Fixed
3. @OSFac,@OSMin,@OSMax,@OSIndexInc</Action>
					<PostCondition>1. if @Su defined a matching FMMU shall be referenced
2. if @Fixed is true at least one entry should be defined
3. if defined @OSxxx shall be greater/equal 0
   and @OSMin less/equal @OSFac greater/equal @OSMax</PostCondition>
					<References>
						<Reference Specification="ETG.2000"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep>
					<!--Check if RxPDOs are defined-->
					<Compare>
						<Equal>
							<Value1>DeviceDescr.RxPdo.Count</Value1>
							<Value2>0</Value2>
							<SkipCase Id="0">Test skipped no RxPdo defined.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<!--Init Loop CounterVariable-->
					<SetVariable Target="CheckAttributes.LoopCounter">0</SetVariable>
				</TestStep>
				<TestStep>
					<!--Init Result Variable-->
					<SetVariable Target="result">true</SetVariable>
				</TestStep>
				<TestStep Name="LOOPSTART">
					<!--Dump loop start info-->
					<WriteLine Id="1" Level="Output" Param0="CheckAttributes.LoopCounter" Param1="DeviceDescr.RxPdo[CheckAttributes.LoopCounter].Index">Check RxPdo[{0}] : 0x{1:x4} attibutes</WriteLine>
				</TestStep>
				<TestStep>
					<!--Check if RxPdo@Su is defined-->
					<Description Id="2" Level="Output">Check @Su attribute.</Description>
					<!--Skip Su test if Su is not defined-->
					<Compare>
						<Equal>
							<Value1>DeviceDescr.RxPdo[CheckAttributes.LoopCounter].Su</Value1>
							<Value2>null</Value2>
							<WriteLine Id="3" Level="Verbose" Param0="CheckAttributes.LoopCounter">RxPdo[{0}].Su not defined.</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.RxPdo[CheckAttributes.LoopCounter].Su</Value1>
							<Value2>null</Value2>
							<GotoStep>TEST_OS_INDEXINC</GotoStep>
						</Equal>
					</Compare>
					<!--Skip Su test if Sm is not defined-->
					<Compare>
						<Equal>
							<Value1>DeviceDescr.RxPdo[CheckAttributes.LoopCounter].Sm</Value1>
							<Value2>null</Value2>
							<WriteLine Id="4" Level="Verbose" Param0="CheckAttributes.LoopCounter">Skip Su test because default Sm not defined (RxPdo[{0}].Sm not defined).</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.RxPdo[CheckAttributes.LoopCounter].Sm</Value1>
							<Value2>null</Value2>
							<GotoStep>TEST_OS_INDEXINC</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<WriteLine Id="5" Level="Output" Param0="CheckAttributes.LoopCounter" Param1="DeviceDescr.RxPdo[CheckAttributes.LoopCounter].Su">Check if RxPdo[{0}].Su ({1}) reference a valid Fmmu.</WriteLine>
				</TestStep>
				<TestStep>
					<!--Get Referenced Fmmu-->
					<CallTestFunction Name="GetFmmuBySu">
						<Parameter>DeviceDescr.RxPdo[CheckAttributes.LoopCounter].Su</Parameter>
						<Parameter>Outputs</Parameter>
						<OutParameter>i32TmpIndex</OutParameter>
					</CallTestFunction>
				</TestStep>
				<TestStep>
					<!--Check if FMMU exists-->
					<Compare>
						<Lower>
							<Value1>i32TmpIndex</Value1>
							<Value2>0</Value2>
							<WriteLine Id="6" Level="Error" Param0="CheckAttributes.LoopCounter" Param1="DeviceDescr.RxPdo[CheckAttributes.LoopCounter].Su">RxPdo[{0}].Su ({1}) doesn't reference an existing/matching Fmmu.</WriteLine>
						</Lower>
					</Compare>
					<Compare>
						<Lower>
							<Value1>i32TmpIndex</Value1>
							<Value2>0</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Lower>
					</Compare>
					<Compare>
						<Lower>
							<Value1>i32TmpIndex</Value1>
							<Value2>0</Value2>
							<GotoStep>TEST_OS_INDEXINC</GotoStep>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_OS_INDEXINC">
					<!--Check RxPdo@OSIndexInc-->
					<Description Id="7" Level="Output">Check @OSxxxx attributes.</Description>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.RxPdo[CheckAttributes.LoopCounter].OSIndexInc</Value1>
							<Value2>null</Value2>
							<GotoStep>TEST_OS_MIN</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Lower>
							<Value1>DeviceDescr.RxPdo[CheckAttributes.LoopCounter].OSIndexInc</Value1>
							<Value2>0</Value2>
							<WriteLine Id="8" Level="Error" Param0="CheckAttributes.LoopCounter" Param1="DeviceDescr.RxPdo[CheckAttributes.LoopCounter].OSIndexInc">RxPdo[{0}]@OSIndexInc shall be &gt;= 0 (current value : {1})</WriteLine>
						</Lower>
					</Compare>
					<Compare>
						<Lower>
							<Value1>DeviceDescr.RxPdo[CheckAttributes.LoopCounter].OSIndexInc</Value1>
							<Value2>0</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_OS_MIN">
					<!--Check RxPdo@OSMin-->
					<Compare>
						<Equal>
							<Value1>DeviceDescr.RxPdo[CheckAttributes.LoopCounter].OSMin</Value1>
							<Value2>null</Value2>
							<GotoStep>TEST_OS_FAC</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Lower>
							<Value1>DeviceDescr.RxPdo[CheckAttributes.LoopCounter].OSMin</Value1>
							<Value2>0</Value2>
							<WriteLine Id="9" Level="Error" Param0="CheckAttributes.LoopCounter" Param1="DeviceDescr.RxPdo[CheckAttributes.LoopCounter].OSMin">RxPdo[{0}]@OSMin shall be &gt;= 0 (current value : {1})</WriteLine>
						</Lower>
					</Compare>
					<Compare>
						<Lower>
							<Value1>DeviceDescr.RxPdo[CheckAttributes.LoopCounter].OSMin</Value1>
							<Value2>0</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Lower>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.RxPdo[CheckAttributes.LoopCounter].OSFac</Value1>
							<Value2>null</Value2>
							<GotoStep>TEST_OS_FAC</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Lower>
							<Value1>DeviceDescr.RxPdo[CheckAttributes.LoopCounter].OSFac</Value1>
							<Value2>DeviceDescr.RxPdo[CheckAttributes.LoopCounter].OSMin</Value2>
							<WriteLine Id="10" Level="Error" Param0="CheckAttributes.LoopCounter" Param1="DeviceDescr.RxPdo[CheckAttributes.LoopCounter].OSMin" Param2="DeviceDescr.RxPdo[CheckAttributes.LoopCounter].OSFac">RxPdo[{0}]: OSMin (current value : {1}) shall be less or equal OSFac (current value : {2})</WriteLine>
						</Lower>
					</Compare>
					<Compare>
						<Lower>
							<Value1>DeviceDescr.RxPdo[CheckAttributes.LoopCounter].OSFac</Value1>
							<Value2>DeviceDescr.RxPdo[CheckAttributes.LoopCounter].OSMin</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_OS_FAC">
					<!--Check RxPdo@OSFac-->
					<Compare>
						<Equal>
							<Value1>DeviceDescr.RxPdo[CheckAttributes.LoopCounter].OSFac</Value1>
							<Value2>null</Value2>
							<GotoStep>TEST_OS_MAX</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Lower>
							<Value1>DeviceDescr.RxPdo[CheckAttributes.LoopCounter].OSFac</Value1>
							<Value2>0</Value2>
							<WriteLine Id="11" Level="Error" Param0="CheckAttributes.LoopCounter" Param1="DeviceDescr.RxPdo[CheckAttributes.LoopCounter].OSFac">RxPdo[{0}]@OSFac shall be &gt;= 0 (current value : {1})</WriteLine>
						</Lower>
					</Compare>
					<Compare>
						<Lower>
							<Value1>DeviceDescr.RxPdo[CheckAttributes.LoopCounter].OSFac</Value1>
							<Value2>0</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Lower>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.RxPdo[CheckAttributes.LoopCounter].OSMax</Value1>
							<Value2>null</Value2>
							<GotoStep>TEST_OS_MAX</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Greater>
							<Value1>DeviceDescr.RxPdo[CheckAttributes.LoopCounter].OSFac</Value1>
							<Value2>DeviceDescr.RxPdo[CheckAttributes.LoopCounter].OSMax</Value2>
							<WriteLine Id="12" Level="Error" Param0="CheckAttributes.LoopCounter" Param1="DeviceDescr.RxPdo[CheckAttributes.LoopCounter].OSMax" Param2="DeviceDescr.RxPdo[CheckAttributes.LoopCounter].OSFac">RxPdo[{0}]: OSMax (current value : {1}) shall be greater or equal OSFac (current value : {2})</WriteLine>
						</Greater>
					</Compare>
					<Compare>
						<Greater>
							<Value1>DeviceDescr.RxPdo[CheckAttributes.LoopCounter].OSFac</Value1>
							<Value2>DeviceDescr.RxPdo[CheckAttributes.LoopCounter].OSMax</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Greater>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_OS_MAX">
					<!--Check RxPdo@OSMax-->
					<Compare>
						<Equal>
							<Value1>DeviceDescr.RxPdo[CheckAttributes.LoopCounter].OSMax</Value1>
							<Value2>null</Value2>
							<GotoStep>TEST_FIXED_FLAG</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Lower>
							<Value1>DeviceDescr.RxPdo[CheckAttributes.LoopCounter].OSMax</Value1>
							<Value2>0</Value2>
							<WriteLine Id="13" Level="Error" Param0="CheckAttributes.LoopCounter" Param1="DeviceDescr.RxPdo[CheckAttributes.LoopCounter].OSMax">RxPdo[{0}]@OSMax shall be &gt;= 0 (current value : {1})</WriteLine>
						</Lower>
					</Compare>
					<Compare>
						<Lower>
							<Value1>DeviceDescr.RxPdo[CheckAttributes.LoopCounter].OSMax</Value1>
							<Value2>0</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Lower>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.RxPdo[CheckAttributes.LoopCounter].OSMin</Value1>
							<Value2>null</Value2>
							<GotoStep>TEST_FIXED_FLAG</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Greater>
							<Value1>DeviceDescr.RxPdo[CheckAttributes.LoopCounter].OSMin</Value1>
							<Value2>DeviceDescr.RxPdo[CheckAttributes.LoopCounter].OSMax</Value2>
							<WriteLine Id="14" Level="Error" Param0="CheckAttributes.LoopCounter" Param1="DeviceDescr.RxPdo[CheckAttributes.LoopCounter].OSMin" Param2="DeviceDescr.RxPdo[CheckAttributes.LoopCounter].OSMax">RxPdo[{0}]: OSMin (current value : {1}) shall be less or equal OSMax (current value : {2})</WriteLine>
						</Greater>
					</Compare>
					<Compare>
						<Greater>
							<Value1>DeviceDescr.RxPdo[CheckAttributes.LoopCounter].OSMin</Value1>
							<Value2>DeviceDescr.RxPdo[CheckAttributes.LoopCounter].OSMax</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Greater>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_FIXED_FLAG">
					<!--If Entries defined the fixed flag doesn't need to be checked-->
					<Description Id="15" Level="Output">Check @Fixed attribute.</Description>
					<Compare>
						<Greater>
							<Value1>DeviceDescr.RxPdo[CheckAttributes.LoopCounter].Entry.Count</Value1>
							<Value2>0</Value2>
							<GotoStep>LOOPEND</GotoStep>
						</Greater>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.RxPdo[CheckAttributes.LoopCounter].Fixed</Value1>
							<Value2>null</Value2>
							<GotoStep>LOOPEND</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<!--If no entries defined fixed flag shall be false-->
					<Compare>
						<Equal>
							<Value1>DeviceDescr.RxPdo[CheckAttributes.LoopCounter].Fixed</Value1>
							<Value2>true</Value2>
							<WriteLine Id="16" Level="Warning" Param0="CheckAttributes.LoopCounter">RxPdo[{0}]: Fixed flag should not be set if no entry is defined.</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="LOOPEND">
					<!--increment loop counter-->
					<SetVariable Target="CheckAttributes.LoopCounter">CheckAttributes.LoopCounter + 1</SetVariable>
				</TestStep>
				<TestStep>
					<!--check if loop finished-->
					<Compare>
						<Lower>
							<Value1>CheckAttributes.LoopCounter</Value1>
							<Value2>DeviceDescr.RxPdo.Count</Value2>
							<GotoStep>LOOPSTART</GotoStep>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep>
					<!--dump test result-->
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>false</Value2>
							<RaiseError Id="17">Test RxPdo(s) attributes failed.</RaiseError>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>true</Value2>
							<ReturnSuccess Id="18">Test RxPdo(s) attributes succeed.</ReturnSuccess>
						</Equal>
					</Compare>
				</TestStep>
			</TestCase>
			<TestCase Name="Check Index" CaseId="2">
				<?MAX_OUTPUT_ID 6?>
				<Description>
					<Purpose>Correct RxPDO index range</Purpose>
					<PreCondition>The device description contains at least one RxPDO element.</PreCondition>
					<Action>Check @Index</Action>
					<PostCondition>@Index shall be between 0x1600 and 0x17FF</PostCondition>
					<References>
						<Reference Specification="ETG.1000"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep>
					<!--Check if RxPDOs are defined-->
					<Compare>
						<Equal>
							<Value1>DeviceDescr.RxPdo.Count</Value1>
							<Value2>0</Value2>
							<SkipCase Id="0">Test skipped no RxPdo defined.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<!--Skip Test for slave with device emulation-->
					<CallTestFunction Name="GetDeviceEmulationFlags">
						<!--if false the device emulation bit will be read out from the ESI file-->
						<Parameter>false</Parameter>
						<OutParameter>boolVar</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>boolVar</Value1>
							<Value2>true</Value2>
							<SkipCase Id="1">DuT is a simple device test skipped.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<!--Skip Test for SoE slaves-->
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Mailbox</Value1>
							<Value2>false</Value2>
							<GotoStep>INITLOOPCOUNTERVAR</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Mailbox.SoE</Value1>
							<Value2>true</Value2>
							<SkipCase Id="2">Pdo Index test is skipped for SoE slaves</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="INITLOOPCOUNTERVAR">
					<!--Init Loop CounterVariable-->
					<SetVariable Target="CheckIndex.LoopCounter">0</SetVariable>
				</TestStep>
				<TestStep>
					<!--Init Result Variable-->
					<SetVariable Target="result">true</SetVariable>
				</TestStep>
				<TestStep Name="LOOPSTART">
					<!--Dump loop start info-->
				</TestStep>
				<TestStep>
					<!--Check if Index is less than 0x1600-->
					<Compare>
						<Lower>
							<Value1>DeviceDescr.RxPdo[CheckIndex.LoopCounter].Index</Value1>
							<Value2>5632</Value2>
							<WriteLine Id="3" Level="Error" Param0="CheckIndex.LoopCounter" Param1="DeviceDescr.RxPdo[CheckIndex.LoopCounter].Index">RxPdo[{0}].Index (0x{1:x4}) shall be between 0x1600 and 0x17FF</WriteLine>
						</Lower>
					</Compare>
					<Compare>
						<Lower>
							<Value1>DeviceDescr.RxPdo[CheckIndex.LoopCounter].Index</Value1>
							<Value2>5632</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep>
					<!--Check if Index is greater than 0x17FF-->
					<Compare>
						<Greater>
							<Value1>DeviceDescr.RxPdo[CheckIndex.LoopCounter].Index</Value1>
							<Value2>6143</Value2>
							<WriteLine Id="4" Level="Error" Param0="CheckIndex.LoopCounter" Param1="DeviceDescr.RxPdo[CheckIndex.LoopCounter].Index">RxPdo[{0}].Index (0x{1:x4}) shall be between 0x1600 and 0x17FF</WriteLine>
						</Greater>
					</Compare>
					<Compare>
						<Greater>
							<Value1>DeviceDescr.RxPdo[CheckIndex.LoopCounter].Index</Value1>
							<Value2>6143</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Greater>
					</Compare>
				</TestStep>
				<TestStep Name="LOOPEND">
					<!--increment loop counter-->
					<SetVariable Target="CheckIndex.LoopCounter">CheckIndex.LoopCounter + 1</SetVariable>
				</TestStep>
				<TestStep>
					<!--check if loop finished-->
					<Compare>
						<Lower>
							<Value1>CheckIndex.LoopCounter</Value1>
							<Value2>DeviceDescr.RxPdo.Count</Value2>
							<GotoStep>LOOPSTART</GotoStep>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep>
					<!--dump test result-->
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>false</Value2>
							<RaiseError></RaiseError>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>true</Value2>
							<ReturnSuccess Id="6">All RxPdo indices are valid.</ReturnSuccess>
						</Equal>
					</Compare>
				</TestStep>
			</TestCase>
			<TestCase Name="Check SM assignment" CaseId="3">
				<?MAX_OUTPUT_ID 3?>
				<Description>
					<Purpose>Correct SyncManager assignment for RxPDOs</Purpose>
					<PreCondition>The device description contains at least one RxPDO element.</PreCondition>
					<Action>- @Mandatory == true
  test only @Sm
  1.) Is @Sm defined
  2.) Is .ExcludedSm defined
- @Mandatory == false
  iterate over all matching SyncManagers
  - referenced via @Sm
  - not excluded via .ExcludedSm
  - referenced via @Su

3.) @Sm match?
4.) Check @Virtual ?</Action>
					<PostCondition>1.) @Sm shall be defined
2.) .ExcludedSm should not be defined (the PDO is fixed assigned to @Sm)
3.) Directon/Type of shall @Sm match
4.) Valid if:
    - PDO is virtual AND SyncManager is virtual AND Entries defined
	- PDO is virtual AND SyncManager is not virtual and no Entries defined
    Error if SyncManager is @Sm else Warning

At least one valid SyncManager is defined.</PostCondition>
					<References>
						<Reference Specification="ETG.2000"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep>
					<!--Check if RxPDOs are defined-->
					<Compare>
						<Equal>
							<Value1>DeviceDescr.RxPdo.Count</Value1>
							<Value2>0</Value2>
							<SkipCase Id="0">Test skipped no RxPdo defined.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<!--Init Loop CounterVariable-->
					<SetVariable Target="CheckSmAssignment.LoopCounter">0</SetVariable>
				</TestStep>
				<TestStep>
					<!--Init Result Variable-->
					<SetVariable Target="result">true</SetVariable>
				</TestStep>
				<TestStep Name="LOOPSTART">
					<!--Dump loop start info-->
					<WriteLine Id="1" Level="Output" Param0="CheckSmAssignment.LoopCounter" Param1="DeviceDescr.RxPdo[CheckSmAssignment.LoopCounter].Index">RxPdo[{0}] : 0x{1:x4} Sm assigment.</WriteLine>
				</TestStep>
				<TestStep>
					<!--Check if Referenced SM are valid-->
					<CallTestFunction Name="CheckRxPdoSmAssignment">
						<Parameter>CheckSmAssignment.LoopCounter</Parameter>
						<OutParameter>TmpResult</OutParameter>
					</CallTestFunction>
				</TestStep>
				<TestStep>
					<!--update result-->
					<Compare>
						<Equal>
							<Value1>TmpResult</Value1>
							<Value2>false</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="LOOPEND">
					<!--increment loop counter-->
					<SetVariable Target="CheckSmAssignment.LoopCounter">CheckSmAssignment.LoopCounter + 1</SetVariable>
				</TestStep>
				<TestStep>
					<!--check if loop finished-->
					<Compare>
						<Lower>
							<Value1>CheckSmAssignment.LoopCounter</Value1>
							<Value2>DeviceDescr.RxPdo.Count</Value2>
							<GotoStep>LOOPSTART</GotoStep>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep>
					<!--dump test result-->
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>false</Value2>
							<RaiseError Id="2">Test RxPdo(s) Sm assignment failed</RaiseError>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>true</Value2>
							<ReturnSuccess Id="3">Test RxPdo(s) Sm assignment succeed.</ReturnSuccess>
						</Equal>
					</Compare>
				</TestStep>
			</TestCase>
			<TestCase Name="Check Pdo entry Data Types" CaseId="4">
				<?MAX_OUTPUT_ID 18?>
				<Description>
					<Purpose>Validation of all RxPDO mapping entries of ESI file.</Purpose>
					<PreCondition>- RxPDO(s) shall be defined
</PreCondition>
					<Action>- checks entry count of each RxPdo element
- checks all existing entries of each defined RxPdo element
- compares the base data types to the bit length of each entry</Action>
					<PostCondition>- The DuT contains entries
- All DataType Entries shall provide the correct bit length</PostCondition>
					<References>
						<Reference Specification="ETG.2000" Chapter="5.6.7 Base Data Types"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="CheckRxPdoObjectsExists">
					<Compare>
						<Equal>
							<Value1>DeviceDescr.RxPdo.Count</Value1>
							<Value2>0</Value2>
							<SkipCase Id="0">Skipped case: Device does not have RxPDO objects.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="WriteDescTestBegins">
					<Description Id="1" Level="Verbose">Checking RxPDO element of ESI file...</Description>
				</TestStep>
				<TestStep Name="CheckPdoEntryCount">
					<Compare>
						<Equal>
							<Value1>DeviceDescr.RxPdo[int32CurrIndex].Entry.Count</Value1>
							<Value2>0</Value2>
							<WriteLine Id="2" Level="Verbose" Param0="DeviceDescr.RxPdo[int32CurrIndex].Index">PDO object 0x{0:x4}: No entry found</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.RxPdo[int32CurrIndex].Entry.Count</Value1>
							<Value2>0</Value2>
							<GotoStep>IncrementPdoIndex</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="WriteDescPdoObject">
					<Description Id="3" Level="Verbose" Param0="DeviceDescr.RxPdo[int32CurrIndex].Index" Param1="DeviceDescr.RxPdo[int32CurrIndex].Entry.Count">Checking {1} entr(y/ies) of PDO object 0x{0:x4}...</Description>
				</TestStep>
				<TestStep Name="ResetSubIndex">
					<SetVariable Target="int32CurrSubIndex">0</SetVariable>
				</TestStep>
				<TestStep Name="CheckIsGap">
					<Compare>
						<NotEqual>
							<Value1>DeviceDescr.RxPdo[int32CurrIndex].Entry[int32CurrSubIndex].Index</Value1>
							<Value2> 0</Value2>
							<GotoStep>CheckIfArrayBaseDataType</GotoStep>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="WriteGapEntry">
					<WriteLine Id="4" Level="Verbose" Param0="DeviceDescr.RxPdo[int32CurrIndex].Index" Param1="int32CurrSubIndex+1" Param2="DeviceDescr.RxPdo[int32CurrIndex].Entry[int32CurrSubIndex].BitLen">Entry 0x{0:x4}:{1} is a gap ({2}).</WriteLine>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>IncrementEntryIndex</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckIfArrayBaseDataType">
					<CallTestFunction Name="CheckForValidArrayDataType">
						<Parameter>DeviceDescr.RxPdo[int32CurrIndex].Entry[int32CurrSubIndex].DataType</Parameter>
						<OutParameter>boolComplexType</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>boolComplexType</Value1>
							<Value2>true</Value2>
							<GotoStep>CheckIfArrayBitLengthLarger31B</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckBaseDataTypeBitLen">
					<CallTestFunction Name="BaseDataType.CheckSize">
						<Parameter>DeviceDescr.RxPdo[int32CurrIndex].Entry[int32CurrSubIndex].BitLen</Parameter>
						<Parameter>DeviceDescr.RxPdo[int32CurrIndex].Entry[int32CurrSubIndex].DataType</Parameter>
						<OutParameter>StringBaseTypeErrorString</OutParameter>
					</CallTestFunction>
					<Compare>
						<NotEqual>
							<Value1>StringBaseTypeErrorString</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>WriteBaseDataTypeError</GotoStep>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="IncrementDataTypeSuccessfullCounter">
					<SetVariable Target="uint16SuccCount">uint16SuccCount+1</SetVariable>
					<WriteLine Id="5" Level="Verbose" Param0="DeviceDescr.RxPdo[int32CurrIndex].Index" Param1="int32CurrSubIndex+1" Param2="DeviceDescr.RxPdo[int32CurrIndex].Entry[int32CurrSubIndex].DataType" Param3="DeviceDescr.RxPdo[int32CurrIndex].Entry[int32CurrSubIndex].BitLen">Entry 0x{0:x4}:{1} has the DataType {2} and the right BitLength ({3}).</WriteLine>
				</TestStep>
				<TestStep Name="IncrementTestedCounter">
					<SetVariable Target="uint16TestedValues">uint16TestedValues+1</SetVariable>
				</TestStep>
				<TestStep Name="GoToNextEntry">
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>IncrementEntryIndex</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="WriteBaseDataTypeError">
					<WriteLine Id="6" Level="Error" Param0="DeviceDescr.RxPdo[int32CurrIndex].Index" Param1="int32CurrSubIndex+1" Param2="StringBaseTypeErrorString">Entry 0x{0:x4}:{1}: {2}</WriteLine>
				</TestStep>
				<TestStep Name="IncrementGeneralCounter">
					<SetVariable Target="uint16Errors">uint16Errors+1</SetVariable>
				</TestStep>
				<TestStep Name="IncrementDataTypeErrorCounter">
					<SetVariable Target="uint16ErrCount">uint16ErrCount+1</SetVariable>
				</TestStep>
				<TestStep Name="IncrementEntryIndex">
					<SetVariable Target="int32CurrSubIndex">int32CurrSubIndex+1</SetVariable>
					<Compare>
						<Lower>
							<Value1>int32CurrSubIndex</Value1>
							<Value2>DeviceDescr.RxPdo[int32CurrIndex].Entry.Count</Value2>
							<GotoStep>CheckIsGap</GotoStep>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep Name="GetAndWriteResult">
					<Compare>
						<NotEqual>
							<Value1>uint16ErrCount</Value1>
							<Value2>0</Value2>
							<WriteLine Id="7" Level="Output" Param0="DeviceDescr.RxPdo[int32CurrIndex].Index" Param1="uint16SuccCount" Param2="uint16ErrCount">PDO object 0x{0:x4}: {2} Entry data type(s) do not match to the expected bit length. {1} data type(s) match to the right bit length.</WriteLine>
						</NotEqual>
					</Compare>
					<Compare>
						<Equal>
							<Value1>(uint16SuccCount+uint16ErrCount)</Value1>
							<Value2>0</Value2>
							<WriteLine Id="8" Level="Output" Param0="DeviceDescr.RxPdo[int32CurrIndex].Index">PDO object 0x{0:x4}: No entry data type checked.</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>(uint16SuccCount+uint16ErrCount)</Value1>
							<Value2>0</Value2>
							<GotoStep>IncrementPdoIndex</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>uint16ErrCount</Value1>
							<Value2>0</Value2>
							<WriteLine Id="9" Level="Output" Param0="DeviceDescr.RxPdo[int32CurrIndex].Index" Param1="uint16SuccCount">PDO object 0x{0:x4}: All entry data type(s) ({1}) match to the expected bit length.</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="IncrementPdoIndex">
					<SetVariable Target="int32CurrIndex">int32CurrIndex+1</SetVariable>
				</TestStep>
				<TestStep Name="ResetSuccessCountForNextPdo">
					<SetVariable Target="uint16SuccCount">0</SetVariable>
				</TestStep>
				<TestStep Name="ResetErrorCountForNextPdo">
					<SetVariable Target="uint16ErrCount">0</SetVariable>
				</TestStep>
				<TestStep Name="GoToCheckNextPdo">
					<Compare>
						<Lower>
							<Value1>int32CurrIndex</Value1>
							<Value2>DeviceDescr.RxPdo.Count</Value2>
							<GotoStep>CheckPdoEntryCount</GotoStep>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep Name="ReturnTestResult">
					<Compare>
						<Greater>
							<Value1>uint16Errors</Value1>
							<Value2>0</Value2>
							<RaiseError Id="18"></RaiseError>
						</Greater>
					</Compare>
					<Compare>
						<Equal>
							<Value1>uint16TestedValues</Value1>
							<Value2>0</Value2>
							<SkipCase Id="11">Skipped case: No entry found.</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<ReturnSuccess Id="12" Param0="uint16TestedValues">All ({0}) entr(y/ies) of RxPDO object(s) match to the right bit length.</ReturnSuccess>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckIfArrayBitLengthLarger31B">
					<SetVariable Target="int32SavedSubIndex">int32CurrSubIndex</SetVariable>
				</TestStep>
				<TestStep>
					<SetVariable Target="Uint32ArrayBitLength">DeviceDescr.RxPdo[int32CurrIndex].Entry[int32CurrSubIndex].BitLen</SetVariable>
				</TestStep>
				<TestStep Name="CheckArrayIfSplittedBitSize">
					<SetVariable Target="int32CurrSubIndex">int32CurrSubIndex+1</SetVariable>
					<Compare>
						<GreaterOrEqual>
							<Value1>int32CurrSubIndex</Value1>
							<Value2>DeviceDescr.RxPdo[int32CurrIndex].Entry.Count</Value2>
							<GotoStep>ResetSubIndexAndGoBack</GotoStep>
						</GreaterOrEqual>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>DeviceDescr.RxPdo[int32CurrIndex].Entry[int32CurrSubIndex].Index</Value1>
							<Value2>0</Value2>
							<GotoStep>ResetSubIndexAndGoBack</GotoStep>
						</NotEqual>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>DeviceDescr.RxPdo[int32CurrIndex].Entry[int32CurrSubIndex].SubIndex</Value1>
							<Value2>0</Value2>
							<GotoStep>ResetSubIndexAndGoBack</GotoStep>
						</NotEqual>
					</Compare>
					<Compare>
						<Greater>
							<Value1>DeviceDescr.RxPdo[int32CurrIndex].Entry[int32CurrSubIndex].BitLen</Value1>
							<Value2>240</Value2>
							<WriteLine Id="13" Level="Warning" Param0="DeviceDescr.RxPdo[int32CurrIndex].Entry[int32CurrSubIndex].BitLen">Bit length of {0} is invalid. A Bit length greater than 240 Bits is not allowed.</WriteLine>
						</Greater>
					</Compare>
				</TestStep>
				<TestStep Name="CheckIfArrayEnd">
					<Compare>
						<NotEqual>
							<Value1>DeviceDescr.RxPdo[int32CurrIndex].Entry[int32CurrSubIndex].Index</Value1>
							<Value2>0</Value2>
							<GotoStep>DecreaseSubIndexAndCheckArrayDataTypeBitSize</GotoStep>
						</NotEqual>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>DeviceDescr.RxPdo[int32CurrIndex].Entry[int32CurrSubIndex].SubIndex</Value1>
							<Value2>0</Value2>
							<GotoStep>DecreaseSubIndexAndCheckArrayDataTypeBitSize</GotoStep>
						</NotEqual>
					</Compare>
					<Compare>
						<Greater>
							<Value1>DeviceDescr.RxPdo[int32CurrIndex].Entry[int32CurrSubIndex].BitLen</Value1>
							<Value2>240</Value2>
							<WriteLine Id="14" Level="Warning" Param0="DeviceDescr.RxPdo[int32CurrIndex].Entry[int32CurrSubIndex].BitLen">Bit length of {0} is invalid. A Bit length greater than 240 Bits is not allowed.</WriteLine>
						</Greater>
					</Compare>
				</TestStep>
				<TestStep>
					<SetVariable Target="Uint32ArrayBitLength">Uint32ArrayBitLength+DeviceDescr.RxPdo[int32CurrIndex].Entry[int32CurrSubIndex].BitLen</SetVariable>
					<Compare>
						<NotEqual>
							<Value1>DeviceDescr.RxPdo[int32CurrIndex].Entry[int32CurrSubIndex].BitLen</Value1>
							<Value2>240</Value2>
							<GotoStep>CheckArrayDataTypeBitSize</GotoStep>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep>
					<SetVariable Target="int32CurrSubIndex">int32CurrSubIndex+1</SetVariable>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>CheckIfArrayEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="DecreaseSubIndexAndCheckArrayDataTypeBitSize">
					<SetVariable Target="int32CurrSubIndex">int32CurrSubIndex-1</SetVariable>
				</TestStep>
				<TestStep Name="CheckArrayDataTypeBitSize">
					<CallTestFunction Name="BaseDataType.CheckSize">
						<Parameter>Uint32ArrayBitLength</Parameter>
						<Parameter>DeviceDescr.RxPdo[int32CurrIndex].Entry[int32SavedSubIndex].DataType</Parameter>
						<OutParameter>StringBaseTypeErrorString</OutParameter>
					</CallTestFunction>
					<Compare>
						<NotEqual>
							<Value1>StringBaseTypeErrorString</Value1>
							<Value2>EmptyString</Value2>
							<WriteLine Id="15" Level="Error" Param0="DeviceDescr.RxPdo[int32CurrIndex].Index" Param1="int32SavedSubIndex+1" Param2="StringBaseTypeErrorString">Entry 0x{0:x4}:{1}: {2}</WriteLine>
						</NotEqual>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>StringBaseTypeErrorString</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>IncrementGeneralCounter</GotoStep>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="WriteArrayDataTypeBitLengthSuccess">
					<SetVariable Target="uint16SuccCount">uint16SuccCount+1</SetVariable>
					<WriteLine Id="16" Level="Verbose" Param0="DeviceDescr.RxPdo[int32CurrIndex].Index" Param1="int32SavedSubIndex+1" Param2="DeviceDescr.RxPdo[int32CurrIndex].Entry[int32SavedSubIndex].DataType" Param3="Uint32ArrayBitLength">Entry 0x{0:x4}:{1} has the DataType {2} and the right BitLength ({3}).</WriteLine>
				</TestStep>
				<TestStep Name="CheckNextEntryWithDataType">
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>IncrementTestedCounter</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="ResetSubIndexAndGoBack">
					<SetVariable Target="int32CurrSubIndex">int32SavedSubIndex</SetVariable>
					<Compare>
						<Greater>
							<Value1>DeviceDescr.RxPdo[int32CurrIndex].Entry[int32CurrSubIndex].BitLen</Value1>
							<Value2>255</Value2>
							<WriteLine Id="17" Level="Output" Param0="DeviceDescr.RxPdo[int32CurrIndex].Entry[int32CurrSubIndex].BitLen" Param1="DeviceDescr.RxPdo[int32CurrIndex].Entry[int32CurrSubIndex].DataType">BitSize ({0}) of data type '{1}' is greater than 255.</WriteLine>
						</Greater>
					</Compare>
					<Compare>
						<Greater>
							<Value1>DeviceDescr.RxPdo[int32CurrIndex].Entry[int32CurrSubIndex].BitLen</Value1>
							<Value2>255</Value2>
							<GotoStep>WriteBaseDataTypeError</GotoStep>
						</Greater>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>CheckBaseDataTypeBitLen</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
			</TestCase>
			<TestCase Name="Check Pdo Default Size" CaseId="5">
				<?MAX_OUTPUT_ID 3?>
				<Description>
					<Purpose>Validation of the Pdo default bit size.</Purpose>
					<PreCondition>- RxPDO(s) shall be defined.</PreCondition>
					<Action>- checks PDO size according to the assigned sync manager
- checks description of assigned sync manager</Action>
					<PostCondition>- size of default assigned PDOs shall match the sync manager DefaultSize attribute
- PDOs marked as mandatory shall asiggned to an sync manager</PostCondition>
					<References>
						<Reference Specification="ETG.2000" Chapter="13.4 Device Type"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="CheckRxPdoObjectsExists">
					<Compare>
						<Equal>
							<Value1>DeviceDescr.RxPdo.Count</Value1>
							<Value2>0</Value2>
							<SkipCase Id="0">Test skipped no RxPdo defined.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CallFunctionCheckDefaultSize">
					<CallTestFunction Name="RxCheckPdSmDefaultSize">
						<OutParameter>uint16Errors</OutParameter>
					</CallTestFunction>
					<Compare>
						<Greater>
							<Value1>uint16Errors</Value1>
							<Value2>0</Value2>
							<GotoStep>RaiseError</GotoStep>
						</Greater>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<ReturnSuccess Id="1">Tested default size of assigned sync manager(s) successfull.</ReturnSuccess>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="RaiseError">
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<RaiseError Id="3"></RaiseError>
						</Equal>
					</Compare>
				</TestStep>
			</TestCase>
			<TestCase Name="Check Pdo Exclude" CaseId="6">
				<?MAX_OUTPUT_ID 4?>
				<Description>
					<Purpose>Validate .Exclude element of RxPdo</Purpose>
					<PreCondition>The device description contains at least one RxPDO element.</PreCondition>
					<Action>Check RxPDOs included in .Exclude</Action>
					<PostCondition>Each excluded RxPDO shall exclude the current RxPDO</PostCondition>
					<References>
						<Reference Specification=""></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep>
					<!--Check if RxPDOs are defined-->
					<Compare>
						<Equal>
							<Value1>DeviceDescr.RxPdo.Count</Value1>
							<Value2>0</Value2>
							<SkipCase Id="0">Test skipped no RxPdo defined.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<!--Init Loop CounterVariable-->
					<SetVariable Target="CheckPdoExclude.LoopCounter">0</SetVariable>
				</TestStep>
				<TestStep>
					<!--Init Result Variable-->
					<SetVariable Target="result">true</SetVariable>
				</TestStep>
				<TestStep Name="LOOPSTART">
					<!--Dump loop start info-->
					<WriteLine Id="1" Level="Output" Param0="CheckPdoExclude.LoopCounter" Param1="DeviceDescr.RxPdo[CheckPdoExclude.LoopCounter].Index">Check RxPdo[{0}] : 0x{1:x4} Exclude element.</WriteLine>
				</TestStep>
				<TestStep>
					<!--Check if current Exclude element is valid-->
					<CallTestFunction Name="CheckRxPdoExcludeElement">
						<Parameter>CheckPdoExclude.LoopCounter</Parameter>
						<OutParameter>TmpResult</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>TmpResult</Value1>
							<Value2>false</Value2>
							<WriteLine Id="2" Level="Output">Exclude information of RxPdo[{0}] are invalid.</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<!--update result-->
					<Compare>
						<Equal>
							<Value1>TmpResult</Value1>
							<Value2>false</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="LOOPEND">
					<!--increment loop counter-->
					<SetVariable Target="CheckPdoExclude.LoopCounter">CheckPdoExclude.LoopCounter + 1</SetVariable>
				</TestStep>
				<TestStep>
					<!--check if loop finished-->
					<Compare>
						<Lower>
							<Value1>CheckPdoExclude.LoopCounter</Value1>
							<Value2>DeviceDescr.RxPdo.Count</Value2>
							<GotoStep>LOOPSTART</GotoStep>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep>
					<!--dump test result-->
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>false</Value2>
							<RaiseError Id="3">Test RxPdo.Exclude failed</RaiseError>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>true</Value2>
							<ReturnSuccess Id="4">Test RxPdo.Exclude succeed.</ReturnSuccess>
						</Equal>
					</Compare>
				</TestStep>
			</TestCase>
		</TestGroup>
		<TestGroup GroupId="8" Name="TxPdo Tests">
			<Comment>Check the correct usage and values of the TxPDO elements</Comment>
			<TestCase Name="Check Attributes" CaseId="1">
				<?MAX_OUTPUT_ID 18?>
				<Description>
					<Purpose>Correct usage of the TxPdo attributes</Purpose>
					<PreCondition>The device description contains at least one TxPDO element.</PreCondition>
					<Action>1. @Su
2. @Fixed
3. @OSFac,@OSMin,@OSMax,@OSIndexInc</Action>
					<PostCondition>1. if @Su defined a matching FMMU shall be referenced
2. if @Fixed is true at least one entry should be defined
3. if defined @OSxxx shall be greater/equal 0
   and @OSMin less/equal @OSFac greater/equal @OSMax</PostCondition>
					<References>
						<Reference Specification="ETG.2000"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep>
					<!--Check if TxPdos are defined-->
					<Compare>
						<Equal>
							<Value1>DeviceDescr.TxPdo.Count</Value1>
							<Value2>0</Value2>
							<SkipCase Id="0">Test skipped no TxPdo defined.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<!--Init Loop CounterVariable-->
					<SetVariable Target="CheckAttributes.LoopCounter">0</SetVariable>
				</TestStep>
				<TestStep>
					<!--Init Result Variable-->
					<SetVariable Target="result">true</SetVariable>
				</TestStep>
				<TestStep Name="LOOPSTART">
					<!--Dump loop start info-->
					<WriteLine Id="1" Level="Output" Param0="CheckAttributes.LoopCounter" Param1="DeviceDescr.TxPdo[CheckAttributes.LoopCounter].Index">Check TxPdo[{0}] : 0x{1:x4} attibutes</WriteLine>
				</TestStep>
				<TestStep>
					<!--Check if TxPdo@Su is defined-->
					<Description Id="2" Level="Output">Check @Su attribute.</Description>
					<!--Skip Su test if Su is not defined-->
					<Compare>
						<Equal>
							<Value1>DeviceDescr.TxPdo[CheckAttributes.LoopCounter].Su</Value1>
							<Value2>null</Value2>
							<WriteLine Id="3" Level="Verbose" Param0="CheckAttributes.LoopCounter">TxPdo[{0}].Su not defined.</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.TxPdo[CheckAttributes.LoopCounter].Su</Value1>
							<Value2>null</Value2>
							<GotoStep>TEST_OS_INDEXINC</GotoStep>
						</Equal>
					</Compare>
					<!--Skip Su test if Sm is not defined-->
					<Compare>
						<Equal>
							<Value1>DeviceDescr.TxPdo[CheckAttributes.LoopCounter].Sm</Value1>
							<Value2>null</Value2>
							<WriteLine Id="4" Level="Verbose" Param0="CheckAttributes.LoopCounter">Skip Su test because default Sm not defined (TxPdo[{0}].Sm not defined).</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.TxPdo[CheckAttributes.LoopCounter].Sm</Value1>
							<Value2>null</Value2>
							<GotoStep>TEST_OS_INDEXINC</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<WriteLine Id="5" Level="Output" Param0="CheckAttributes.LoopCounter" Param1="DeviceDescr.TxPdo[CheckAttributes.LoopCounter].Su">Check if TxPdo[{0}].Su ({1}) reference a valid Fmmu.</WriteLine>
				</TestStep>
				<TestStep>
					<!--Get Referenced Fmmu-->
					<CallTestFunction Name="GetFmmuBySu">
						<Parameter>DeviceDescr.TxPdo[CheckAttributes.LoopCounter].Su</Parameter>
						<Parameter>Inputs</Parameter>
						<OutParameter>i32TmpIndex</OutParameter>
					</CallTestFunction>
				</TestStep>
				<TestStep>
					<!--Check if FMMU exists-->
					<Compare>
						<Lower>
							<Value1>i32TmpIndex</Value1>
							<Value2>0</Value2>
							<WriteLine Id="6" Level="Error" Param0="CheckAttributes.LoopCounter" Param1="DeviceDescr.TxPdo[CheckAttributes.LoopCounter].Su">TxPdo[{0}].Su ({1}) doesn't reference an existing/matching Fmmu.</WriteLine>
						</Lower>
					</Compare>
					<Compare>
						<Lower>
							<Value1>i32TmpIndex</Value1>
							<Value2>0</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Lower>
					</Compare>
					<Compare>
						<Lower>
							<Value1>i32TmpIndex</Value1>
							<Value2>0</Value2>
							<GotoStep>TEST_OS_INDEXINC</GotoStep>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_OS_INDEXINC">
					<!--Check TxPdo@OSIndexInc-->
					<Description Id="7" Level="Output">Check @OSxxxx attributes.</Description>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.TxPdo[CheckAttributes.LoopCounter].OSIndexInc</Value1>
							<Value2>null</Value2>
							<GotoStep>TEST_OS_MIN</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Lower>
							<Value1>DeviceDescr.TxPdo[CheckAttributes.LoopCounter].OSIndexInc</Value1>
							<Value2>0</Value2>
							<WriteLine Id="8" Level="Error" Param0="CheckAttributes.LoopCounter" Param1="DeviceDescr.TxPdo[CheckAttributes.LoopCounter].OSIndexInc">TxPdo[{0}]@OSIndexInc shall be &gt;= 0 (current value : {1})</WriteLine>
						</Lower>
					</Compare>
					<Compare>
						<Lower>
							<Value1>DeviceDescr.TxPdo[CheckAttributes.LoopCounter].OSIndexInc</Value1>
							<Value2>0</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_OS_MIN">
					<!--Check TxPdo@OSMin-->
					<Compare>
						<Equal>
							<Value1>DeviceDescr.TxPdo[CheckAttributes.LoopCounter].OSMin</Value1>
							<Value2>null</Value2>
							<GotoStep>TEST_OS_FAC</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Lower>
							<Value1>DeviceDescr.TxPdo[CheckAttributes.LoopCounter].OSMin</Value1>
							<Value2>0</Value2>
							<WriteLine Id="9" Level="Error" Param0="CheckAttributes.LoopCounter" Param1="DeviceDescr.TxPdo[CheckAttributes.LoopCounter].OSMin">TxPdo[{0}]@OSMin shall be &gt;= 0 (current value : {1})</WriteLine>
						</Lower>
					</Compare>
					<Compare>
						<Lower>
							<Value1>DeviceDescr.TxPdo[CheckAttributes.LoopCounter].OSMin</Value1>
							<Value2>0</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Lower>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.TxPdo[CheckAttributes.LoopCounter].OSFac</Value1>
							<Value2>null</Value2>
							<GotoStep>TEST_OS_FAC</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Lower>
							<Value1>DeviceDescr.TxPdo[CheckAttributes.LoopCounter].OSFac</Value1>
							<Value2>DeviceDescr.TxPdo[CheckAttributes.LoopCounter].OSMin</Value2>
							<WriteLine Id="10" Level="Error" Param0="CheckAttributes.LoopCounter" Param1="DeviceDescr.TxPdo[CheckAttributes.LoopCounter].OSMin" Param2="DeviceDescr.TxPdo[CheckAttributes.LoopCounter].OSFac">TxPdo[{0}]: OSMin (current value : {1}) shall be less or equal OSFac (current value : {2})</WriteLine>
						</Lower>
					</Compare>
					<Compare>
						<Lower>
							<Value1>DeviceDescr.TxPdo[CheckAttributes.LoopCounter].OSFac</Value1>
							<Value2>DeviceDescr.TxPdo[CheckAttributes.LoopCounter].OSMin</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_OS_FAC">
					<!--Check TxPdo@OSFac-->
					<Compare>
						<Equal>
							<Value1>DeviceDescr.TxPdo[CheckAttributes.LoopCounter].OSFac</Value1>
							<Value2>null</Value2>
							<GotoStep>TEST_OS_MAX</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Lower>
							<Value1>DeviceDescr.TxPdo[CheckAttributes.LoopCounter].OSFac</Value1>
							<Value2>0</Value2>
							<WriteLine Id="11" Level="Error" Param0="CheckAttributes.LoopCounter" Param1="DeviceDescr.TxPdo[CheckAttributes.LoopCounter].OSFac">TxPdo[{0}]@OSFac shall be &gt;= 0 (current value : {1})</WriteLine>
						</Lower>
					</Compare>
					<Compare>
						<Lower>
							<Value1>DeviceDescr.TxPdo[CheckAttributes.LoopCounter].OSFac</Value1>
							<Value2>0</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Lower>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.TxPdo[CheckAttributes.LoopCounter].OSMax</Value1>
							<Value2>null</Value2>
							<GotoStep>TEST_OS_MAX</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Greater>
							<Value1>DeviceDescr.TxPdo[CheckAttributes.LoopCounter].OSFac</Value1>
							<Value2>DeviceDescr.TxPdo[CheckAttributes.LoopCounter].OSMax</Value2>
							<WriteLine Id="12" Level="Error" Param0="CheckAttributes.LoopCounter" Param1="DeviceDescr.TxPdo[CheckAttributes.LoopCounter].OSMax" Param2="DeviceDescr.TxPdo[CheckAttributes.LoopCounter].OSFac">TxPdo[{0}]: OSMax (current value : {1}) shall be greater or equal OSFac (current value : {2})</WriteLine>
						</Greater>
					</Compare>
					<Compare>
						<Greater>
							<Value1>DeviceDescr.TxPdo[CheckAttributes.LoopCounter].OSFac</Value1>
							<Value2>DeviceDescr.TxPdo[CheckAttributes.LoopCounter].OSMax</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Greater>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_OS_MAX">
					<!--Check TxPdo@OSMax-->
					<Compare>
						<Equal>
							<Value1>DeviceDescr.TxPdo[CheckAttributes.LoopCounter].OSMax</Value1>
							<Value2>null</Value2>
							<GotoStep>TEST_FIXED_FLAG</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Lower>
							<Value1>DeviceDescr.TxPdo[CheckAttributes.LoopCounter].OSMax</Value1>
							<Value2>0</Value2>
							<WriteLine Id="13" Level="Error" Param0="CheckAttributes.LoopCounter" Param1="DeviceDescr.TxPdo[CheckAttributes.LoopCounter].OSMax">TxPdo[{0}]@OSMax shall be &gt;= 0 (current value : {1})</WriteLine>
						</Lower>
					</Compare>
					<Compare>
						<Lower>
							<Value1>DeviceDescr.TxPdo[CheckAttributes.LoopCounter].OSMax</Value1>
							<Value2>0</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Lower>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.TxPdo[CheckAttributes.LoopCounter].OSMin</Value1>
							<Value2>null</Value2>
							<GotoStep>TEST_FIXED_FLAG</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Greater>
							<Value1>DeviceDescr.TxPdo[CheckAttributes.LoopCounter].OSMin</Value1>
							<Value2>DeviceDescr.TxPdo[CheckAttributes.LoopCounter].OSMax</Value2>
							<WriteLine Id="14" Level="Error" Param0="CheckAttributes.LoopCounter" Param1="DeviceDescr.TxPdo[CheckAttributes.LoopCounter].OSMin" Param2="DeviceDescr.TxPdo[CheckAttributes.LoopCounter].OSMax">TxPdo[{0}]: OSMin (current value : {1}) shall be less or equal OSMax (current value : {2})</WriteLine>
						</Greater>
					</Compare>
					<Compare>
						<Greater>
							<Value1>DeviceDescr.TxPdo[CheckAttributes.LoopCounter].OSMin</Value1>
							<Value2>DeviceDescr.TxPdo[CheckAttributes.LoopCounter].OSMax</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Greater>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_FIXED_FLAG">
					<!--If Entries defined the fixed flag doesn't need to be checked-->
					<Description Id="15" Level="Output">Check @Fixed attribute.</Description>
					<Compare>
						<Greater>
							<Value1>DeviceDescr.TxPdo[CheckAttributes.LoopCounter].Entry.Count</Value1>
							<Value2>0</Value2>
							<GotoStep>LOOPEND</GotoStep>
						</Greater>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.TxPdo[CheckAttributes.LoopCounter].Fixed</Value1>
							<Value2>null</Value2>
							<GotoStep>LOOPEND</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<!--If no entries defined fixed flag shall be false-->
					<Compare>
						<Equal>
							<Value1>DeviceDescr.TxPdo[CheckAttributes.LoopCounter].Fixed</Value1>
							<Value2>true</Value2>
							<WriteLine Id="16" Level="Warning" Param0="CheckAttributes.LoopCounter">TxPdo[{0}]: Fixed flag should not be set if no entry is defined.</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="LOOPEND">
					<!--increment loop counter-->
					<SetVariable Target="CheckAttributes.LoopCounter">CheckAttributes.LoopCounter + 1</SetVariable>
				</TestStep>
				<TestStep>
					<!--check if loop finished-->
					<Compare>
						<Lower>
							<Value1>CheckAttributes.LoopCounter</Value1>
							<Value2>DeviceDescr.TxPdo.Count</Value2>
							<GotoStep>LOOPSTART</GotoStep>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep>
					<!--dump test result-->
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>false</Value2>
							<RaiseError Id="17">Test TxPdo(s) attributes failed.</RaiseError>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>true</Value2>
							<ReturnSuccess Id="18">Test TxPdo(s) attributes succeed.</ReturnSuccess>
						</Equal>
					</Compare>
				</TestStep>
			</TestCase>
			<TestCase Name="Check Index" CaseId="2">
				<?MAX_OUTPUT_ID 6?>
				<Description>
					<Purpose>Correct TxPDO index range</Purpose>
					<PreCondition>The device description contains at least one TxPDO element.</PreCondition>
					<Action>Check @Index</Action>
					<PostCondition>@Index shall be between 0x1A00 and 0x1BFF</PostCondition>
					<References>
						<Reference Specification="ETG.1000"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep>
					<!--Check if TxPdos are defined-->
					<Compare>
						<Equal>
							<Value1>DeviceDescr.TxPdo.Count</Value1>
							<Value2>0</Value2>
							<SkipCase Id="0">Test skipped no TxPdo defined.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<!--Skip Test for slave with device emulation-->
					<CallTestFunction Name="GetDeviceEmulationFlags">
						<!--if false the device emulation bit will be read out from the ESI file-->
						<Parameter>false</Parameter>
						<OutParameter>boolVar</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>boolVar</Value1>
							<Value2>true</Value2>
							<SkipCase Id="1">DuT is a simple device test skipped.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<!--Skip Test for SoE slaves-->
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Mailbox</Value1>
							<Value2>false</Value2>
							<GotoStep>INITLOOPCOUNTERVAR</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Mailbox.SoE</Value1>
							<Value2>true</Value2>
							<SkipCase Id="2">Pdo Index test is skipped for SoE slaves</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="INITLOOPCOUNTERVAR">
					<!--Init Loop CounterVariable-->
					<SetVariable Target="CheckIndex.LoopCounter">0</SetVariable>
				</TestStep>
				<TestStep>
					<!--Init Result Variable-->
					<SetVariable Target="result">true</SetVariable>
				</TestStep>
				<TestStep Name="LOOPSTART">
					<!--Dump loop start info-->
				</TestStep>
				<TestStep>
					<!--Check if Index is less than 0x1A00-->
					<Compare>
						<Lower>
							<Value1>DeviceDescr.TxPdo[CheckIndex.LoopCounter].Index</Value1>
							<Value2>6656</Value2>
							<WriteLine Id="3" Level="Error" Param0="CheckIndex.LoopCounter" Param1="DeviceDescr.TxPdo[CheckIndex.LoopCounter].Index">TxPdo[{0}].Index (0x{1:x4}) shall be between 0x1A00 and 0x1BFF</WriteLine>
						</Lower>
					</Compare>
					<Compare>
						<Lower>
							<Value1>DeviceDescr.TxPdo[CheckIndex.LoopCounter].Index</Value1>
							<Value2>6656</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep>
					<!--Check if Index is greater than 0x1BFF-->
					<Compare>
						<Greater>
							<Value1>DeviceDescr.TxPdo[CheckIndex.LoopCounter].Index</Value1>
							<Value2>7167</Value2>
							<WriteLine Id="4" Level="Error" Param0="CheckIndex.LoopCounter" Param1="DeviceDescr.TxPdo[CheckIndex.LoopCounter].Index">TxPdo[{0}].Index (0x{1:x4}) shall be between 0x1A00 and 0x1BFF</WriteLine>
						</Greater>
					</Compare>
					<Compare>
						<Greater>
							<Value1>DeviceDescr.TxPdo[CheckIndex.LoopCounter].Index</Value1>
							<Value2>7167</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Greater>
					</Compare>
				</TestStep>
				<TestStep Name="LOOPEND">
					<!--increment loop counter-->
					<SetVariable Target="CheckIndex.LoopCounter">CheckIndex.LoopCounter + 1</SetVariable>
				</TestStep>
				<TestStep>
					<!--check if loop finished-->
					<Compare>
						<Lower>
							<Value1>CheckIndex.LoopCounter</Value1>
							<Value2>DeviceDescr.TxPdo.Count</Value2>
							<GotoStep>LOOPSTART</GotoStep>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep>
					<!--dump test result-->
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>false</Value2>
							<RaiseError></RaiseError>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>true</Value2>
							<ReturnSuccess Id="6">All TxPdo indices are valid.</ReturnSuccess>
						</Equal>
					</Compare>
				</TestStep>
			</TestCase>
			<TestCase Name="Check SM assignment" CaseId="3">
				<?MAX_OUTPUT_ID 3?>
				<Description>
					<Purpose>Correct SyncManager assignment for TxPDOs</Purpose>
					<PreCondition>The device description contains at least one TxPDO element.</PreCondition>
					<Action>- @Mandatory == true
  test only @Sm
  1.) Is @Sm defined
  2.) Is .ExcludedSm defined
- @Mandatory == false
  iterate over all matching SyncManagers
  - referenced via @Sm
  - not excluded via .ExcludedSm
  - referenced via @Su

3.) @Sm match?
4.) Check @Virtual ?</Action>
					<PostCondition>1.) @Sm shall be defined
2.) .ExcludedSm should not be defined (the PDO is fixed assigned to @Sm)
3.) Directon/Type of shall @Sm match
4.) Valid if:
    - PDO is virtual AND SyncManager is virtual AND Entries defined
	- PDO is virtual AND SyncManager is not virtual and no Entries defined
    Error if SyncManager is @Sm else Warning

At least one valid SyncManager is defined.</PostCondition>
					<References>
						<Reference Specification="ETG.2000"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep>
					<!--Check if TxPdos are defined-->
					<Compare>
						<Equal>
							<Value1>DeviceDescr.TxPdo.Count</Value1>
							<Value2>0</Value2>
							<SkipCase Id="0">Test skipped no TxPdo defined.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<!--Init Loop CounterVariable-->
					<SetVariable Target="CheckSmAssignment.LoopCounter">0</SetVariable>
				</TestStep>
				<TestStep>
					<!--Init Result Variable-->
					<SetVariable Target="result">true</SetVariable>
				</TestStep>
				<TestStep Name="LOOPSTART">
					<!--Dump loop start info-->
					<WriteLine Id="1" Level="Output" Param0="CheckSmAssignment.LoopCounter" Param1="DeviceDescr.TxPdo[CheckSmAssignment.LoopCounter].Index">TxPdo[{0}] : 0x{1:x4} Sm assigment.</WriteLine>
				</TestStep>
				<TestStep>
					<!--Check if Referenced SM are valid-->
					<CallTestFunction Name="CheckTxPdoSmAssignment">
						<Parameter>CheckSmAssignment.LoopCounter</Parameter>
						<OutParameter>TmpResult</OutParameter>
					</CallTestFunction>
				</TestStep>
				<TestStep>
					<!--update result-->
					<Compare>
						<Equal>
							<Value1>TmpResult</Value1>
							<Value2>false</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="LOOPEND">
					<!--increment loop counter-->
					<SetVariable Target="CheckSmAssignment.LoopCounter">CheckSmAssignment.LoopCounter + 1</SetVariable>
				</TestStep>
				<TestStep>
					<!--check if loop finished-->
					<Compare>
						<Lower>
							<Value1>CheckSmAssignment.LoopCounter</Value1>
							<Value2>DeviceDescr.TxPdo.Count</Value2>
							<GotoStep>LOOPSTART</GotoStep>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep>
					<!--dump test result-->
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>false</Value2>
							<RaiseError Id="2">Test TxPdo(s) Sm assignment failed</RaiseError>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>true</Value2>
							<ReturnSuccess Id="3">Test TxPdo(s) Sm assignment succeed.</ReturnSuccess>
						</Equal>
					</Compare>
				</TestStep>
			</TestCase>
			<TestCase Name="Check Pdo entry Data Types" CaseId="4">
				<?MAX_OUTPUT_ID 18?>
				<Description>
					<Purpose>Validation of all TxPDO mapping entries of ESI file.</Purpose>
					<PreCondition>- TxPDO(s) shall be defined
</PreCondition>
					<Action>- checks entry count of each TxPdo element
- checks all existing entries of each defined TxPdo element
- compares the base data types to the bit length of each entry</Action>
					<PostCondition>- The DuT contains entries
- All DataType Entries shall provide the correct bit length</PostCondition>
					<References>
						<Reference Specification="ETG.2000" Chapter="5.6.7 Base Data Types"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="CheckTxPdoObjectsExists">
					<Compare>
						<Equal>
							<Value1>DeviceDescr.TxPdo.Count</Value1>
							<Value2>0</Value2>
							<SkipCase Id="0">Skipped case: Device does not have TxPDO objects.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="WriteDescTestBegins">
					<Description Id="1" Level="Verbose">Checking TxPDO element of ESI file...</Description>
				</TestStep>
				<TestStep Name="CheckPdoEntryCount">
					<Compare>
						<Equal>
							<Value1>DeviceDescr.TxPdo[int32CurrIndex].Entry.Count</Value1>
							<Value2>0</Value2>
							<WriteLine Id="2" Level="Verbose" Param0="DeviceDescr.TxPdo[int32CurrIndex].Index">PDO object 0x{0:x4}: No entry found</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.TxPdo[int32CurrIndex].Entry.Count</Value1>
							<Value2>0</Value2>
							<GotoStep>IncrementPdoIndex</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="WriteDescPdoObject">
					<Description Id="3" Level="Verbose" Param0="DeviceDescr.TxPdo[int32CurrIndex].Index" Param1="DeviceDescr.TxPdo[int32CurrIndex].Entry.Count">Checking {1} entr(y/ies) of PDO object 0x{0:x4}...</Description>
				</TestStep>
				<TestStep Name="ResetSubIndex">
					<SetVariable Target="int32CurrSubIndex">0</SetVariable>
				</TestStep>
				<TestStep Name="CheckIsGap">
					<Compare>
						<NotEqual>
							<Value1>DeviceDescr.TxPdo[int32CurrIndex].Entry[int32CurrSubIndex].Index</Value1>
							<Value2> 0</Value2>
							<GotoStep>CheckIfArrayBaseDataType</GotoStep>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="WriteGapEntry">
					<WriteLine Id="4" Level="Verbose" Param0="DeviceDescr.TxPdo[int32CurrIndex].Index" Param1="int32CurrSubIndex+1" Param2="DeviceDescr.TxPdo[int32CurrIndex].Entry[int32CurrSubIndex].BitLen">Entry 0x{0:x4}:{1} is a gap ({2}).</WriteLine>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>IncrementEntryIndex</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckIfArrayBaseDataType">
					<CallTestFunction Name="CheckForValidArrayDataType">
						<Parameter>DeviceDescr.TxPdo[int32CurrIndex].Entry[int32CurrSubIndex].DataType</Parameter>
						<OutParameter>boolComplexType</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>boolComplexType</Value1>
							<Value2>true</Value2>
							<GotoStep>CheckIfArrayBitLengthLarger31B</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckBaseDataTypeBitLen">
					<CallTestFunction Name="BaseDataType.CheckSize">
						<Parameter>DeviceDescr.TxPdo[int32CurrIndex].Entry[int32CurrSubIndex].BitLen</Parameter>
						<Parameter>DeviceDescr.TxPdo[int32CurrIndex].Entry[int32CurrSubIndex].DataType</Parameter>
						<OutParameter>StringBaseTypeErrorString</OutParameter>
					</CallTestFunction>
					<Compare>
						<NotEqual>
							<Value1>StringBaseTypeErrorString</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>WriteBaseDataTypeError</GotoStep>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="IncrementDataTypeSuccessfullCounter">
					<SetVariable Target="uint16SuccCount">uint16SuccCount+1</SetVariable>
					<WriteLine Id="5" Level="Verbose" Param0="DeviceDescr.TxPdo[int32CurrIndex].Index" Param1="int32CurrSubIndex+1" Param2="DeviceDescr.TxPdo[int32CurrIndex].Entry[int32CurrSubIndex].DataType" Param3="DeviceDescr.TxPdo[int32CurrIndex].Entry[int32CurrSubIndex].BitLen">Entry 0x{0:x4}:{1} has the DataType {2} and the right BitLength ({3}).</WriteLine>
				</TestStep>
				<TestStep Name="IncrementTestedCounter">
					<SetVariable Target="uint16TestedValues">uint16TestedValues+1</SetVariable>
				</TestStep>
				<TestStep Name="GoToNextEntry">
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>IncrementEntryIndex</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="WriteBaseDataTypeError">
					<WriteLine Id="6" Level="Error" Param0="DeviceDescr.TxPdo[int32CurrIndex].Index" Param1="int32CurrSubIndex+1" Param2="StringBaseTypeErrorString">Entry 0x{0:x4}:{1}: {2}</WriteLine>
				</TestStep>
				<TestStep Name="IncrementGeneralCounter">
					<SetVariable Target="uint16Errors">uint16Errors+1</SetVariable>
				</TestStep>
				<TestStep Name="IncrementDataTypeErrorCounter">
					<SetVariable Target="uint16ErrCount">uint16ErrCount+1</SetVariable>
				</TestStep>
				<TestStep Name="IncrementEntryIndex">
					<SetVariable Target="int32CurrSubIndex">int32CurrSubIndex+1</SetVariable>
					<Compare>
						<Lower>
							<Value1>int32CurrSubIndex</Value1>
							<Value2>DeviceDescr.TxPdo[int32CurrIndex].Entry.Count</Value2>
							<GotoStep>CheckIsGap</GotoStep>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep Name="GetAndWriteResult">
					<Compare>
						<NotEqual>
							<Value1>uint16ErrCount</Value1>
							<Value2>0</Value2>
							<WriteLine Id="7" Level="Output" Param0="DeviceDescr.TxPdo[int32CurrIndex].Index" Param1="uint16SuccCount" Param2="uint16ErrCount">PDO object 0x{0:x4}: {2} Entry data type(s) do not match to the expected bit length. {1} data type(s) match to the right bit length.</WriteLine>
						</NotEqual>
					</Compare>
					<Compare>
						<Equal>
							<Value1>(uint16SuccCount+uint16ErrCount)</Value1>
							<Value2>0</Value2>
							<WriteLine Id="8" Level="Output" Param0="DeviceDescr.TxPdo[int32CurrIndex].Index">PDO object 0x{0:x4}: No entry data type checked.</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>(uint16SuccCount+uint16ErrCount)</Value1>
							<Value2>0</Value2>
							<GotoStep>IncrementPdoIndex</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>uint16ErrCount</Value1>
							<Value2>0</Value2>
							<WriteLine Id="9" Level="Output" Param0="DeviceDescr.TxPdo[int32CurrIndex].Index" Param1="uint16SuccCount">PDO object 0x{0:x4}: All entry data type(s) ({1}) match to the expected bit length.</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="IncrementPdoIndex">
					<SetVariable Target="int32CurrIndex">int32CurrIndex+1</SetVariable>
				</TestStep>
				<TestStep Name="ResetSuccessCountForNextPdo">
					<SetVariable Target="uint16SuccCount">0</SetVariable>
				</TestStep>
				<TestStep Name="ResetErrorCountForNextPdo">
					<SetVariable Target="uint16ErrCount">0</SetVariable>
				</TestStep>
				<TestStep Name="GoToCheckNextPdo">
					<Compare>
						<Lower>
							<Value1>int32CurrIndex</Value1>
							<Value2>DeviceDescr.TxPdo.Count</Value2>
							<GotoStep>CheckPdoEntryCount</GotoStep>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep Name="ReturnTestResult">
					<Compare>
						<Greater>
							<Value1>uint16Errors</Value1>
							<Value2>0</Value2>
							<RaiseError Id="18"></RaiseError>
						</Greater>
					</Compare>
					<Compare>
						<Equal>
							<Value1>uint16TestedValues</Value1>
							<Value2>0</Value2>
							<SkipCase Id="11">Skipped case: No entry found.</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<ReturnSuccess Id="12" Param0="uint16TestedValues">All ({0}) entr(y/ies) of TxPDO object(s) match to the right bit length.</ReturnSuccess>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckIfArrayBitLengthLarger31B">
					<SetVariable Target="int32SavedSubIndex">int32CurrSubIndex</SetVariable>
				</TestStep>
				<TestStep>
					<SetVariable Target="Uint32ArrayBitLength">DeviceDescr.TxPdo[int32CurrIndex].Entry[int32CurrSubIndex].BitLen</SetVariable>
				</TestStep>
				<TestStep Name="CheckArrayIfSplittedBitSize">
					<SetVariable Target="int32CurrSubIndex">int32CurrSubIndex+1</SetVariable>
					<Compare>
						<GreaterOrEqual>
							<Value1>int32CurrSubIndex</Value1>
							<Value2>DeviceDescr.TxPdo[int32CurrIndex].Entry.Count</Value2>
							<GotoStep>ResetSubIndexAndGoBack</GotoStep>
						</GreaterOrEqual>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>DeviceDescr.TxPdo[int32CurrIndex].Entry[int32CurrSubIndex].Index</Value1>
							<Value2>0</Value2>
							<GotoStep>ResetSubIndexAndGoBack</GotoStep>
						</NotEqual>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>DeviceDescr.TxPdo[int32CurrIndex].Entry[int32CurrSubIndex].SubIndex</Value1>
							<Value2>0</Value2>
							<GotoStep>ResetSubIndexAndGoBack</GotoStep>
						</NotEqual>
					</Compare>
					<Compare>
						<Greater>
							<Value1>DeviceDescr.TxPdo[int32CurrIndex].Entry[int32CurrSubIndex].BitLen</Value1>
							<Value2>240</Value2>
							<WriteLine Id="13" Level="Warning" Param0="DeviceDescr.TxPdo[int32CurrIndex].Entry[int32CurrSubIndex].BitLen">Bit length of {0} is invalid. A Bit length greater than 240 Bits is not allowed.</WriteLine>
						</Greater>
					</Compare>
				</TestStep>
				<TestStep Name="CheckIfArrayEnd">
					<Compare>
						<NotEqual>
							<Value1>DeviceDescr.TxPdo[int32CurrIndex].Entry[int32CurrSubIndex].Index</Value1>
							<Value2>0</Value2>
							<GotoStep>DecreaseSubIndexAndCheckArrayDataTypeBitSize</GotoStep>
						</NotEqual>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>DeviceDescr.TxPdo[int32CurrIndex].Entry[int32CurrSubIndex].SubIndex</Value1>
							<Value2>0</Value2>
							<GotoStep>DecreaseSubIndexAndCheckArrayDataTypeBitSize</GotoStep>
						</NotEqual>
					</Compare>
					<Compare>
						<Greater>
							<Value1>DeviceDescr.TxPdo[int32CurrIndex].Entry[int32CurrSubIndex].BitLen</Value1>
							<Value2>240</Value2>
							<WriteLine Id="14" Level="Warning" Param0="DeviceDescr.TxPdo[int32CurrIndex].Entry[int32CurrSubIndex].BitLen">Bit length of {0} is invalid. A Bit length greater than 240 Bits is not allowed.</WriteLine>
						</Greater>
					</Compare>
				</TestStep>
				<TestStep>
					<SetVariable Target="Uint32ArrayBitLength">Uint32ArrayBitLength+DeviceDescr.TxPdo[int32CurrIndex].Entry[int32CurrSubIndex].BitLen</SetVariable>
					<Compare>
						<NotEqual>
							<Value1>DeviceDescr.TxPdo[int32CurrIndex].Entry[int32CurrSubIndex].BitLen</Value1>
							<Value2>240</Value2>
							<GotoStep>CheckArrayDataTypeBitSize</GotoStep>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep>
					<SetVariable Target="int32CurrSubIndex">int32CurrSubIndex+1</SetVariable>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>CheckIfArrayEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="DecreaseSubIndexAndCheckArrayDataTypeBitSize">
					<SetVariable Target="int32CurrSubIndex">int32CurrSubIndex-1</SetVariable>
				</TestStep>
				<TestStep Name="CheckArrayDataTypeBitSize">
					<CallTestFunction Name="BaseDataType.CheckSize">
						<Parameter>Uint32ArrayBitLength</Parameter>
						<Parameter>DeviceDescr.TxPdo[int32CurrIndex].Entry[int32SavedSubIndex].DataType</Parameter>
						<OutParameter>StringBaseTypeErrorString</OutParameter>
					</CallTestFunction>
					<Compare>
						<NotEqual>
							<Value1>StringBaseTypeErrorString</Value1>
							<Value2>EmptyString</Value2>
							<WriteLine Id="15" Level="Error" Param0="DeviceDescr.TxPdo[int32CurrIndex].Index" Param1="int32SavedSubIndex+1" Param2="StringBaseTypeErrorString">Entry 0x{0:x4}:{1}: {2}</WriteLine>
						</NotEqual>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>StringBaseTypeErrorString</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>IncrementGeneralCounter</GotoStep>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="WriteArrayDataTypeBitLengthSuccess">
					<SetVariable Target="uint16SuccCount">uint16SuccCount+1</SetVariable>
					<WriteLine Id="16" Level="Verbose" Param0="DeviceDescr.TxPdo[int32CurrIndex].Index" Param1="int32SavedSubIndex+1" Param2="DeviceDescr.TxPdo[int32CurrIndex].Entry[int32SavedSubIndex].DataType" Param3="Uint32ArrayBitLength">Entry 0x{0:x4}:{1} has the DataType {2} and the right BitLength ({3}).</WriteLine>
				</TestStep>
				<TestStep Name="CheckNextEntryWithDataType">
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>IncrementTestedCounter</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="ResetSubIndexAndGoBack">
					<SetVariable Target="int32CurrSubIndex">int32SavedSubIndex</SetVariable>
					<Compare>
						<Greater>
							<Value1>DeviceDescr.TxPdo[int32CurrIndex].Entry[int32CurrSubIndex].BitLen</Value1>
							<Value2>255</Value2>
							<WriteLine Id="17" Level="Output" Param0="DeviceDescr.TxPdo[int32CurrIndex].Entry[int32CurrSubIndex].BitLen" Param1="DeviceDescr.TxPdo[int32CurrIndex].Entry[int32CurrSubIndex].DataType">BitSize ({0}) of data type '{1}' is greater than 255.</WriteLine>
						</Greater>
					</Compare>
					<Compare>
						<Greater>
							<Value1>DeviceDescr.TxPdo[int32CurrIndex].Entry[int32CurrSubIndex].BitLen</Value1>
							<Value2>255</Value2>
							<GotoStep>WriteBaseDataTypeError</GotoStep>
						</Greater>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>CheckBaseDataTypeBitLen</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
			</TestCase>
			<TestCase Name="Check Pdo Default Size" CaseId="5">
				<?MAX_OUTPUT_ID 3?>
				<Description>
					<Purpose>Validation of the Pdo default bit size.</Purpose>
					<PreCondition>- TxPDO(s) shall be defined.</PreCondition>
					<Action>- checks PDO size according to the assigned sync manager
- checks description of assigned sync manager</Action>
					<PostCondition>- size of default assigned PDOs shall match the sync manager DefaultSize attribute
- PDOs marked as mandatory shall asiggned to an sync manager</PostCondition>
					<References>
						<Reference Specification="ETG.2000" Chapter="13.4 Device Type"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="CheckRxPdoObjectsExists">
					<Compare>
						<Equal>
							<Value1>DeviceDescr.TxPdo.Count</Value1>
							<Value2>0</Value2>
							<SkipCase Id="0">Test skipped no TxPdo defined.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CallFunctionCheckDefaultSize">
					<CallTestFunction Name="TxCheckPdSmDefaultSize">
						<OutParameter>uint16Errors</OutParameter>
					</CallTestFunction>
					<Compare>
						<Greater>
							<Value1>uint16Errors</Value1>
							<Value2>0</Value2>
							<GotoStep>RaiseError</GotoStep>
						</Greater>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<ReturnSuccess Id="1">Tested default size of assigned sync manager(s) successfull.</ReturnSuccess>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="RaiseError">
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<RaiseError Id="3"></RaiseError>
						</Equal>
					</Compare>
				</TestStep>
			</TestCase>
			<TestCase Name="Check Pdo Exclude" CaseId="6">
				<?MAX_OUTPUT_ID 4?>
				<Description>
					<Purpose>Validate .Exclude element of TxPdo</Purpose>
					<PreCondition>The device description contains at least one TxPDO element.</PreCondition>
					<Action>Check TxPDOs included in .Exclude</Action>
					<PostCondition>Each excluded TxPDO shall exclude the current TxPDO</PostCondition>
					<References>
						<Reference Specification=""></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep>
					<!--Check if TxPdos are defined-->
					<Compare>
						<Equal>
							<Value1>DeviceDescr.TxPdo.Count</Value1>
							<Value2>0</Value2>
							<SkipCase Id="0">Test skipped no TxPdo defined.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<!--Init Loop CounterVariable-->
					<SetVariable Target="CheckPdoExclude.LoopCounter">0</SetVariable>
				</TestStep>
				<TestStep>
					<!--Init Result Variable-->
					<SetVariable Target="result">true</SetVariable>
				</TestStep>
				<TestStep Name="LOOPSTART">
					<!--Dump loop start info-->
					<WriteLine Id="1" Level="Output" Param0="CheckPdoExclude.LoopCounter" Param1="DeviceDescr.TxPdo[CheckPdoExclude.LoopCounter].Index">Check TxPdo[{0}] : 0x{1:x4} Exclude element.</WriteLine>
				</TestStep>
				<TestStep>
					<!--Check if current Exclude element is valid-->
					<CallTestFunction Name="CheckTxPdoExcludeElement">
						<Parameter>CheckPdoExclude.LoopCounter</Parameter>
						<OutParameter>TmpResult</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>TmpResult</Value1>
							<Value2>false</Value2>
							<WriteLine Id="2" Level="Output">Exclude information of TxPdo[{0}] are invalid.</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<!--update result-->
					<Compare>
						<Equal>
							<Value1>TmpResult</Value1>
							<Value2>false</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="LOOPEND">
					<!--increment loop counter-->
					<SetVariable Target="CheckPdoExclude.LoopCounter">CheckPdoExclude.LoopCounter + 1</SetVariable>
				</TestStep>
				<TestStep>
					<!--check if loop finished-->
					<Compare>
						<Lower>
							<Value1>CheckPdoExclude.LoopCounter</Value1>
							<Value2>DeviceDescr.TxPdo.Count</Value2>
							<GotoStep>LOOPSTART</GotoStep>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep>
					<!--dump test result-->
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>false</Value2>
							<RaiseError Id="3">Test TxPdo.Exclude failed</RaiseError>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>true</Value2>
							<ReturnSuccess Id="4">Test TxPdo.Exclude succeed.</ReturnSuccess>
						</Equal>
					</Compare>
				</TestStep>
			</TestCase>
		</TestGroup>
		<TestGroup GroupId="9" Name="Fmmu Tests">
			<Comment>Check the correct usage and values of the Fmmu elements</Comment>
			<TestCase Name="ESC supported FMMUs" CaseId="1">
				<?MAX_OUTPUT_ID 4?>
				<Description>
					<Purpose>Check if defined FMMUs are supported by the ESC</Purpose>
					<PreCondition>At Least on FMMU element need to be defined in the device description.</PreCondition>
					<Action>Get number of supported FMMUs by the ESC.</Action>
					<PostCondition>The number of defined FMMUS shall be less or equal the number of FMMUs in defined regsiter 0x5.</PostCondition>
					<References>
						<Reference Specification="ETG.2000" Chapter=""></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="INIT_RESULT">
					<SetVariable Target="result">true</SetVariable>
				</TestStep>
				<TestStep Name="SKIP_IF_NO_FMMU_IS_DEFINED">
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Fmmu.Count</Value1>
							<Value2>0</Value2>
							<SkipCase Id="0">No FMMU defined.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="SKIP_IF_DEVICE_IS_OFFLINE">
					<CallTestFunction Name="Reset"></CallTestFunction>
				</TestStep>
				<TestStep Name="GET_ESC_FMMUs">
					<!--Get number of supported Fmmus by ESC-->
					<ReadEscData Target="u8EscFmmu">
						<Address>4</Address>
					</ReadEscData>
				</TestStep>
				<TestStep Name="CHECK_ALL_FMMUS_ARE_SUPPORTED">
					<Description Id="1" Level="Verbose" Param0="u8EscFmmu">ESC supports {0} FMMU(s).</Description>
					<Compare>
						<Lower>
							<Value1>u8EscFmmu</Value1>
							<Value2>DeviceDescr.Fmmu.Count</Value2>
							<WriteLine Id="2" Level="Error">The ESC supports less FMMUs than used in ESI file</WriteLine>
						</Lower>
					</Compare>
					<Compare>
						<Lower>
							<Value1>u8EscFmmu</Value1>
							<Value2>DeviceDescr.Fmmu.Count</Value2>
							<SetVariable Target="result">False</SetVariable>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep Name="DUMP_RESULT">
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>false</Value2>
							<RaiseError Id="3"></RaiseError>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>true</Value2>
							<ReturnSuccess Id="4">All defined FMMUs are supported.</ReturnSuccess>
						</Equal>
					</Compare>
				</TestStep>
			</TestCase>
			<TestCase Name="FMMU Names" CaseId="2">
				<?MAX_OUTPUT_ID 3?>
				<Description>
					<Purpose>Check if valid FMMU names are used</Purpose>
					<PreCondition>At Least on FMMU element need to be defined in the device description.</PreCondition>
					<Action>Read Fmmu name</Action>
					<PostCondition>Fmmu name "Outputs", "Inputs" or "MBoxState" shall be used.</PostCondition>
					<References>
						<Reference Specification="ETG.2000" Chapter=""></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="INIT_RESULT">
					<SetVariable Target="result">true</SetVariable>
				</TestStep>
				<TestStep Name="SKIP_IF_NO_FMMU_IS_DEFINED">
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Fmmu.Count</Value1>
							<Value2>0</Value2>
							<SkipCase Id="0">No FMMU defined.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="LOOP_START">
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Fmmu[FmmuIndex]</Value1>
							<Value2>EmptyString</Value2>
							<SetVariable Target="bIsMatch">false</SetVariable>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Fmmu[FmmuIndex]</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>DUMP_ERROR_IF_NAME_IS_INVALID</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Fmmu[FmmuIndex]</Value1>
							<Value2>null</Value2>
							<SetVariable Target="bIsMatch">false</SetVariable>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Fmmu[FmmuIndex]</Value1>
							<Value2>null</Value2>
							<GotoStep>DUMP_ERROR_IF_NAME_IS_INVALID</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CHECK_NAME_VALUE">
					<RegexIsMatch ReturnValue="bIsMatch">
						<Pattern>^(Inputs|Outputs|MBoxState|DynamicOutputs|DynamicInputs)$</Pattern>
						<InputString>DeviceDescr.Fmmu[FmmuIndex]</InputString>
					</RegexIsMatch>
				</TestStep>
				<TestStep Name="DUMP_ERROR_IF_NAME_IS_INVALID">
					<Compare>
						<Equal>
							<Value1>bIsMatch</Value1>
							<Value2>false</Value2>
							<WriteLine Id="1" Level="Error" Param0="DeviceDescr.Fmmu[FmmuIndex]" Param1="FmmuIndex">FMMU[{1}] name '{0}' is invallid.</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>bIsMatch</Value1>
							<Value2>false</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="LOOP_END">
					<SetVariable Target="FmmuIndex">FmmuIndex + 1</SetVariable>
					<Compare>
						<Lower>
							<Value1>FmmuIndex</Value1>
							<Value2>DeviceDescr.Fmmu.Count</Value2>
							<GotoStep>LOOP_START</GotoStep>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep Name="DUMP_RESULT">
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>false</Value2>
							<RaiseError Id="2"></RaiseError>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>true</Value2>
							<ReturnSuccess Id="3">All defined FMMU names are valid.</ReturnSuccess>
						</Equal>
					</Compare>
				</TestStep>
			</TestCase>
			<TestCase Name="FMMU 'MBoxState'" CaseId="3">
				<?MAX_OUTPUT_ID 9?>
				<Description>
					<Purpose>Check settings of 'MBoxState' FMMU elements</Purpose>
					<PreCondition>At Least on FMMU element need to be defined in the device description.</PreCondition>
					<Action>1.) Get all input mailbox SyncManager
2.) Get Fmmu@Sm
3.) Get Fmmu@OpOnly
4.) Get Fmmu@Su</Action>
					<PostCondition>1.) Number input mailbox SyncManager (MBoxIn) should match 'MBoxState' FMMUs
2.) Only input mailbox SyncManager shall be referenced
3.) Fmmu@OpOnly shall not be definde or false.
4.) Fmmu@Su shall not be defined</PostCondition>
					<References>
						<Reference Specification="ETG.2000" Chapter=""></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="SKIP_IF_NO_FMMU_IS_DEFINED">
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Fmmu.Count</Value1>
							<Value2>0</Value2>
							<SkipCase Id="0">No FMMU defined.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="INIT_RESULT">
					<SetVariable Target="result">true</SetVariable>
				</TestStep>
				<TestStep Name="GET_MBOXSTATE_FMMUs">
					<CallTestFunction Name="FMMU.CreateArray">
						<Parameter>MBoxState</Parameter>
						<OutParameter>u16ArrFmmu</OutParameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="GET_NUMBER_OF_FMMUs">
					<SizeOf UInt32Var="u16FmmuArrCount">u16ArrFmmu</SizeOf>
				</TestStep>
				<TestStep Name="GET_NUMBER_OF_MBOX_IN_SM">
					<CallTestFunction Name="GetSyncManagers">
						<!--SyncManager Filter-->
						<Parameter>MBoxIn</Parameter>
						<!--get all Syncmanager-->
						<Parameter>false</Parameter>
						<OutParameter>allMboxInSm</OutParameter>
					</CallTestFunction>
				</TestStep>
				<TestStep>
					<SizeOf UInt32Var="MboxInSmCount">allMboxInSm</SizeOf>
				</TestStep>
				<TestStep Name="SM_GREATER_FMMU">
					<Compare>
						<Greater>
							<Value1>MboxInSmCount</Value1>
							<Value2>u16FmmuArrCount</Value2>
							<SetVariable Target="abortMessage">One 'MBoxState' FMMU should be defined for each 'MBoxIn' SyncManager.</SetVariable>
						</Greater>
					</Compare>
					<Compare>
						<Greater>
							<Value1>MboxInSmCount</Value1>
							<Value2>u16FmmuArrCount</Value2>
							<CallTestFunction Name="DumpFmmuSyncManagerWarning">
								<Parameter>allMboxInSm</Parameter>
								<Parameter>abortMessage</Parameter>
							</CallTestFunction>
						</Greater>
					</Compare>
				</TestStep>
				<TestStep Name="CHECK_IF_MBOX_FMMU_DEFINED">
					<Compare>
						<Greater>
							<Value1>u16FmmuArrCount</Value1>
							<Value2>0</Value2>
							<GotoStep>CHECK_FMMU_SETTINGS</GotoStep>
						</Greater>
					</Compare>
				</TestStep>
				<TestStep Name="CHECK_IF_MBOX_IN_SM_DEFINED">
					<!--If no FMMU and no MBoxIn SyncManger defined => skip test-->
					<Compare>
						<Equal>
							<Value1>MboxInSmCount</Value1>
							<Value2>0</Value2>
							<SkipCase Id="1">No 'MBoxState' FMMU defined.</SkipCase>
						</Equal>
					</Compare>
					<!--If no FMMU and SyncManger defined => return-->
					<Compare>
						<Greater>
							<Value1>MboxInSmCount</Value1>
							<Value2>0</Value2>
							<ReturnSuccess Id="2">FMMU test passed.</ReturnSuccess>
						</Greater>
					</Compare>
				</TestStep>
				<TestStep Name="CHECK_FMMU_SETTINGS">
					<Description Id="3" Level="Verbose" Param0="u16ArrFmmu[FmmuIndex]">Check Settings of FMMU[{0}]</Description>
					<SetVariable Target="CurrentFMMU">u16ArrFmmu[FmmuIndex]</SetVariable>
				</TestStep>
				<TestStep Name="CHECK_OP_ONLY">
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Fmmu[CurrentFMMU].OpOnly</Value1>
							<Value2>true</Value2>
							<WriteLine Id="4" Level="Error" Param0="CurrentFMMU">Fmmu[{0}].OpOnly shall be false or not defined.</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Fmmu[CurrentFMMU].OpOnly</Value1>
							<Value2>true</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CHECK_SU">
					<Compare>
						<NotEqual>
							<Value1>DeviceDescr.Fmmu[CurrentFMMU].Su</Value1>
							<Value2>null</Value2>
							<WriteLine Id="5" Level="Error" Param0="CurrentFMMU">Fmmu[{0}].Su shall not not be defined.</WriteLine>
						</NotEqual>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>DeviceDescr.Fmmu[CurrentFMMU].Su</Value1>
							<Value2>null</Value2>
							<SetVariable Target="result">false</SetVariable>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="CHECK_SM">
					<Compare>
						<NotEqual>
							<Value1>DeviceDescr.Fmmu[CurrentFMMU].Sm</Value1>
							<Value2>null</Value2>
							<GotoStep>CHECK_SM_VALUE</GotoStep>
						</NotEqual>
					</Compare>
					<Compare>
						<LowerOrEqual>
							<Value1>MboxInSmCount</Value1>
							<Value2>1</Value2>
							<GotoStep>CHECK_SM_VALUE</GotoStep>
						</LowerOrEqual>
					</Compare>
				</TestStep>
				<TestStep Name="HANDLE_MORE_THAN_ONE_SM">
					<!--If more than one SM defined the element SM shall be used-->
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Fmmu[CurrentFMMU].Sm</Value1>
							<Value2>null</Value2>
							<WriteLine Id="6" Level="Error" Param0="CurrentFMMU">Fmmu[{0}].Sm shall be defined if more than one (non consecutive) SM are defined in the same direction.</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Fmmu[CurrentFMMU].Sm</Value1>
							<Value2>null</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Fmmu[CurrentFMMU].Sm</Value1>
							<Value2>null</Value2>
							<GotoStep>LOOP_END</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CHECK_SM_VALUE">
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Fmmu[CurrentFMMU].Sm</Value1>
							<Value2>null</Value2>
							<GotoStep>LOOP_END</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<CallTestFunction Name="ArrayOfUInt16.IndexOf">
						<Parameter>DeviceDescr.Fmmu[CurrentFMMU].Sm</Parameter>
						<Parameter>allMboxInSm</Parameter>
						<OutParameter>i32TmpVar</OutParameter>
					</CallTestFunction>
					<Compare>
						<Lower>
							<Value1>i32TmpVar</Value1>
							<Value2>0</Value2>
							<WriteLine Id="7" Level="Error" Param0="CurrentFMMU" Param1="DeviceDescr.Fmmu[CurrentFMMU].Sm">Fmmu[{0}].Sm ({1}) reference a non MBoxIn SyncManager.</WriteLine>
						</Lower>
					</Compare>
					<Compare>
						<Lower>
							<Value1>i32TmpVar</Value1>
							<Value2>0</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep Name="LOOP_END">
					<SetVariable Target="FmmuIndex">FmmuIndex + 1</SetVariable>
					<Compare>
						<Greater>
							<Value1>u16FmmuArrCount</Value1>
							<Value2>FmmuIndex</Value2>
							<GotoStep>CHECK_FMMU_SETTINGS</GotoStep>
						</Greater>
					</Compare>
				</TestStep>
				<TestStep Name="DUMP_RESULT">
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>false</Value2>
							<RaiseError Id="8"></RaiseError>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>true</Value2>
							<ReturnSuccess Id="9">FMMU test passed.</ReturnSuccess>
						</Equal>
					</Compare>
				</TestStep>
			</TestCase>
			<TestCase Name="FMMU 'Inputs'" CaseId="4">
				<?MAX_OUTPUT_ID 7?>
				<Description>
					<Purpose>Check settings of 'Inputs' FMMU elements</Purpose>
					<PreCondition>At Least on FMMU element need to be defined in the device description.</PreCondition>
					<Action>1.) Get all input SyncManager
2.) Get Fmmu@Sm</Action>
					<PostCondition>1.) Number input SyncManager (Inputs) should match 'Inputs' FMMUs
2.) Only input SyncManager shall be referenced</PostCondition>
					<References>
						<Reference Specification="ETG.2000" Chapter=""></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="SKIP_IF_NO_FMMU_IS_DEFINED">
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Fmmu.Count</Value1>
							<Value2>0</Value2>
							<SkipCase Id="0">No FMMU defined.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="INIT_RESULT">
					<SetVariable Target="result">true</SetVariable>
				</TestStep>
				<TestStep Name="GET_INPUTS_FMMUs">
					<CallTestFunction Name="FMMU.CreateArray">
						<Parameter>Inputs</Parameter>
						<OutParameter>u16ArrFmmu</OutParameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="GET_NUMBER_OF_FMMUs">
					<SizeOf UInt32Var="u16FmmuArrCount">u16ArrFmmu</SizeOf>
				</TestStep>
				<TestStep Name="GET_NUMBER_OF_INPUT_SM">
					<CallTestFunction Name="GetSyncManagers">
						<!--SyncManager Filter-->
						<Parameter>Inputs</Parameter>
						<!--only non consecutive Syncmanager shall be added-->
						<Parameter>true</Parameter>
						<OutParameter>allInputSm</OutParameter>
					</CallTestFunction>
				</TestStep>
				<TestStep>
					<SizeOf UInt32Var="inputSmCount">allInputSm</SizeOf>
				</TestStep>
				<TestStep Name="SM_GREATER_FMMU">
					<Compare>
						<Greater>
							<Value1>inputSmCount</Value1>
							<Value2>u16FmmuArrCount</Value2>
							<SetVariable Target="abortMessage">One 'Inputs' FMMU should be defined for each non consecutive 'Inputs' SyncManager.</SetVariable>
						</Greater>
					</Compare>
					<Compare>
						<Greater>
							<Value1>inputSmCount</Value1>
							<Value2>u16FmmuArrCount</Value2>
							<CallTestFunction Name="DumpFmmuSyncManagerWarning">
								<Parameter>allInputSm</Parameter>
								<Parameter>abortMessage</Parameter>
							</CallTestFunction>
						</Greater>
					</Compare>
				</TestStep>
				<TestStep Name="CHECK_IF_INPUTS_FMMU_DEFINED">
					<Compare>
						<Greater>
							<Value1>u16FmmuArrCount</Value1>
							<Value2>0</Value2>
							<GotoStep>CHECK_FMMU_SETTINGS</GotoStep>
						</Greater>
					</Compare>
				</TestStep>
				<TestStep Name="CHECK_IF_INPUTS_SM_DEFINED">
					<!--If no FMMU and no Inputs SyncManger defined => skip test-->
					<Compare>
						<Equal>
							<Value1>inputSmCount</Value1>
							<Value2>0</Value2>
							<SkipCase Id="1">No 'Inputs' FMMUs defined.</SkipCase>
						</Equal>
					</Compare>
					<!--If no FMMU and SyncManger defined => return-->
					<Compare>
						<NotEqual>
							<Value1>inputSmCount</Value1>
							<Value2>0</Value2>
							<ReturnSuccess Id="2">FMMU test passed.</ReturnSuccess>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="CHECK_FMMU_SETTINGS">
					<Description Id="3" Level="Verbose" Param0="u16ArrFmmu[FmmuIndex]">Check Settings of FMMU[{0}]</Description>
					<SetVariable Target="CurrentFMMU">u16ArrFmmu[FmmuIndex]</SetVariable>
				</TestStep>
				<TestStep Name="CHECK_SM">
					<Compare>
						<NotEqual>
							<Value1>DeviceDescr.Fmmu[CurrentFMMU].Sm</Value1>
							<Value2>null</Value2>
							<GotoStep>CHECK_SM_VALUE</GotoStep>
						</NotEqual>
					</Compare>
					<Compare>
						<LowerOrEqual>
							<Value1>inputSmCount</Value1>
							<Value2>1</Value2>
							<GotoStep>CHECK_SM_VALUE</GotoStep>
						</LowerOrEqual>
					</Compare>
				</TestStep>
				<TestStep Name="HANDLE_MORE_THAN_ONE_SM">
					<!--If more than one SM defined the element SM shall be used-->
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Fmmu[CurrentFMMU].Sm</Value1>
							<Value2>null</Value2>
							<WriteLine Id="4" Level="Error" Param0="CurrentFMMU">Fmmu[{0}].Sm shall be defined if more than one (non consecutive) SM are defined in the same direction.</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Fmmu[CurrentFMMU].Sm</Value1>
							<Value2>null</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CHECK_SM_VALUE">
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Fmmu[CurrentFMMU].Sm</Value1>
							<Value2>null</Value2>
							<GotoStep>LOOP_END</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<CallTestFunction Name="ArrayOfBytes.IndexOf">
						<Parameter>DeviceDescr.Fmmu[CurrentFMMU].Sm</Parameter>
						<Parameter>allInputSm</Parameter>
						<OutParameter>i32TmpVar</OutParameter>
					</CallTestFunction>
					<Compare>
						<Lower>
							<Value1>i32TmpVar</Value1>
							<Value2>0</Value2>
							<WriteLine Id="5" Level="Error" Param0="CurrentFMMU" Param1="DeviceDescr.Fmmu[CurrentFMMU].Sm">Fmmu[{0}].Sm ({1}) reference a non Inputs SyncManager.</WriteLine>
						</Lower>
					</Compare>
					<Compare>
						<Lower>
							<Value1>i32TmpVar</Value1>
							<Value2>0</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep Name="LOOP_END">
					<SetVariable Target="FmmuIndex">FmmuIndex + 1</SetVariable>
					<Compare>
						<Greater>
							<Value1>u16FmmuArrCount</Value1>
							<Value2>FmmuIndex</Value2>
							<GotoStep>CHECK_FMMU_SETTINGS</GotoStep>
						</Greater>
					</Compare>
				</TestStep>
				<TestStep Name="DUMP_RESULT">
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>false</Value2>
							<RaiseError Id="6"></RaiseError>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>true</Value2>
							<ReturnSuccess Id="7">FMMU test passed.</ReturnSuccess>
						</Equal>
					</Compare>
				</TestStep>
			</TestCase>
			<TestCase Name="FMMU 'Outputs'" CaseId="5">
				<?MAX_OUTPUT_ID 7?>
				<Description>
					<Purpose>Check settings of 'Outputs' FMMU elements</Purpose>
					<PreCondition>At Least on FMMU element need to be defined in the device description.</PreCondition>
					<Action>1.) Get all output SyncManager
2.) Get Fmmu@Sm</Action>
					<PostCondition>1.) Number input SyncManager (Outputs) should match 'Outputs' FMMUs
2.) Only output SyncManager shall be referenced</PostCondition>
					<References>
						<Reference Specification="ETG.2000" Chapter=""></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="SKIP_IF_NO_FMMU_IS_DEFINED">
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Fmmu.Count</Value1>
							<Value2>0</Value2>
							<SkipCase Id="0">No FMMU defined.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="INIT_RESULT">
					<SetVariable Target="result">true</SetVariable>
				</TestStep>
				<TestStep Name="GET_OUTPUTS_FMMUs">
					<CallTestFunction Name="FMMU.CreateArray">
						<Parameter>Outputs</Parameter>
						<OutParameter>u16ArrFmmu</OutParameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="GET_NUMBER_OF_FMMUs">
					<SizeOf UInt32Var="u16FmmuArrCount">u16ArrFmmu</SizeOf>
				</TestStep>
				<TestStep Name="GET_NUMBER_OF_OUTPUTs_SM">
					<CallTestFunction Name="GetSyncManagers">
						<!--SyncManager Filter-->
						<Parameter>Outputs</Parameter>
						<!--only non consecutive Syncmanager shall be added-->
						<Parameter>true</Parameter>
						<OutParameter>allOutputSm</OutParameter>
					</CallTestFunction>
				</TestStep>
				<TestStep>
					<SizeOf UInt32Var="outputSmCount">allOutputSm</SizeOf>
				</TestStep>
				<TestStep Name="SM_GREATER_FMMU">
					<Compare>
						<Greater>
							<Value1>outputSmCount</Value1>
							<Value2>u16FmmuArrCount</Value2>
							<SetVariable Target="abortMessage">One 'Outputs' FMMU should be defined for each non consecutive 'Outputs' SyncManager.</SetVariable>
						</Greater>
					</Compare>
					<Compare>
						<Greater>
							<Value1>outputSmCount</Value1>
							<Value2>u16FmmuArrCount</Value2>
							<CallTestFunction Name="DumpFmmuSyncManagerWarning">
								<Parameter>allOutputSm</Parameter>
								<Parameter>abortMessage</Parameter>
							</CallTestFunction>
						</Greater>
					</Compare>
				</TestStep>
				<TestStep Name="CHECK_IF_OUTPUTS_FMMU_DEFINED">
					<Compare>
						<Greater>
							<Value1>u16FmmuArrCount</Value1>
							<Value2>0</Value2>
							<GotoStep>CHECK_FMMU_SETTINGS</GotoStep>
						</Greater>
					</Compare>
				</TestStep>
				<TestStep Name="CHECK_IF_OUTPUTS_SM_DEFINED">
					<!--If no FMMU and no Output SyncManger defined => skip test-->
					<Compare>
						<Equal>
							<Value1>outputSmCount</Value1>
							<Value2>0</Value2>
							<SkipCase Id="1">No 'Outputs' FMMUs defined.</SkipCase>
						</Equal>
					</Compare>
					<!--If no FMMU and Output SyncManger defined => skip test-->
					<Compare>
						<NotEqual>
							<Value1>outputSmCount</Value1>
							<Value2>0</Value2>
							<ReturnSuccess Id="2">FMMU test passed.</ReturnSuccess>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="CHECK_FMMU_SETTINGS">
					<Description Id="3" Level="Verbose" Param0="u16ArrFmmu[FmmuIndex]">Check Settings of FMMU[{0}]</Description>
					<SetVariable Target="CurrentFMMU">u16ArrFmmu[FmmuIndex]</SetVariable>
				</TestStep>
				<TestStep Name="CHECK_SM">
					<Compare>
						<NotEqual>
							<Value1>DeviceDescr.Fmmu[CurrentFMMU].Sm</Value1>
							<Value2>null</Value2>
							<GotoStep>CHECK_SM_VALUE</GotoStep>
						</NotEqual>
					</Compare>
					<Compare>
						<LowerOrEqual>
							<Value1>outputSmCount</Value1>
							<Value2>1</Value2>
							<GotoStep>CHECK_SM_VALUE</GotoStep>
						</LowerOrEqual>
					</Compare>
				</TestStep>
				<TestStep Name="HANDLE_MORE_THAN_ONE_SM">
					<!--If more than one SM defined the element SM shall be used-->
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Fmmu[CurrentFMMU].Sm</Value1>
							<Value2>null</Value2>
							<WriteLine Id="4" Level="Error" Param0="CurrentFMMU">Fmmu[{0}].Sm shall be defined if more than one (non consecutive) SM are defined in the same direction.</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Fmmu[CurrentFMMU].Sm</Value1>
							<Value2>null</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CHECK_SM_VALUE">
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Fmmu[CurrentFMMU].Sm</Value1>
							<Value2>null</Value2>
							<GotoStep>LOOP_END</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<CallTestFunction Name="ArrayOfBytes.IndexOf">
						<Parameter>DeviceDescr.Fmmu[CurrentFMMU].Sm</Parameter>
						<Parameter>allOutputSm</Parameter>
						<OutParameter>i32TmpVar</OutParameter>
					</CallTestFunction>
					<Compare>
						<Lower>
							<Value1>i32TmpVar</Value1>
							<Value2>0</Value2>
							<WriteLine Id="5" Level="Error" Param0="CurrentFMMU" Param1="DeviceDescr.Fmmu[CurrentFMMU].Sm">Fmmu[{0}].Sm ({1}) reference a non Outputs SyncManager.</WriteLine>
						</Lower>
					</Compare>
					<Compare>
						<Lower>
							<Value1>i32TmpVar</Value1>
							<Value2>0</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep Name="LOOP_END">
					<SetVariable Target="FmmuIndex">FmmuIndex + 1</SetVariable>
					<Compare>
						<Greater>
							<Value1>u16FmmuArrCount</Value1>
							<Value2>FmmuIndex</Value2>
							<GotoStep>CHECK_FMMU_SETTINGS</GotoStep>
						</Greater>
					</Compare>
				</TestStep>
				<TestStep Name="DUMP_RESULT">
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>false</Value2>
							<RaiseError Id="6"></RaiseError>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>true</Value2>
							<ReturnSuccess Id="7">FMMU test passed.</ReturnSuccess>
						</Equal>
					</Compare>
				</TestStep>
			</TestCase>
			<TestCase Name="Process data length test" CaseId="6">
				<?MAX_OUTPUT_ID 12?>
				<Description>
					<PreCondition>- Slave has process data</PreCondition>
					<Action>- Check if the current process data length</Action>
					<PostCondition>- The length shall be multiple of one Byte
Otherwise the the FMMU would not write the full byte =&gt; no SM event is created</PostCondition>
					<References>
						<Reference></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="CheckIfFmmusDefined">
					<Description Id="0" Level="Verbose" Param0="DeviceDescr.Fmmu.Count">{0} FMMU(s) defined.</Description>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Fmmu.Count</Value1>
							<Value2>0</Value2>
							<SkipCase Id="1">No Fmmu defined.</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>Esc.DeviceEmulation</Value1>
							<Value2>true</Value2>
							<SkipCase Id="2">Device emulation is enabled.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="Reset">
					<CallTestFunction Name="Reset"></CallTestFunction>
				</TestStep>
				<TestStep Name="InitResult">
					<SetVariable Target="boolVar">true</SetVariable>
				</TestStep>
				<TestStep>
					<CallTestFunction Name="GetPreOpTimeout">
						<OutParameter>preOPTimeout</OutParameter>
					</CallTestFunction>
				</TestStep>
				<TestStep>
					<CallTestFunction Name="GetSafeOpOpTimeout">
						<OutParameter>safeOPTimeout</OutParameter>
					</CallTestFunction>
				</TestStep>
				<TestStep>
					<SetVariable Target="EsmTimeout">preOPTimeout + (2 * safeOPTimeout)</SetVariable>
				</TestStep>
				<TestStep Name="RunToOP">
					<RunToState Timeout="EsmTimeout" SendProcessData="true">
						<State>OP</State>
					</RunToState>
					<RaiseErrorOnFailure Id="3">Failed to Run to OP</RaiseErrorOnFailure>
				</TestStep>
				<TestStep Name="InitLoopCounter">
					<SetVariable Target="uInt32">0</SetVariable>
				</TestStep>
				<TestStep Name="LoopStart">
					<Description Id="4" Level="Verbose" Param0="uInt32" Param1="DeviceDescr.Fmmu[uInt32]">FMMU[{0}] '{1}'</Description>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Fmmu[uInt32]</Value1>
							<Value2>"Inputs"</Value2>
							<GotoStep>CheckIfEnabled</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Fmmu[uInt32]</Value1>
							<Value2>"Outputs"</Value2>
							<GotoStep>CheckIfEnabled</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>LoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckIfEnabled">
					<Description Id="5" Level="Output" Param0="uInt32">Check if FMMU {0} is enabled</Description>
					<SetVariable Target="uInt16">#x60C + (uInt32 * #x10)</SetVariable>
				</TestStep>
				<TestStep>
					<ReadEscData Target="byte">
						<Address>uInt16</Address>
					</ReadEscData>
					<Compare>
						<Equal>
							<Value1>byte</Value1>
							<Value2>0</Value2>
							<WriteLine Id="6" Level="Verbose" Param0="uInt32">FMMU[{0}] is disabled</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>byte</Value1>
							<Value2>0</Value2>
							<GotoStep>LoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="GetFmmuEndBit">
					<Description Id="7" Level="Output" Param0="uInt32">Check length of FMMU {0}</Description>
					<SetVariable Target="uInt16">#x607 + (uInt32 * #x10)</SetVariable>
				</TestStep>
				<TestStep>
					<Description Id="8" Level="Verbose" Param0="uInt16">Read register 0x{0:X}</Description>
					<ReadEscData Target="byte">
						<Address>uInt16</Address>
					</ReadEscData>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="9" Level="Verbose" Param0="uInt16" Param1="byte">Register 0x{0:X} : 0x{1}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>byte</Value1>
							<Value2>7</Value2>
							<SetVariable Target="boolVar">false</SetVariable>
						</NotEqual>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>byte</Value1>
							<Value2>7</Value2>
							<WriteLine Id="10" Level="Warning" Param0="uInt32">The process data handled via FMMU {0} shall be byte aligned.</WriteLine>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="LoopEnd">
					<SetVariable Target="uInt32">uInt32 + 1</SetVariable>
					<Compare>
						<Greater>
							<Value1>DeviceDescr.Fmmu.Count</Value1>
							<Value2>uInt32</Value2>
							<GotoStep>LoopStart</GotoStep>
						</Greater>
					</Compare>
				</TestStep>
				<TestStep Name="End">
					<Compare>
						<Equal>
							<Value1>boolVar</Value1>
							<Value2>true</Value2>
							<ReturnSuccess Id="11">Bit length tests succeed.</ReturnSuccess>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>boolVar</Value1>
							<Value2>false</Value2>
							<RaiseWarning Id="12">At least one Warning found</RaiseWarning>
						</Equal>
					</Compare>
				</TestStep>
			</TestCase>
		</TestGroup>
		<TestGroup GroupId="10" Name="Device DataType Tests">
			<Comment>Check the DataType definitions of the device.</Comment>
			<TestCase Name="All DataType Names" CaseId="1">
				<?MAX_OUTPUT_ID 4?>
				<Description>
					<PreCondition>The device provides an offline object dictionary.</PreCondition>
					<Action>Check name of DataTypes</Action>
					<PostCondition>The name shall be either:
- Base DataType listed in the ETG.1020
- DTxxxx
- DTxxxxARR
- DTxxxxENnn

xxxx is a 16Bit hex value (usually the object index)
nn is the number of Bits used for the Enum</PostCondition>
					<References>
						<Reference Specification="ETG.2000 ETG.1020"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep>
					<!--Skip Test if SoE Device-->
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Mailbox.SoE</Value1>
							<Value2>true</Value2>
							<SkipCase Id="0">Test skipped for SoE Devices.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="InitGlobalVariables">
					<CallTestFunction Name="InitGlobalVariablesForDataTypeTest"></CallTestFunction>
				</TestStep>
				<TestStep Name="INIT_RESULT">
					<!--"result" = true-->
					<SetVariable Target="result">true</SetVariable>
				</TestStep>
				<TestStep Name="INIT_LOOP_COUNTER">
					<!--"AllDataTypeNames.LoopCounter" = 1-->
					<SetVariable Target="AllDataTypeNames.LoopCounter">1</SetVariable>
				</TestStep>
				<TestStep Name="DataTypeLoopStart"></TestStep>
				<TestStep Name="CREATE_XPATH_FOR_DT_ELEMENT">
					<SetVariable Target="XPathDtTmp" Param0="XPathDt" Param1="AllDataTypeNames.LoopCounter">{0}[{1}]</SetVariable>
				</TestStep>
				<TestStep Name="CHECK_IF_LAST_ELEEMT">
					<GetXmlValue FileName="XmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="XPathDtTmp">{0}</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>DumpTestResult</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>DumpTestResult</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="GET_CURRENT_DT_NAME">
					<GetXmlValue FileName="XmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="XPathDtTmp">{0}/Name</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="1" Level="Verbose" Param0="strXmlValue">Check name {0}.</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<!--Check if fixed BaseDataType is used-->
					<RegexIsMatch ReturnValue="IsMatch">
						<Pattern>^(BOOL|BIT|BIT[1-8]|BYTE|BITARR8|BITARR16|WORD|BITARR32|DWORD|SINT|INT|INT24|DINT|INT40|INT48|INT56|LINT|USINT|UINT|UINT24|UDINT|UINT40|UINT48|UINT56|ULINT|REAL|LREAL|GUID)$</Pattern>
						<InputString>strXmlValue</InputString>
					</RegexIsMatch>
					<Compare>
						<Equal>
							<Value1>IsMatch</Value1>
							<Value2>true</Value2>
							<GotoStep>DataTypeLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<!--Check if "ARRAY [0...n] of BYTE|UINT" is used-->
					<RegexIsMatch ReturnValue="IsMatch">
						<Pattern>^(ARRAY \[0\.\.[0-9]+\] OF (BYTE|SINT|UINT|INT|DINT|UDINT))$</Pattern>
						<InputString>strXmlValue</InputString>
					</RegexIsMatch>
					<Compare>
						<Equal>
							<Value1>IsMatch</Value1>
							<Value2>true</Value2>
							<GotoStep>DataTypeLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<!--Check if "STRING(n)" is used-->
					<RegexIsMatch ReturnValue="IsMatch">
						<Pattern>^(STRING\([0-9]+\))$</Pattern>
						<InputString>strXmlValue</InputString>
					</RegexIsMatch>
					<Compare>
						<Equal>
							<Value1>IsMatch</Value1>
							<Value2>true</Value2>
							<GotoStep>DataTypeLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<!--Check if "DTxxxx" is used-->
					<RegexIsMatch ReturnValue="IsMatch">
						<Pattern>^(DT[0-9A-Fa-fXx]{1,4})$</Pattern>
						<InputString>strXmlValue</InputString>
					</RegexIsMatch>
					<Compare>
						<Equal>
							<Value1>IsMatch</Value1>
							<Value2>true</Value2>
							<GotoStep>DataTypeLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<!--Check if "DTxxxARR" is used-->
					<RegexIsMatch ReturnValue="IsMatch">
						<Pattern>^(DT[0-9A-Fa-fXx]{1,4}ARR)$</Pattern>
						<InputString>strXmlValue</InputString>
					</RegexIsMatch>
					<Compare>
						<Equal>
							<Value1>IsMatch</Value1>
							<Value2>true</Value2>
							<GotoStep>DataTypeLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<!--Check if "DTxxxENnn" is used-->
					<RegexIsMatch ReturnValue="IsMatch">
						<Pattern>^(DT[0-9A-Fa-fXx]{4}EN([0-9]{2}))$</Pattern>
						<InputString>strXmlValue</InputString>
					</RegexIsMatch>
					<Compare>
						<Equal>
							<Value1>IsMatch</Value1>
							<Value2>true</Value2>
							<GotoStep>DataTypeLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<!--No specified DataType name is used => Dump Error-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="2" Level="Error" Param0="strXmlValue">DataType name "{0}" is not valid.</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>DataTypeLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="DataTypeLoopEnd">
					<!--Increment loop counter-->
					<SetVariable Target="AllDataTypeNames.LoopCounter">AllDataTypeNames.LoopCounter + 1</SetVariable>
					<!--Goto Loop start-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>DataTypeLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="DumpTestResult">
					<!--Dump Test case result-->
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>true</Value2>
							<ReturnSuccess Id="3">DataType Name Test successful.</ReturnSuccess>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>false</Value2>
							<RaiseError></RaiseError>
						</Equal>
					</Compare>
				</TestStep>
			</TestCase>
			<TestCase Name="Check Access Flag" CaseId="2">
				<?MAX_OUTPUT_ID 6?>
				<Description>
					<PreCondition>The device provides an offline object dictionary.</PreCondition>
					<Action>Check if the write/read restriction "PreOp" is used</Action>
					<PostCondition>In case of an PreOP write/read restriction the syntax "PreOP" (not "PreOp") shall be used</PostCondition>
					<References>
						<Reference Specification="ETG.2000 ETG.1020"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep>
					<!--Skip Test if SoE Device-->
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Mailbox.SoE</Value1>
							<Value2>true</Value2>
							<SkipCase Id="0">Test skipped for SoE Devices.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="InitGlobalVariables">
					<CallTestFunction Name="InitGlobalVariablesForDataTypeTest"></CallTestFunction>
				</TestStep>
				<TestStep Name="INIT_RESULT">
					<!--"result" = true-->
					<SetVariable Target="result">true</SetVariable>
				</TestStep>
				<TestStep Name="INIT_LOOP_COUNTER">
					<!--"CheckAccessFlag.LoopCounter" = 1-->
					<SetVariable Target="CheckAccessFlag.LoopCounter">1</SetVariable>
				</TestStep>
				<TestStep Name="DataTypeLoopStart">
					<GetXmlValue FileName="XmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="XPathDt" Param1="CheckAccessFlag.LoopCounter">{0}[{1}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>END</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>END</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="InitSubItemLoopCounter">
					<SetVariable Target="i32TmpIndex">1</SetVariable>
				</TestStep>
				<TestStep Name="SubItemLoopStart">
					<GetXmlValue FileName="XmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="XPathDt" Param1="CheckAccessFlag.LoopCounter" Param2="i32TmpIndex">{0}[{1}]/SubItem[{2}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>DataTypeLoopEnd</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>DataTypeLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="GET_CURRENT_WriteRestriction">
					<GetXmlValue FileName="XmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="XPathDt" Param1="CheckAccessFlag.LoopCounter" Param2="i32TmpIndex">{0}[{1}]/SubItem[{2}]/Flags/Access/@WriteRestrictions</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="1" Level="Verbose" Param0="XPathDt" Param1="CheckAccessFlag.LoopCounter" Param2="i32TmpIndex" Param3="strXmlValue">Check {0}[{1}]/SubItem[{2}]/Flags/Access/@WriteRestrictions '{3}'.</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>PreOp</Value2>
							<WriteLine Id="2" Level="Error" Param0="strXmlValue" Param1="(CheckAccessFlag.LoopCounter-1)" Param2="(i32TmpIndex-1)">DataType[{1}].SubItem[{2}] WriteRestriction 'PreOp' is not valid use 'PreOP' instead.</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>PreOp</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="GET_CURRENT_ReadRestriction">
					<GetXmlValue FileName="XmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="XPathDt" Param1="CheckAccessFlag.LoopCounter" Param2="i32TmpIndex">{0}[{1}]/SubItem[{2}]/Flags/Access/@ReadRestrictions</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="3" Level="Verbose" Param0="XPathDt" Param1="CheckAccessFlag.LoopCounter" Param2="i32TmpIndex" Param3="strXmlValue">Check {0}[{1}]/SubItem[{2}]/Flags/Access/@ReadRestrictions '{3}'.</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>PreOp</Value2>
							<WriteLine Id="4" Level="Error" Param0="strXmlValue" Param1="(CheckAccessFlag.LoopCounter-1)" Param2="(i32TmpIndex-1)">DataType[{1}].SubItem[{2}] ReadRestriction 'PreOp' is not valid use 'PreOP' instead.</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>PreOp</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="SubItemLoopCounterEnd">
					<!--Increment loop counter-->
					<SetVariable Target="i32TmpIndex">i32TmpIndex + 1</SetVariable>
					<!--goto loop start by default -->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>SubItemLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="DataTypeLoopEnd">
					<!--Increment loop counter-->
					<SetVariable Target="CheckAccessFlag.LoopCounter">CheckAccessFlag.LoopCounter + 1</SetVariable>
					<!--Goto Loop start if counter is less than Number of DataTypes -->
					<!--goto loop start by default -->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>DataTypeLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="END">
					<!--Dump Test case result-->
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>true</Value2>
							<ReturnSuccess Id="5">DataType AccessType Test successful.</ReturnSuccess>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>false</Value2>
							<RaiseError></RaiseError>
						</Equal>
					</Compare>
				</TestStep>
			</TestCase>
			<TestCase Name="BaseDataTypes (fixed length)" CaseId="3">
				<?MAX_OUTPUT_ID 5?>
				<Description>
					<PreCondition>The device provides an offline object dictionary.</PreCondition>
					<Action>1.)Get BaseType, ArrayInfo, SubItem, EnumInfo
2.)Get BitSize</Action>
					<PostCondition>1.) Non of elements BaseType, ArrayInfo, SubItem, EnumInfo shall be defined

2.) BitSize shall match the specified DataType</PostCondition>
					<References>
						<Reference Specification="ETG.1020"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="InitGlobalVariables">
					<CallTestFunction Name="InitGlobalVariablesForDataTypeTest"></CallTestFunction>
				</TestStep>
				<TestStep Name="INIT_RESULT">
					<!--"result" = true-->
					<SetVariable Target="result">true</SetVariable>
				</TestStep>
				<TestStep Name="INIT_LOOP_COUNTER">
					<!--"BaseDataTypes.LoopCounter" = 1-->
					<SetVariable Target="BaseDataTypes.LoopCounter">1</SetVariable>
				</TestStep>
				<TestStep Name="DataTypeLoopStart"></TestStep>
				<TestStep Name="CREATE_XPATH_FOR_DT_ELEMENT">
					<SetVariable Target="XPathDtTmp" Param0="XPathDt" Param1="BaseDataTypes.LoopCounter">{0}[{1}]</SetVariable>
				</TestStep>
				<TestStep Name="CHECK_IF_ELEMENT_EXISTS">
					<GetXmlValue FileName="XmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="XPathDtTmp">{0}</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>END</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>END</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="GET_CURRENT_DT_NAME">
					<GetXmlValue FileName="XmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="XPathDtTmp">{0}/Name</XPath>
					</GetXmlValue>
				</TestStep>
				<TestStep>
					<!--Check if fixed BaseDataType is used-->
					<RegexIsMatch ReturnValue="IsMatch">
						<Pattern>^(BOOL|BIT|BIT[1-8]|BYTE|BITARR8|BITARR16|WORD|BITARR32|DWORD|SINT|INT|INT24|DINT|INT40|INT48|INT56|LINT|USINT|UINT|UINT24|UDINT|UINT40|UINT48|UINT56|ULINT|REAL|LREAL|GUID)$</Pattern>
						<InputString>strXmlValue</InputString>
					</RegexIsMatch>
					<Compare>
						<Equal>
							<Value1>IsMatch</Value1>
							<Value2>false</Value2>
							<GotoStep>DataTypeLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="FIXED_BASETYPE">
					<Description Id="0" Level="Output" Param0="strXmlValue">Check definition of "{0}".</Description>
					<!--Handle fixed base data type-->
					<CallTestFunction Name="CheckFixedBaseDataType">
						<Parameter>XmlFile</Parameter>
						<Parameter>XPathDtTmp</Parameter>
						<OutParameter>TmpResult</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>TmpResult</Value1>
							<Value2>false</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<SetVariable Target="AtLeastOneDtFound">true</SetVariable>
						</Equal>
					</Compare>
					<!--Test fixed base type definition finished-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>DataTypeLoopEnd</GotoStep>
						</Equal>
					</Compare>
					<!--Dump info if test was successful-->
					<Compare>
						<Equal>
							<Value1>TmpResult</Value1>
							<Value2>true</Value2>
							<WriteLine Id="1" Level="Output">DataType definition valid.</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="DataTypeLoopEnd">
					<!--Increment loop counter-->
					<SetVariable Target="BaseDataTypes.LoopCounter">BaseDataTypes.LoopCounter + 1</SetVariable>
					<!--goto loop header by default-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>DataTypeLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="END">
					<!--Dump Test case result-->
					<Compare>
						<Equal>
							<Value1>AtLeastOneDtFound</Value1>
							<Value2>false</Value2>
							<SkipCase Id="2">No "fixed" BaseDataType found.</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>true</Value2>
							<ReturnSuccess Id="3">DataType Test successful.</ReturnSuccess>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>false</Value2>
							<RaiseError Id="5"></RaiseError>
						</Equal>
					</Compare>
				</TestStep>
			</TestCase>
			<TestCase Name="BaseDataTypes (ARRAY [0..n] OF xxx)" CaseId="4">
				<?MAX_OUTPUT_ID 5?>
				<Description>
					<PreCondition>The device provides an offline object dictionary.</PreCondition>
					<Action>1.) Get SubItem, EnumInfo
2.) Get BaseType
3.) Get ArrayInfo
4.) Get BitSize</Action>
					<PostCondition>1.) Non of elements SubItem, EnumInfo shall be defined

2.) The BaseType shall match the DataType name
	ARRAY [0..n] OF BYTE : BYTE or USINT
	ARRAY [0..n] OF UINT : UINT
	ARRAY [0..n] OF INT : INT
	ARRAY [0..n] OF SINT : SINT
	ARRAY [0..n] OF DINT : DINT
	ARRAY [0..n] OF UDINT : UDINT


3.) ArrayInfo shall be defined. 
	ArrayInfo.LBound shall be 0
	ArrayInfo.Elements shall match n+1

4.) The BitSize shall match ArrayInfo.Elements * size of BaseType </PostCondition>
					<References>
						<Reference Specification="ETG.2000"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="InitGlobalVariables">
					<CallTestFunction Name="InitGlobalVariablesForDataTypeTest"></CallTestFunction>
				</TestStep>
				<TestStep Name="INIT_RESULT">
					<SetVariable Target="result">true</SetVariable>
				</TestStep>
				<TestStep Name="INIT_LOOP_COUNTER">
					<!--"BaseDataTypesArray.LoopCounter" = 1-->
					<SetVariable Target="BaseDataTypesArray.LoopCounter">1</SetVariable>
				</TestStep>
				<TestStep Name="DataTypeLoopStart"></TestStep>
				<TestStep Name="CREATE_XPATH_FOR_DT_ELEMENT">
					<SetVariable Target="XPathDtTmp" Param0="XPathDt" Param1="BaseDataTypesArray.LoopCounter">{0}[{1}]</SetVariable>
				</TestStep>
				<TestStep Name="CHECK_IF_ELEMENT_EXISTS">
					<GetXmlValue FileName="XmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="XPathDtTmp">{0}</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>END</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>END</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="GET_CURRENT_DT_NAME">
					<GetXmlValue FileName="XmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="XPathDtTmp">{0}/Name</XPath>
					</GetXmlValue>
				</TestStep>
				<TestStep>
					<!--Check if "ARRAY [0...n] of BYTE|UINT" is used-->
					<RegexIsMatch ReturnValue="IsMatch">
						<Pattern>^(ARRAY \[0\.\.[0-9]+\] OF (BYTE|SINT|UINT|INT|DINT|UDINT))$</Pattern>
						<InputString>strXmlValue</InputString>
					</RegexIsMatch>
					<Compare>
						<Equal>
							<Value1>IsMatch</Value1>
							<Value2>false</Value2>
							<GotoStep>DataTypeLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="ARRAY_BASETYPE">
					<Description Id="0" Level="Output" Param0="strXmlValue">Check definition of "{0}".</Description>
					<!--Handle array base data type-->
					<CallTestFunction Name="CheckArrayBaseDataType">
						<Parameter>XmlFile</Parameter>
						<Parameter>XPathDtTmp</Parameter>
						<OutParameter>TmpResult</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>TmpResult</Value1>
							<Value2>false</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Equal>
					</Compare>
					<!--Indicate that at least one DT found-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<SetVariable Target="AtLeastOneDtFound">true</SetVariable>
						</Equal>
					</Compare>
					<!--Dump info if test was successful-->
					<Compare>
						<Equal>
							<Value1>TmpResult</Value1>
							<Value2>true</Value2>
							<WriteLine Id="1" Level="Output">DataType definition valid.</WriteLine>
						</Equal>
					</Compare>
					<!--Test array base type definition finished-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>DataTypeLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="DataTypeLoopEnd">
					<!--Increment loop counter-->
					<SetVariable Target="BaseDataTypesArray.LoopCounter">BaseDataTypesArray.LoopCounter + 1</SetVariable>
					<!--goto loop header by default-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>DataTypeLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="END">
					<!--Dump Test case result-->
					<Compare>
						<Equal>
							<Value1>AtLeastOneDtFound</Value1>
							<Value2>false</Value2>
							<SkipCase Id="2">No "ARRAY" BaseDataType found.</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>true</Value2>
							<ReturnSuccess Id="3">DataType Test successful.</ReturnSuccess>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>false</Value2>
							<RaiseError Id="5"></RaiseError>
						</Equal>
					</Compare>
				</TestStep>
			</TestCase>
			<TestCase Name="BaseDataTypes (STRING(n))" CaseId="5">
				<?MAX_OUTPUT_ID 6?>
				<Description>
					<PreCondition>The device provides an offline object dictionary.</PreCondition>
					<Action>1.)Get BaseType, ArrayInfo, SubItem, EnumInfo
2.)Get BitSize</Action>
					<PostCondition>1.)Non of the Elements BaseType, ArrayInfo, SubItem, EnumInfo shall be defined
2.)The BitSize shall be n*8</PostCondition>
					<References>
						<Reference Specification="ETG.2000"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="InitGlobalVariables">
					<CallTestFunction Name="InitGlobalVariablesForDataTypeTest"></CallTestFunction>
				</TestStep>
				<TestStep Name="INIT_RESULT">
					<!--"result" = true-->
					<SetVariable Target="result">true</SetVariable>
				</TestStep>
				<TestStep Name="INIT_LOOP_COUNTER">
					<!--"BaseDataTypesString.LoopCounter" = 1-->
					<SetVariable Target="BaseDataTypesString.LoopCounter">1</SetVariable>
				</TestStep>
				<TestStep Name="DataTypeLoopStart"></TestStep>
				<TestStep Name="CREATE_XPATH_FOR_DT_ELEMENT">
					<SetVariable Target="XPathDtTmp" Param0="XPathDt" Param1="BaseDataTypesString.LoopCounter">{0}[{1}]</SetVariable>
				</TestStep>
				<TestStep Name="CHECK_IF_ELEMENT_EXISTS">
					<GetXmlValue FileName="XmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="XPathDtTmp">{0}</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>END</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>END</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="GET_CURRENT_DT_NAME">
					<GetXmlValue FileName="XmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="XPathDtTmp">{0}/Name</XPath>
					</GetXmlValue>
				</TestStep>
				<TestStep>
					<!--Check if "STRING(n)" is used-->
					<RegexIsMatch ReturnValue="IsMatch">
						<Pattern>^(STRING\([0-9]+\))$</Pattern>
						<InputString>strXmlValue</InputString>
					</RegexIsMatch>
					<Compare>
						<Equal>
							<Value1>IsMatch</Value1>
							<Value2>false</Value2>
							<GotoStep>DataTypeLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="STRING_BASETYPE">
					<Description Id="0" Level="Output" Param0="strXmlValue">Check definition of "{0}".</Description>
					<!--Handle string base data type-->
					<CallTestFunction Name="CheckStringBaseDataType">
						<Parameter>XmlFile</Parameter>
						<Parameter>XPathDtTmp</Parameter>
						<OutParameter>TmpResult</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="1" Param0="TmpResult" Level="Verbose">String(n) DataType test result : {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>TmpResult</Value1>
							<Value2>false</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Equal>
					</Compare>
					<!--Dump info if test was successful-->
					<Compare>
						<Equal>
							<Value1>TmpResult</Value1>
							<Value2>true</Value2>
							<WriteLine Id="2" Level="Output">DataType definition valid.</WriteLine>
						</Equal>
					</Compare>
					<!--Indicate that at least one DT was found-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<SetVariable Target="AtLeastOneDtFound">true</SetVariable>
						</Equal>
					</Compare>
					<!--Test string base type definition finished-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>DataTypeLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="DataTypeLoopEnd">
					<!--Increment loop counter-->
					<SetVariable Target="BaseDataTypesString.LoopCounter">BaseDataTypesString.LoopCounter + 1</SetVariable>
					<!--goto loop header-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>DataTypeLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="END">
					<!--Dump Test case result-->
					<Compare>
						<Equal>
							<Value1>AtLeastOneDtFound</Value1>
							<Value2>false</Value2>
							<SkipCase Id="3">No "STRING" BaseDataType found.</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>true</Value2>
							<ReturnSuccess Id="4">DataType Test successful.</ReturnSuccess>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>false</Value2>
							<RaiseError Id="6"></RaiseError>
						</Equal>
					</Compare>
				</TestStep>
			</TestCase>
			<TestCase Name="Array/Record DataTypes" CaseId="6">
				<?MAX_OUTPUT_ID 8?>
				<Description>
					<PreCondition>The device provides an offline object dictionary.</PreCondition>
					<Action>1.) DTxxxxARR
1a.) Get SubItem, EnumInfo
1b.) Get BaseType
1c.) Get ArrayInfo
1d.) Get BitSize

2.) DTxxxx
2a.) Get ArrayInfo, EnumInfo, BaseType
2b.) Get SubItem
2c.) Get BitSize</Action>
					<PostCondition>1a.) Non of elements SubItem, EnumInfo shall be defined
1b.) The BaseType shall be a Base DataType with a fixed length
1c.) ArrayInfo shall be defined. 
	ArrayInfo.LBound shall be 1
	ArrayInfo.Elements shall match n+1 and shall be less 256
1d.) The BitSize shall match ArrayInfo.Elements * size of BaseType 

2a.) Non of the Elements ArrayInfo, EnumInfo, BaseType shall be defined
2b.) At least two SubItems shall be defined
	- First SubItem:
	    SubIdx shall be 0
		Name shall be "SubIndex 000" or "Number of Entries"
		Type shall be "USINT"
		BitSize shall be 8
		BitOffs shall be 0
	- Second SubItem:
		BitOffs shall be 16
		Name shall not be empty
		BitSize shall match size of Type
		SubItem not defined (Array object)
			Type shall be DTxxxxARR
	-Following SubItems (only for record objects)
		BitOffs shall be at least greater than the following BitSize + BitOffs.
		Type shall be Base DataType
		Name shall not be empty
		BitSize shall match size of Type
			
2c.) The BitSize shall match the total size of the SubItems</PostCondition>
					<References>
						<Reference Specification="ETG.2000"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep>
					<!--Skip Test if SoE Device-->
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Mailbox.SoE</Value1>
							<Value2>true</Value2>
							<SkipCase Id="0">Test skipped for SoE Devices.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="InitGlobalVariables">
					<CallTestFunction Name="InitGlobalVariablesForDataTypeTest"></CallTestFunction>
				</TestStep>
				<TestStep Name="INIT_RESULT">
					<!--"result" = true-->
					<SetVariable Target="result">true</SetVariable>
				</TestStep>
				<TestStep Name="INIT_LOOP_COUNTER">
					<!--"BaseDataTypesRecord.LoopCounter" = 1-->
					<SetVariable Target="BaseDataTypesRecord.LoopCounter">1</SetVariable>
				</TestStep>
				<TestStep Name="DataTypeLoopStart"></TestStep>
				<TestStep Name="CREATE_XPATH_FOR_DT_ELEMENT">
					<SetVariable Target="XPathDtTmp" Param0="XPathDt" Param1="BaseDataTypesRecord.LoopCounter">{0}[{1}]</SetVariable>
				</TestStep>
				<TestStep Name="CHECK_IF_ELEMENT_EXISTS">
					<GetXmlValue FileName="XmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="XPathDtTmp">{0}</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>END</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>END</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="GET_CURRENT_DT_NAME">
					<GetXmlValue FileName="XmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="XPathDtTmp">{0}/Name</XPath>
					</GetXmlValue>
				</TestStep>
				<TestStep>
					<!--Check if "DTxxxx" is used-->
					<RegexIsMatch ReturnValue="IsMatch">
						<Pattern>^(DT[0-9A-Fa-fXx]{1,4})$</Pattern>
						<InputString>strXmlValue</InputString>
					</RegexIsMatch>
					<Compare>
						<Equal>
							<Value1>IsMatch</Value1>
							<Value2>true</Value2>
							<GotoStep>DTxxxx_TYPE</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<!--Check if "DTxxxARR" is used-->
					<RegexIsMatch ReturnValue="IsMatch">
						<Pattern>^(DT[0-9A-Fa-fXx]{1,4}ARR)$</Pattern>
						<InputString>strXmlValue</InputString>
					</RegexIsMatch>
					<Compare>
						<Equal>
							<Value1>IsMatch</Value1>
							<Value2>true</Value2>
							<GotoStep>DTxxxARR_TYPE</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<!--proceed with next DT-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>DataTypeLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="DTxxxx_TYPE">
					<Description Id="1" Level="Output" Param0="strXmlValue">Check definition of "{0}".</Description>
					<!--Handle DTxxx data type-->
					<CallTestFunction Name="CheckDTxxxxDataType">
						<Parameter>XmlFile</Parameter>
						<Parameter>XPathDtTmp</Parameter>
						<OutParameter>TmpResult</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>TmpResult</Value1>
							<Value2>false</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Equal>
					</Compare>
					<!--Dump info if test was successful-->
					<Compare>
						<Equal>
							<Value1>TmpResult</Value1>
							<Value2>true</Value2>
							<WriteLine Id="2" Level="Output">DataType definition valid.</WriteLine>
						</Equal>
					</Compare>
					<!--Indicate that at least one DT found-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<SetVariable Target="AtLeastOneDtFound">true</SetVariable>
						</Equal>
					</Compare>
					<!--Test DTxxx type definition finished-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>DataTypeLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="DTxxxARR_TYPE">
					<Description Id="3" Level="Output" Param0="strXmlValue">Check definition of "{0}".</Description>
					<!--Handle DTxxxARR data type-->
					<CallTestFunction Name="CheckDTxxxxARRDataType">
						<Parameter>XmlFile</Parameter>
						<Parameter>XPathDtTmp</Parameter>
						<OutParameter>TmpResult</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>TmpResult</Value1>
							<Value2>false</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Equal>
					</Compare>
					<!--Dump info if test was successful-->
					<Compare>
						<Equal>
							<Value1>TmpResult</Value1>
							<Value2>true</Value2>
							<WriteLine Id="4" Level="Output">DataType definition valid.</WriteLine>
						</Equal>
					</Compare>
					<!--Indicate that at least one DT found-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<SetVariable Target="AtLeastOneDtFound">true</SetVariable>
						</Equal>
					</Compare>
					<!--Test DTxxxARR type definition finished-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>DataTypeLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="DataTypeLoopEnd">
					<!--Increment loop counter-->
					<SetVariable Target="BaseDataTypesRecord.LoopCounter">BaseDataTypesRecord.LoopCounter + 1</SetVariable>
					<!--goto loop header-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>DataTypeLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="END">
					<!--Dump Test case result-->
					<Compare>
						<Equal>
							<Value1>AtLeastOneDtFound</Value1>
							<Value2>false</Value2>
							<SkipCase Id="5">No Array or Record DataType found.</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>true</Value2>
							<ReturnSuccess Id="6">DataType Test successful.</ReturnSuccess>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>false</Value2>
							<RaiseError Id="8"></RaiseError>
						</Equal>
					</Compare>
				</TestStep>
			</TestCase>
			<TestCase Name="Enum DataTypes" CaseId="7">
				<?MAX_OUTPUT_ID 6?>
				<Description>
					<PreCondition>The device provides an offline object dictionary.</PreCondition>
					<Action>1.)Get ArrayInfo, SubItem
2.)Get BitSize
3.)Get BaseType
4.)Get EnumInfo</Action>
					<PostCondition>1.)Non of the Elements ArrayInfo, SubItem shall be defined
2.)The BitSize shall equal nn and less or equal size of BaseType
3.)The BaseType shall be USINT, UINT or UDINT
4.)EnumInfo shall be defined
	EnumInfo.Enum shall be within the range of values limited by nn
	Enum.Text shall not be empty</PostCondition>
					<References>
						<Reference Specification="ETG.2000"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep>
					<!--Skip Test if SoE Device-->
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Mailbox.SoE</Value1>
							<Value2>true</Value2>
							<SkipCase Id="0">Test skipped for SoE Devices.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="InitGlobalVariables">
					<CallTestFunction Name="InitGlobalVariablesForDataTypeTest"></CallTestFunction>
				</TestStep>
				<TestStep Name="INIT_RESULT">
					<!--"result" = true-->
					<SetVariable Target="result">true</SetVariable>
				</TestStep>
				<TestStep Name="INIT_LOOP_COUNTER">
					<!--"BaseDataTypesEnum.LoopCounter" = 1-->
					<SetVariable Target="BaseDataTypesEnum.LoopCounter">1</SetVariable>
				</TestStep>
				<TestStep Name="DataTypeLoopStart"></TestStep>
				<TestStep Name="CREATE_XPATH_FOR_DT_ELEMENT">
					<SetVariable Target="XPathDtTmp" Param0="XPathDt" Param1="BaseDataTypesEnum.LoopCounter">{0}[{1}]</SetVariable>
				</TestStep>
				<TestStep Name="CHECK_IF_ELEMENT_EXISTS">
					<GetXmlValue FileName="XmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="XPathDtTmp">{0}</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>END</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>END</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="GET_CURRENT_DT_NAME">
					<GetXmlValue FileName="XmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="XPathDtTmp">{0}/Name</XPath>
					</GetXmlValue>
				</TestStep>
				<TestStep>
					<!--Check if "DTxxxENnn" is used-->
					<RegexIsMatch ReturnValue="IsMatch">
						<Pattern>^(DT[0-9A-Fa-fXx]{4}EN([0-9]{2}))$</Pattern>
						<InputString>strXmlValue</InputString>
					</RegexIsMatch>
					<Compare>
						<Equal>
							<Value1>IsMatch</Value1>
							<Value2>false</Value2>
							<GotoStep>DataTypeLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="DTxxxENnn_TYPE">
					<Description Id="1" Level="Output" Param0="strXmlValue">Check definition of "{0}".</Description>
					<!--Handle DTxxxENnn data type-->
					<CallTestFunction Name="CheckDTxxxxENnnDataType">
						<Parameter>XmlFile</Parameter>
						<Parameter>XPathDtTmp</Parameter>
						<OutParameter>TmpResult</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>TmpResult</Value1>
							<Value2>false</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Equal>
					</Compare>
					<!--Dump info if test was successful-->
					<Compare>
						<Equal>
							<Value1>TmpResult</Value1>
							<Value2>true</Value2>
							<WriteLine Id="2" Level="Output">DataType definition valid.</WriteLine>
						</Equal>
					</Compare>
					<!--Indicate that at least one DT found-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<SetVariable Target="AtLeastOneDtFound">true</SetVariable>
						</Equal>
					</Compare>
					<!--Test DTxxxENnn type definition finished-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>DataTypeLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="DataTypeLoopEnd">
					<!--Increment loop counter-->
					<SetVariable Target="BaseDataTypesEnum.LoopCounter">BaseDataTypesEnum.LoopCounter + 1</SetVariable>
					<!--goto loop header-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>DataTypeLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="END">
					<!--Dump Test case result-->
					<Compare>
						<Equal>
							<Value1>AtLeastOneDtFound</Value1>
							<Value2>false</Value2>
							<SkipCase Id="3">No Enum DataType found.</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>true</Value2>
							<ReturnSuccess Id="4">DataType Test successful.</ReturnSuccess>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>false</Value2>
							<RaiseError Id="6"></RaiseError>
						</Equal>
					</Compare>
				</TestStep>
			</TestCase>
		</TestGroup>
		<TestGroup GroupId="11" Name="Device Object Tests">
			<Comment>Check the Object definitions of the device.</Comment>
			<TestCase Name="General Object Attributes" CaseId="1">
				<?MAX_OUTPUT_ID 10?>
				<Description>
					<PreCondition>The device provides an offline object dictionary.</PreCondition>
					<Action>1.) Get the object Index
2.) Get the object Name</Action>
					<PostCondition>1.) The Index shall be between 0x1000 and 0xFFFF
2.) The Name shall not be empty</PostCondition>
					<References>
						<Reference Specification="ETG.2000 ETG.1020"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep>
					<!--Skip Test if SoE Device-->
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Mailbox.SoE</Value1>
							<Value2>true</Value2>
							<SkipCase Id="0">Test skipped for SoE Devices.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="InitGlobalVariables">
					<CallTestFunction Name="InitGlobalVariablesForObjectTests"></CallTestFunction>
				</TestStep>
				<TestStep Name="INIT_RESULT">
					<SetVariable Target="result">true</SetVariable>
				</TestStep>
				<TestStep Name="INIT_LOOP_COUNTER">
					<SetVariable Target="ObjectAttributes.LoopCounter">1</SetVariable>
				</TestStep>
				<TestStep Name="ObjectLoopStart"></TestStep>
				<TestStep Name="CREATE_XPATH_FOR_OBJ_ELEMENT">
					<SetVariable Target="XPathObjTmp" Param0="XPathObject" Param1="ObjectAttributes.LoopCounter">{0}[{1}]</SetVariable>
				</TestStep>
				<TestStep Name="CHECK_IF_ELEMENT_EXISTS">
					<GetXmlValue FileName="XmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="XPathObjTmp">{0}</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>END</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>END</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="GET_OBJ_INDEX">
					<GetXmlValue FileName="XmlFile" Markup="false" ReturnValue="ObjIndex">
						<XPath Param0="XPathObjTmp">{0}/Index</XPath>
					</GetXmlValue>
				</TestStep>
				<TestStep Name="COMPARE_OBJ_INDEX">
					<!--Dump an Error if no Object index is defined-->
					<Compare>
						<Equal>
							<Value1>ObjIndex</Value1>
							<Value2>null</Value2>
							<WriteLine Id="1" Level="Error" Param0="(ObjectAttributes.LoopCounter-1)">Object[{0}].Index shall be defined.</WriteLine>
						</Equal>
					</Compare>
					<!--Update Result-->
					<Compare>
						<Equal>
							<Value1>ObjIndex</Value1>
							<Value2>null</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Equal>
					</Compare>
					<!--goto "GET_OBJ_NAME"-->
					<Compare>
						<Equal>
							<Value1>ObjIndex</Value1>
							<Value2>null</Value2>
							<GotoStep>GET_OBJ_NAME</GotoStep>
						</Equal>
					</Compare>
					<!--Dump an error if the index is less 0x1000-->
					<Compare>
						<Lower>
							<Value1>ObjIndex</Value1>
							<Value2>#x1000</Value2>
							<WriteLine Id="2" Level="Error" Param0="(ObjectAttributes.LoopCounter-1)" Param1="ObjIndex">Object[{0}].Index ({1}) shall be within 0x1000 and 0xFFFF.</WriteLine>
						</Lower>
					</Compare>
					<!--Update Result-->
					<Compare>
						<Lower>
							<Value1>ObjIndex</Value1>
							<Value2>#x1000</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Lower>
					</Compare>
					<!--Dump valid Info-->
					<Compare>
						<GreaterOrEqual>
							<Value1>ObjIndex</Value1>
							<Value2>#x1000</Value2>
							<WriteLine Id="3" Level="Output" Param0="(ObjectAttributes.LoopCounter-1)" Param1="ObjIndex">Object[{0}].Index ({1}) is valid.</WriteLine>
						</GreaterOrEqual>
					</Compare>
				</TestStep>
				<TestStep Name="GET_OBJ_NAME">
					<GetXmlValue FileName="XmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="XPathObjTmp">{0}/Name</XPath>
					</GetXmlValue>
					<!--Dump an Error if no Object name is defined-->
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<WriteLine Id="4" Level="Error" Param0="(ObjectAttributes.LoopCounter-1)">Object[{0}] : No Name defined.</WriteLine>
						</Equal>
					</Compare>
					<!--Update Result-->
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Equal>
					</Compare>
					<!--goto "ObjectLoopEnd"-->
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>GET_OBJ_READ_RESTRICTION</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="COMPARE_OBJ_NAME">
					<!--Dump an Error if the Object name is empty-->
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<WriteLine Id="5" Level="Error" Param0="(ObjectAttributes.LoopCounter-1)">Object[{0}].Name shall not be empty.</WriteLine>
						</Equal>
					</Compare>
					<!--Update Result-->
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Equal>
					</Compare>
					<!--Write valid Info-->
					<Compare>
						<NotEqual>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<WriteLine Id="6" Level="Output" Param0="(ObjectAttributes.LoopCounter-1)" Param1="strXmlValue">Object[{0}].Name '{1}' is valid.</WriteLine>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="GET_OBJ_READ_RESTRICTION">
					<GetXmlValue FileName="XmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="XPathObjTmp">{0}/Flags/Access/@ReadRestrictions</XPath>
					</GetXmlValue>
					<!--goto "ObjectLoopEnd"-->
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>GET_OBJ_WRITE_RESTRICTION</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="COMPARE_READ_RESTRICTION">
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>"PreOp"</Value2>
							<WriteLine Id="7" Level="Error" Param0="(ObjectAttributes.LoopCounter-1)">Object[{0}]/Flags/Access/@ReadRestrictions shall not be'PreOp' (use 'PreOP' instead).</WriteLine>
						</Equal>
					</Compare>
					<!--Update Result-->
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>"PreOp"</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="GET_OBJ_WRITE_RESTRICTION">
					<GetXmlValue FileName="XmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="XPathObjTmp">{0}/Flags/Access/@WriteRestrictions</XPath>
					</GetXmlValue>
				</TestStep>
				<TestStep Name="COMPARE_WRITE_RESTRICTION">
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>"PreOp"</Value2>
							<WriteLine Id="8" Level="Error" Param0="(ObjectAttributes.LoopCounter-1)">Object[{0}]/Flags/Access/@WriteRestrictions shall not be'PreOp' (use 'PreOP' instead).</WriteLine>
						</Equal>
					</Compare>
					<!--Update Result-->
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>"PreOp"</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="ObjectLoopEnd">
					<!--Increment loop counter-->
					<SetVariable Target="ObjectAttributes.LoopCounter">ObjectAttributes.LoopCounter + 1</SetVariable>
					<!--goto loop header by default-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>ObjectLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="END">
					<!--Dump Test case result-->
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>true</Value2>
							<ReturnSuccess Id="9">Object indices and names are valid.</ReturnSuccess>
						</Equal>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>result</Value1>
							<Value2>true</Value2>
							<RaiseError Id="10"></RaiseError>
						</NotEqual>
					</Compare>
				</TestStep>
			</TestCase>
			<TestCase Name="Object DataType and BitSize" CaseId="2">
				<?MAX_OUTPUT_ID 7?>
				<Description>
					<PreCondition>The device provides an offline object dictionary.</PreCondition>
					<Action>1.) Get object Type
2.) Get object Bitsize</Action>
					<PostCondition>1.) The object Type shall be defined in the DataType list
2.) The Bitsize shall be equal to the DataType size</PostCondition>
					<References>
						<Reference Specification="ETG.2000 ETG.1020"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="InitGlobalVariables">
					<CallTestFunction Name="InitGlobalVariablesForObjectTests"></CallTestFunction>
				</TestStep>
				<TestStep Name="INIT_RESULT">
					<SetVariable Target="result">true</SetVariable>
				</TestStep>
				<TestStep Name="INIT_LOOP_COUNTER">
					<SetVariable Target="ObjectDataType.LoopCounter">1</SetVariable>
				</TestStep>
				<TestStep Name="ObjectLoopStart"></TestStep>
				<TestStep Name="CREATE_XPATH_FOR_OBJ_ELEMENT">
					<SetVariable Target="XPathObjTmp" Param0="XPathObject" Param1="ObjectDataType.LoopCounter">{0}[{1}]</SetVariable>
				</TestStep>
				<TestStep Name="CHECK_IF_ELEMENT_EXISTS">
					<GetXmlValue FileName="XmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="XPathObjTmp">{0}</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>END</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>END</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="GET_OBJ_INDEX">
					<GetXmlValue FileName="XmlFile" Markup="false" ReturnValue="ObjIndex">
						<XPath Param0="XPathObjTmp">{0}/Index</XPath>
					</GetXmlValue>
				</TestStep>
				<TestStep Name="GET_OBJ_DATATYPE">
					<GetXmlValue FileName="XmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="XPathObjTmp">{0}/Type</XPath>
					</GetXmlValue>
					<!--Dump an Error if no Type is defined-->
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<WriteLine Id="0" Level="Error" Param0="ObjIndex">0x{0:X4}.Type shall be defined.</WriteLine>
						</Equal>
					</Compare>
					<!--Update Result-->
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Equal>
					</Compare>
					<!--goto "ObjectLoopEnd"-->
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>ObjectLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CREATE_DT_PATH">
					<RegexReplace OutputString="XPathDtTmp">
						<Pattern>/Objects/Object</Pattern>
						<InputString>XPathObject</InputString>
						<ReplacementString>/DataTypes/DataType</ReplacementString>
					</RegexReplace>
				</TestStep>
				<TestStep Name="GET_TYPE_BITSIZE">
					<Description Id="1" Level="Verbose" Param0="strXmlValue" Param1="ObjIndex">0x{1:X4}.Type '{0}' get BitSize.</Description>
					<CallTestFunction Name="DataTypeName.GetBitSize">
						<Parameter>strXmlValue</Parameter>
						<Parameter>XmlFile</Parameter>
						<Parameter>XPathDtTmp</Parameter>
						<OutParameter>TypeBitSize</OutParameter>
					</CallTestFunction>
					<!--Dump an Error if DataType was not found-->
					<Compare>
						<Lower>
							<Value1>TypeBitSize</Value1>
							<Value2>0</Value2>
							<WriteLine Id="2" Level="Error" Param0="ObjIndex" Param1="strXmlValue">0x{0:X4}.Type "{1}" was not found in DataTypes element.</WriteLine>
						</Lower>
					</Compare>
					<!--Update Result-->
					<Compare>
						<Lower>
							<Value1>TypeBitSize</Value1>
							<Value2>0</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Lower>
					</Compare>
					<!--goto "ObjectLoopEnd"-->
					<Compare>
						<Lower>
							<Value1>TypeBitSize</Value1>
							<Value2>0</Value2>
							<GotoStep>ObjectLoopEnd</GotoStep>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep Name="GET_BITSIZE">
					<GetXmlValue FileName="XmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="XPathObjTmp">{0}/BitSize</XPath>
					</GetXmlValue>
					<!--Dump an Error if no Object BitSize is defined-->
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<WriteLine Id="3" Level="Error" Param0="(ObjectDataType.LoopCounter-1)">Object[{0}].BitSize shall be defined.</WriteLine>
						</Equal>
					</Compare>
					<!--Update Result-->
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Equal>
					</Compare>
					<!--goto "ObjectLoopEnd"-->
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>ObjectLoopEnd</GotoStep>
						</Equal>
					</Compare>
					<!--Convert String to Int32-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<SetVariable Target="ObjBitSize">strXmlValue</SetVariable>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="COMPARE_BITSIZE">
					<!--Dump an Error if the BitSize not match-->
					<Compare>
						<NotEqual>
							<Value1>TypeBitSize</Value1>
							<Value2>ObjBitSize</Value2>
							<WriteLine Id="4" Level="Error" Param0="ObjIndex" Param1="ObjBitSize" Param2="TypeBitSize">0x{0:X4}.BitSize ({1}) shall be equal to DataType BitSize ({2}).</WriteLine>
						</NotEqual>
					</Compare>
					<!--Update Result-->
					<Compare>
						<NotEqual>
							<Value1>TypeBitSize</Value1>
							<Value2>ObjBitSize</Value2>
							<SetVariable Target="result">false</SetVariable>
						</NotEqual>
					</Compare>
					<!--Dump an Output if data type matches-->
					<Compare>
						<Equal>
							<Value1>TypeBitSize</Value1>
							<Value2>ObjBitSize</Value2>
							<WriteLine Id="5" Level="Output" Param0="ObjIndex" Param1="ObjBitSize">0x{0:X4}.BitSize ({1}) matching data type bit size.</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="ObjectLoopEnd">
					<!--Increment loop counter-->
					<SetVariable Target="ObjectDataType.LoopCounter">ObjectDataType.LoopCounter + 1</SetVariable>
					<!--goto loop header by default-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>ObjectLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="END">
					<!--Dump Test case result-->
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>true</Value2>
							<ReturnSuccess Id="6">Object Type and BitSize are valid.</ReturnSuccess>
						</Equal>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>result</Value1>
							<Value2>true</Value2>
							<RaiseError Id="7"></RaiseError>
						</NotEqual>
					</Compare>
				</TestStep>
			</TestCase>
			<TestCase Name="Object Info (Variable)" CaseId="3">
				<?MAX_OUTPUT_ID 5?>
				<Description>
					<PreCondition>At least one object (Code: VARIABLE) is defined and includes an info element</PreCondition>
					<Action>1.) Get 'SubItem'
2.) Get 'DefaultData'
3.) Get 'MinData'
4.) Get 'MaxData'
5.) Get 'DefaultValue'
6.) Get 'MinValue'
7.) Get 'MaxValue'
8.) Get 'DefaultString'</Action>
					<PostCondition>1.) 'SubItem' shall not be defined
2.) 'DefaultData' shall not exceed the used DataType
3.) 'MinData' shall not exceed the used DataType
4.) 'MaxData' shall not exceed the used DataType
5.) 'DefaultValue' shall not exceed the used DataType and shall only used for DataType with a fixed length
6.) 'MinValue' shall not exceed the used DataType and shall only used for DataType with a fixed length
7.) 'MaxValue' shall not exceed the used DataType and shall only used for DataType with a fixed length
8.) 'DefaultString' shall not exceed the used DataType and shall only used for STRING(n)</PostCondition>
					<References>
						<Reference Specification="ETG.2000 ETG.1020"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="InitGlobalVariables">
					<CallTestFunction Name="InitGlobalVariablesForObjectTests"></CallTestFunction>
				</TestStep>
				<TestStep Name="INIT_LOOP_COUNTER">
					<SetVariable Target="ObjectInfoVar.LoopCounter">1</SetVariable>
				</TestStep>
				<TestStep Name="INIT_RESULT">
					<SetVariable Target="result">true</SetVariable>
				</TestStep>
				<TestStep Name="INIT_OBJ_FOUND">
					<SetVariable Target="ObjFound">false</SetVariable>
				</TestStep>
				<TestStep Name="ObjectLoopStart"></TestStep>
				<TestStep Name="CREATE_XPATH_FOR_OBJ_ELEMENT">
					<SetVariable Target="XPathObjTmp" Param0="XPathObject" Param1="ObjectInfoVar.LoopCounter">{0}[{1}]</SetVariable>
				</TestStep>
				<TestStep Name="CHECK_IF_ELEMENT_EXISTS">
					<GetXmlValue FileName="XmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="XPathObjTmp">{0}</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>END</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>END</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="GET_OBJ_DATATYPE">
					<GetXmlValue FileName="XmlFile" Markup="false" ReturnValue="BaseType">
						<XPath Param0="XPathObjTmp">{0}/Type</XPath>
					</GetXmlValue>
					<!--Dump an Error if no Type is defined-->
					<Compare>
						<Equal>
							<Value1>BaseType</Value1>
							<Value2>null</Value2>
							<WriteLine Id="0" Level="Verbose" Param0="(ObjectInfoVar.LoopCounter-1)">Object[{0}].Type shall be defined.</WriteLine>
						</Equal>
					</Compare>
					<!--goto "ObjectLoopEnd"-->
					<Compare>
						<Equal>
							<Value1>BaseType</Value1>
							<Value2>null</Value2>
							<GotoStep>ObjectLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CHECK_IF_BASE_TYPE">
					<RegexIsMatch ReturnValue="IsMatch">
						<Pattern>^(BOOL|BIT|BIT[1-8]|BYTE|BITARR8|BITARR16|WORD|BITARR32|DOWRD|SINT|INT|INT24|DINT|INT40|INT48|INT56|LINT|USINT|UINT|UINT24|UDINT|UINT40|UINT48|UINT56|ULINT|REAL|LREAL|(DT[0-9A-F]{1,4}EN([0-9]{2}))|(ARRAY \[0\.\.[0-9]+\] OF (BYTE|SINT|UINT|INT|DINT|UDINT))|(STRING\([0-9]+\)))$</Pattern>
						<InputString>BaseType</InputString>
					</RegexIsMatch>
					<Compare>
						<Equal>
							<Value1>IsMatch</Value1>
							<Value2>false</Value2>
							<GotoStep>ObjectLoopEnd</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>IsMatch</Value1>
							<Value2>true</Value2>
							<SetVariable Target="ObjFound">true</SetVariable>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="GET_OBJ_INDEX">
					<GetXmlValue FileName="XmlFile" Markup="false" ReturnValue="CurrentObjIndex">
						<XPath Param0="XPathObjTmp">{0}/Index</XPath>
					</GetXmlValue>
					<!--Dump an info if no index is defined-->
					<Compare>
						<Equal>
							<Value1>CurrentObjIndex</Value1>
							<Value2>null</Value2>
							<WriteLine Id="1" Level="Verbose" Param0="(ObjectInfoVar.LoopCounter-1)">Object[{0}].Index shall be defined.</WriteLine>
						</Equal>
					</Compare>
					<!--Skip if no Index is defined-->
					<Compare>
						<Equal>
							<Value1>CurrentObjIndex</Value1>
							<Value2>null</Value2>
							<GotoStep>ObjectLoopEnd</GotoStep>
						</Equal>
					</Compare>
					<!--Create Info String-->
					<Compare>
						<NotEqual>
							<Value1>CurrentObjIndex</Value1>
							<Value2>null</Value2>
							<SetVariable Target="strHexObjIndex" Param0="CurrentObjIndex">0x{0:X4}.Info</SetVariable>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="CREATE_INFO_PATH">
					<SetVariable Target="XPathInfo" Param0="XPathObjTmp">{0}/Info</SetVariable>
				</TestStep>
				<TestStep Name="GET_INFO_ELEMENT">
					<GetXmlValue FileName="XmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="XPathInfo">{0}</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>ObjectLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CHECK_IF_SUBITEM_IS_DEFINED">
					<!--For objects with no entries (Variable) no SubItem shall be defined-->
					<GetXmlValue FileName="XmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="XPathInfo">{0}/SubItem</XPath>
					</GetXmlValue>
					<Compare>
						<NotEqual>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<WriteLine Id="2" Level="Error" Param0="strHexObjIndex">{0}.Info shall have no SubItems.</WriteLine>
						</NotEqual>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<SetVariable Target="result">false</SetVariable>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="CheckInfoElement">
					<CallTestFunction Name="ValidateObjectInfoType">
						<Parameter>XPathInfo</Parameter>
						<Parameter>XmlFile</Parameter>
						<Parameter>BaseType</Parameter>
						<Parameter>strHexObjIndex</Parameter>
						<OutParameter>TmpResult</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>TmpResult</Value1>
							<Value2>false</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="ObjectLoopEnd">
					<!--Increment loop counter-->
					<SetVariable Target="ObjectInfoVar.LoopCounter">ObjectInfoVar.LoopCounter + 1</SetVariable>
					<!--goto loop header by default-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>ObjectLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="END">
					<!--Dump Test case result-->
					<Compare>
						<Equal>
							<Value1>ObjFound</Value1>
							<Value2>false</Value2>
							<SkipCase Id="3">No Variable object found.</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>true</Value2>
							<ReturnSuccess Id="4">Variable objects are valid</ReturnSuccess>
						</Equal>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>result</Value1>
							<Value2>true</Value2>
							<RaiseError Id="5"></RaiseError>
						</NotEqual>
					</Compare>
				</TestStep>
			</TestCase>
			<TestCase Name="Object Info (Array/Record)" CaseId="4">
				<?MAX_OUTPUT_ID 6?>
				<Description>
					<PreCondition>At least one object (Code: ARRAY/RECORD) is defined and includes an info element</PreCondition>
					<Action>1.) Get 'DefaultData'
2.) Get 'MinData'
3.) Get 'MaxData'
4.) Get 'DefaultValue'
5.) Get 'MinValue'
6.) Get 'MaxValue'
7.) Get 'DefaultString'
8.) Foreach 'SubItem'
	8.1.) Get 'DefaultData'
	8.2.) Get 'MinData'
	8.3.) Get 'MaxData'
	8.4.) Get 'DefaultValue'
	8.5.) Get 'MinValue'
	8.6.) Get 'MaxValue'
	8.7.) Get 'DefaultString'</Action>
					<PostCondition>1.) 'DefaultData' shall not exceed the used DataType
2.) 'MinData' shall not be defined
3.) 'MaxData' shall not be defined
4.) 'DefaultValue' shall not be defined
5.) 'MinValue' shall not be defined
6.) 'MaxValue' shall not be defined
7.) 'DefaultString' shall not be defined
8.) 'SubItem' shall not be defined
	8.1.) 'DefaultData' shall not exceed the used DataType
	8.2.) 'MinData' shall not exceed the used DataType
	8.3.) 'MaxData' shall not exceed the used DataType
	8.4.) 'DefaultValue' shall not exceed the used DataType and shall only used for DataType with a fixed length
	8.5.) 'MinValue' shall not exceed the used DataType and shall only used for DataType with a fixed length
	8.6.) 'MaxValue' shall not exceed the used DataType and shall only used for DataType with a fixed length
	8.7.) 'DefaultString' shall not exceed the used DataType and shall only used for STRING(n)</PostCondition>
					<References>
						<Reference Specification="ETG.2000 ETG.1020"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="SkipTestForSoe">
					<!--Skip Test if SoE Device-->
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Mailbox.SoE</Value1>
							<Value2>true</Value2>
							<SkipCase Id="0">Test skipped for SoE Devices.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="InitGlobalVariables">
					<CallTestFunction Name="InitGlobalVariablesForObjectTests"></CallTestFunction>
				</TestStep>
				<TestStep Name="INIT_LOOP_COUNTER">
					<SetVariable Target="ObjectInfoArrRec.LoopCounter">1</SetVariable>
				</TestStep>
				<TestStep Name="INIT_RESULT">
					<SetVariable Target="result">true</SetVariable>
				</TestStep>
				<TestStep Name="INIT_OBJ_FOUND">
					<SetVariable Target="ObjFound">false</SetVariable>
				</TestStep>
				<TestStep Name="ObjectLoopStart"></TestStep>
				<TestStep Name="CREATE_XPATH_FOR_OBJ_ELEMENT">
					<SetVariable Target="XPathObjTmp" Param0="XPathObject" Param1="ObjectInfoArrRec.LoopCounter">{0}[{1}]</SetVariable>
				</TestStep>
				<TestStep Name="CHECK_IF_ELEMENT_EXISTS">
					<GetXmlValue FileName="XmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="XPathObjTmp">{0}</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>DumpTestResult</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>DumpTestResult</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="GET_OBJ_DATATYPE">
					<GetXmlValue FileName="XmlFile" Markup="false" ReturnValue="BaseType">
						<XPath Param0="XPathObjTmp">{0}/Type</XPath>
					</GetXmlValue>
					<!--Dump an Error if no Type is defined-->
					<Compare>
						<Equal>
							<Value1>BaseType</Value1>
							<Value2>null</Value2>
							<WriteLine Id="1" Level="Verbose" Param0="(ObjectInfoArrRec.LoopCounter-1)">Object[{0}].Type shall be defined.</WriteLine>
						</Equal>
					</Compare>
					<!--goto "ObjectLoopEnd"-->
					<Compare>
						<Equal>
							<Value1>BaseType</Value1>
							<Value2>null</Value2>
							<GotoStep>ObjectLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="SKIP_IF_BASE_TYPE">
					<RegexIsMatch ReturnValue="IsMatch">
						<Pattern>^(BOOL|BIT|BIT[1-8]|BYTE|BITARR8|BITARR16|WORD|BITARR32|DOWRD|SINT|INT|INT24|DINT|INT40|INT48|INT56|LINT|USINT|UINT|UINT24|UDINT|UINT40|UINT48|UINT56|ULINT|REAL|LREAL|(DT[0-9A-F]{1,4}EN([0-9]{2}))|(ARRAY \[0\.\.[0-9]+\] OF (BYTE|SINT|UINT|INT|DINT|UDINT))|(STRING\([0-9]+\)))$</Pattern>
						<InputString>BaseType</InputString>
					</RegexIsMatch>
					<Compare>
						<Equal>
							<Value1>IsMatch</Value1>
							<Value2>true</Value2>
							<GotoStep>ObjectLoopEnd</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>IsMatch</Value1>
							<Value2>false</Value2>
							<SetVariable Target="ObjFound">true</SetVariable>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="GET_OBJ_INDEX">
					<GetXmlValue FileName="XmlFile" Markup="false" ReturnValue="CurrentObjIndex">
						<XPath Param0="XPathObjTmp">{0}/Index</XPath>
					</GetXmlValue>
					<!--Dump an info if no index is defined-->
					<Compare>
						<Equal>
							<Value1>CurrentObjIndex</Value1>
							<Value2>null</Value2>
							<WriteLine Id="2" Level="Verbose" Param0="(ObjectInfoArrRec.LoopCounter-1)">Object[{0}].Index shall be defined.</WriteLine>
						</Equal>
					</Compare>
					<!--Skip if no Index is defined-->
					<Compare>
						<Equal>
							<Value1>CurrentObjIndex</Value1>
							<Value2>null</Value2>
							<GotoStep>ObjectLoopEnd</GotoStep>
						</Equal>
					</Compare>
					<!--Create Info String-->
					<Compare>
						<NotEqual>
							<Value1>CurrentObjIndex</Value1>
							<Value2>null</Value2>
							<SetVariable Target="strHexObjIndex" Param0="CurrentObjIndex">0x{0:X4}.Info</SetVariable>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="CREATE_INFO_PATH">
					<SetVariable Target="XPathInfo" Param0="XPathObjTmp">{0}/Info</SetVariable>
				</TestStep>
				<TestStep Name="GET_INFO_ELEMENT">
					<GetXmlValue FileName="XmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="XPathInfo">{0}</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>ObjectLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CHECK_INFO_ELEMENT">
					<!--Call ValidateObjectInfoType (all elements except of the SubItem elements will be checked)-->
					<CallTestFunction Name="ValidateObjectInfoType">
						<Parameter>XPathInfo</Parameter>
						<Parameter>XmlFile</Parameter>
						<Parameter>BaseType</Parameter>
						<Parameter>strHexObjIndex</Parameter>
						<OutParameter>TmpResult</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>TmpResult</Value1>
							<Value2>false</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CREATE_SUBITEM_PATH">
					<SetVariable Target="strXmlValue" Param0="XPathInfo">{0}/SubItem</SetVariable>
				</TestStep>
				<TestStep Name="CHECK_SUBITEM">
					<CallTestFunction Name="ValidateSubItemElements">
						<Parameter>strXmlValue</Parameter>
						<Parameter>XmlFile</Parameter>
						<Parameter>BaseType</Parameter>
						<Parameter>strHexObjIndex</Parameter>
						<OutParameter>TmpResult</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>TmpResult</Value1>
							<Value2>false</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="ObjectLoopEnd">
					<!--Increment loop counter-->
					<SetVariable Target="ObjectInfoArrRec.LoopCounter">ObjectInfoArrRec.LoopCounter + 1</SetVariable>
					<!--goto loop header by default-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>ObjectLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="DumpTestResult">
					<!--Dump Test case result-->
					<Compare>
						<Equal>
							<Value1>ObjFound</Value1>
							<Value2>false</Value2>
							<SkipCase Id="3">No Variable object found.</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>true</Value2>
							<ReturnSuccess Id="4">Variable objects are valid</ReturnSuccess>
						</Equal>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>result</Value1>
							<Value2>true</Value2>
							<RaiseError Id="6"></RaiseError>
						</NotEqual>
					</Compare>
				</TestStep>
			</TestCase>
		</TestGroup>
		<TestGroup GroupId="12" Name="SyncManager Tests">
			<Comment>Check the Sm definitions of the device.</Comment>
			<TestCase Name="Text" CaseId="1">
				<?MAX_OUTPUT_ID 3?>
				<Comment>checks if Text of element Device : Sm[i] is correct</Comment>
				<Description>
					<Purpose>checks if [Text] of element Device : Sm[FHa_i] is correct</Purpose>
					<PreCondition>--</PreCondition>
					<Action>checks if [Text] of element Device : Sm[FHa_i] is correct</Action>
					<PostCondition>Error if [Text] is not "Inputs", "Outputs", "MBoxOut", or "MBoxIn"</PostCondition>
					<References>
						<Reference Specification="ETG.2000" Chapter="13.4 DeviceType"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep>
					<!--FHa_Error = false-->
					<SetVariable Target="FHa_Error">False</SetVariable>
				</TestStep>
				<TestStep>
					<!--FHa_i = 0-->
					<SetVariable Target="FHa_i">0</SetVariable>
				</TestStep>
				<TestStep>
					<!--If (DeviceDescr.SM.Count == 0)
   SkipCase-->
					<Compare>
						<Equal>
							<Value1>DeviceDescr.SM.Count</Value1>
							<Value2>0</Value2>
							<SkipCase Id="0">No Sm element defined -&gt; test skipped</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="Iteration">
					<!--show [Text]-->
					<WriteLine Id="1" Param0="FHa_i" Param1="DeviceDescr.SM[FHa_i]" Level="Verbose">Testing entry {0}. [Text] of Sm: {1}</WriteLine>
				</TestStep>
				<TestStep>
					<!--If (Name == null|| Name == EmptyString)
   ...-->
					<Compare>
						<Equal>
							<Value1>DeviceDescr.SM[FHa_i]</Value1>
							<Value2>null</Value2>
							<SetVariable Target="FHa_BoolTemp1">false</SetVariable>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.SM[FHa_i]</Value1>
							<Value2>null</Value2>
							<GotoStep>ResultDump</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.SM[FHa_i]</Value1>
							<Value2>EmptyString</Value2>
							<SetVariable Target="FHa_BoolTemp1">false</SetVariable>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.SM[FHa_i]</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>ResultDump</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<!--If (Name != Outputs|Inputs|MBoxOut|MBoxIn)
   ...-->
					<RegexIsMatch ReturnValue="FHa_BoolTemp1">
						<Pattern>^(Outputs|Inputs|MBoxOut|MBoxIn|DynamicOutputs|DynamicInputs)$</Pattern>
						<InputString>DeviceDescr.SM[FHa_i]</InputString>
					</RegexIsMatch>
				</TestStep>
				<TestStep Name="ResultDump">
					<!--...
   set FHa_Error = true   
   show error message-->
					<Compare>
						<Equal>
							<Value1>FHa_BoolTemp1</Value1>
							<Value2>False</Value2>
							<SetVariable Target="FHa_Error">True</SetVariable>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>FHa_BoolTemp1</Value1>
							<Value2>False</Value2>
							<WriteLine Id="2" Param0="FHa_i" Level="Error">Sm{0} has no valid [Text]</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<!--FHa_i++

If (FHa_i < OpMode.Count)
   next step-->
					<SetVariable Target="FHa_i">FHa_i+1</SetVariable>
					<Compare>
						<Greater>
							<Value1>DeviceDescr.SM.Count</Value1>
							<Value2>FHa_i</Value2>
							<GotoStep>Iteration</GotoStep>
						</Greater>
					</Compare>
				</TestStep>
				<TestStep>
					<!--if (FHa_Error == true)
   raise Error-->
					<Compare>
						<Equal>
							<Value1>FHa_Error</Value1>
							<Value2>True</Value2>
							<RaiseError Id="3"></RaiseError>
						</Equal>
					</Compare>
				</TestStep>
			</TestCase>
			<TestCase Name="Sm Order" CaseId="2">
				<?MAX_OUTPUT_ID 2?>
				<Comment>checks if Sm elements are in correct order</Comment>
				<Description>
					<Purpose>checks if Sm elements are in correct order</Purpose>
					<PreCondition>--</PreCondition>
					<Action>checks if Sm elements are in correct order</Action>
					<PostCondition>Error if order is not (MBoxOut -&gt; MBoxIn) -&gt; (Outputs) -&gt; Inputs</PostCondition>
					<References>
						<Reference Specification="ETG.2000" Chapter=""></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep>
					<CallTestFunction Name="IsSimpleDevice">
						<OutParameter>deviceEmulation</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>deviceEmulation</Value1>
							<Value2>true</Value2>
							<SkipCase Id="0"></SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<!--FHa_Error = false-->
					<SetVariable Target="FHa_Error">False</SetVariable>
				</TestStep>
				<TestStep>
					<!--If (DeviceDescr.SM.Count == 0)
   SkipCase-->
					<Compare>
						<Equal>
							<Value1>DeviceDescr.SM.Count</Value1>
							<Value2>0</Value2>
							<SkipCase Id="1">No Sm element defined -&gt; test skipped</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<CallTestFunction Name="CheckSmOrder">
						<OutParameter>FHa_Error</OutParameter>
					</CallTestFunction>
				</TestStep>
				<TestStep>
					<!--if (FHa_Error == true)
   raise Error-->
					<Compare>
						<Equal>
							<Value1>FHa_Error</Value1>
							<Value2>True</Value2>
							<RaiseError Id="2"></RaiseError>
						</Equal>
					</Compare>
				</TestStep>
			</TestCase>
			<TestCase Name="SyncMan start addresses" CaseId="3">
				<?MAX_OUTPUT_ID 1?>
				<Comment>Info: Take the default length and checks for overlapping Sync Manager. \nError: If a start address is in the range of the previous SM.</Comment>
				<Description>
					<Purpose>A overlapping Sync Manager default configuration shall be avoided.</Purpose>
					<PreCondition>The DuT supports at least 2 Sync Manager</PreCondition>
					<Action>Calculation of the length, start address and end address of each enabled Sync Manager
Comparision of the end and start addresses of Sync Manager n and n+1</Action>
					<PostCondition>The Sync Manager addresses shall not overlap</PostCondition>
					<References>
						<Reference Specification="ETG.2000" Chapter=""></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep>
					<Compare>
						<LowerOrEqual>
							<Value1>DeviceDescr.SM.Count</Value1>
							<Value2>1</Value2>
							<GotoStep>End</GotoStep>
						</LowerOrEqual>
					</Compare>
				</TestStep>
				<TestStep>
					<SetVariable Target="index">0</SetVariable>
				</TestStep>
				<TestStep Name="CheckEnable">
					<Compare>
						<Equal>
							<Value1>DeviceDescr.SM[index].Enable</Value1>
							<Value2>false</Value2>
							<GotoStep>IncrementIndex</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<CallFunction>GetSmLength</CallFunction>
				</TestStep>
				<TestStep>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.SM[index].StartAddress</Value1>
							<Value2>null</Value2>
							<WriteLine Id="0" Param0="index" Param1="DeviceDescr.SM[index].StartAddress" Level="Verbose">SM[{0}] skipped. SM[{0}].StartAddress is null.</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.SM[index].StartAddress</Value1>
							<Value2>null</Value2>
							<GotoStep>IncrementIndex</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<AddArrayItem TargetArray="arrStrtEndAddr">DeviceDescr.SM[index].StartAddress</AddArrayItem>
				</TestStep>
				<TestStep>
					<SetVariable Target="smLen">DeviceDescr.SM[index].StartAddress+smLen-1</SetVariable>
				</TestStep>
				<TestStep>
					<AddArrayItem TargetArray="arrStrtEndAddr">smLen</AddArrayItem>
				</TestStep>
				<TestStep Name="IncrementIndex">
					<SetVariable Target="index">index+1</SetVariable>
				</TestStep>
				<TestStep>
					<Compare>
						<Lower>
							<Value1>index</Value1>
							<Value2>DeviceDescr.SM.Count</Value2>
							<GotoStep>CheckEnable</GotoStep>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep>
					<CallFunction>CheckStrtAddrs</CallFunction>
				</TestStep>
				<TestStep Name="End">
					<WriteLine Id="1" Level="Success">No overlapping Sync Manager found</WriteLine>
				</TestStep>
			</TestCase>
			<TestCase Name="SyncMan default size" CaseId="4">
				<?MAX_OUTPUT_ID 5?>
				<Comment>Info: Checks the default size of each  Sync Manager. \nError: If a default size is greater than the max size, If the default size is lower than the min size.</Comment>
				<Description>
					<Purpose>The Sync Manager default size shall not be greater than the max size and not lower than the min size.</Purpose>
					<PreCondition>The DuT supports at least one Sync Manager with default, min and max length</PreCondition>
					<Action>Comparision of the correspondin ESI elements</Action>
					<PostCondition>The Sync Manager default length shall be between min and max</PostCondition>
					<References>
						<Reference Specification="ETG.2000" Chapter=""></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep>
					<Compare>
						<LowerOrEqual>
							<Value1>DeviceDescr.SM.Count</Value1>
							<Value2>1</Value2>
							<GotoStep>End</GotoStep>
						</LowerOrEqual>
					</Compare>
				</TestStep>
				<TestStep>
					<SetVariable Target="index">0</SetVariable>
				</TestStep>
				<TestStep Name="CheckEnableAndSizesAvailable">
					<Compare>
						<Equal>
							<Value1>DeviceDescr.SM[index].Enable</Value1>
							<Value2>false</Value2>
							<GotoStep>IncrementIndex</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.SM[index].MinSize</Value1>
							<Value2>null</Value2>
							<WriteLine Id="0" Param0="index">MinSize of Sm[{0}] is not defined. </WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.SM[index].MinSize</Value1>
							<Value2>null</Value2>
							<GotoStep>IncrementIndex</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.SM[index].MaxSize</Value1>
							<Value2>null</Value2>
							<WriteLine Id="1" Param0="index">MaxSize of Sm[{0}] is not defined. </WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.SM[index].MaxSize</Value1>
							<Value2>null</Value2>
							<GotoStep>IncrementIndex</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.SM[index].DefaultSize</Value1>
							<Value2>null</Value2>
							<WriteLine Id="2" Param0="index">DefaultSize of Sm[{0}] is not defined. </WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.SM[index].DefaultSize</Value1>
							<Value2>null</Value2>
							<GotoStep>IncrementIndex</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<Compare>
						<Lower>
							<Value1>DeviceDescr.SM[index].DefaultSize</Value1>
							<Value2>DeviceDescr.SM[index].MinSize</Value2>
							<RaiseError Id="3" Param0="index">DefaultSize of Sm[{0}] is lower than the MinSize</RaiseError>
						</Lower>
					</Compare>
					<Compare>
						<Greater>
							<Value1>DeviceDescr.SM[index].DefaultSize</Value1>
							<Value2>DeviceDescr.SM[index].MaxSize</Value2>
							<RaiseError Id="4" Param0="index">DefaultSize of Sm[{0}] is greater than the MaxSize</RaiseError>
						</Greater>
					</Compare>
				</TestStep>
				<TestStep Name="IncrementIndex">
					<SetVariable Target="index">index+1</SetVariable>
				</TestStep>
				<TestStep>
					<Compare>
						<Lower>
							<Value1>index</Value1>
							<Value2>DeviceDescr.SM.Count</Value2>
							<GotoStep>CheckEnableAndSizesAvailable</GotoStep>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep Name="End">
					<WriteLine Id="5" Level="Success">No invalid Sync Manager sizes found</WriteLine>
				</TestStep>
			</TestCase>
			<TestCase Name="SM@Enable" CaseId="5">
				<?MAX_OUTPUT_ID 3?>
				<Comment>Check Sm@Enable Value</Comment>
				<Description>
					<Purpose>Check if the correct Sm@Enable value is used.</Purpose>
					<PreCondition>Sm elements need to be defined.</PreCondition>
					<Action>Get Sm@Enable value.</Action>
					<PostCondition>The value shall either be 0 or 1.</PostCondition>
					<References>
						<Reference Specification="ETG.2000" Chapter=""></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="INIT_LOOP_COUNTER">
					<!--"SmEnable.LoopCounter" = 1-->
					<SetVariable Target="SmEnable.LoopCounter">1</SetVariable>
				</TestStep>
				<TestStep Name="INIT_RESULT">
					<SetVariable Target="result">true</SetVariable>
				</TestStep>
				<TestStep Name="SKIP_IF_NO_SM_DEFINED">
					<Compare>
						<LowerOrEqual>
							<Value1>DeviceDescr.SM.Count</Value1>
							<Value2>0</Value2>
							<SkipCase Id="0">No 'Sm' element defined. Skip Test.</SkipCase>
						</LowerOrEqual>
					</Compare>
				</TestStep>
				<TestStep Name="LOOP_START">
					<SetVariable Target="XPathTmp" Param0="SmEnable.LoopCounter">Sm[{0}]/@Enable</SetVariable>
				</TestStep>
				<TestStep Name="START">
					<GetXmlValue ReturnValue="strXmlValue" Markup="true" FileName="EmptyString">
						<XPath Param0="XPathTmp">{0}</XPath>
					</GetXmlValue>
				</TestStep>
				<TestStep Name="CHECK_IF_DEFINED">
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>LOOP_END</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>LOOP_END</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CHECK_IF_VALID">
					<RegexIsMatch ReturnValue="IsMatch">
						<Pattern>^(#x)?(1|0)$</Pattern>
						<InputString>strXmlValue</InputString>
					</RegexIsMatch>
					<Compare>
						<NotEqual>
							<Value1>IsMatch</Value1>
							<Value2>true</Value2>
							<WriteLine Id="1" Level="Error" Param0="(SmEnable.LoopCounter - 1)" Param1="strXmlValue">Device.Sm[{0}]@Enable ({1}) shall be 1 or 0.</WriteLine>
						</NotEqual>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>IsMatch</Value1>
							<Value2>true</Value2>
							<SetVariable Target="result">false</SetVariable>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="LOOP_END">
					<SetVariable Target="SmEnable.LoopCounter">SmEnable.LoopCounter + 1</SetVariable>
					<Compare>
						<LowerOrEqual>
							<Value1>SmEnable.LoopCounter</Value1>
							<Value2>DeviceDescr.SM.Count</Value2>
							<GotoStep>LOOP_START</GotoStep>
						</LowerOrEqual>
					</Compare>
				</TestStep>
				<TestStep Name="END">
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>true</Value2>
							<ReturnSuccess Id="2">Device.Sm@Enable definition valid.</ReturnSuccess>
						</Equal>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>result</Value1>
							<Value2>true</Value2>
							<RaiseError Id="3"></RaiseError>
						</NotEqual>
					</Compare>
				</TestStep>
			</TestCase>
		</TestGroup>
		<TestGroup GroupId="13" Name="Explicit Device Identification">
			<Comment>Expl Device ID tests</Comment>
			<TestCase Name="Support ID Reg134 mandatory if Reg12 available" CaseId="1">
				<?MAX_OUTPUT_ID 7?>
				<Description>
					<Purpose>- Skip if ESI eleemnt Info, Info:IdentificationAdo are available
- Skip if IdentificationAdo no 0x0012
- If IdentificationAdo= 0x0012 then verifiy that IdentificationReg134 is TRUE
- Retrun warning if not.</Purpose>
					<PreCondition></PreCondition>
					<Action></Action>
					<PostCondition></PostCondition>
					<References>
						<Reference Specification="ETG.1020" Chapter="Explicit Device Identification"></Reference>
						<Reference Specification="ETG.1020" Chapter="Clause InfoType"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep>
					<Description Id="0" Level="Verbose">Check if ESI elements Info available</Description>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Info</Value1>
							<Value2>false</Value2>
							<SkipCase Id="1">IdentifcationAdo is not 0x0012</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Info.IdentificationAdo</Value1>
							<Value2>null</Value2>
							<SkipCase Id="2">IdentifcationAdo is not 0x0012</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<Description Id="3" Level="Verbose">Check if IdentificationAdo = 0x12. Retrun waning if IdentifcatoniReg134 not set</Description>
					<Compare>
						<NotEqual>
							<Value1>DeviceDescr.Info.IdentificationAdo</Value1>
							<Value2>#x0012</Value2>
							<SkipCase Id="4">IdentifcationAdo is not 0x0012</SkipCase>
						</NotEqual>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Info.IdentificationReg134</Value1>
							<Value2>null</Value2>
							<RaiseWarning Id="5">DuT supports the Legacy Mode of Explicit Device Identification (ESI element Info:IdentificationAdo = 0x0012). Also Requesting Mechanism (ESI element Info:IdentificationReg134) should be supported. This may become mandatory in the future. </RaiseWarning>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Info.IdentificationReg134</Value1>
							<Value2>false</Value2>
							<RaiseWarning Id="6">DuT supports the Legacy Mode of Explicit Device Identification (ESI element Info:IdentificationAdo = 0x0012). Also Requesting Mechanism (ESI element Info:IdentificationReg134) should be supported. This may become mandatory in the future. </RaiseWarning>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Info.IdentificationReg134</Value1>
							<Value2>true</Value2>
							<ReturnSuccess Id="7">IdentificationReg134 is true!</ReturnSuccess>
						</Equal>
					</Compare>
				</TestStep>
			</TestCase>
			<TestCase Name="IdentifcationAdo = 0x12, 0x134, DevEmu false" CaseId="2">
				<?MAX_OUTPUT_ID 10?>
				<Description>
					<Purpose></Purpose>
					<PreCondition></PreCondition>
					<Action></Action>
					<PostCondition></PostCondition>
					<References>
						<Reference Specification="ETG.1020" Chapter="Explicit Device Identification"></Reference>
						<Reference Specification="ETG.1020" Chapter="Clause InfoType"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="ResetAndSkipIfOffline">
					<Description Id="0">Reset</Description>
					<CallTestFunction Name="Reset"></CallTestFunction>
				</TestStep>
				<TestStep>
					<Description Id="1" Level="Verbose">Check if ESI elements Info available</Description>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Info</Value1>
							<Value2>false</Value2>
							<SkipCase Id="2">No Explicit Device ID information available in ESI file</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Info.IdentificationReg134</Value1>
							<Value2>null</Value2>
							<WriteLine Id="3">IdentificationReg134 not available</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Info.IdentificationReg134</Value1>
							<Value2>false</Value2>
							<WriteLine Id="4">IdentificationReg134 = false</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Info.IdentificationReg134</Value1>
							<Value2>true</Value2>
							<GotoStep>CHECK_DEV_EMU_REG134</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Info.IdentificationAdo</Value1>
							<Value2>null</Value2>
							<SkipCase Id="5">Neither IdentificationReg134 nor IdentificationAdo = 12 supported</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>DeviceDescr.Info.IdentificationAdo</Value1>
							<Value2>#x12</Value2>
							<SkipCase Id="6">Neither IdentificationReg134 nor IdentificationAdo = 12 supported</SkipCase>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="CHECK_DEV_EMU_REG12">
					<Description Id="7" Level="Verbose">Read register 0x0140.08 Device Emulation active and check if IdentificationAdo = 12 (Legacy Mode) is supported.</Description>
					<Compare>
						<Equal>
							<Value1>Esc.DeviceEmulation </Value1>
							<Value2>true</Value2>
							<RaiseError Id="8">IdentificationAdo = 0x12 (Legacy Mode) must only be supported when Device Emulation is off.</RaiseError>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CHECK_DEV_EMU_REG134">
					<Description Id="9" Level="Verbose">Read register 0x0140.08 Device Emulation active and check if IdentificationReg134 is supported</Description>
					<Compare>
						<Equal>
							<Value1>Esc.DeviceEmulation </Value1>
							<Value2>true</Value2>
							<RaiseError Id="10">IdentificationReg134 must only be supported when Device Emulation is off.</RaiseError>
						</Equal>
					</Compare>
				</TestStep>
			</TestCase>
			<TestCase Name="IdentificationAdo = 0x1000, DevEmu true " CaseId="3">
				<?MAX_OUTPUT_ID 5?>
				<Description>
					<Purpose></Purpose>
					<PreCondition></PreCondition>
					<Action></Action>
					<PostCondition></PostCondition>
					<References>
						<Reference Specification="ETG.1020" Chapter="Explicit Device Identification"></Reference>
						<Reference Specification="ETG.1020" Chapter="Clause InfoType"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep>
					<Description Id="0" Level="Verbose">Check if ESI elements Info available</Description>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Info</Value1>
							<Value2>false</Value2>
							<SkipCase Id="1">IdentifcationAdo is not 0x0012</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Info.IdentificationAdo</Value1>
							<Value2>null</Value2>
							<SkipCase Id="2">IdentifcationAdo is not 0x0012</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<Description Id="3" Level="Verbose"></Description>
					<Compare>
						<NotEqual>
							<Value1>DeviceDescr.Info.IdentificationAdo</Value1>
							<Value2>#x1000</Value2>
							<SkipCase Id="4">IdentifcationAdo is not 0x1000</SkipCase>
						</NotEqual>
					</Compare>
					<Compare>
						<Equal>
							<Value1>Esc.DeviceEmulation </Value1>
							<Value2>false</Value2>
							<RaiseWarning Id="5">IdentificationAdo = 0x1000 shall only be used for simple device (Device Emulation = off)</RaiseWarning>
						</Equal>
					</Compare>
				</TestStep>
			</TestCase>
			<TestCase Name="Warning in case of Legacy Mode support" CaseId="4">
				<?MAX_OUTPUT_ID 3?>
				<Description>
					<Purpose></Purpose>
					<PreCondition></PreCondition>
					<Action></Action>
					<PostCondition></PostCondition>
					<References>
						<Reference Specification="ETG.1020" Chapter="Explicit Device Identification"></Reference>
						<Reference Specification="ETG.1020" Chapter="Clause InfoType"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Info</Value1>
							<Value2>false</Value2>
							<SkipCase Id="0">No IdentifcationAdo element in ESI available</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Info.IdentificationAdo</Value1>
							<Value2>null</Value2>
							<SkipCase Id="1">No IdentifcationAdo element in ESI available</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<Compare>
						<NotEqual>
							<Value1>DeviceDescr.Info.IdentificationAdo</Value1>
							<Value2>#x12</Value2>
							<SkipCase Id="2">No IdentifcationAdo element in ESI available</SkipCase>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Info.IdentificationAdo</Value1>
							<Value2>#x12</Value2>
							<RaiseWarning Id="3">DuT uses Legayc Mode (IdentifcationAdo = 0x12) for Expl. Dev. ID. It shall only be used for legacy reasons. Requesting Mechanism (IdentificationReg = true) shall be used.</RaiseWarning>
						</Equal>
					</Compare>
				</TestStep>
			</TestCase>
			<TestCase Name="Ignore ID Request if IdentificationReg134 = false in INIT" CaseId="5">
				<?MAX_OUTPUT_ID 15?>
				<Description>
					<Purpose>- Check if ESI element Info:IdentificationReg134 shall be set to TRUE (when it is currently set to FALSE)
- Check that DuT confirms state request from Init to Init state with AckFlag = 0 (i.e.  AL Control = 0x01) and from ErrorInit to Init with AckFlag = 1 (i.e. AL Control = 0x11)</Purpose>
					<PreCondition>- ESI:Info:IdentificationReg134 = false
- Device Emulation off
- DuT in Init
- Either Error Flag is 0 (then AckFlag is 0 in Action) or Error Flag is 1 (then AckFlag is 1 in Action)
- Assign EEPROM access to PDI</PreCondition>
					<Action>State request to Init with either Ack Flag 0 or 1, IdRequest = 1</Action>
					<PostCondition>- DuT goes to Init
- Acknowledge error by setting Error Flag = 0
- AL Status Code should be 0
- ID Flag = false</PostCondition>
					<ProposalForSolution>- If DuT returns the ID Value the ESI element Info:IdentificationReg134 shall be set TRUE</ProposalForSolution>
					<References>
						<Reference Specification="ETG.1000, part 6" Chapter="6.4,  #2"></Reference>
						<Reference Specification="ETG.1020" Chapter="Explicit Device Identification"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep>
					<!--Skip if IdentificationReg134True-->
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Info</Value1>
							<Value2>false</Value2>
							<GotoStep>PERFORM</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Info.IdentificationReg134</Value1>
							<Value2>null</Value2>
							<GotoStep>PERFORM</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Info.IdentificationReg134</Value1>
							<Value2>false</Value2>
							<GotoStep>PERFORM</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Info.IdentificationReg134</Value1>
							<Value2>true</Value2>
							<SkipCase Id="0">SKIP | IdentificationReg134 = true (test only applies if false)</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="PERFORM">
					<!--Reset device (if offline test will skipped)-->
					<Description Id="1">Reset</Description>
					<CallTestFunction Name="Reset"></CallTestFunction>
				</TestStep>
				<TestStep>
					<!--SkipTestIfDeviceEmulationActive-->
					<Description Id="2" Level="Verbose">Check if device emulation (register 0x0140.8) is active. If active test is skipped.</Description>
					<CallTestFunction Name="SkipTestIfDeviceEmulationActive"></CallTestFunction>
				</TestStep>
				<TestStep>
					<!--Set StateMachineTimeouts-->
					<Description Id="3" Level="Verbose">Set ESM Timeout values</Description>
					<CallFunction>SetEsmTimeouts</CallFunction>
				</TestStep>
				<TestStep>
					<!--stateValueNext 0x01, 0x02 0x04, 0x08-->
					<SetVariable Target="stateValueNext">#x01</SetVariable>
				</TestStep>
				<TestStep>
					<!--SetLocalEsmTimeouts-->
					<Compare>
						<Equal>
							<Value1>stateValueNext</Value1>
							<Value2>#x01</Value2>
							<SetVariable Target="EsmTimeout">backInitTimeout</SetVariable>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>stateValueNext</Value1>
							<Value2>#x02</Value2>
							<SetVariable Target="EsmTimeout">preOPTimeout</SetVariable>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>stateValueNext</Value1>
							<Value2>#x04</Value2>
							<SetVariable Target="EsmTimeout">safeOPTimeout</SetVariable>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>stateValueNext</Value1>
							<Value2>#x08</Value2>
							<SetVariable Target="EsmTimeout">safeOPTimeout</SetVariable>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<!--expectedAlStatusCode = 0x00-->
					<SetVariable Target="expectedAlStatusCode">#x00</SetVariable>
				</TestStep>
				<TestStep>
					<!--ACK = 0-->
					<SetVariable Target="errAck">False</SetVariable>
				</TestStep>
				<TestStep>
					<!--Reset device (if offline test will skipped)-->
					<Description Id="4" Level="Verbose">Reset DuT before actual test starts (with AckFlag = 0)</Description>
					<CallTestFunction Name="Reset"></CallTestFunction>
				</TestStep>
				<TestStep>
					<!--> State (INIT, PREOP, SAFEOP; OP)-->
					<Description Id="5" Level="Output">Set DuT to Starting State</Description>
					<RunToState Timeout="EsmTimeout">
						<State>INIT</State>
					</RunToState>
					<RaiseErrorOnFailure Id="6">Failed to run to State !</RaiseErrorOnFailure>
				</TestStep>
				<TestStep>
					<!--stateValue = 0x21 | 0x22 | 0x24 | 0x28-->
					<SetVariable Target="stateValue">#x21</SetVariable>
				</TestStep>
				<TestStep>
					<!--state > stateValue-->
					<Description Id="7" Param0="stateValue" Param1="errAck" Level="Output">EVENT: Request State with ID Request Flag = TRUE (even thougth IdentificationReg134 = FALSE) | AL Control State = 0x{0:x2}, Ack Flag = {1})</Description>
					<WriteEscData Source="stateValue">
						<Address>#x0120</Address>
					</WriteEscData>
				</TestStep>
				<TestStep Delay="EsmTimeout"></TestStep>
				<TestStep>
					<!--GetAndVerifyAlStatusAndStatusCode-->
					<Description Id="8" Level="Verbose">Check AL Status (0x0130) and AL Status Code (0x0134)</Description>
					<CallTestFunction Name="GetAndVerifyAlStatusAndStatusCode">
						<Parameter>stateValueNext<!--expcted AlStatus-->
						</Parameter>
						<Parameter>expectedAlStatusCode<!--expected AlStatusCode-->
						</Parameter>
						<Parameter>#x0000<!--alternative AlStatusCode2-->
						</Parameter>
						<Parameter>#x0000<!--alternative  AlStatusCode3-->
						</Parameter>
						<Parameter>FALSE<!--bWarning-->
						</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep>
					<!--Successful-->
					<WriteLine Id="9" Level="Success">SUCCESSFUL</WriteLine>
				</TestStep>
				<TestStep>
					<!--ACK = 1-->
					<SetVariable Target="errAck">True</SetVariable>
				</TestStep>
				<TestStep>
					<!--Reset device (if offline test will skipped)-->
					<Description Id="10" Level="Verbose">Reset DuT before actual test starts (with AckFlag = 1)</Description>
					<CallTestFunction Name="Reset"></CallTestFunction>
				</TestStep>
				<TestStep>
					<!--> ErrState (ERRINIT; ERRPREOP; ERRSAFEOP, ERROP)-->
					<Description Id="11" Level="Output">Set DuT to Starting State</Description>
					<RunToState Timeout="EsmTimeout">
						<State>ERROR_INIT</State>
					</RunToState>
					<RaiseErrorOnFailure Id="12">Failed to run to ErrState!</RaiseErrorOnFailure>
				</TestStep>
				<TestStep>
					<!--stateValue = 0x31 | 0x32 | 0x34 | 0x38-->
					<SetVariable Target="stateValue">#x31</SetVariable>
				</TestStep>
				<TestStep>
					<!--state > stateValue-->
					<Description Id="13" Param0="stateValue" Param1="errAck" Level="Output">EVENT: Request State with ID Request Flag = TRUE (even thougth IdentificationReg134 = FALSE) | AL Control State = 0x{0:x2}, Ack Flag = {1})</Description>
					<WriteEscData Source="stateValue">
						<Address>#x0120</Address>
					</WriteEscData>
				</TestStep>
				<TestStep Delay="EsmTimeout"></TestStep>
				<TestStep>
					<!--GetAndVerifyAlStatusAndStatusCode-->
					<Description Id="14" Level="Verbose">Check AL Status (0x0130) and AL Status Code (0x0134)</Description>
					<CallTestFunction Name="GetAndVerifyAlStatusAndStatusCode">
						<Parameter>stateValueNext<!--expcted AlStatus-->
						</Parameter>
						<Parameter>expectedAlStatusCode<!--expected AlStatusCode-->
						</Parameter>
						<Parameter>#x0000<!--alternative AlStatusCode2-->
						</Parameter>
						<Parameter>#x0000<!--alternative  AlStatusCode3-->
						</Parameter>
						<Parameter>FALSE<!--bWarning-->
						</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep>
					<!--Successful-->
					<WriteLine Id="15" Level="Success">SUCCESSFUL</WriteLine>
				</TestStep>
			</TestCase>
			<TestCase Name="Ignore ID Request if IdentificationReg134 = false in PREOP" CaseId="6">
				<?MAX_OUTPUT_ID 15?>
				<Description>
					<Purpose>- Check if ESI element Info:IdentificationReg134 shall be set to TRUE (when it is currently set to FALSE)
- Check that DuT confirms state request from PreOp to PreOp state with AckFlag = 0 (i.e.  AL Control = 0x01) and from ErrorPreOp to PreOp with AckFlag = 1 (i.e. AL Control = 0x11)</Purpose>
					<PreCondition>- ESI:Info:IdentificationReg134 = false
- Device Emulation off
- DuT in PreOp
- Either Error Flag is 0 (then AckFlag is 0 in Action) or Errof Flag is 1 (then AckFlag is 1 in Action)</PreCondition>
					<Action>State request to PreOp with either Ack Flag 0 or 1, IdRequest = 1</Action>
					<PostCondition>- DuT goes to PreOp
- Acknowledge error by setting Error Flag = 0
- AL Status Code should be 0
- ID Flag = false</PostCondition>
					<ProposalForSolution>- If DuT returns the ID Value the ESI element Info:IdentificationReg134 shall be set TRUE</ProposalForSolution>
					<References>
						<Reference Specification="ETG.1000, part 6" Chapter="6.4,  #13"></Reference>
						<Reference Specification="ETG.1020" Chapter="Explicit Device Identification"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep>
					<!--Skip if IdentificationReg134True-->
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Info</Value1>
							<Value2>false</Value2>
							<GotoStep>PERFORM</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Info.IdentificationReg134</Value1>
							<Value2>null</Value2>
							<GotoStep>PERFORM</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Info.IdentificationReg134</Value1>
							<Value2>false</Value2>
							<GotoStep>PERFORM</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Info.IdentificationReg134</Value1>
							<Value2>true</Value2>
							<SkipCase Id="0">SKIP | IdentificationReg134 = true (test only applies if false)</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="PERFORM">
					<!--Reset device (if offline test will skipped)-->
					<Description Id="1">Reset</Description>
					<CallTestFunction Name="Reset"></CallTestFunction>
				</TestStep>
				<TestStep>
					<!--SkipTestIfDeviceEmulationActive-->
					<Description Id="2" Level="Verbose">Check if device emulation (register 0x0140.8) is active. If active test is skipped.</Description>
					<CallTestFunction Name="SkipTestIfDeviceEmulationActive"></CallTestFunction>
				</TestStep>
				<TestStep>
					<!--Set StateMachineTimeouts-->
					<Description Id="3" Level="Verbose">Set ESM Timeout values</Description>
					<CallFunction>SetEsmTimeouts</CallFunction>
				</TestStep>
				<TestStep>
					<!--stateValueNext 0x01, 0x02 0x04, 0x08-->
					<SetVariable Target="stateValueNext">#x02</SetVariable>
				</TestStep>
				<TestStep>
					<!--SetLocalEsmTimeouts-->
					<Compare>
						<Equal>
							<Value1>stateValueNext</Value1>
							<Value2>#x01</Value2>
							<SetVariable Target="EsmTimeout">backInitTimeout</SetVariable>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>stateValueNext</Value1>
							<Value2>#x02</Value2>
							<SetVariable Target="EsmTimeout">preOPTimeout</SetVariable>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>stateValueNext</Value1>
							<Value2>#x04</Value2>
							<SetVariable Target="EsmTimeout">safeOPTimeout</SetVariable>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>stateValueNext</Value1>
							<Value2>#x08</Value2>
							<SetVariable Target="EsmTimeout">safeOPTimeout</SetVariable>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<!--expectedAlStatusCode = 0x00-->
					<SetVariable Target="expectedAlStatusCode">#x00</SetVariable>
				</TestStep>
				<TestStep>
					<!--ACK = 0-->
					<SetVariable Target="errAck">False</SetVariable>
				</TestStep>
				<TestStep>
					<!--Reset device (if offline test will skipped)-->
					<Description Id="4" Level="Verbose">Reset DuT before actual test starts (with AckFlag = 0)</Description>
					<CallTestFunction Name="Reset"></CallTestFunction>
				</TestStep>
				<TestStep>
					<!--> State (INIT, PREOP, SAFEOP; OP)-->
					<Description Id="5" Level="Output">Set DuT to Starting State</Description>
					<RunToState Timeout="EsmTimeout">
						<State>PREOP</State>
					</RunToState>
					<RaiseErrorOnFailure Id="6">Failed to run to State !</RaiseErrorOnFailure>
				</TestStep>
				<TestStep>
					<!--stateValue = 0x21 | 0x22 | 0x24 | 0x28-->
					<SetVariable Target="stateValue">#x22</SetVariable>
				</TestStep>
				<TestStep>
					<!--state > stateValue-->
					<Description Id="7" Param0="stateValue" Param1="errAck" Level="Output">EVENT: Request State with ID Request Flag = TRUE (even thougth IdentificationReg134 = FALSE) | AL Control State = 0x{0:x2}, Ack Flag = {1})</Description>
					<WriteEscData Source="stateValue">
						<Address>#x0120</Address>
					</WriteEscData>
				</TestStep>
				<TestStep Delay="EsmTimeout"></TestStep>
				<TestStep>
					<!--GetAndVerifyAlStatusAndStatusCode-->
					<Description Id="8" Level="Verbose">Check AL Status (0x0130) and AL Status Code (0x0134)</Description>
					<CallTestFunction Name="GetAndVerifyAlStatusAndStatusCode">
						<Parameter>stateValueNext<!--expcted AlStatus-->
						</Parameter>
						<Parameter>expectedAlStatusCode<!--expected AlStatusCode-->
						</Parameter>
						<Parameter>#x0000<!--alternative AlStatusCode2-->
						</Parameter>
						<Parameter>#x0000<!--alternative  AlStatusCode3-->
						</Parameter>
						<Parameter>FALSE<!--bWarning-->
						</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep>
					<!--Successful-->
					<WriteLine Id="9" Level="Success">SUCCESSFUL</WriteLine>
				</TestStep>
				<TestStep>
					<!--ACK = 1-->
					<SetVariable Target="errAck">True</SetVariable>
				</TestStep>
				<TestStep>
					<!--Reset device (if offline test will skipped)-->
					<Description Id="10" Level="Verbose">Reset DuT before actual test starts (with AckFlag = 1)</Description>
					<CallTestFunction Name="Reset"></CallTestFunction>
				</TestStep>
				<TestStep>
					<!--> ErrState (ERRINIT; ERRPREOP; ERRSAFEOP, ERROP)-->
					<Description Id="11" Level="Output">Set DuT to Starting State</Description>
					<RunToState Timeout="EsmTimeout">
						<State>ERROR_PREOP</State>
					</RunToState>
					<RaiseErrorOnFailure Id="12">Failed to run to ErrState!</RaiseErrorOnFailure>
				</TestStep>
				<TestStep>
					<!--stateValue = 0x31 | 0x32 | 0x34 | 0x38-->
					<SetVariable Target="stateValue">#x32</SetVariable>
				</TestStep>
				<TestStep>
					<!--state > stateValue-->
					<Description Id="13" Param0="stateValue" Param1="errAck" Level="Output">EVENT: Request State with ID Request Flag = TRUE (even thougth IdentificationReg134 = FALSE) | AL Control State = 0x{0:x2}, Ack Flag = {1})</Description>
					<WriteEscData Source="stateValue">
						<Address>#x0120</Address>
					</WriteEscData>
				</TestStep>
				<TestStep Delay="EsmTimeout"></TestStep>
				<TestStep>
					<!--GetAndVerifyAlStatusAndStatusCode-->
					<Description Id="14" Level="Verbose">Check AL Status (0x0130) and AL Status Code (0x0134)</Description>
					<CallTestFunction Name="GetAndVerifyAlStatusAndStatusCode">
						<Parameter>stateValueNext<!--expcted AlStatus-->
						</Parameter>
						<Parameter>expectedAlStatusCode<!--expected AlStatusCode-->
						</Parameter>
						<Parameter>#x0000<!--alternative AlStatusCode2-->
						</Parameter>
						<Parameter>#x0000<!--alternative  AlStatusCode3-->
						</Parameter>
						<Parameter>FALSE<!--bWarning-->
						</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep>
					<!--Successful-->
					<WriteLine Id="15" Level="Success">SUCCESSFUL</WriteLine>
				</TestStep>
			</TestCase>
			<TestCase Name="Ignore ID Request if IdentificationReg134 = false in SAFEOP" CaseId="7">
				<?MAX_OUTPUT_ID 15?>
				<Description>
					<Purpose>- Check if ESI element Info:IdentificationReg134 shall be set to TRUE (when it is currently set to FALSE)
- Check that DuT confirms state request from SafeOp to SafeOp state with AckFlag = 0 (i.e.  AL Control = 0x04) and from ErrorPreOp to PreOp with AckFlag = 1 (i.e. AL Control = 0x14)</Purpose>
					<PreCondition>- ESI:Info:IdentificationReg134 = false
- Device Emulation off
- DuT in SafeOp
- Either Error Flag is 0 (then AckFlag is 0 in Action) or Errof Flag is 1 (then AckFlag is 1 in Action)</PreCondition>
					<Action>State request to SafeOp with either Ack Flag 0 or 1, IdRequest = 1</Action>
					<PostCondition>- DuT goes to SafeOp
- Acknowledge error by setting Error Flag = 0
- AL Status Code should be 0
- ID Flag = false</PostCondition>
					<ProposalForSolution>- If DuT returns the ID Value the ESI element Info:IdentificationReg134 shall be set TRUE</ProposalForSolution>
					<References>
						<Reference Specification="ETG.1000, part 6" Chapter="6.4"></Reference>
						<Reference Specification="ETG.1020" Chapter="Explicit Device Identification"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep>
					<!--Skip if IdentificationReg134True-->
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Info</Value1>
							<Value2>false</Value2>
							<GotoStep>PERFORM</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Info.IdentificationReg134</Value1>
							<Value2>null</Value2>
							<GotoStep>PERFORM</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Info.IdentificationReg134</Value1>
							<Value2>false</Value2>
							<GotoStep>PERFORM</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Info.IdentificationReg134</Value1>
							<Value2>true</Value2>
							<SkipCase Id="0">SKIP | IdentificationReg134 = true (test only applies if false)</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="PERFORM">
					<!--Reset device (if offline test will skipped)-->
					<Description Id="1">Reset</Description>
					<CallTestFunction Name="Reset"></CallTestFunction>
				</TestStep>
				<TestStep>
					<!--SkipTestIfDeviceEmulationActive-->
					<Description Id="2" Level="Verbose">Check if device emulation (register 0x0140.8) is active. If active test is skipped.</Description>
					<CallTestFunction Name="SkipTestIfDeviceEmulationActive"></CallTestFunction>
				</TestStep>
				<TestStep>
					<!--Set StateMachineTimeouts-->
					<Description Id="3" Level="Verbose">Set ESM Timeout values</Description>
					<CallFunction>SetEsmTimeouts</CallFunction>
				</TestStep>
				<TestStep>
					<!--stateValueNext 0x01, 0x02 0x04, 0x08-->
					<SetVariable Target="stateValueNext">#x04</SetVariable>
				</TestStep>
				<TestStep>
					<!--SetLocalEsmTimeouts-->
					<Compare>
						<Equal>
							<Value1>stateValueNext</Value1>
							<Value2>#x01</Value2>
							<SetVariable Target="EsmTimeout">backInitTimeout</SetVariable>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>stateValueNext</Value1>
							<Value2>#x02</Value2>
							<SetVariable Target="EsmTimeout">preOPTimeout</SetVariable>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>stateValueNext</Value1>
							<Value2>#x04</Value2>
							<SetVariable Target="EsmTimeout">safeOPTimeout</SetVariable>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>stateValueNext</Value1>
							<Value2>#x08</Value2>
							<SetVariable Target="EsmTimeout">safeOPTimeout</SetVariable>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<!--expectedAlStatusCode = 0x00-->
					<SetVariable Target="expectedAlStatusCode">#x00</SetVariable>
				</TestStep>
				<TestStep>
					<!--ACK = 0-->
					<SetVariable Target="errAck">False</SetVariable>
				</TestStep>
				<TestStep>
					<!--Reset device (if offline test will skipped)-->
					<Description Id="4" Level="Verbose">Reset DuT before actual test starts (with AckFlag = 0)</Description>
					<CallTestFunction Name="Reset"></CallTestFunction>
				</TestStep>
				<TestStep>
					<!--> State (INIT, PREOP, SAFEOP; OP)-->
					<Description Id="5" Level="Output">Set DuT to Starting State</Description>
					<RunToState Timeout="EsmTimeout">
						<State>SAFEOP</State>
					</RunToState>
					<RaiseErrorOnFailure Id="6">Failed to run to State !</RaiseErrorOnFailure>
				</TestStep>
				<TestStep>
					<!--stateValue = 0x21 | 0x22 | 0x24 | 0x28-->
					<SetVariable Target="stateValue">#x24</SetVariable>
				</TestStep>
				<TestStep>
					<!--state > stateValue-->
					<Description Id="7" Param0="stateValue" Param1="errAck" Level="Output">EVENT: Request State with ID Request Flag = TRUE (even thougth IdentificationReg134 = FALSE) | AL Control State = 0x{0:x2}, Ack Flag = {1})</Description>
					<WriteEscData Source="stateValue">
						<Address>#x0120</Address>
					</WriteEscData>
				</TestStep>
				<TestStep Delay="EsmTimeout"></TestStep>
				<TestStep>
					<!--GetAndVerifyAlStatusAndStatusCode-->
					<Description Id="8" Level="Verbose">Check AL Status (0x0130) and AL Status Code (0x0134)</Description>
					<CallTestFunction Name="GetAndVerifyAlStatusAndStatusCode">
						<Parameter>stateValueNext<!--expcted AlStatus-->
						</Parameter>
						<Parameter>expectedAlStatusCode<!--expected AlStatusCode-->
						</Parameter>
						<Parameter>#x0000<!--alternative AlStatusCode2-->
						</Parameter>
						<Parameter>#x0000<!--alternative  AlStatusCode3-->
						</Parameter>
						<Parameter>FALSE<!--bWarning-->
						</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep>
					<!--Successful-->
					<WriteLine Id="9" Level="Success">SUCCESSFUL</WriteLine>
				</TestStep>
				<TestStep>
					<!--ACK = 1-->
					<SetVariable Target="errAck">True</SetVariable>
				</TestStep>
				<TestStep>
					<!--Reset device (if offline test will skipped)-->
					<Description Id="10" Level="Verbose">Reset DuT before actual test starts (with AckFlag = 1)</Description>
					<CallTestFunction Name="Reset"></CallTestFunction>
				</TestStep>
				<TestStep>
					<!--> ErrState (ERRINIT; ERRPREOP; ERRSAFEOP, ERROP)-->
					<Description Id="11" Level="Output">Set DuT to Starting State</Description>
					<RunToState Timeout="EsmTimeout">
						<State>ERROR_SAFEOP</State>
					</RunToState>
					<RaiseErrorOnFailure Id="12">Failed to run to ErrState!</RaiseErrorOnFailure>
				</TestStep>
				<TestStep>
					<!--stateValue = 0x31 | 0x32 | 0x34 | 0x38-->
					<SetVariable Target="stateValue">#x34</SetVariable>
				</TestStep>
				<TestStep>
					<!--state > stateValue-->
					<Description Id="13" Param0="stateValue" Param1="errAck" Level="Output">EVENT: Request State with ID Request Flag = TRUE (even thougth IdentificationReg134 = FALSE) | AL Control State = 0x{0:x2}, Ack Flag = {1})</Description>
					<WriteEscData Source="stateValue">
						<Address>#x0120</Address>
					</WriteEscData>
				</TestStep>
				<TestStep Delay="EsmTimeout"></TestStep>
				<TestStep>
					<!--GetAndVerifyAlStatusAndStatusCode-->
					<Description Id="14" Level="Verbose">Check AL Status (0x0130) and AL Status Code (0x0134)</Description>
					<CallTestFunction Name="GetAndVerifyAlStatusAndStatusCode">
						<Parameter>stateValueNext<!--expcted AlStatus-->
						</Parameter>
						<Parameter>expectedAlStatusCode<!--expected AlStatusCode-->
						</Parameter>
						<Parameter>#x0000<!--alternative AlStatusCode2-->
						</Parameter>
						<Parameter>#x0000<!--alternative  AlStatusCode3-->
						</Parameter>
						<Parameter>FALSE<!--bWarning-->
						</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep>
					<!--Successful-->
					<WriteLine Id="15" Level="Success">SUCCESSFUL</WriteLine>
				</TestStep>
			</TestCase>
			<TestCase Name="Ignore ID Request if IdentificationReg134 = false in OP" CaseId="8">
				<?MAX_OUTPUT_ID 9?>
				<Description>
					<Purpose>- Check if ESI element Info:IdentificationReg134 shall be set to TRUE (when it is currently set to FALSE)
- Check that DuT confirms state request from Op to Op with AL Control = 0x08 or AL Control = 0x018</Purpose>
					<PreCondition>- ESI:Info:IdentificationReg134 = false
- Device Emulation off
- DuT in Op (AL Status = 0x08)</PreCondition>
					<Action>- State request to Op state with AckFlag 0 (AL Control = 0x28) or AckFlag 1 (AL Control = 0x38) and ID Request = 1</Action>
					<PostCondition>- DuT remains in Op (AL Status = 0x08)
- AL Status Code should be 0
- ID Flag = false</PostCondition>
					<ProposalForSolution>- If DuT returns the ID Value the ESI element Info:IdentificationReg134 shall be set TRUE</ProposalForSolution>
					<References>
						<Reference Specification="ETG.1000, part 6" Chapter="6.4,  #40"></Reference>
						<Reference Specification="ETG.1020" Chapter="Explicit Device Identification"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep>
					<!--Skip if IdentificationReg134True-->
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Info</Value1>
							<Value2>false</Value2>
							<GotoStep>PERFORM</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Info.IdentificationReg134</Value1>
							<Value2>null</Value2>
							<GotoStep>PERFORM</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Info.IdentificationReg134</Value1>
							<Value2>false</Value2>
							<GotoStep>PERFORM</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Info.IdentificationReg134</Value1>
							<Value2>true</Value2>
							<SkipCase Id="0">SKIP | IdentificationReg134 = true (test only applies if false)</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="PERFORM">
					<!--Reset device (if offline test will skipped)-->
					<Description Id="1">Reset</Description>
					<CallTestFunction Name="Reset"></CallTestFunction>
				</TestStep>
				<TestStep>
					<!--SkipTestIfDeviceEmulationActive-->
					<Description Id="2" Level="Verbose">Check if device emulation (register 0x0140.8) is active. If active test is skipped.</Description>
					<CallTestFunction Name="SkipTestIfDeviceEmulationActive"></CallTestFunction>
				</TestStep>
				<TestStep>
					<!--Set StateMachineTimeouts-->
					<Description Id="3" Level="Verbose">Set ESM Timeout values</Description>
					<CallFunction>SetEsmTimeouts</CallFunction>
				</TestStep>
				<TestStep>
					<!--stateValueNext 0x01, 0x02 0x04, 0x08-->
					<SetVariable Target="stateValueNext">#x08</SetVariable>
				</TestStep>
				<TestStep>
					<!--SetLocalEsmTimeouts-->
					<Compare>
						<Equal>
							<Value1>stateValueNext</Value1>
							<Value2>#x01</Value2>
							<SetVariable Target="EsmTimeout">backInitTimeout</SetVariable>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>stateValueNext</Value1>
							<Value2>#x02</Value2>
							<SetVariable Target="EsmTimeout">preOPTimeout</SetVariable>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>stateValueNext</Value1>
							<Value2>#x04</Value2>
							<SetVariable Target="EsmTimeout">safeOPTimeout</SetVariable>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>stateValueNext</Value1>
							<Value2>#x08</Value2>
							<SetVariable Target="EsmTimeout">safeOPTimeout</SetVariable>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<!--expectedAlStatusCode = 0x00-->
					<SetVariable Target="expectedAlStatusCode">#x00</SetVariable>
				</TestStep>
				<TestStep>
					<!--ACK = 0-->
					<SetVariable Target="errAck">False</SetVariable>
				</TestStep>
				<TestStep>
					<!--Reset device (if offline test will skipped)-->
					<Description Id="4" Level="Verbose">Reset DuT before actual test starts (with AckFlag = 0)</Description>
					<CallTestFunction Name="Reset"></CallTestFunction>
				</TestStep>
				<TestStep>
					<!--> State (INIT, PREOP, SAFEOP; OP)-->
					<Description Id="5" Level="Output">Set DuT to Starting State</Description>
					<RunToState Timeout="EsmTimeout">
						<State>OP</State>
					</RunToState>
					<RaiseErrorOnFailure Id="6">Failed to run to State !</RaiseErrorOnFailure>
				</TestStep>
				<TestStep>
					<!--stateValue = 0x21 | 0x22 | 0x24 | 0x28-->
					<SetVariable Target="stateValue">#x38</SetVariable>
				</TestStep>
				<TestStep>
					<!--state > stateValue-->
					<Description Id="7" Param0="stateValue" Param1="errAck" Level="Output">EVENT: Request State with ID Request Flag = TRUE (even thougth IdentificationReg134 = FALSE) | AL Control State = 0x{0:x2}, Ack Flag = {1})</Description>
					<WriteEscData Source="stateValue">
						<Address>#x0120</Address>
					</WriteEscData>
				</TestStep>
				<TestStep Delay="EsmTimeout"></TestStep>
				<TestStep>
					<!--GetAndVerifyAlStatusAndStatusCode-->
					<Description Id="8" Level="Verbose">Check AL Status (0x0130) and AL Status Code (0x0134)</Description>
					<CallTestFunction Name="GetAndVerifyAlStatusAndStatusCode">
						<Parameter>stateValueNext<!--expcted AlStatus-->
						</Parameter>
						<Parameter>expectedAlStatusCode<!--expected AlStatusCode-->
						</Parameter>
						<Parameter>#x0000<!--alternative AlStatusCode2-->
						</Parameter>
						<Parameter>#x0000<!--alternative  AlStatusCode3-->
						</Parameter>
						<Parameter>FALSE<!--bWarning-->
						</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep>
					<!--Successful-->
					<WriteLine Id="9" Level="Success">SUCCESSFUL</WriteLine>
				</TestStep>
			</TestCase>
			<TestCase Name="Element Info:StationAliasSupported shall not be used" CaseId="9">
				<?MAX_OUTPUT_ID 2?>
				<Description>
					<Purpose>Check if the obsolete element Info:StationAliasSupported is used and generated an warning.</Purpose>
					<PreCondition></PreCondition>
					<Action></Action>
					<PostCondition></PostCondition>
					<References>
						<Reference Specification="ETG.1020" Chapter="Clause InfoType"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Info</Value1>
							<Value2>false</Value2>
							<ReturnSuccess Id="0">Obsolete element Info:StationAliasSupported ist not used</ReturnSuccess>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Info.StationAliasSupported</Value1>
							<Value2>null</Value2>
							<SkipCase Id="1">Obsolete element Info:StationAliasSupported ist not used</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<Compare>
						<NotEqual>
							<Value1>DeviceDescr.Info.StationAliasSupported</Value1>
							<Value2>null</Value2>
							<RaiseWarning Id="2">Obsolete element Info:StationAliasSupported shall not be used. Use one of the allowed ESI elements.</RaiseWarning>
						</NotEqual>
					</Compare>
				</TestStep>
			</TestCase>
		</TestGroup>
		<TestGroup GroupId="100" Name="(Local) Module DataType Tests">
			<Comment>Check the DataType definitions of the modules defined locally in ESI</Comment>
			<TestCase Name="All DataType Names" CaseId="1">
				<?MAX_OUTPUT_ID 10?>
				<Description>
					<PreCondition>The device description includes locally defined module object dictionary</PreCondition>
					<Action>- Check name of module DataTypes</Action>
					<PostCondition>The name shall be either:
- Base DataType listed in the ETG.1020
- DTxxxx
- DTxxxxARR
- DTxxxxENnn

xxxx is a 16Bit hex value (usually the object index)
nn is the number of Bits used for the Enum</PostCondition>
					<References>
						<Reference Specification="ETG.2000"></Reference>
						<Reference Specification="ETG.1020"></Reference>
						<Reference Specification="ETG.5001"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="Toggle_LOC_EXT">
					<!--Flag for InitGlobalVariables for default XPaths of local or external file-->
					<SetVariable Target="LocExt_InitToggle">false</SetVariable>
					<WriteLine Id="0" Level="Output">Checking for modules within ESI.</WriteLine>
				</TestStep>
				<TestStep Name="SkipNoSlots">
					<!--Skip Test if "CurrentConfig.SlotCount" == 0-->
					<Compare>
						<Equal>
							<Value1>CurrentConfig.SlotCount</Value1>
							<Value2>0</Value2>
							<SkipCase Id="1">Test skipped. No slots defined.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="SkipSoE">
					<!--Skip Test if SoE Device-->
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Mailbox.SoE</Value1>
							<Value2>true</Value2>
							<SkipCase Id="2">Test skipped for SoE Devices.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="INIT_AVAIL_GLOB_ARRAY">
					<CallTestFunction Name="AvailableDuTModuleIdents"></CallTestFunction>
				</TestStep>
				<TestStep Name="InitGlobalVariables">
					<!--Init global XPaths-->
					<CallTestFunction Name="InitGlobalVariablesForModuleODTest">
						<Parameter>LocExt_InitToggle</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="INIT_RESULT">
					<!--"result" = true-->
					<SetVariable Target="result">true</SetVariable>
				</TestStep>
				<TestStep Name="INIT_LOOP_COUNTER">
					<!--Init "ModuleCounter" = 1-->
					<SetVariable Target="ModuleCounter">1</SetVariable>
				</TestStep>
				<TestStep Name="CHECK_IF_EXISTS">
					<!--Checking if modules exist-->
					<Compare>
						<Equal>
							<Value1>loc_XPathModuleIdent</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>END</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="InitTestedArray">
					<!--Array of already processed modules, no doubles-->
					<InitArray TargetArray="AllModuleIdents.Uint32Array"></InitArray>
				</TestStep>
				<TestStep Name="DataTypeLoopStart">
					<!--__Loop START for LOCAL Modules__-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>END</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>END</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_AVAILABLE_MDL">
					<!--Get ModuleIdent and Flag to SKIP testing of assigned modules-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="AllModuleIdents.Uint32">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>TestAvailableMdls</Value1>
							<Value2>false</Value2>
							<GotoStep>TEST_MODULES</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckItemInArray">
					<!--Check if module in list of assigned modules-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllAvailableDuTModules.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleInArray.boolAssigned</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="3" Level="Verbose" Param0="CheckModuleInArray.boolAssigned" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleInArray.boolAssigned == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleInArray.boolAssigned</Value1>
							<Value2>false</Value2>
							<GotoStep>DataTypeLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckAlreadyTested">
					<!--Check if module already tested-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllModuleIdents.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleAlreadyTested.boolAlreadyChecked</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="4" Level="Verbose" Param0="CheckModuleAlreadyTested.boolAlreadyChecked" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleAlreadyTested.boolAlreadyChecked == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleAlreadyTested.boolAlreadyChecked</Value1>
							<Value2>true</Value2>
							<GotoStep>DataTypeLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_MODULES">
					<!--Print Module Ident-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="5" Level="Verbose" Param0="ModuleCounter" Param1="strXmlValue">Module[{0}]: Ident: {1}</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="Check_extOD_FileRef">
					<CallTestFunction Name="CheckForExtRefDict">
						<Parameter>loc_ModuleXmlFile</Parameter>
						<Parameter>loc_XPathModuleIdent</Parameter>
						<Parameter>ModuleCounter</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="InitSubItemLoopCounter">
					<!--Init of nested loop counter for DataTypes of current module-->
					<SetVariable Target="i32TmpModuleIndex">1</SetVariable>
				</TestStep>
				<TestStep Name="SubItemLoopStart">
					<!--__Loop START for current module DataTypes__-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/Profile/Dictionary/DataTypes/DataType[{2}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>DataTypeLoopEnd</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>DataTypeLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="GET_CURRENT_DT_NAME">
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/Profile/Dictionary/DataTypes/DataType[{2}]/Name</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<SetVariable Target="AtLeastOneModuleFound">true</SetVariable>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="6" Level="Verbose" Param0="strXmlValue">Check name {0}.</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<!--Check if fixed BaseDataType is used-->
					<RegexIsMatch ReturnValue="IsMatch">
						<Pattern>^(BOOL|BIT|BIT[1-8]|BYTE|BITARR8|BITARR16|WORD|BITARR32|DWORD|SINT|INT|INT24|DINT|INT40|INT48|INT56|LINT|USINT|UINT|UINT24|UDINT|UINT40|UINT48|UINT56|ULINT|REAL|LREAL|GUID)$</Pattern>
						<InputString>strXmlValue</InputString>
					</RegexIsMatch>
					<Compare>
						<Equal>
							<Value1>IsMatch</Value1>
							<Value2>true</Value2>
							<GotoStep>SubItemLoopCounterEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<!--Check if "ARRAY [0...n] of BYTE|UINT" is used-->
					<RegexIsMatch ReturnValue="IsMatch">
						<Pattern>^(ARRAY \[0\.\.[0-9]+\] OF (BYTE|SINT|UINT|INT|DINT|UDINT))$</Pattern>
						<InputString>strXmlValue</InputString>
					</RegexIsMatch>
					<Compare>
						<Equal>
							<Value1>IsMatch</Value1>
							<Value2>true</Value2>
							<GotoStep>SubItemLoopCounterEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<!--Check if "STRING(n)" is used-->
					<RegexIsMatch ReturnValue="IsMatch">
						<Pattern>^(STRING\([0-9]+\))$</Pattern>
						<InputString>strXmlValue</InputString>
					</RegexIsMatch>
					<Compare>
						<Equal>
							<Value1>IsMatch</Value1>
							<Value2>true</Value2>
							<GotoStep>SubItemLoopCounterEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<!--Check if "DTxxxx" is used-->
					<RegexIsMatch ReturnValue="IsMatch">
						<Pattern>^(DT[0-9A-Fa-fXx]{1,4})$</Pattern>
						<InputString>strXmlValue</InputString>
					</RegexIsMatch>
					<Compare>
						<Equal>
							<Value1>IsMatch</Value1>
							<Value2>true</Value2>
							<GotoStep>SubItemLoopCounterEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<!--Check if "DTxxxARR" is used-->
					<RegexIsMatch ReturnValue="IsMatch">
						<Pattern>^(DT[0-9A-Fa-fXx]{1,4}ARR)$</Pattern>
						<InputString>strXmlValue</InputString>
					</RegexIsMatch>
					<Compare>
						<Equal>
							<Value1>IsMatch</Value1>
							<Value2>true</Value2>
							<GotoStep>SubItemLoopCounterEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<!--Check if "DTxxxENnn" is used-->
					<RegexIsMatch ReturnValue="IsMatch">
						<Pattern>^(DT[0-9A-Fa-fXx]{4}EN([0-9]{2}))$</Pattern>
						<InputString>strXmlValue</InputString>
					</RegexIsMatch>
					<Compare>
						<Equal>
							<Value1>IsMatch</Value1>
							<Value2>true</Value2>
							<GotoStep>SubItemLoopCounterEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<!--No specified DataType name is used => Dump Error-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="7" Level="Error" Param0="strXmlValue">DataType name "{0}" is not valid.</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="SubItemLoopCounterEnd">
					<!--__END of "SubItemLoopStart", increment loop counter__-->
					<SetVariable Target="i32TmpModuleIndex">i32TmpModuleIndex + 1</SetVariable>
					<!--goto loop start by default -->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>SubItemLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="DataTypeLoopEnd">
					<!--__END of "DataTypeLoopStart", add ModuleIdent to tested Array__-->
					<AddArrayItem TargetArray="AllModuleIdents.Uint32Array">AllModuleIdents.Uint32</AddArrayItem>
				</TestStep>
				<TestStep>
					<!--Increment module counter-->
					<SetVariable Target="ModuleCounter">ModuleCounter + 1</SetVariable>
					<!--Goto loop start by default -->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>DataTypeLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="END">
					<!--Dump Test case result-->
					<Compare>
						<Equal>
							<Value1>AtLeastOneModuleFound</Value1>
							<Value2>false</Value2>
							<SkipCase Id="8">No DataType found.</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>true</Value2>
							<ReturnSuccess Id="9">DataType AccessType Test successful.</ReturnSuccess>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>false</Value2>
							<RaiseError></RaiseError>
						</Equal>
					</Compare>
				</TestStep>
			</TestCase>
			<TestCase Name="Check Access Flag" CaseId="2">
				<?MAX_OUTPUT_ID 12?>
				<Description>
					<PreCondition>The device description includes locally defined module object dictionary</PreCondition>
					<Action>- Check if the write/read restriction "PreOp" is used</Action>
					<PostCondition>- In case of an PreOP write/read restriction the syntax "PreOP" (not "PreOp") shall be used</PostCondition>
					<References>
						<Reference Specification="ETG.2000"></Reference>
						<Reference Specification="ETG.1020"></Reference>
						<Reference Specification="ETG.5001"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="Toggle_LOC_EXT">
					<!--Flag for InitGlobalVariables for default XPaths of local or external file-->
					<SetVariable Target="LocExt_InitToggle">false</SetVariable>
					<WriteLine Id="0" Level="Output">Checking for modules within ESI.</WriteLine>
				</TestStep>
				<TestStep Name="SkipNoSlots">
					<!--Skip Test if "CurrentConfig.SlotCount" == 0-->
					<Compare>
						<Equal>
							<Value1>CurrentConfig.SlotCount</Value1>
							<Value2>0</Value2>
							<SkipCase Id="1">Test skipped. No slots defined.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="SkipSoE">
					<!--Skip Test if SoE Device-->
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Mailbox.SoE</Value1>
							<Value2>true</Value2>
							<SkipCase Id="2">Test skipped for SoE Devices.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="INIT_AVAIL_GLOB_ARRAY">
					<CallTestFunction Name="AvailableDuTModuleIdents"></CallTestFunction>
				</TestStep>
				<TestStep Name="InitGlobalVariables">
					<!--Init global XPaths-->
					<CallTestFunction Name="InitGlobalVariablesForModuleODTest">
						<Parameter>LocExt_InitToggle</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="INIT_RESULT">
					<!--"result" = true-->
					<SetVariable Target="result">true</SetVariable>
				</TestStep>
				<TestStep Name="INIT_LOOP_COUNTER">
					<!--Init "ModuleCounter" = 1-->
					<SetVariable Target="ModuleCounter">1</SetVariable>
				</TestStep>
				<TestStep Name="CHECK_IF_EXISTS">
					<!--Checking if modules exist-->
					<Compare>
						<Equal>
							<Value1>loc_XPathModuleIdent</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>END</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="InitTestedArray">
					<!--Array of already processed modules, no doubles-->
					<InitArray TargetArray="AllModuleIdents.Uint32Array"></InitArray>
				</TestStep>
				<TestStep Name="DataTypeLoopStart">
					<!--__Loop START for LOCAL Modules__-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>END</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>END</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_AVAILABLE_MDL">
					<!--Get ModuleIdent and Flag to SKIP testing of assigned modules-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="AllModuleIdents.Uint32">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>TestAvailableMdls</Value1>
							<Value2>false</Value2>
							<GotoStep>TEST_MODULES</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckItemInArray">
					<!--Check if module in list of assigned modules-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllAvailableDuTModules.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleInArray.boolAssigned</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="3" Level="Verbose" Param0="CheckModuleInArray.boolAssigned" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleInArray.boolAssigned == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleInArray.boolAssigned</Value1>
							<Value2>false</Value2>
							<GotoStep>DataTypeLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckAlreadyTested">
					<!--Check if module already tested-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllModuleIdents.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleAlreadyTested.boolAlreadyChecked</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="4" Level="Verbose" Param0="CheckModuleAlreadyTested.boolAlreadyChecked" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleAlreadyTested.boolAlreadyChecked == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleAlreadyTested.boolAlreadyChecked</Value1>
							<Value2>true</Value2>
							<GotoStep>DataTypeLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_MODULES">
					<!--Print Module Ident-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="5" Level="Verbose" Param0="ModuleCounter" Param1="strXmlValue">Module[{0}]: Ident: {1}</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="Check_extOD_FileRef">
					<CallTestFunction Name="CheckForExtRefDict">
						<Parameter>loc_ModuleXmlFile</Parameter>
						<Parameter>loc_XPathModuleIdent</Parameter>
						<Parameter>ModuleCounter</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="InitSubItemLoopCounter">
					<!--Init of 1. nested loop counter for DataTypes of current module-->
					<SetVariable Target="i32TmpModuleIndex">1</SetVariable>
				</TestStep>
				<TestStep Name="SubItemLoopStart">
					<!--__Loop START for current module DataTypes__-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/Profile/Dictionary/DataTypes/DataType[{2}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>DataTypeLoopEnd</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>DataTypeLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="InitAccessRightLoopCounter">
					<!--Init of 2. nested loop counter for DataType Subitems of current module-->
					<SetVariable Target="i32TmpModuleIndexDeep">1</SetVariable>
				</TestStep>
				<TestStep Name="AccessRightLoopStart">
					<!--__Loop START for current module DataType Subitems__-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex" Param3="i32TmpModuleIndexDeep">{0}[{1}]/Profile/Dictionary/DataTypes/DataType[{2}]/SubItem[{3}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>SubItemLoopCounterEnd</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>SubItemLoopCounterEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="GET_CURRENT_WriteRestriction">
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex" Param3="i32TmpModuleIndexDeep">{0}[{1}]/Profile/Dictionary/DataTypes/DataType[{2}]/SubItem[{3}]/Flags/Access/@WriteRestrictions</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<SetVariable Target="AtLeastOneModuleFound">true</SetVariable>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="6" Level="Verbose" Param0="ModuleCounter" Param1="i32TmpModuleIndex" Param2="i32TmpModuleIndexDeep" Param3="strXmlValue">EtherCATModule/Modules/Module[{0}]/Profile/Dictionary/DataTypes/DataType[{1}]/SubItem[{2}]/Flags/Access/@WriteRestrictions: '{3}'.</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>PreOp</Value2>
							<WriteLine Id="7" Level="Error" Param0="loc_XPathModuleIdent" Param1="(ModuleCounter-1)" Param2="(i32TmpModuleIndex-1)" Param3="(i32TmpModuleIndexDeep-1)">{0}[{1}]/Profile/Dictionary/DataTypes/DataType[{2}]/SubItem[{3}] WriteRestriction 'PreOp' is not valid use 'PreOP' instead.</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>PreOp</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="GET_CURRENT_ReadRestriction">
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex" Param3="i32TmpModuleIndexDeep">{0}[{1}]/Profile/Dictionary/DataTypes/DataType[{2}]/SubItem[{3}]/Flags/Access/@ReadRestrictions</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<SetVariable Target="AtLeastOneModuleFound">true</SetVariable>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="8" Level="Verbose" Param0="ModuleCounter" Param1="i32TmpModuleIndex" Param2="i32TmpModuleIndexDeep" Param3="strXmlValue">EtherCATModule/Modules/Module[{0}]/Profile/Dictionary/DataTypes/DataType[{1}]/SubItem[{2}]/Flags/Access/@ReadRestrictions '{3}'.</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>PreOp</Value2>
							<WriteLine Id="9" Level="Error" Param0="loc_XPathModuleIdent" Param1="(ModuleCounter-1)" Param2="(i32TmpModuleIndex-1)" Param3="(i32TmpModuleIndexDeep-1)">{0}[{1}]/Profile/Dictionary/DataTypes/DataType[{2}]/SubItem[{3}] ReadRestriction 'PreOp' is not valid use 'PreOP' instead.</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>PreOp</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="AccessRightLoopCounterEnd">
					<!--__END of "AccessRightLoopStart", increment loop counter__-->
					<SetVariable Target="i32TmpModuleIndexDeep">i32TmpModuleIndexDeep + 1</SetVariable>
					<!--goto deep loop start-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>AccessRightLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="SubItemLoopCounterEnd">
					<!--__END of "SubItemLoopStart", increment loop counter__-->
					<SetVariable Target="i32TmpModuleIndex">i32TmpModuleIndex + 1</SetVariable>
					<!--goto loop start by default -->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>SubItemLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="DataTypeLoopEnd">
					<!--__END of "DataTypeLoopStart", add ModuleIdent to tested Array__-->
					<AddArrayItem TargetArray="AllModuleIdents.Uint32Array">AllModuleIdents.Uint32</AddArrayItem>
				</TestStep>
				<TestStep>
					<!--Increment module counter-->
					<SetVariable Target="ModuleCounter">ModuleCounter + 1</SetVariable>
					<!--Goto Loop start if counter is less than Number of DataTypes -->
					<!--Goto loop start by default -->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>DataTypeLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="END">
					<!--Dump Test case result-->
					<Compare>
						<Equal>
							<Value1>AtLeastOneModuleFound</Value1>
							<Value2>false</Value2>
							<SkipCase Id="10">No Access Flag found.</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>true</Value2>
							<ReturnSuccess Id="11">DataType AccessType Test successful.</ReturnSuccess>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>false</Value2>
							<RaiseError></RaiseError>
						</Equal>
					</Compare>
				</TestStep>
			</TestCase>
			<TestCase Name="BaseDataTypes (fixed length)" CaseId="3">
				<?MAX_OUTPUT_ID 11?>
				<Description>
					<PreCondition>The device description includes locally defined module object dictionary</PreCondition>
					<Action>1.) Get BaseType, ArrayInfo, SubItem, EnumInfo
2.) Get BitSize</Action>
					<PostCondition>1.) Non of elements BaseType, ArrayInfo, SubItem, EnumInfo shall be defined

2.) BitSize shall match the specified DataType</PostCondition>
					<References>
						<Reference Specification="ETG.2000"></Reference>
						<Reference Specification="ETG.1020"></Reference>
						<Reference Specification="ETG.5001"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="Toggle_LOC_EXT">
					<!--Flag for InitGlobalVariables for default XPaths of local or external file-->
					<SetVariable Target="LocExt_InitToggle">false</SetVariable>
					<WriteLine Id="0" Level="Output">Checking for modules within ESI.</WriteLine>
				</TestStep>
				<TestStep Name="SkipNoSlots">
					<!--Skip Test if "CurrentConfig.SlotCount" == 0-->
					<Compare>
						<Equal>
							<Value1>CurrentConfig.SlotCount</Value1>
							<Value2>0</Value2>
							<SkipCase Id="1">Test skipped. No slots defined.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="SkipSoE">
					<!--Skip Test if SoE Device-->
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Mailbox.SoE</Value1>
							<Value2>true</Value2>
							<SkipCase Id="2">Test skipped for SoE Devices.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="INIT_AVAIL_GLOB_ARRAY">
					<CallTestFunction Name="AvailableDuTModuleIdents"></CallTestFunction>
				</TestStep>
				<TestStep Name="InitGlobalVariables">
					<!--Init global XPaths-->
					<CallTestFunction Name="InitGlobalVariablesForModuleODTest">
						<Parameter>LocExt_InitToggle</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="INIT_RESULT">
					<!--"result" = true-->
					<SetVariable Target="result">true</SetVariable>
				</TestStep>
				<TestStep Name="INIT_LOOP_COUNTER">
					<!--Init "ModuleCounter" = 1-->
					<SetVariable Target="ModuleCounter">1</SetVariable>
				</TestStep>
				<TestStep Name="CHECK_IF_EXISTS">
					<!--Checking if modules exist-->
					<Compare>
						<Equal>
							<Value1>loc_XPathModuleIdent</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>END</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="InitTestedArray">
					<!--Array of already processed modules, no doubles-->
					<InitArray TargetArray="AllModuleIdents.Uint32Array"></InitArray>
				</TestStep>
				<TestStep Name="DataTypeLoopStart">
					<!--__Loop START for LOCAL Modules__-->
				</TestStep>
				<TestStep Name="CHECK_IF_MODULE_EXISTS">
					<!--Checking if module exist-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>END</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>END</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_AVAILABLE_MDL">
					<!--Get ModuleIdent and Flag to SKIP testing of assigned modules-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="AllModuleIdents.Uint32">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>TestAvailableMdls</Value1>
							<Value2>false</Value2>
							<GotoStep>TEST_MODULES</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckItemInArray">
					<!--Check if module in list of assigned modules-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllAvailableDuTModules.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleInArray.boolAssigned</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="3" Level="Verbose" Param0="CheckModuleInArray.boolAssigned" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleInArray.boolAssigned == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleInArray.boolAssigned</Value1>
							<Value2>false</Value2>
							<GotoStep>DataTypeLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckAlreadyTested">
					<!--Check if module already tested-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllModuleIdents.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleAlreadyTested.boolAlreadyChecked</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="4" Level="Verbose" Param0="CheckModuleAlreadyTested.boolAlreadyChecked" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleAlreadyTested.boolAlreadyChecked == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleAlreadyTested.boolAlreadyChecked</Value1>
							<Value2>true</Value2>
							<GotoStep>DataTypeLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_MODULES">
					<!--Print Module Ident-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="5" Level="Verbose" Param0="ModuleCounter" Param1="strXmlValue">Module[{0}]: Ident: {1}</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="Check_extOD_FileRef">
					<CallTestFunction Name="CheckForExtRefDict">
						<Parameter>loc_ModuleXmlFile</Parameter>
						<Parameter>loc_XPathModuleIdent</Parameter>
						<Parameter>ModuleCounter</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="InitSubItemLoopCounter">
					<!--Init of nested loop counter for DataTypes of current module-->
					<SetVariable Target="i32TmpModuleIndex">1</SetVariable>
				</TestStep>
				<TestStep Name="SubItemLoopStart">
					<!--__Loop START for current module DataTypes__-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/Profile/Dictionary/DataTypes/DataType[{2}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>DataTypeLoopEnd</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>DataTypeLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="GET_CURRENT_DT_NAME">
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/Profile/Dictionary/DataTypes/DataType[{2}]/Name</XPath>
					</GetXmlValue>
				</TestStep>
				<TestStep Name="CREATE_XPATH_FOR_DT_ELEMENT">
					<SetVariable Target="loc_XPathDtTmp" Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/Profile/Dictionary/DataTypes/DataType[{2}]</SetVariable>
				</TestStep>
				<TestStep>
					<!--Check if fixed BaseDataType is used-->
					<RegexIsMatch ReturnValue="IsMatch">
						<Pattern>^(BOOL|BIT|BIT[1-8]|BYTE|BITARR8|BITARR16|WORD|BITARR32|DWORD|SINT|INT|INT24|DINT|INT40|INT48|INT56|LINT|USINT|UINT|UINT24|UDINT|UINT40|UINT48|UINT56|ULINT|REAL|LREAL|GUID)$</Pattern>
						<InputString>strXmlValue</InputString>
					</RegexIsMatch>
					<Compare>
						<Equal>
							<Value1>IsMatch</Value1>
							<Value2>false</Value2>
							<GotoStep>SubItemLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="FIXED_BASETYPE">
					<!--Handle fixed base data type-->
					<Description Id="6" Level="Output" Param0="strXmlValue">Check definition of "{0}".</Description>
					<CallTestFunction Name="CheckFixedBaseDataType">
						<Parameter>loc_ModuleXmlFile</Parameter>
						<Parameter>loc_XPathDtTmp</Parameter>
						<OutParameter>TmpResult</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<SetVariable Target="AtLeastOneModuleFound">true</SetVariable>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>TmpResult</Value1>
							<Value2>false</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Equal>
					</Compare>
					<!--Test fixed base type definition finished-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>SubItemLoopEnd</GotoStep>
						</Equal>
					</Compare>
					<!--Dump info if test was successful-->
					<Compare>
						<Equal>
							<Value1>TmpResult</Value1>
							<Value2>true</Value2>
							<WriteLine Id="7" Level="Output">DataType definition valid.</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="SubItemLoopEnd">
					<!--__END of "SubItemLoopStart", increment loop counter__-->
					<SetVariable Target="i32TmpModuleIndex">i32TmpModuleIndex + 1</SetVariable>
					<!--goto loop header by default-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>SubItemLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="DataTypeLoopEnd">
					<!--__END of "DataTypeLoopStart", add ModuleIdent to tested Array__-->
					<AddArrayItem TargetArray="AllModuleIdents.Uint32Array">AllModuleIdents.Uint32</AddArrayItem>
				</TestStep>
				<TestStep>
					<!--Increment loop counter-->
					<SetVariable Target="ModuleCounter">ModuleCounter + 1</SetVariable>
					<!--goto loop header by default-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>DataTypeLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="END">
					<!--Dump Test case result-->
					<Compare>
						<Equal>
							<Value1>AtLeastOneModuleFound</Value1>
							<Value2>false</Value2>
							<SkipCase Id="8">No "fixed" BaseDataType found.</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>true</Value2>
							<ReturnSuccess Id="9">DataType Test successful.</ReturnSuccess>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>false</Value2>
							<RaiseError Id="11"></RaiseError>
						</Equal>
					</Compare>
				</TestStep>
			</TestCase>
			<TestCase Name="BaseDataTypes (ARRAY [0..n] OF xxx)" CaseId="4">
				<?MAX_OUTPUT_ID 11?>
				<Description>
					<PreCondition>The device description includes locally defined module object dictionary</PreCondition>
					<Action>1.) Get SubItem, EnumInfo
2.) Get BaseType
3.) Get ArrayInfo
4.) Get BitSize</Action>
					<PostCondition>1.) Non of elements SubItem, EnumInfo shall be defined

2.) The BaseType shall match the DataType name
	ARRAY [0..n] OF BYTE : BYTE or USINT
	ARRAY [0..n] OF UINT : UINT
	ARRAY [0..n] OF INT : INT
	ARRAY [0..n] OF SINT : SINT
	ARRAY [0..n] OF DINT : DINT
	ARRAY [0..n] OF UDINT : UDINT


3.) ArrayInfo shall be defined. 
	ArrayInfo.LBound shall be 0
	ArrayInfo.Elements shall match n+1

4.) The BitSize shall match ArrayInfo.Elements * size of BaseType </PostCondition>
					<References>
						<Reference Specification="ETG.2000"></Reference>
						<Reference Specification="ETG.1020"></Reference>
						<Reference Specification="ETG.5001"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="Toggle_LOC_EXT">
					<!--Flag for InitGlobalVariables for default XPaths of local or external file-->
					<SetVariable Target="LocExt_InitToggle">false</SetVariable>
					<WriteLine Id="0" Level="Output">Checking for modules within ESI.</WriteLine>
				</TestStep>
				<TestStep Name="SkipNoSlots">
					<!--Skip Test if "CurrentConfig.SlotCount" == 0-->
					<Compare>
						<Equal>
							<Value1>CurrentConfig.SlotCount</Value1>
							<Value2>0</Value2>
							<SkipCase Id="1">Test skipped. No slots defined.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="SkipSoE">
					<!--Skip Test if SoE Device-->
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Mailbox.SoE</Value1>
							<Value2>true</Value2>
							<SkipCase Id="2">Test skipped for SoE Devices.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="INIT_AVAIL_GLOB_ARRAY">
					<CallTestFunction Name="AvailableDuTModuleIdents"></CallTestFunction>
				</TestStep>
				<TestStep Name="InitGlobalVariables">
					<!--Init global XPaths-->
					<CallTestFunction Name="InitGlobalVariablesForModuleODTest">
						<Parameter>LocExt_InitToggle</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="INIT_RESULT">
					<!--"result" = true-->
					<SetVariable Target="result">true</SetVariable>
				</TestStep>
				<TestStep Name="INIT_LOOP_COUNTER">
					<!--Init "ModuleCounter" = 1-->
					<SetVariable Target="ModuleCounter">1</SetVariable>
				</TestStep>
				<TestStep Name="CHECK_IF_EXISTS">
					<!--Checking if modules exist-->
					<Compare>
						<Equal>
							<Value1>loc_XPathModuleIdent</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>END</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="InitTestedArray">
					<!--Array of already processed modules, no doubles-->
					<InitArray TargetArray="AllModuleIdents.Uint32Array"></InitArray>
				</TestStep>
				<TestStep Name="DataTypeLoopStart">
					<!--__Loop START for LOCAL Modules__-->
				</TestStep>
				<TestStep Name="CHECK_IF_MODULE_EXISTS">
					<!--Checking if module exist-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>END</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>END</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_AVAILABLE_MDL">
					<!--Get ModuleIdent and Flag to SKIP testing of assigned modules-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="AllModuleIdents.Uint32">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>TestAvailableMdls</Value1>
							<Value2>false</Value2>
							<GotoStep>TEST_MODULES</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckItemInArray">
					<!--Check if module in list of assigned modules-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllAvailableDuTModules.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleInArray.boolAssigned</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="3" Level="Verbose" Param0="CheckModuleInArray.boolAssigned" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleInArray.boolAssigned == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleInArray.boolAssigned</Value1>
							<Value2>false</Value2>
							<GotoStep>DataTypeLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckAlreadyTested">
					<!--Check if module already tested-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllModuleIdents.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleAlreadyTested.boolAlreadyChecked</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="4" Level="Verbose" Param0="CheckModuleAlreadyTested.boolAlreadyChecked" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleAlreadyTested.boolAlreadyChecked == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleAlreadyTested.boolAlreadyChecked</Value1>
							<Value2>true</Value2>
							<GotoStep>DataTypeLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_MODULES">
					<!--Print Module Ident-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="5" Level="Verbose" Param0="ModuleCounter" Param1="strXmlValue">Module[{0}]: Ident: {1}</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="Check_extOD_FileRef">
					<CallTestFunction Name="CheckForExtRefDict">
						<Parameter>loc_ModuleXmlFile</Parameter>
						<Parameter>loc_XPathModuleIdent</Parameter>
						<Parameter>ModuleCounter</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="InitSubItemLoopCounter">
					<!--Init of nested loop counter for DataTypes of current module-->
					<SetVariable Target="i32TmpModuleIndex">1</SetVariable>
				</TestStep>
				<TestStep Name="SubItemLoopStart">
					<!--__Loop START for current module DataTypes__-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/Profile/Dictionary/DataTypes/DataType[{2}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>DataTypeLoopEnd</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>DataTypeLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="GET_CURRENT_DT_NAME">
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/Profile/Dictionary/DataTypes/DataType[{2}]/Name</XPath>
					</GetXmlValue>
				</TestStep>
				<TestStep Name="CREATE_XPATH_FOR_DT_ELEMENT">
					<SetVariable Target="loc_XPathDtTmp" Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/Profile/Dictionary/DataTypes/DataType[{2}]</SetVariable>
				</TestStep>
				<TestStep>
					<!--Check if "ARRAY [0...n] of BYTE|UINT" is used-->
					<RegexIsMatch ReturnValue="IsMatch">
						<Pattern>^(ARRAY \[0\.\.[0-9]+\] OF (BYTE|SINT|UINT|INT|DINT|UDINT))$</Pattern>
						<InputString>strXmlValue</InputString>
					</RegexIsMatch>
					<Compare>
						<Equal>
							<Value1>IsMatch</Value1>
							<Value2>false</Value2>
							<GotoStep>SubItemLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="ARRAY_BASETYPE">
					<!--Handle array base data type-->
					<Description Id="6" Level="Output" Param0="strXmlValue">Check definition of "{0}".</Description>
					<CallTestFunction Name="CheckArrayBaseDataType">
						<Parameter>loc_ModuleXmlFile</Parameter>
						<Parameter>loc_XPathDtTmp</Parameter>
						<OutParameter>TmpResult</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>TmpResult</Value1>
							<Value2>false</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Equal>
					</Compare>
					<!--Indicate that at least one DT found-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<SetVariable Target="AtLeastOneModuleFound">true</SetVariable>
						</Equal>
					</Compare>
					<!--Dump info if test was successful-->
					<Compare>
						<Equal>
							<Value1>TmpResult</Value1>
							<Value2>true</Value2>
							<WriteLine Id="7" Level="Output">DataType definition valid.</WriteLine>
						</Equal>
					</Compare>
					<!--Test array base type definition finished-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>SubItemLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="SubItemLoopEnd">
					<!--__END of "SubItemLoopStart", increment loop counter__-->
					<SetVariable Target="i32TmpModuleIndex">i32TmpModuleIndex + 1</SetVariable>
					<!--goto loop header by default-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>SubItemLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="DataTypeLoopEnd">
					<!--__END of "DataTypeLoopStart", add ModuleIdent to tested Array__-->
					<AddArrayItem TargetArray="AllModuleIdents.Uint32Array">AllModuleIdents.Uint32</AddArrayItem>
				</TestStep>
				<TestStep>
					<!--Increment loop counter-->
					<SetVariable Target="ModuleCounter">ModuleCounter + 1</SetVariable>
					<!--goto loop header by default-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>DataTypeLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="END">
					<!--Dump Test case result-->
					<Compare>
						<Equal>
							<Value1>AtLeastOneModuleFound</Value1>
							<Value2>false</Value2>
							<SkipCase Id="8">No "ARRAY" BaseDataType found.</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>true</Value2>
							<ReturnSuccess Id="9">DataType Test successful.</ReturnSuccess>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>false</Value2>
							<RaiseError Id="11"></RaiseError>
						</Equal>
					</Compare>
				</TestStep>
			</TestCase>
			<TestCase Name="BaseDataTypes (STRING(n))" CaseId="5">
				<?MAX_OUTPUT_ID 12?>
				<Description>
					<PreCondition>The device description includes locally defined module object dictionary</PreCondition>
					<Action>1.) Get BaseType, ArrayInfo, SubItem, EnumInfo
2.) Get BitSize</Action>
					<PostCondition>1.) Non of the Elements BaseType, ArrayInfo, SubItem, EnumInfo shall be defined

2.) The BitSize shall be n*8</PostCondition>
					<References>
						<Reference Specification="ETG.2000"></Reference>
						<Reference Specification="ETG.1020"></Reference>
						<Reference Specification="ETG.5001"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="Toggle_LOC_EXT">
					<!--Flag for InitGlobalVariables for default XPaths of local or external file-->
					<SetVariable Target="LocExt_InitToggle">false</SetVariable>
					<WriteLine Id="0" Level="Output">Checking for modules within ESI.</WriteLine>
				</TestStep>
				<TestStep Name="SkipNoSlots">
					<!--Skip Test if "CurrentConfig.SlotCount" == 0-->
					<Compare>
						<Equal>
							<Value1>CurrentConfig.SlotCount</Value1>
							<Value2>0</Value2>
							<SkipCase Id="1">Test skipped. No slots defined.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="SkipSoE">
					<!--Skip Test if SoE Device-->
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Mailbox.SoE</Value1>
							<Value2>true</Value2>
							<SkipCase Id="2">Test skipped for SoE Devices.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="INIT_AVAIL_GLOB_ARRAY">
					<CallTestFunction Name="AvailableDuTModuleIdents"></CallTestFunction>
				</TestStep>
				<TestStep Name="InitGlobalVariables">
					<!--Init global XPaths-->
					<CallTestFunction Name="InitGlobalVariablesForModuleODTest">
						<Parameter>LocExt_InitToggle</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="INIT_RESULT">
					<!--"result" = true-->
					<SetVariable Target="result">true</SetVariable>
				</TestStep>
				<TestStep Name="INIT_LOOP_COUNTER">
					<!--Init "ModuleCounter" = 1-->
					<SetVariable Target="ModuleCounter">1</SetVariable>
				</TestStep>
				<TestStep Name="CHECK_IF_EXISTS">
					<!--Checking if modules exist-->
					<Compare>
						<Equal>
							<Value1>loc_XPathModuleIdent</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>END</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="InitTestedArray">
					<!--Array of already processed modules, no doubles-->
					<InitArray TargetArray="AllModuleIdents.Uint32Array"></InitArray>
				</TestStep>
				<TestStep Name="DataTypeLoopStart">
					<!--__Loop START for LOCAL Modules__-->
				</TestStep>
				<TestStep Name="CHECK_IF_MODULE_EXISTS">
					<!--Checking if module exist-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>END</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>END</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_AVAILABLE_MDL">
					<!--Get ModuleIdent and Flag to SKIP testing of assigned modules-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="AllModuleIdents.Uint32">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>TestAvailableMdls</Value1>
							<Value2>false</Value2>
							<GotoStep>TEST_MODULES</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckItemInArray">
					<!--Check if module in list of assigned modules-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllAvailableDuTModules.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleInArray.boolAssigned</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="3" Level="Verbose" Param0="CheckModuleInArray.boolAssigned" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleInArray.boolAssigned == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleInArray.boolAssigned</Value1>
							<Value2>false</Value2>
							<GotoStep>DataTypeLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckAlreadyTested">
					<!--Check if module already tested-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllModuleIdents.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleAlreadyTested.boolAlreadyChecked</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="4" Level="Verbose" Param0="CheckModuleAlreadyTested.boolAlreadyChecked" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleAlreadyTested.boolAlreadyChecked == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleAlreadyTested.boolAlreadyChecked</Value1>
							<Value2>true</Value2>
							<GotoStep>DataTypeLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_MODULES">
					<!--Print Module Ident-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="5" Level="Verbose" Param0="ModuleCounter" Param1="strXmlValue">Module[{0}]: Ident: {1}</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="Check_extOD_FileRef">
					<CallTestFunction Name="CheckForExtRefDict">
						<Parameter>loc_ModuleXmlFile</Parameter>
						<Parameter>loc_XPathModuleIdent</Parameter>
						<Parameter>ModuleCounter</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="InitSubItemLoopCounter">
					<!--Init of nested loop counter for DataTypes of current module-->
					<SetVariable Target="i32TmpModuleIndex">1</SetVariable>
				</TestStep>
				<TestStep Name="SubItemLoopStart">
					<!--__Loop START for current module DataTypes__-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/Profile/Dictionary/DataTypes/DataType[{2}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>DataTypeLoopEnd</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>DataTypeLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="GET_CURRENT_DT_NAME">
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/Profile/Dictionary/DataTypes/DataType[{2}]/Name</XPath>
					</GetXmlValue>
				</TestStep>
				<TestStep Name="CREATE_XPATH_FOR_DT_ELEMENT">
					<SetVariable Target="loc_XPathDtTmp" Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/Profile/Dictionary/DataTypes/DataType[{2}]</SetVariable>
				</TestStep>
				<TestStep>
					<!--Check if "STRING(n)" is used-->
					<RegexIsMatch ReturnValue="IsMatch">
						<Pattern>^(STRING\([0-9]+\))$</Pattern>
						<InputString>strXmlValue</InputString>
					</RegexIsMatch>
					<Compare>
						<Equal>
							<Value1>IsMatch</Value1>
							<Value2>false</Value2>
							<GotoStep>SubItemLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="STRING_BASETYPE">
					<!--Handle string base data type-->
					<Description Id="6" Level="Output" Param0="strXmlValue">Check definition of "{0}".</Description>
					<CallTestFunction Name="CheckStringBaseDataType">
						<Parameter>loc_ModuleXmlFile</Parameter>
						<Parameter>loc_XPathDtTmp</Parameter>
						<OutParameter>TmpResult</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="7" Param0="TmpResult" Level="Verbose">String(n) DataType test result : {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>TmpResult</Value1>
							<Value2>false</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Equal>
					</Compare>
					<!--Dump info if test was successful-->
					<Compare>
						<Equal>
							<Value1>TmpResult</Value1>
							<Value2>true</Value2>
							<WriteLine Id="8" Level="Output">DataType definition valid.</WriteLine>
						</Equal>
					</Compare>
					<!--Indicate that at least one DT was found-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<SetVariable Target="AtLeastOneModuleFound">true</SetVariable>
						</Equal>
					</Compare>
					<!--Test string base type definition finished-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>SubItemLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="SubItemLoopEnd">
					<!--__END of "SubItemLoopStart", increment loop counter__-->
					<SetVariable Target="i32TmpModuleIndex">i32TmpModuleIndex + 1</SetVariable>
					<!--goto loop header by default-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>SubItemLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="DataTypeLoopEnd">
					<!--__END of "DataTypeLoopStart", add ModuleIdent to tested Array__-->
					<AddArrayItem TargetArray="AllModuleIdents.Uint32Array">AllModuleIdents.Uint32</AddArrayItem>
				</TestStep>
				<TestStep>
					<!--Increment loop counter-->
					<SetVariable Target="ModuleCounter">ModuleCounter + 1</SetVariable>
					<!--goto loop header by default-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>DataTypeLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="END">
					<!--Dump Test case result-->
					<Compare>
						<Equal>
							<Value1>AtLeastOneModuleFound</Value1>
							<Value2>false</Value2>
							<SkipCase Id="9">No "STRING" BaseDataType found.</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>true</Value2>
							<ReturnSuccess Id="10">DataType Test successful.</ReturnSuccess>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>false</Value2>
							<RaiseError Id="12"></RaiseError>
						</Equal>
					</Compare>
				</TestStep>
			</TestCase>
			<TestCase Name="Array/Record DataTypes" CaseId="6">
				<?MAX_OUTPUT_ID 13?>
				<Description>
					<PreCondition>The device description includes locally defined module object dictionary</PreCondition>
					<Action>1.) DTxxxxARR
1a.) Get SubItem, EnumInfo
1b.) Get BaseType
1c.) Get ArrayInfo
1d.) Get BitSize

2.) DTxxxx
2a.) Get ArrayInfo, EnumInfo, BaseType
2b.) Get SubItem
2c.) Get BitSize</Action>
					<PostCondition>1a.) Non of elements SubItem, EnumInfo shall be defined
1b.) The BaseType shall be a Base DataType with a fixed length
1c.) ArrayInfo shall be defined. 
	ArrayInfo.LBound shall be 1
	ArrayInfo.Elements shall match n+1 and shall be less 256
1d.) The BitSize shall match ArrayInfo.Elements * size of BaseType 

2a.) Non of the Elements ArrayInfo, EnumInfo, BaseType shall be defined
2b.) At least two SubItems shall be defined
	- First SubItem:
	    SubIdx shall be 0
		Name shall be "SubIndex 000" or "Number of Entries"
		Type shall be "USINT"
		BitSize shall be 8
		BitOffs shall be 0
	- Second SubItem:
		BitOffs shall be 16
		Name shall not be empty
		BitSize shall match size of Type
		SubItem not defined (Array object)
			Type shall be DTxxxxARR
	-Following SubItems (only for record objects)
		BitOffs shall be at least greater than the following BitSize + BitOffs.
		Type shall be Base DataType
		Name shall not be empty
		BitSize shall match size of Type
			
2c.) The BitSize shall match the total size of the SubItems</PostCondition>
					<References>
						<Reference Specification="ETG.2000"></Reference>
						<Reference Specification="ETG.1020"></Reference>
						<Reference Specification="ETG.5001"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="Toggle_LOC_EXT">
					<!--Flag for InitGlobalVariables for default XPaths of local or external file-->
					<SetVariable Target="LocExt_InitToggle">false</SetVariable>
					<WriteLine Id="0" Level="Output">Checking for modules within ESI.</WriteLine>
				</TestStep>
				<TestStep Name="SkipNoSlots">
					<!--Skip Test if "CurrentConfig.SlotCount" == 0-->
					<Compare>
						<Equal>
							<Value1>CurrentConfig.SlotCount</Value1>
							<Value2>0</Value2>
							<SkipCase Id="1">Test skipped. No slots defined.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="SkipSoE">
					<!--Skip Test if SoE Device-->
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Mailbox.SoE</Value1>
							<Value2>true</Value2>
							<SkipCase Id="2">Test skipped for SoE Devices.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="INIT_AVAIL_GLOB_ARRAY">
					<CallTestFunction Name="AvailableDuTModuleIdents"></CallTestFunction>
				</TestStep>
				<TestStep Name="InitGlobalVariables">
					<!--Init global XPaths-->
					<CallTestFunction Name="InitGlobalVariablesForModuleODTest">
						<Parameter>LocExt_InitToggle</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="INIT_RESULT">
					<!--"result" = true-->
					<SetVariable Target="result">true</SetVariable>
				</TestStep>
				<TestStep Name="INIT_LOOP_COUNTER">
					<!--Init "ModuleCounter" = 1-->
					<SetVariable Target="ModuleCounter">1</SetVariable>
				</TestStep>
				<TestStep Name="CHECK_IF_EXISTS">
					<!--Checking if modules exist-->
					<Compare>
						<Equal>
							<Value1>loc_XPathModuleIdent</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>END</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="InitTestedArray">
					<!--Array of already processed modules, no doubles-->
					<InitArray TargetArray="AllModuleIdents.Uint32Array"></InitArray>
				</TestStep>
				<TestStep Name="DataTypeLoopStart">
					<!--__Loop START for LOCAL Modules__-->
				</TestStep>
				<TestStep Name="CHECK_IF_MODULE_EXISTS">
					<!--Checking if module exist-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>END</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>END</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_AVAILABLE_MDL">
					<!--Get ModuleIdent and Flag to SKIP testing of assigned modules-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="AllModuleIdents.Uint32">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>TestAvailableMdls</Value1>
							<Value2>false</Value2>
							<GotoStep>TEST_MODULES</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckItemInArray">
					<!--Check if module in list of assigned modules-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllAvailableDuTModules.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleInArray.boolAssigned</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="3" Level="Verbose" Param0="CheckModuleInArray.boolAssigned" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleInArray.boolAssigned == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleInArray.boolAssigned</Value1>
							<Value2>false</Value2>
							<GotoStep>DataTypeLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckAlreadyTested">
					<!--Check if module already tested-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllModuleIdents.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleAlreadyTested.boolAlreadyChecked</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="4" Level="Verbose" Param0="CheckModuleAlreadyTested.boolAlreadyChecked" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleAlreadyTested.boolAlreadyChecked == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleAlreadyTested.boolAlreadyChecked</Value1>
							<Value2>true</Value2>
							<GotoStep>DataTypeLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_MODULES">
					<!--Print Module Ident-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="5" Level="Verbose" Param0="ModuleCounter" Param1="strXmlValue">Module[{0}]: Ident: {1}</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="Check_extOD_FileRef">
					<CallTestFunction Name="CheckForExtRefDict">
						<Parameter>loc_ModuleXmlFile</Parameter>
						<Parameter>loc_XPathModuleIdent</Parameter>
						<Parameter>ModuleCounter</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="InitSubItemLoopCounter">
					<!--Init of nested loop counter for DataTypes of current module-->
					<SetVariable Target="i32TmpModuleIndex">1</SetVariable>
				</TestStep>
				<TestStep Name="SubItemLoopStart">
					<!--__Loop START for current module DataTypes__-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/Profile/Dictionary/DataTypes/DataType[{2}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>DataTypeLoopEnd</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>DataTypeLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="GET_CURRENT_DT_NAME">
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/Profile/Dictionary/DataTypes/DataType[{2}]/Name</XPath>
					</GetXmlValue>
				</TestStep>
				<TestStep Name="CREATE_XPATH_FOR_DT_ELEMENT">
					<SetVariable Target="loc_XPathDtTmp" Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/Profile/Dictionary/DataTypes/DataType[{2}]</SetVariable>
				</TestStep>
				<TestStep>
					<!--Check if "DTxxxx" is used-->
					<RegexIsMatch ReturnValue="IsMatch">
						<Pattern>^(DT[0-9A-Fa-fXx]{1,4})$</Pattern>
						<InputString>strXmlValue</InputString>
					</RegexIsMatch>
					<Compare>
						<Equal>
							<Value1>IsMatch</Value1>
							<Value2>true</Value2>
							<GotoStep>DTxxxx_TYPE</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<!--Check if "DTxxxARR" is used-->
					<RegexIsMatch ReturnValue="IsMatch">
						<Pattern>^(DT[0-9A-Fa-fXx]{1,4}ARR)$</Pattern>
						<InputString>strXmlValue</InputString>
					</RegexIsMatch>
					<Compare>
						<Equal>
							<Value1>IsMatch</Value1>
							<Value2>true</Value2>
							<GotoStep>DTxxxARR_TYPE</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<!--proceed with next DT-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>SubItemLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="DTxxxx_TYPE">
					<!--Handle DTxxx data type-->
					<Description Id="6" Level="Output" Param0="strXmlValue">Check definition of "{0}".</Description>
					<CallTestFunction Name="CheckDTxxxxDataType">
						<Parameter>loc_ModuleXmlFile</Parameter>
						<Parameter>loc_XPathDtTmp</Parameter>
						<OutParameter>TmpResult</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>TmpResult</Value1>
							<Value2>false</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Equal>
					</Compare>
					<!--Dump info if test was successful-->
					<Compare>
						<Equal>
							<Value1>TmpResult</Value1>
							<Value2>true</Value2>
							<WriteLine Id="7" Level="Output">DataType definition valid.</WriteLine>
						</Equal>
					</Compare>
					<!--Indicate that at least one DT found-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<SetVariable Target="AtLeastOneModuleFound">true</SetVariable>
						</Equal>
					</Compare>
					<!--Test DTxxx type definition finished-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>SubItemLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="DTxxxARR_TYPE">
					<!--Handle DTxxxARR data type-->
					<Description Id="8" Level="Output" Param0="strXmlValue">Check definition of "{0}".</Description>
					<CallTestFunction Name="CheckDTxxxxARRDataType">
						<Parameter>loc_ModuleXmlFile</Parameter>
						<Parameter>loc_XPathDtTmp</Parameter>
						<OutParameter>TmpResult</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>TmpResult</Value1>
							<Value2>false</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Equal>
					</Compare>
					<!--Dump info if test was successful-->
					<Compare>
						<Equal>
							<Value1>TmpResult</Value1>
							<Value2>true</Value2>
							<WriteLine Id="9" Level="Output">DataType definition valid.</WriteLine>
						</Equal>
					</Compare>
					<!--Indicate that at least one DT found-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<SetVariable Target="AtLeastOneModuleFound">true</SetVariable>
						</Equal>
					</Compare>
					<!--Test DTxxxARR type definition finished-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>SubItemLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="SubItemLoopEnd">
					<!--__END of "SubItemLoopStart", increment loop counter__-->
					<SetVariable Target="i32TmpModuleIndex">i32TmpModuleIndex + 1</SetVariable>
					<!--goto loop header by default-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>SubItemLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="DataTypeLoopEnd">
					<!--__END of "DataTypeLoopStart", add ModuleIdent to tested Array__-->
					<AddArrayItem TargetArray="AllModuleIdents.Uint32Array">AllModuleIdents.Uint32</AddArrayItem>
				</TestStep>
				<TestStep>
					<!--Increment loop counter-->
					<SetVariable Target="ModuleCounter">ModuleCounter + 1</SetVariable>
					<!--goto loop header-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>DataTypeLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="END">
					<!--Dump Test case result-->
					<Compare>
						<Equal>
							<Value1>AtLeastOneModuleFound</Value1>
							<Value2>false</Value2>
							<SkipCase Id="10">No Array or Record DataType found.</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>true</Value2>
							<ReturnSuccess Id="11">DataType Test successful.</ReturnSuccess>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>false</Value2>
							<RaiseError Id="13"></RaiseError>
						</Equal>
					</Compare>
				</TestStep>
			</TestCase>
			<TestCase Name="Enum DataTypes" CaseId="7">
				<?MAX_OUTPUT_ID 11?>
				<Description>
					<PreCondition>The device description includes locally defined module object dictionary</PreCondition>
					<Action>1.) Get ArrayInfo, SubItem
2.) Get BitSize
3.) Get BaseType
4.) Get EnumInfo</Action>
					<PostCondition>1.) Non of the Elements ArrayInfo, SubItem shall be defined

2.) The BitSize shall equal nn and less or equal size of BaseType

3.) The BaseType shall be USINT, UINT or UDINT

4.) EnumInfo shall be defined
	EnumInfo.Enum shall be within the range of values limited by nn
	Enum.Text shall not be empty</PostCondition>
					<References>
						<Reference Specification="ETG.2000"></Reference>
						<Reference Specification="ETG.1020"></Reference>
						<Reference Specification="ETG.5001"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="Toggle_LOC_EXT">
					<!--Flag for InitGlobalVariables for default XPaths of local or external file-->
					<SetVariable Target="LocExt_InitToggle">false</SetVariable>
					<WriteLine Id="0" Level="Output">Checking for modules within ESI.</WriteLine>
				</TestStep>
				<TestStep Name="SkipNoSlots">
					<!--Skip Test if "CurrentConfig.SlotCount" == 0-->
					<Compare>
						<Equal>
							<Value1>CurrentConfig.SlotCount</Value1>
							<Value2>0</Value2>
							<SkipCase Id="1">Test skipped. No slots defined.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="SkipSoE">
					<!--Skip Test if SoE Device-->
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Mailbox.SoE</Value1>
							<Value2>true</Value2>
							<SkipCase Id="2">Test skipped for SoE Devices.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="INIT_AVAIL_GLOB_ARRAY">
					<CallTestFunction Name="AvailableDuTModuleIdents"></CallTestFunction>
				</TestStep>
				<TestStep Name="InitGlobalVariables">
					<!--Init global XPaths-->
					<CallTestFunction Name="InitGlobalVariablesForModuleODTest">
						<Parameter>LocExt_InitToggle</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="INIT_RESULT">
					<!--"result" = true-->
					<SetVariable Target="result">true</SetVariable>
				</TestStep>
				<TestStep Name="INIT_LOOP_COUNTER">
					<!--"ModuleCounter" = 1-->
					<SetVariable Target="ModuleCounter">1</SetVariable>
				</TestStep>
				<TestStep Name="CHECK_IF_EXISTS">
					<!--Checking if modules exist-->
					<Compare>
						<Equal>
							<Value1>loc_XPathModuleIdent</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>END</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="InitTestedArray">
					<!--Array of already processed modules, no doubles-->
					<InitArray TargetArray="AllModuleIdents.Uint32Array"></InitArray>
				</TestStep>
				<TestStep Name="DataTypeLoopStart">
					<!--__Loop START for LOCAL Modules__-->
				</TestStep>
				<TestStep Name="CHECK_IF_MODULE_EXISTS">
					<!--Checking if module exist-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>END</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>END</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_AVAILABLE_MDL">
					<!--Get ModuleIdent and Flag to SKIP testing of assigned modules-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="AllModuleIdents.Uint32">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>TestAvailableMdls</Value1>
							<Value2>false</Value2>
							<GotoStep>TEST_MODULES</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckItemInArray">
					<!--Check if module in list of assigned modules-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllAvailableDuTModules.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleInArray.boolAssigned</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="3" Level="Verbose" Param0="CheckModuleInArray.boolAssigned" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleInArray.boolAssigned == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleInArray.boolAssigned</Value1>
							<Value2>false</Value2>
							<GotoStep>DataTypeLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckAlreadyTested">
					<!--Check if module already tested-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllModuleIdents.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleAlreadyTested.boolAlreadyChecked</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="4" Level="Verbose" Param0="CheckModuleAlreadyTested.boolAlreadyChecked" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleAlreadyTested.boolAlreadyChecked == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleAlreadyTested.boolAlreadyChecked</Value1>
							<Value2>true</Value2>
							<GotoStep>DataTypeLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_MODULES">
					<!--Print Module Ident-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="5" Level="Verbose" Param0="ModuleCounter" Param1="strXmlValue">Module[{0}]: Ident: {1}</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="Check_extOD_FileRef">
					<CallTestFunction Name="CheckForExtRefDict">
						<Parameter>loc_ModuleXmlFile</Parameter>
						<Parameter>loc_XPathModuleIdent</Parameter>
						<Parameter>ModuleCounter</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="InitSubItemLoopCounter">
					<!--Init of nested loop counter for DataTypes of current module-->
					<SetVariable Target="i32TmpModuleIndex">1</SetVariable>
				</TestStep>
				<TestStep Name="SubItemLoopStart">
					<!--__Loop START for current module DataTypes__-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/Profile/Dictionary/DataTypes/DataType[{2}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>DataTypeLoopEnd</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>DataTypeLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="GET_CURRENT_DT_NAME">
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/Profile/Dictionary/DataTypes/DataType[{2}]/Name</XPath>
					</GetXmlValue>
				</TestStep>
				<TestStep Name="CREATE_XPATH_FOR_DT_ELEMENT">
					<SetVariable Target="loc_XPathDtTmp" Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/Profile/Dictionary/DataTypes/DataType[{2}]</SetVariable>
				</TestStep>
				<TestStep>
					<!--Check if "DTxxxENnn" is used-->
					<RegexIsMatch ReturnValue="IsMatch">
						<Pattern>^(DT[0-9A-Fa-fXx]{4}EN([0-9]{2}))$</Pattern>
						<InputString>strXmlValue</InputString>
					</RegexIsMatch>
					<Compare>
						<Equal>
							<Value1>IsMatch</Value1>
							<Value2>false</Value2>
							<GotoStep>SubItemLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="DTxxxENnn_TYPE">
					<!--Handle DTxxxENnn data type-->
					<Description Id="6" Level="Output" Param0="strXmlValue">Check definition of "{0}".</Description>
					<CallTestFunction Name="CheckDTxxxxENnnDataType">
						<Parameter>loc_ModuleXmlFile</Parameter>
						<Parameter>loc_XPathDtTmp</Parameter>
						<OutParameter>TmpResult</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>TmpResult</Value1>
							<Value2>false</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Equal>
					</Compare>
					<!--Dump info if test was successful-->
					<Compare>
						<Equal>
							<Value1>TmpResult</Value1>
							<Value2>true</Value2>
							<WriteLine Id="7" Level="Output">DataType definition valid.</WriteLine>
						</Equal>
					</Compare>
					<!--Indicate that at least one DT found-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<SetVariable Target="AtLeastOneModuleFound">true</SetVariable>
						</Equal>
					</Compare>
					<!--Test DTxxxENnn type definition finished-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>SubItemLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="SubItemLoopEnd">
					<!--__END of "SubItemLoopStart", increment loop counter__-->
					<SetVariable Target="i32TmpModuleIndex">i32TmpModuleIndex + 1</SetVariable>
					<!--goto loop header by default-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>SubItemLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="DataTypeLoopEnd">
					<!--__END of "DataTypeLoopStart", add ModuleIdent to tested Array__-->
					<AddArrayItem TargetArray="AllModuleIdents.Uint32Array">AllModuleIdents.Uint32</AddArrayItem>
				</TestStep>
				<TestStep>
					<!--Increment loop counter-->
					<SetVariable Target="ModuleCounter">ModuleCounter + 1</SetVariable>
					<!--goto loop header by default-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>DataTypeLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="END">
					<!--Dump Test case result-->
					<Compare>
						<Equal>
							<Value1>AtLeastOneModuleFound</Value1>
							<Value2>false</Value2>
							<SkipCase Id="8">No Enum DataType found.</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>true</Value2>
							<ReturnSuccess Id="9">DataType Test successful.</ReturnSuccess>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>false</Value2>
							<RaiseError Id="11"></RaiseError>
						</Equal>
					</Compare>
				</TestStep>
			</TestCase>
		</TestGroup>
		<TestGroup GroupId="101" Name="(Local) Module RxPdo Tests">
			<Comment>Check the correct usage and values of the RxPDO elements for modules defined locally in ESI</Comment>
			<TestCase Name="Check Attributes" CaseId="1">
				<?MAX_OUTPUT_ID 27?>
				<Description>
					<Purpose>Correct usage of module RxPdo attributes</Purpose>
					<PreCondition>The device description includes locally defined module object dictionary and contains at least one RxPDO element.</PreCondition>
					<Action>1. @Su
2. @Fixed
3. @OSFac,@OSMin,@OSMax,@OSIndexInc</Action>
					<PostCondition>1. if @Su defined a matching FMMU shall be referenced
2. if @Fixed is true at least one entry should be defined
3. if defined @OSxxx shall be greater/equal 0
   and @OSMin less/equal @OSFac greater/equal @OSMax</PostCondition>
					<References>
						<Reference Specification="ETG.2000"></Reference>
						<Reference Specification="ETG.5001"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="Toggle_LOC_EXT">
					<!--Flag for InitGlobalVariables for default XPaths of local or external file-->
					<SetVariable Target="LocExt_InitToggle">false</SetVariable>
					<WriteLine Id="0" Level="Output">Checking for external file with modules</WriteLine>
				</TestStep>
				<TestStep Name="SkipNoSlots">
					<!--Skip Test if "CurrentConfig.SlotCount" == 0-->
					<Compare>
						<Equal>
							<Value1>CurrentConfig.SlotCount</Value1>
							<Value2>0</Value2>
							<SkipCase Id="1">Test skipped. No slots defined.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="SkipSoE">
					<!--Skip Test if SoE Device-->
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Mailbox.SoE</Value1>
							<Value2>true</Value2>
							<SkipCase Id="2">Test skipped for SoE Devices.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="INIT_AVAIL_GLOB_ARRAY">
					<CallTestFunction Name="AvailableDuTModuleIdents"></CallTestFunction>
				</TestStep>
				<TestStep Name="InitGlobalVariables">
					<!--Init global XPaths-->
					<CallTestFunction Name="InitGlobalVariablesForModuleODTest">
						<Parameter>LocExt_InitToggle</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="INIT_RESULT">
					<!--"result" = true-->
					<SetVariable Target="result">true</SetVariable>
				</TestStep>
				<TestStep Name="INIT_LOOP_COUNTER">
					<!--"ModuleCounter" = 1-->
					<SetVariable Target="ModuleCounter">1</SetVariable>
				</TestStep>
				<TestStep Name="CHECK_IF_EXISTS">
					<!--Checking if modules exist-->
					<Compare>
						<Equal>
							<Value1>loc_XPathModuleIdent</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>TEST_END</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="InitTestedArray">
					<!--Array of already processed modules, no doubles-->
					<InitArray TargetArray="AllModuleIdents.Uint32Array"></InitArray>
				</TestStep>
				<TestStep Name="ModuleLoopStart">
					<!--__Loop START for LOCAL Modules__-->
				</TestStep>
				<TestStep Name="CHECK_IF_MODULE_EXISTS">
					<!--Checking if module exist-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>TEST_END</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>TEST_END</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_AVAILABLE_MDL">
					<!--Get ModuleIdent and Flag to SKIP testing of assigned modules-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="AllModuleIdents.Uint32">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>TestAvailableMdls</Value1>
							<Value2>false</Value2>
							<GotoStep>TEST_MODULES</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckItemInArray">
					<!--Check if module in list of assigned modules-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllAvailableDuTModules.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleInArray.boolAssigned</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="3" Level="Verbose" Param0="CheckModuleInArray.boolAssigned" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleInArray.boolAssigned == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleInArray.boolAssigned</Value1>
							<Value2>false</Value2>
							<GotoStep>RxPdoLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckAlreadyTested">
					<!--Check if module already tested-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllModuleIdents.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleAlreadyTested.boolAlreadyChecked</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="4" Level="Verbose" Param0="CheckModuleAlreadyTested.boolAlreadyChecked" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleAlreadyTested.boolAlreadyChecked == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleAlreadyTested.boolAlreadyChecked</Value1>
							<Value2>true</Value2>
							<GotoStep>RxPdoLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_MODULES">
					<!--Print Module Ident-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="5" Level="Verbose" Param0="ModuleCounter" Param1="strXmlValue">Module[{0}]: Ident: {1}</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="Check_extOD_FileRef">
					<CallTestFunction Name="CheckForExtRefDict">
						<Parameter>loc_ModuleXmlFile</Parameter>
						<Parameter>loc_XPathModuleIdent</Parameter>
						<Parameter>ModuleCounter</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="InitSubItemLoopCounter">
					<!--Init of nested loop counter for RxPdo of current module-->
					<SetVariable Target="i32TmpModuleIndex">1</SetVariable>
				</TestStep>
				<TestStep Name="AttributeLoopStart">
					<!--__Loop START for current module RxPdo__-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/RxPdo[{2}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>RxPdoLoopEnd</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>RxPdoLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<!--Check if RxPdo@Su is defined-->
					<Description Id="6" Level="Output">Check @Su attribute.</Description>
					<!--Skip Su test if Sm is not defined-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/RxPdo[{2}]/@Sm</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<WriteLine Id="7" Level="Verbose" Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">Skip Su test because default Sm not defined ({0}[{1}]/RxPdo[{2}]/@Sm not defined).</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<WriteLine Id="8" Level="Verbose" Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">Skip Su test because default Sm not defined ({0}[{1}]/RxPdo[{2}]/@Sm not defined).</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>TEST_OS_INDEXINC</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>TEST_OS_INDEXINC</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<!--Skip Su test if Su is not defined-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/RxPdo[{2}]/@Su</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<WriteLine Id="9" Level="Verbose" Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/RxPdo[{2}]/@Su not defined.</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<WriteLine Id="10" Level="Verbose" Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/RxPdo[{2}]/@Su not defined.</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>TEST_OS_INDEXINC</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>TEST_OS_INDEXINC</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<WriteLine Id="11" Level="Output" Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">Check if {0}[{1}]/RxPdo[{2}]/@Su reference a valid Fmmu.</WriteLine>
				</TestStep>
				<TestStep>
					<!--Convert to Uint16-->
					<SetVariable Target="strXmlValue.Su.Uint16">strXmlValue</SetVariable>
				</TestStep>
				<TestStep>
					<!--Get Referenced Fmmu-->
					<CallTestFunction Name="GetFmmuBySu">
						<Parameter>strXmlValue.Su.Uint16</Parameter>
						<Parameter>Outputs</Parameter>
						<OutParameter>i32TmpIndex</OutParameter>
					</CallTestFunction>
				</TestStep>
				<TestStep>
					<!--Check if FMMU exists-->
					<Compare>
						<Lower>
							<Value1>i32TmpIndex</Value1>
							<Value2>0</Value2>
							<WriteLine Id="12" Level="Error" Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/RxPdo[{2}]/@Su doesn't reference an existing/matching Fmmu.</WriteLine>
						</Lower>
					</Compare>
					<Compare>
						<Lower>
							<Value1>i32TmpIndex</Value1>
							<Value2>0</Value2>
							<SetVariable Target="AtLeastOneModuleFound">true</SetVariable>
						</Lower>
					</Compare>
					<Compare>
						<Lower>
							<Value1>i32TmpIndex</Value1>
							<Value2>0</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Lower>
					</Compare>
					<Compare>
						<Lower>
							<Value1>i32TmpIndex</Value1>
							<Value2>0</Value2>
							<GotoStep>TEST_OS_INDEXINC</GotoStep>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_OS_INDEXINC">
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/RxPdo[{2}]/@OSIndexInc</XPath>
					</GetXmlValue>
				</TestStep>
				<TestStep>
					<!--Convert to Int32-->
					<SetVariable Target="strXmlValue.OSIndexInc.Int32">strXmlValue</SetVariable>
				</TestStep>
				<TestStep>
					<!--Check RxPdo@OSIndexInc-->
					<Description Id="13" Level="Output">Check @OSxxxx attributes.</Description>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>TEST_OS_MIN</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>TEST_OS_MIN</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Lower>
							<Value1>strXmlValue.OSIndexInc.Int32</Value1>
							<Value2>0</Value2>
							<WriteLine Id="14" Level="Error" Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex" Param3="strXmlValue.OSIndexInc.Int32">{0}[{1}]/RxPdo[{2}]/@OSIndexInc shall be &gt;= 0 (current value : {3})</WriteLine>
						</Lower>
					</Compare>
					<Compare>
						<Lower>
							<Value1>strXmlValue.OSIndexInc.Int32</Value1>
							<Value2>0</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_OS_MIN">
					<!--Get RxPdo@OSMin-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValueOSMin">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/RxPdo[{2}]/@OSMin</XPath>
					</GetXmlValue>
				</TestStep>
				<TestStep>
					<!--Get RxPdo@OSFac-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValueOSFac">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/RxPdo[{2}]/@OSFac</XPath>
					</GetXmlValue>
				</TestStep>
				<TestStep>
					<!--Get RxPdo@OSMax-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValueOSMax">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/RxPdo[{2}]/@OSMax</XPath>
					</GetXmlValue>
				</TestStep>
				<TestStep>
					<!--Convert to Int32-->
					<SetVariable Target="strXmlValue.OSMin.Int32">strXmlValueOSMin</SetVariable>
				</TestStep>
				<TestStep>
					<!--Convert to Int32-->
					<SetVariable Target="strXmlValue.OSFac.Int32">strXmlValueOSFac</SetVariable>
				</TestStep>
				<TestStep>
					<!--Convert to Int32-->
					<SetVariable Target="strXmlValue.OSMax.Int32">strXmlValueOSMax</SetVariable>
				</TestStep>
				<TestStep>
					<!--Check RxPdo@OSMin-->
					<Compare>
						<Equal>
							<Value1>strXmlValueOSMin</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>TEST_OS_FAC</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValueOSMin</Value1>
							<Value2>null</Value2>
							<GotoStep>TEST_OS_FAC</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<SetVariable Target="AtLeastOneModuleFound">true</SetVariable>
						</Equal>
					</Compare>
					<Compare>
						<Lower>
							<Value1>strXmlValue.OSMin.Int32</Value1>
							<Value2>0</Value2>
							<WriteLine Id="15" Level="Error" Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex" Param3="strXmlValue.OSMin.Int32">{0}[{1}]/RxPdo[{2}]/@OSMin shall be &gt;= 0 (current value : {3})</WriteLine>
						</Lower>
					</Compare>
					<Compare>
						<Lower>
							<Value1>strXmlValue.OSMin.Int32</Value1>
							<Value2>0</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Lower>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValueOSFac</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>TEST_OS_FAC</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValueOSFac</Value1>
							<Value2>null</Value2>
							<GotoStep>TEST_OS_FAC</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<SetVariable Target="AtLeastOneModuleFound">true</SetVariable>
						</Equal>
					</Compare>
					<Compare>
						<Lower>
							<Value1>strXmlValue.OSFac.Int32</Value1>
							<Value2>strXmlValue.OSMin.Int32</Value2>
							<WriteLine Id="16" Level="Error" Param0="ModuleCounter" Param1="i32TmpModuleIndex" Param2="strXmlValue.OSMin.Int32" Param3="strXmlValue.OSFac.Int32">EtherCATModule/Modules/Module[{0}]/RxPdo[{1}]/@OSMin: (current value : {2}) shall be less or equal OSFac (current value : {3})</WriteLine>
						</Lower>
					</Compare>
					<Compare>
						<Lower>
							<Value1>strXmlValue.OSFac.Int32</Value1>
							<Value2>strXmlValue.OSMin.Int32</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_OS_FAC">
					<!--Check RxPdo@OSFac-->
					<Compare>
						<Equal>
							<Value1>strXmlValueOSFac</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>TEST_OS_MAX</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValueOSFac</Value1>
							<Value2>null</Value2>
							<GotoStep>TEST_OS_MAX</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<SetVariable Target="AtLeastOneModuleFound">true</SetVariable>
						</Equal>
					</Compare>
					<Compare>
						<Lower>
							<Value1>strXmlValue.OSFac.Int32</Value1>
							<Value2>0</Value2>
							<WriteLine Id="17" Level="Error" Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex" Param3="strXmlValue.OSFac.Int32">{0}[{1}]/RxPdo[{2}]/@OSFac shall be &gt;= 0 (current value : {3})</WriteLine>
						</Lower>
					</Compare>
					<Compare>
						<Lower>
							<Value1>strXmlValue.OSFac.Int32</Value1>
							<Value2>0</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Lower>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValueOSMax</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>TEST_OS_MAX</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValueOSMax</Value1>
							<Value2>null</Value2>
							<GotoStep>TEST_OS_MAX</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<SetVariable Target="AtLeastOneModuleFound">true</SetVariable>
						</Equal>
					</Compare>
					<Compare>
						<Greater>
							<Value1>strXmlValue.OSFac.Int32</Value1>
							<Value2>strXmlValue.OSMax.Int32</Value2>
							<WriteLine Id="18" Level="Error" Param0="ModuleCounter" Param1="i32TmpModuleIndex" Param2="strXmlValue.OSMax.Int32" Param3="strXmlValue.OSFac.Int32">EtherCATModule/Modules/Module[{0}]/RxPdo[{1}] OSMax (current value : {2}) shall be greater or equal OSFac (current value : {3})</WriteLine>
						</Greater>
					</Compare>
					<Compare>
						<Greater>
							<Value1>strXmlValue.OSFac.Int32</Value1>
							<Value2>strXmlValue.OSMax.Int32</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Greater>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_OS_MAX">
					<!--Check RxPdo@OSMax-->
					<Compare>
						<Equal>
							<Value1>strXmlValueOSMax</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>TEST_FIXED_FLAG</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValueOSMax</Value1>
							<Value2>null</Value2>
							<GotoStep>TEST_FIXED_FLAG</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<SetVariable Target="AtLeastOneModuleFound">true</SetVariable>
						</Equal>
					</Compare>
					<Compare>
						<Lower>
							<Value1>strXmlValue.OSMax.Int32</Value1>
							<Value2>0</Value2>
							<WriteLine Id="19" Level="Error" Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex" Param3="strXmlValue.OSMax.Int32">{0}[{1}]/RxPdo[{2}]/@OSMax shall be &gt;= 0 (current value : {3})</WriteLine>
						</Lower>
					</Compare>
					<Compare>
						<Lower>
							<Value1>strXmlValue.OSMax.Int32</Value1>
							<Value2>0</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Lower>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValueOSMin</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>TEST_FIXED_FLAG</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValueOSMin</Value1>
							<Value2>null</Value2>
							<GotoStep>TEST_FIXED_FLAG</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<SetVariable Target="AtLeastOneModuleFound">true</SetVariable>
						</Equal>
					</Compare>
					<Compare>
						<Greater>
							<Value1>strXmlValue.OSMin.Int32</Value1>
							<Value2>strXmlValue.OSMax.Int32</Value2>
							<WriteLine Id="20" Level="Error" Param0="ModuleCounter" Param1="i32TmpModuleIndex" Param2="strXmlValue.OSMin.Int32" Param3="strXmlValue.OSMax.Int32">EtherCATModule/Modules/Module[{0}]/RxPdo[{1}]  OSMin (current value : {2}) shall be less or equal OSMax (current value : {3})</WriteLine>
						</Greater>
					</Compare>
					<Compare>
						<Greater>
							<Value1>strXmlValue.OSMin.Int32</Value1>
							<Value2>strXmlValue.OSMax.Int32</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Greater>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_FIXED_FLAG">
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValueFixed.Bool">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/RxPdo[{2}]/@Fixed</XPath>
					</GetXmlValue>
				</TestStep>
				<TestStep>
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="true" ReturnValue="strXmlValueEntries">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/RxPdo[{2}]/Entry</XPath>
					</GetXmlValue>
				</TestStep>
				<TestStep>
					<!--If Entries defined the fixed flag doesn't need to be checked-->
					<Description Id="21" Level="Output">Check @Fixed attribute.</Description>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="22" Level="Verbose" Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex" Param3="strXmlValueFixed.Bool">{0}[{1}]/RxPdo[{2}]: Fixed flag == {3}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="23" Level="Verbose" Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex" Param3="strXmlValueEntries">{0}[{1}]/RxPdo[{2}]/Entry: {3}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValueEntries</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>FIXED_FLAG</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValueEntries</Value1>
							<Value2>null</Value2>
							<GotoStep>FIXED_FLAG</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>LOOPEND</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="FIXED_FLAG">
					<!--If no entries defined fixed flag shall be false-->
					<Compare>
						<Equal>
							<Value1>strXmlValueFixed.Bool</Value1>
							<Value2>true</Value2>
							<WriteLine Id="24" Level="Warning" Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/RxPdo[{2}]: Fixed flag should not be set if no entry is defined.</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<SetVariable Target="AtLeastOneModuleFound">true</SetVariable>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="LOOPEND">
					<!--__END of "AttributeLoopStart", increment loop counter__-->
					<SetVariable Target="i32TmpModuleIndex">i32TmpModuleIndex + 1</SetVariable>
					<!--goto loop header by default-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>AttributeLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="RxPdoLoopEnd">
					<!--__END of "ModuleLoopStart", add ModuleIdent to tested Array__-->
					<AddArrayItem TargetArray="AllModuleIdents.Uint32Array">AllModuleIdents.Uint32</AddArrayItem>
				</TestStep>
				<TestStep>
					<!--Increment loop counter-->
					<SetVariable Target="ModuleCounter">ModuleCounter + 1</SetVariable>
					<!--goto loop header by default-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>ModuleLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_END">
					<!--dump test result-->
					<Compare>
						<Equal>
							<Value1>AtLeastOneModuleFound</Value1>
							<Value2>false</Value2>
							<SkipCase Id="25">No Attributes in RxPdo found.</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>false</Value2>
							<RaiseError Id="26">Test RxPdo(s) attributes failed.</RaiseError>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>true</Value2>
							<ReturnSuccess Id="27">Test RxPdo(s) attributes succeed.</ReturnSuccess>
						</Equal>
					</Compare>
				</TestStep>
			</TestCase>
			<TestCase Name="Check Index" CaseId="2">
				<?MAX_OUTPUT_ID 13?>
				<Description>
					<Purpose>Correct module RxPDO index range</Purpose>
					<PreCondition>The device description includes locally defined module object dictionary and contains at least one RxPDO element.</PreCondition>
					<Action>Check @Index</Action>
					<PostCondition>@Index shall be between 0x1600 and 0x17FF</PostCondition>
					<References>
						<Reference Specification="ETG.2000"></Reference>
						<Reference Specification="ETG.1000"></Reference>
						<Reference Specification="ETG.5001"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="Toggle_LOC_EXT">
					<!--Flag for InitGlobalVariables for default XPaths of local or external file-->
					<SetVariable Target="LocExt_InitToggle">false</SetVariable>
					<WriteLine Id="0" Level="Output">Checking for external file with modules</WriteLine>
				</TestStep>
				<TestStep Name="SkipEmulation">
					<!--Skip Test for slave with device emulation-->
					<CallTestFunction Name="GetDeviceEmulationFlags">
						<!--if false the device emulation bit will be read out from the ESI file-->
						<Parameter>false</Parameter>
						<OutParameter>boolVar</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>boolVar</Value1>
							<Value2>true</Value2>
							<SkipCase Id="1">DuT is a simple device test skipped.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="SkipNoSlots">
					<!--Skip Test if "CurrentConfig.SlotCount" == 0-->
					<Compare>
						<Equal>
							<Value1>CurrentConfig.SlotCount</Value1>
							<Value2>0</Value2>
							<SkipCase Id="2">Test skipped. No slots defined.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="SkipSoE">
					<!--Skip Test if SoE Device-->
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Mailbox.SoE</Value1>
							<Value2>true</Value2>
							<SkipCase Id="3">Test skipped for SoE Devices.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="INIT_AVAIL_GLOB_ARRAY">
					<CallTestFunction Name="AvailableDuTModuleIdents"></CallTestFunction>
				</TestStep>
				<TestStep Name="InitGlobalVariables">
					<!--Init global XPaths-->
					<CallTestFunction Name="InitGlobalVariablesForModuleODTest">
						<Parameter>LocExt_InitToggle</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="INIT_RESULT">
					<!--"result" = true-->
					<SetVariable Target="result">true</SetVariable>
				</TestStep>
				<TestStep Name="INIT_LOOP_COUNTER">
					<!--"ModuleCounter" = 1-->
					<SetVariable Target="ModuleCounter">1</SetVariable>
				</TestStep>
				<TestStep Name="CHECK_IF_EXISTS">
					<!--Checking if module exist-->
					<Compare>
						<Equal>
							<Value1>loc_XPathModuleIdent</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>TEST_END</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="InitTestedArray">
					<!--Array of already processed modules, no doubles-->
					<InitArray TargetArray="AllModuleIdents.Uint32Array"></InitArray>
				</TestStep>
				<TestStep Name="ModuleLoopStart">
					<!--__Loop START for LOCAL Modules__-->
				</TestStep>
				<TestStep Name="CHECK_IF_MODULE_EXISTS">
					<!--Checking if module exist-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>TEST_END</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>TEST_END</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_AVAILABLE_MDL">
					<!--Get ModuleIdent and Flag to SKIP testing of assigned modules-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="AllModuleIdents.Uint32">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>TestAvailableMdls</Value1>
							<Value2>false</Value2>
							<GotoStep>TEST_MODULES</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckItemInArray">
					<!--Check if module in list of assigned modules-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllAvailableDuTModules.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleInArray.boolAssigned</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="4" Level="Verbose" Param0="CheckModuleInArray.boolAssigned" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleInArray.boolAssigned == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleInArray.boolAssigned</Value1>
							<Value2>false</Value2>
							<GotoStep>RxPdoLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckAlreadyTested">
					<!--Check if module already tested-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllModuleIdents.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleAlreadyTested.boolAlreadyChecked</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="5" Level="Verbose" Param0="CheckModuleAlreadyTested.boolAlreadyChecked" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleAlreadyTested.boolAlreadyChecked == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleAlreadyTested.boolAlreadyChecked</Value1>
							<Value2>true</Value2>
							<GotoStep>RxPdoLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_MODULES">
					<!--Print Module Ident-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="6" Level="Verbose" Param0="ModuleCounter" Param1="strXmlValue">Module[{0}]: Ident: {1}</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="Check_extOD_FileRef">
					<CallTestFunction Name="CheckForExtRefDict">
						<Parameter>loc_ModuleXmlFile</Parameter>
						<Parameter>loc_XPathModuleIdent</Parameter>
						<Parameter>ModuleCounter</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="InitSubItemLoopCounter">
					<!--Init of nested loop counter for RxPdo of current module-->
					<SetVariable Target="i32TmpModuleIndex">1</SetVariable>
				</TestStep>
				<TestStep Name="IndexLoopStart">
					<!--__Loop START for current module RxPdo__-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/RxPdo[{2}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>RxPdoLoopEnd</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>RxPdoLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="LOOPSTART">
					<!--Dump loop start info-->
				</TestStep>
				<TestStep>
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.Index.Uint16">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/RxPdo[{2}]/Index</XPath>
					</GetXmlValue>
				</TestStep>
				<TestStep>
					<!--Check if Index is less than 0x1600-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<SetVariable Target="AtLeastOneModuleFound">true</SetVariable>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="7" Level="Output" Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex" Param3="strXmlValue.Index.Uint16">{0}[{1}]/RxPdo[{2}]/Index (0x{3:x4})</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Lower>
							<Value1>strXmlValue.Index.Uint16</Value1>
							<Value2>5632</Value2>
							<WriteLine Id="8" Level="Error" Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex" Param3="strXmlValue.Index.Uint16">{0}[{1}]/RxPdo[{2}]/Index (0x{3:x4}) shall be between 0x1600 and 0x17FF</WriteLine>
						</Lower>
					</Compare>
					<Compare>
						<Lower>
							<Value1>strXmlValue.Index.Uint16</Value1>
							<Value2>5632</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep>
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.Index.Uint16">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/RxPdo[{2}]/Index</XPath>
					</GetXmlValue>
				</TestStep>
				<TestStep>
					<!--Check if Index is greater than 0x17FF-->
					<Compare>
						<Greater>
							<Value1>strXmlValue.Index.Uint16</Value1>
							<Value2>6143</Value2>
							<WriteLine Id="9" Level="Error" Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex" Param3="strXmlValue.Index.Uint16">{0}[{1}]/RxPdo[{2}]/Index (0x{3:x4}) shall be between 0x1600 and 0x17FF</WriteLine>
						</Greater>
					</Compare>
					<Compare>
						<Greater>
							<Value1>strXmlValue.Index.Uint16</Value1>
							<Value2>6143</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Greater>
					</Compare>
				</TestStep>
				<TestStep Name="LOOPEND">
					<!--__END of "IndexLoopStart", increment loop counter__-->
					<SetVariable Target="i32TmpModuleIndex">i32TmpModuleIndex + 1</SetVariable>
					<!--goto loop header by default-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>IndexLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="RxPdoLoopEnd">
					<!--__END of "ModuleLoopStart", add ModuleIdent to tested Array__-->
					<AddArrayItem TargetArray="AllModuleIdents.Uint32Array">AllModuleIdents.Uint32</AddArrayItem>
				</TestStep>
				<TestStep>
					<!--Increment loop counter-->
					<SetVariable Target="ModuleCounter">ModuleCounter + 1</SetVariable>
					<!--goto loop header by default-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>ModuleLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_END">
					<!--dump test result-->
					<Compare>
						<Equal>
							<Value1>AtLeastOneModuleFound</Value1>
							<Value2>false</Value2>
							<SkipCase Id="10">No Index in RxPdo found.</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>false</Value2>
							<RaiseError Id="13"></RaiseError>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>true</Value2>
							<ReturnSuccess Id="12">All RxPdo indices are valid.</ReturnSuccess>
						</Equal>
					</Compare>
				</TestStep>
			</TestCase>
			<TestCase Name="Check SM assignment" CaseId="3">
				<?MAX_OUTPUT_ID 8?>
				<Description>
					<Purpose>Correct SyncManager assignment for module RxPDOs</Purpose>
					<PreCondition>The device description includes locally defined module object dictionary and contains at least one RxPDO element.</PreCondition>
					<Action>- @Mandatory == true
  test only @Sm
  1.) Is @Sm defined
  2.) Is .ExcludedSm defined
- @Mandatory == false
  iterate over all matching SyncManagers
  - referenced via @Sm
  - not excluded via .ExcludedSm
  - referenced via @Su

3.) @Sm match?
4.) Check @Virtual ?</Action>
					<PostCondition>1.) @Sm shall be defined
2.) .ExcludedSm should not be defined (the PDO is fixed assigned to @Sm)
3.) Directon/Type of shall @Sm match
4.) Valid if:
    - PDO is virtual AND SyncManager is virtual AND Entries defined
	- PDO is virtual AND SyncManager is not virtual and no Entries defined
    Error if SyncManager is @Sm else Warning

At least one valid SyncManager is defined.</PostCondition>
					<References>
						<Reference Specification="ETG.2000"></Reference>
						<Reference Specification="ETG.5001"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="Toggle_LOC_EXT">
					<!--Flag for InitGlobalVariables for default XPaths of local or external file-->
					<SetVariable Target="LocExt_InitToggle">false</SetVariable>
					<WriteLine Id="0" Level="Output">Checking for external file with modules</WriteLine>
				</TestStep>
				<TestStep Name="SkipNoSlots">
					<!--Skip Test if "CurrentConfig.SlotCount" == 0-->
					<Compare>
						<Equal>
							<Value1>CurrentConfig.SlotCount</Value1>
							<Value2>0</Value2>
							<SkipCase Id="1">Test skipped. No slots defined.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="SkipSoE">
					<!--Skip Test if SoE Device-->
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Mailbox.SoE</Value1>
							<Value2>true</Value2>
							<SkipCase Id="2">Test skipped for SoE Devices.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="INIT_AVAIL_GLOB_ARRAY">
					<CallTestFunction Name="AvailableDuTModuleIdents"></CallTestFunction>
				</TestStep>
				<TestStep Name="InitGlobalVariables">
					<!--Init global XPaths-->
					<CallTestFunction Name="InitGlobalVariablesForModuleODTest">
						<Parameter>LocExt_InitToggle</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="INIT_RESULT">
					<!--"result" = true-->
					<SetVariable Target="result">true</SetVariable>
				</TestStep>
				<TestStep Name="INIT_LOOP_COUNTER">
					<!--"ModuleCounter" = 1-->
					<SetVariable Target="ModuleCounter">1</SetVariable>
				</TestStep>
				<TestStep Name="CHECK_IF_EXISTS">
					<!--Checking if module exist-->
					<Compare>
						<Equal>
							<Value1>loc_XPathModuleIdent</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>TEST_END</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="InitTestedArray">
					<!--Array of already processed modules, no doubles-->
					<InitArray TargetArray="AllModuleIdents.Uint32Array"></InitArray>
				</TestStep>
				<TestStep Name="ModuleLoopStart">
					<!--__Loop START for LOCAL Modules__-->
				</TestStep>
				<TestStep Name="CHECK_IF_MODULE_EXISTS">
					<!--Checking if module exist-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>TEST_END</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>TEST_END</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_AVAILABLE_MDL">
					<!--Get ModuleIdent and Flag to SKIP testing of assigned modules-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="AllModuleIdents.Uint32">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>TestAvailableMdls</Value1>
							<Value2>false</Value2>
							<GotoStep>TEST_MODULES</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckItemInArray">
					<!--Check if module in list of assigned modules-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllAvailableDuTModules.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleInArray.boolAssigned</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="3" Level="Verbose" Param0="CheckModuleInArray.boolAssigned" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleInArray.boolAssigned == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleInArray.boolAssigned</Value1>
							<Value2>false</Value2>
							<GotoStep>RxPdoLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckAlreadyTested">
					<!--Check if module already tested-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllModuleIdents.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleAlreadyTested.boolAlreadyChecked</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="4" Level="Verbose" Param0="CheckModuleAlreadyTested.boolAlreadyChecked" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleAlreadyTested.boolAlreadyChecked == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleAlreadyTested.boolAlreadyChecked</Value1>
							<Value2>true</Value2>
							<GotoStep>RxPdoLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_MODULES">
					<!--Print Module Ident-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="5" Level="Verbose" Param0="ModuleCounter" Param1="strXmlValue">Module[{0}]: Ident: {1}</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="Check_extOD_FileRef">
					<CallTestFunction Name="CheckForExtRefDict">
						<Parameter>loc_ModuleXmlFile</Parameter>
						<Parameter>loc_XPathModuleIdent</Parameter>
						<Parameter>ModuleCounter</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="InitSubItemLoopCounter">
					<!--Init of nested loop counter for RxPdo of current module-->
					<SetVariable Target="i32TmpModuleIndex">1</SetVariable>
				</TestStep>
				<TestStep Name="SMAssignLoopStart">
					<!--__Loop START for current module RxPdo__-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/RxPdo[{2}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>RxPdoLoopEnd</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>RxPdoLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="LOOPSTART">
					<!--Dump loop start info-->
				</TestStep>
				<TestStep>
					<!--Check if Referenced SM are valid-->
					<CallTestFunction Name="CheckModuleRxPdoSmAssignment_gen">
						<Parameter>loc_ModuleXmlFile</Parameter>
						<Parameter>loc_XPathModuleIdent</Parameter>
						<Parameter>ModuleCounter</Parameter>
						<Parameter>i32TmpModuleIndex</Parameter>
						<OutParameter>TmpResult</OutParameter>
					</CallTestFunction>
				</TestStep>
				<TestStep>
					<!--update result-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<SetVariable Target="AtLeastOneModuleFound">true</SetVariable>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>TmpResult</Value1>
							<Value2>false</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="LOOPEND">
					<!--__END of "SMAssignLoopStart", increment loop counter__-->
					<SetVariable Target="i32TmpModuleIndex">i32TmpModuleIndex + 1</SetVariable>
					<!--goto loop header by default-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>SMAssignLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="RxPdoLoopEnd">
					<!--__END of "ModuleLoopStart", add ModuleIdent to tested Array__-->
					<AddArrayItem TargetArray="AllModuleIdents.Uint32Array">AllModuleIdents.Uint32</AddArrayItem>
				</TestStep>
				<TestStep>
					<!--Increment loop counter-->
					<SetVariable Target="ModuleCounter">ModuleCounter + 1</SetVariable>
					<!--goto loop header by default-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>ModuleLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_END">
					<!--dump test result-->
					<Compare>
						<Equal>
							<Value1>AtLeastOneModuleFound</Value1>
							<Value2>false</Value2>
							<SkipCase Id="6">No SM Assignment in RxPdo found.</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>false</Value2>
							<RaiseError Id="7">Test RxPdo(s) Sm assignment failed</RaiseError>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>true</Value2>
							<ReturnSuccess Id="8">Test RxPdo(s) Sm assignment succeed.</ReturnSuccess>
						</Equal>
					</Compare>
				</TestStep>
			</TestCase>
			<TestCase Name="Check Pdo entry Data Types" CaseId="4">
				<?MAX_OUTPUT_ID 41?>
				<Description>
					<Purpose>Validation of all module RxPDO mapping entries of ESI file.</Purpose>
					<PreCondition>The device description includes locally defined module object dictionary and contains at least one RxPDO element.</PreCondition>
					<Action>- checks entry count of each RxPdo element
- checks all existing entries of each defined RxPdo element
- compares the base data types to the bit length of each entry</Action>
					<PostCondition>- The DuTs module contains entries
- All DataType Entries shall provide the correct bit length</PostCondition>
					<References>
						<Reference Specification="ETG.2000" Chapter="5.6.7 Base Data Types"></Reference>
						<Reference Specification="ETG.5001"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="Toggle_LOC_EXT">
					<!--Flag for InitGlobalVariables for default XPaths of local or external file-->
					<SetVariable Target="LocExt_InitToggle">false</SetVariable>
					<WriteLine Id="0" Level="Output">Checking for external file with modules</WriteLine>
				</TestStep>
				<TestStep Name="SkipNoSlots">
					<!--Skip Test if "CurrentConfig.SlotCount" == 0-->
					<Compare>
						<Equal>
							<Value1>CurrentConfig.SlotCount</Value1>
							<Value2>0</Value2>
							<SkipCase Id="1">Test skipped. No slots defined.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="SkipSoE">
					<!--Skip Test if SoE Device-->
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Mailbox.SoE</Value1>
							<Value2>true</Value2>
							<SkipCase Id="2">Test skipped for SoE Devices.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="INIT_AVAIL_GLOB_ARRAY">
					<CallTestFunction Name="AvailableDuTModuleIdents"></CallTestFunction>
				</TestStep>
				<TestStep Name="InitGlobalVariables">
					<!--Init global XPaths-->
					<CallTestFunction Name="InitGlobalVariablesForModuleODTest">
						<Parameter>LocExt_InitToggle</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="INIT_MODULE_COUNTER">
					<!--"ModuleCounter" = 1-->
					<SetVariable Target="ModuleCounter">1</SetVariable>
				</TestStep>
				<TestStep Name="CHECK_IF_EXISTS">
					<!--Checking if module exist-->
					<Compare>
						<Equal>
							<Value1>loc_XPathModuleIdent</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>ReturnTestResult</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="InitTestedArray">
					<!--Array of already processed modules, no doubles-->
					<InitArray TargetArray="AllModuleIdents.Uint32Array"></InitArray>
				</TestStep>
				<TestStep Name="ModuleLoopStart">
					<!--__Loop START for LOCAL Modules__-->
				</TestStep>
				<TestStep Name="CHECK_IF_MODULE_EXISTS">
					<!--Checking if module exist-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>ReturnTestResult</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>ReturnTestResult</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_AVAILABLE_MDL">
					<!--Get ModuleIdent and Flag to SKIP testing of assigned modules-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="AllModuleIdents.Uint32">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>TestAvailableMdls</Value1>
							<Value2>false</Value2>
							<GotoStep>TEST_MODULES</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckItemInArray">
					<!--Check if module in list of assigned modules-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllAvailableDuTModules.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleInArray.boolAssigned</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="3" Level="Verbose" Param0="CheckModuleInArray.boolAssigned" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleInArray.boolAssigned == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleInArray.boolAssigned</Value1>
							<Value2>false</Value2>
							<GotoStep>GoToCheckNextModule</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckAlreadyTested">
					<!--Check if module already tested-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllModuleIdents.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleAlreadyTested.boolAlreadyChecked</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="4" Level="Verbose" Param0="CheckModuleAlreadyTested.boolAlreadyChecked" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleAlreadyTested.boolAlreadyChecked == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleAlreadyTested.boolAlreadyChecked</Value1>
							<Value2>true</Value2>
							<GotoStep>GoToCheckNextModule</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_MODULES">
					<!--Print Module Ident-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="5" Level="Verbose" Param0="ModuleCounter" Param1="strXmlValue">Module[{0}]: Ident: {1}</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="Check_extOD_FileRef">
					<CallTestFunction Name="CheckForExtRefDict">
						<Parameter>loc_ModuleXmlFile</Parameter>
						<Parameter>loc_XPathModuleIdent</Parameter>
						<Parameter>ModuleCounter</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="INIT_RXPDO_COUNTER">
					<!--Init of 1. nested loop counter for RxPdo of current module-->
					<SetVariable Target="i32TmpRxPdoIndex">1</SetVariable>
				</TestStep>
				<TestStep Name="RxPdoLoopStart">
					<!--__Loop START for current module RxPdo__-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpRxPdoIndex">{0}[{1}]/RxPdo[{2}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>GoToCheckNextModule</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>GoToCheckNextModule</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="INIT_ENTRY_COUNTER">
					<!--Init of 2. nested loop counter for RxPdo entries of current module-->
					<SetVariable Target="i32TmpEntryIndex">1</SetVariable>
				</TestStep>
				<TestStep Name="EntryLoopStart">
					<!--__Loop START for current module RxPdo entry__-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpRxPdoIndex" Param3="i32TmpEntryIndex">{0}[{1}]/RxPdo[{2}]/Entry[{3}]/Index</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="6" Level="Output" Param0="ModuleCounter" Param1="i32TmpRxPdoIndex" Param2="i32TmpEntryIndex" Param3="strXmlValue">Module[{0}]/RxPdo[{1}]/Entry[{2}]: {3}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>GetAndWriteResult</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>GetAndWriteResult</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="WriteDescPdoObject">
					<!--Dump testing info-->
					<Description Id="7" Level="Verbose" Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpRxPdoIndex" Param3="i32TmpEntryIndex">Checking {3}. entry of {0}[{1}]/RxPdo[{2}]...</Description>
				</TestStep>
				<TestStep Name="CheckIsGap">
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.Index.Uint16">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpRxPdoIndex" Param3="i32TmpEntryIndex">{0}[{1}]/RxPdo[{2}]/Entry[{3}]/Index</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="8" Level="Output" Param0="strXmlValue.Index.Uint16">Value of "strXmlValue.Index.Uint16": {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>strXmlValue.Index.Uint16</Value1>
							<Value2>0</Value2>
							<GotoStep>CheckIfArrayBaseDataType</GotoStep>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="WriteGapEntry">
					<!--Dump gap entry info-->
					<WriteLine Id="9" Level="Verbose" Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpRxPdoIndex" Param3="i32TmpEntryIndex">{0}[{1}]/RxPdo[{2}]/Entry[{3}] is a gap entry.</WriteLine>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>IncrementEntryIndex</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckIfArrayBaseDataType">
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.EntryDT.String">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpRxPdoIndex" Param3="i32TmpEntryIndex">{0}[{1}]/RxPdo[{2}]/Entry[{3}]/DataType</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="10" Level="Output" Param0="strXmlValue.EntryDT.String">Checking {0} if valid Array DataType...</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<!--Call test function "CheckForValidArrayDataTYpe"-->
					<CallTestFunction Name="CheckForValidArrayDataType">
						<Parameter>strXmlValue.EntryDT.String</Parameter>
						<OutParameter>boolComplexType</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="11" Level="Output" Param0="boolComplexType">Is Array type DataType: {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>boolComplexType</Value1>
							<Value2>true</Value2>
							<GotoStep>CheckIfArrayBitLengthLarger31B</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckBaseDataTypeBitLen">
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.BitLen.Uint32">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpRxPdoIndex" Param3="i32TmpEntryIndex">{0}[{1}]/RxPdo[{2}]/Entry[{3}]/BitLen</XPath>
					</GetXmlValue>
				</TestStep>
				<TestStep>
					<!--Call test function "BaseDataType.CheckSize"-->
					<CallTestFunction Name="BaseDataType.CheckSize">
						<Parameter>strXmlValue.BitLen.Uint32</Parameter>
						<Parameter>strXmlValue.EntryDT.String</Parameter>
						<OutParameter>StringBaseTypeErrorString</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="12" Level="Output" Param0="strXmlValue.BitLen.Uint32" Param1="strXmlValue.EntryDT.String">Checked BitLength: {0} vs DataType: {1}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="13" Level="Output" Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpRxPdoIndex" Param3="i32TmpEntryIndex">Checked BaseDataType Length of {0}[{1}]/RxPdo[{2}]/Entry[{3}]</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>StringBaseTypeErrorString</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>WriteBaseDataTypeError</GotoStep>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="IncrementDataTypeSuccessfullCounter">
					<!--Successful counter-->
					<SetVariable Target="uint16SuccCount">uint16SuccCount+1</SetVariable>
					<WriteLine Id="14" Level="Verbose" Param0="i32TmpRxPdoIndex" Param1="i32TmpEntryIndex" Param2="strXmlValue.EntryDT.String" Param3="strXmlValue.BitLen.Uint32">RxPdo[{0}]/Entry[{1}] has the DataType {2} and the right BitLength ({3}).</WriteLine>
				</TestStep>
				<TestStep Name="IncrementTestedCounter">
					<!--Tested values counter-->
					<SetVariable Target="uint16TestedValues">uint16TestedValues+1</SetVariable>
				</TestStep>
				<TestStep Name="GoToNextEntry">
					<!--__END of "EntryLoopStart"__-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>IncrementEntryIndex</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="WriteBaseDataTypeError">
					<!--Dump Error message for DT-->
					<WriteLine Id="15" Level="Error" Param0="i32TmpRxPdoIndex" Param1="i32TmpEntryIndex" Param2="StringBaseTypeErrorString">RxPdo[{0}]/Entry[{1}]: {2}</WriteLine>
				</TestStep>
				<TestStep Name="IncrementGeneralCounter">
					<!--General Error counter-->
					<SetVariable Target="uint16Errors">uint16Errors+1</SetVariable>
				</TestStep>
				<TestStep Name="IncrementDataTypeErrorCounter">
					<!--DT error Counter-->
					<SetVariable Target="uint16ErrCount">uint16ErrCount+1</SetVariable>
				</TestStep>
				<TestStep Name="IncrementEntryIndex">
					<!--Increment 2. nested loop counter for "EntryLoopStart"-->
					<SetVariable Target="i32TmpEntryIndex">i32TmpEntryIndex+1</SetVariable>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>EntryLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="GetAndWriteResult">
					<!--dump test results-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="16" Level="Output" Param0="uint16SuccCount" Param1="uint16ErrCount">uint16SuccCount: {0} and uint16ErrCount: {1}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>uint16ErrCount</Value1>
							<Value2>0</Value2>
							<WriteLine Id="17" Level="Output" Param0="ModuleCounter" Param1="i32TmpRxPdoIndex" Param2="uint16SuccCount" Param3="uint16ErrCount">PDO object Module[{0}]/RxPdo[{1}]: {3} Entry data type(s) do not match to the expected bit length. {2} data type(s) match to the right bit length.</WriteLine>
						</NotEqual>
					</Compare>
					<Compare>
						<Equal>
							<Value1>(uint16SuccCount+uint16ErrCount)</Value1>
							<Value2>0</Value2>
							<WriteLine Id="18" Level="Output" Param0="i32TmpRxPdoIndex" Param1="i32TmpEntryIndex">RxPdo[{0}]/Entry[{1}]: No entry data type checked.</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>(uint16SuccCount+uint16ErrCount)</Value1>
							<Value2>0</Value2>
							<GotoStep>IncrementRxPdoIndex</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>uint16ErrCount</Value1>
							<Value2>0</Value2>
							<WriteLine Id="19" Level="Output" Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpRxPdoIndex" Param3="uint16SuccCount">PDO object {0}[{1}]/RxPdo[{2}]: All entry data type(s) ({3}) match to the expected bit length.</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="IncrementRxPdoIndex">
					<!--Increment 1. nested loop counter for "RxPdoLoopStart"-->
					<SetVariable Target="i32TmpRxPdoIndex">i32TmpRxPdoIndex+1</SetVariable>
				</TestStep>
				<TestStep Name="ResetSuccessCountForNextPdo">
					<!--Reset Successful counter-->
					<SetVariable Target="uint16SuccCount">0</SetVariable>
				</TestStep>
				<TestStep Name="ResetErrorCountForNextPdo">
					<!--Reset DT Error counter-->
					<SetVariable Target="uint16ErrCount">0</SetVariable>
				</TestStep>
				<TestStep Name="GoToCheckNextPdo">
					<!--__END of "RxPdoLoopStart"__-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>RxPdoLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="GoToCheckNextModule">
					<!--__END of "ModuleLoopStart", add ModuleIdent to tested Array__-->
					<AddArrayItem TargetArray="AllModuleIdents.Uint32Array">AllModuleIdents.Uint32</AddArrayItem>
				</TestStep>
				<TestStep>
					<!--Increment loop counter-->
					<SetVariable Target="ModuleCounter">ModuleCounter+1</SetVariable>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>ModuleLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="ReturnTestResult">
					<!--The "uint16TestedValues" is not increased for Gap/padding entries. Total number of entries tested is different from total entries present in the ESI, Module file.-->
					<Compare>
						<Greater>
							<Value1>uint16Errors</Value1>
							<Value2>0</Value2>
							<RaiseError Id="41"></RaiseError>
						</Greater>
					</Compare>
					<Compare>
						<Equal>
							<Value1>uint16TestedValues</Value1>
							<Value2>0</Value2>
							<SkipCase Id="21">Skipped case: No entry found.</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<ReturnSuccess Id="22" Param0="uint16TestedValues">All ({0}) entr(y/ies) of RxPDO object(s) match to the right bit length (Gap entries excluded).</ReturnSuccess>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckIfArrayBitLengthLarger31B">
					<!--31B == 248 bit-->
					<SetVariable Target="int32SavedSubIndex">i32TmpEntryIndex</SetVariable>
				</TestStep>
				<TestStep>
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.EntryBitLenCopy.Uint32">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpRxPdoIndex" Param3="i32TmpEntryIndex">{0}[{1}]/RxPdo[{2}]/Entry[{3}]/BitLen</XPath>
					</GetXmlValue>
				</TestStep>
				<TestStep>
					<SetVariable Target="Uint32ArrayBitLength">strXmlValue.EntryBitLenCopy.Uint32</SetVariable>
				</TestStep>
				<TestStep Name="CheckArrayIfSplittedBitSize">
					<SetVariable Target="i32TmpEntryIndex">i32TmpEntryIndex+1</SetVariable>
				</TestStep>
				<TestStep>
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.EntryNmmr.String">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpRxPdoIndex" Param3="i32TmpEntryIndex">{0}[{1}]/RxPdo[{2}]/Entry[{3}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="23" Level="Output" Param0="strXmlValue.EntryNmmr.String">Value of "strXmlValue.EntryNmmr.String": {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="24" Level="Output" Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpRxPdoIndex" Param3="i32TmpEntryIndex">{0}[{1}]/RxPdo[{2}]/Entry[{3}]</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue.EntryNmmr.String</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>ResetSubIndexAndGoBack</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue.EntryNmmr.String</Value1>
							<Value2>null</Value2>
							<GotoStep>ResetSubIndexAndGoBack</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.EntryIndex.Uint16">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpRxPdoIndex" Param3="i32TmpEntryIndex">{0}[{1}]/RxPdo[{2}]/Entry[{3}]/Index</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="25" Level="Output" Param0="strXmlValue.EntryIndex.Uint16">Value of "strXmlValue.EntryIndex.Uint16": {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>strXmlValue.EntryIndex.Uint16</Value1>
							<Value2>0</Value2>
							<GotoStep>ResetSubIndexAndGoBack</GotoStep>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep>
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.EntrySubindex.Uint16">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpRxPdoIndex" Param3="i32TmpEntryIndex">{0}[{1}]/RxPdo[{2}]/Entry[{3}]/SubIndex</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="26" Level="Output" Param0="strXmlValue.EntrySubindex.Uint16">Value of "strXmlValue.EntrySubindex.Uint16": {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>strXmlValue.EntrySubindex.Uint16</Value1>
							<Value2>0</Value2>
							<GotoStep>ResetSubIndexAndGoBack</GotoStep>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="EndOf_CheckArrayIfSplittedBitSize">
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="27" Level="Verbose">Checking for split Array.</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Greater>
							<Value1>strXmlValue.EntryBitLenCopy.Uint32</Value1>
							<Value2>240</Value2>
							<WriteLine Id="28" Level="Warning" Param0="strXmlValue.EntryBitLenCopy.Uint32">Bit length of {0} is invalid. In case of splitted Array a Bit length greater than 240 Bits is not allowed.</WriteLine>
						</Greater>
					</Compare>
				</TestStep>
				<TestStep Name="CheckIfArrayEnd">
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.EntryNmmr.String">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpRxPdoIndex" Param3="i32TmpEntryIndex">{0}[{1}]/RxPdo[{2}]/Entry[{3}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue.EntryNmmr.String</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>DecreaseSubIndexAndCheckArrayDataTypeBitSize</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue.EntryNmmr.String</Value1>
							<Value2>null</Value2>
							<GotoStep>DecreaseSubIndexAndCheckArrayDataTypeBitSize</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.EntryIndex.Uint16">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpRxPdoIndex" Param3="i32TmpEntryIndex">{0}[{1}]/RxPdo[{2}]/Entry[{3}]/Index</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue.EntryIndex.Uint16</Value1>
							<Value2>null</Value2>
							<GotoStep>DecreaseSubIndexAndCheckArrayDataTypeBitSize</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>strXmlValue.EntryIndex.Uint16</Value1>
							<Value2>0</Value2>
							<GotoStep>DecreaseSubIndexAndCheckArrayDataTypeBitSize</GotoStep>
						</NotEqual>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue.EntryIndex.Uint16</Value1>
							<Value2>0</Value2>
							<GotoStep>CheckIfArrayEnd_Continue</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.EntrySubindex.Uint16">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpRxPdoIndex" Param3="i32TmpEntryIndex">{0}[{1}]/RxPdo[{2}]/Entry[{3}]/SubIndex</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue.EntrySubindex.Uint16</Value1>
							<Value2>null</Value2>
							<GotoStep>DecreaseSubIndexAndCheckArrayDataTypeBitSize</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>strXmlValue.EntrySubindex.Uint16</Value1>
							<Value2>0</Value2>
							<GotoStep>DecreaseSubIndexAndCheckArrayDataTypeBitSize</GotoStep>
						</NotEqual>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue.EntrySubindex.Uint16</Value1>
							<Value2>0</Value2>
							<GotoStep>CheckIfArrayEnd_Continue</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckIfArrayEnd_Continue">
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.BitLen.Uint32">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpRxPdoIndex" Param3="i32TmpEntryIndex">{0}[{1}]/RxPdo[{2}]/Entry[{3}]/BitLen</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="29" Level="Verbose">Checking if Array ended.</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="30" Level="Verbose" Param0="i32TmpEntryIndex">i32TmpEntryIndex == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="31" Level="Verbose" Param0="strXmlValue.EntryIndex.Uint16">strXmlValue.EntryIndex.Uint16 == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="32" Level="Verbose" Param0="strXmlValue.EntrySubindex.Uint16">strXmlValue.EntrySubindex.Uint16 == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Greater>
							<Value1>strXmlValue.BitLen.Uint32</Value1>
							<Value2>240</Value2>
							<WriteLine Id="33" Level="Warning" Param0="strXmlValue.BitLen.Uint32">Bit length of {0} is invalid. In case of splitted Array a Bit length greater than 240 Bits is not allowed.</WriteLine>
						</Greater>
					</Compare>
				</TestStep>
				<TestStep>
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.EntryDTSave.String">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpRxPdoIndex" Param3="int32SavedSubIndex">{0}[{1}]/RxPdo[{2}]/Entry[{3}]/DataType</XPath>
					</GetXmlValue>
				</TestStep>
				<TestStep>
					<CallTestFunction Name="BaseDataType.CheckSize">
						<Parameter>Uint32ArrayBitLength</Parameter>
						<Parameter>strXmlValue.EntryDTSave.String</Parameter>
						<OutParameter>StringBaseTypeErrorString</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="34" Level="Verbose" Param0="StringBaseTypeErrorString">StringBaseTypeErrorString = {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>StringBaseTypeErrorString</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>DecreaseSubIndexAndCheckArrayDataTypeBitSize</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<SetVariable Target="Uint32ArrayBitLength">Uint32ArrayBitLength+strXmlValue.BitLen.Uint32</SetVariable>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="35" Level="Verbose" Param0="Uint32ArrayBitLength">Uint32ArrayBitLength == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>strXmlValue.BitLen.Uint32</Value1>
							<Value2>240</Value2>
							<GotoStep>CheckArrayDataTypeBitSize</GotoStep>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep>
					<SetVariable Target="i32TmpEntryIndex">i32TmpEntryIndex+1</SetVariable>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>CheckIfArrayEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="DecreaseSubIndexAndCheckArrayDataTypeBitSize">
					<SetVariable Target="i32TmpEntryIndex">i32TmpEntryIndex-1</SetVariable>
				</TestStep>
				<TestStep Name="CheckArrayDataTypeBitSize">
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.EntryDTSave.String">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpRxPdoIndex" Param3="int32SavedSubIndex">{0}[{1}]/RxPdo[{2}]/Entry[{3}]/DataType</XPath>
					</GetXmlValue>
				</TestStep>
				<TestStep>
					<CallTestFunction Name="BaseDataType.CheckSize">
						<Parameter>Uint32ArrayBitLength</Parameter>
						<Parameter>strXmlValue.EntryDTSave.String</Parameter>
						<OutParameter>StringBaseTypeErrorString</OutParameter>
					</CallTestFunction>
					<Compare>
						<NotEqual>
							<Value1>StringBaseTypeErrorString</Value1>
							<Value2>EmptyString</Value2>
							<WriteLine Id="36" Level="Error" Param0="i32TmpRxPdoIndex" Param1="int32SavedSubIndex+1" Param2="StringBaseTypeErrorString">RxPdo[{0}]/Entry[{1}]: {2}</WriteLine>
						</NotEqual>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>StringBaseTypeErrorString</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>IncrementGeneralCounter</GotoStep>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="WriteArrayDataTypeBitLengthSuccess">
					<SetVariable Target="uint16SuccCount">uint16SuccCount+1</SetVariable>
					<WriteLine Id="37" Level="Verbose" Param0="i32TmpRxPdoIndex" Param1="int32SavedSubIndex" Param2="strXmlValue.EntryDTSave.String" Param3="Uint32ArrayBitLength">RxPdo[{0}]/Entry[{1}] has the DataType {2} and the right BitLength ({3}).</WriteLine>
				</TestStep>
				<TestStep Name="CheckNextEntryWithDataType">
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>IncrementTestedCounter</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="ResetSubIndexAndGoBack">
					<SetVariable Target="i32TmpEntryIndex">int32SavedSubIndex</SetVariable>
				</TestStep>
				<TestStep>
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.BitLen.Uint32">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpRxPdoIndex" Param3="i32TmpEntryIndex">{0}[{1}]/RxPdo[{2}]/Entry[{3}]/BitLen</XPath>
					</GetXmlValue>
				</TestStep>
				<TestStep>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="38" Level="Output" Param0="strXmlValue.BitLen.Uint32">Value of "strXmlValue.BitLen.Uint32": {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="39" Level="Output" Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpRxPdoIndex" Param3="i32TmpEntryIndex">{0}[{1}]/RxPdo[{2}]/Entry[{3}]/BitLen</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.EntryDTCopy.String">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpRxPdoIndex" Param3="i32TmpEntryIndex">{0}[{1}]/RxPdo[{2}]/Entry[{3}]/DataType</XPath>
					</GetXmlValue>
				</TestStep>
				<TestStep>
					<Compare>
						<Greater>
							<Value1>strXmlValue.BitLen.Uint32</Value1>
							<Value2>255</Value2>
							<WriteLine Id="40" Level="Output" Param0="strXmlValue.BitLen.Uint32" Param1="strXmlValue.EntryDTCopy.String">BitSize ({0}) of data type '{1}' is greater than 255.</WriteLine>
						</Greater>
					</Compare>
					<Compare>
						<Greater>
							<Value1>strXmlValue.BitLen.Uint32</Value1>
							<Value2>255</Value2>
							<SetVariable Target="StringBaseTypeErrorString" Param0="strXmlValue.BitLen.Uint32" Param1="strXmlValue.EntryDTCopy.String">BitSize ({0}) of data type '{1}' shall not be greater than 255.</SetVariable>
						</Greater>
					</Compare>
					<Compare>
						<Greater>
							<Value1>strXmlValue.BitLen.Uint32</Value1>
							<Value2>255</Value2>
							<GotoStep>WriteBaseDataTypeError</GotoStep>
						</Greater>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>CheckBaseDataTypeBitLen</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
			</TestCase>
			<TestCase Name="Check Pdo Exclude" CaseId="5">
				<?MAX_OUTPUT_ID 10?>
				<Description>
					<Purpose>Validate .Exclude element of module RxPdo</Purpose>
					<PreCondition>The device description includes locally defined module object dictionary and contains at least one RxPDO element.</PreCondition>
					<Action>Check RxPDOs included in .Exclude</Action>
					<PostCondition>Each excluded RxPDO shall exclude the current RxPDO</PostCondition>
					<References>
						<Reference Specification="ETG.2000"></Reference>
						<Reference Specification="ETG.5001"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="Toggle_LOC_EXT">
					<!--Flag for InitGlobalVariables for default XPaths of local or external file-->
					<SetVariable Target="LocExt_InitToggle">false</SetVariable>
					<WriteLine Id="0" Level="Output">Checking for external file with modules</WriteLine>
				</TestStep>
				<TestStep Name="SkipNoSlots">
					<!--Skip Test if "CurrentConfig.SlotCount" == 0-->
					<Compare>
						<Equal>
							<Value1>CurrentConfig.SlotCount</Value1>
							<Value2>0</Value2>
							<SkipCase Id="1">Test skipped. No slots defined.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="SkipSoE">
					<!--Skip Test if SoE Device-->
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Mailbox.SoE</Value1>
							<Value2>true</Value2>
							<SkipCase Id="2">Test skipped for SoE Devices.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="INIT_AVAIL_GLOB_ARRAY">
					<CallTestFunction Name="AvailableDuTModuleIdents"></CallTestFunction>
				</TestStep>
				<TestStep Name="InitGlobalVariables">
					<!--Init global XPaths-->
					<CallTestFunction Name="InitGlobalVariablesForModuleODTest">
						<Parameter>LocExt_InitToggle</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="INIT_RESULT">
					<!--"result" = true-->
					<SetVariable Target="result">true</SetVariable>
				</TestStep>
				<TestStep Name="INIT_MODULE_COUNTER">
					<!--"ModuleCounter" = 1-->
					<SetVariable Target="ModuleCounter">1</SetVariable>
				</TestStep>
				<TestStep Name="CHECK_IF_EXISTS">
					<!--Checking if module exist-->
					<Compare>
						<Equal>
							<Value1>loc_XPathModuleIdent</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>ReturnTestResult</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="InitTestedArray">
					<!--Array of already processed modules, no doubles-->
					<InitArray TargetArray="AllModuleIdents.Uint32Array"></InitArray>
				</TestStep>
				<TestStep Name="ModuleLoopStart">
					<!--__Loop START for LOCAL Modules__-->
				</TestStep>
				<TestStep Name="CHECK_IF_MODULE_EXISTS">
					<!--Checking if module exist-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>ReturnTestResult</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>ReturnTestResult</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_AVAILABLE_MDL">
					<!--Get ModuleIdent and Flag to SKIP testing of assigned modules-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="AllModuleIdents.Uint32">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>TestAvailableMdls</Value1>
							<Value2>false</Value2>
							<GotoStep>TEST_MODULES</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckItemInArray">
					<!--Check if module in list of assigned modules-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllAvailableDuTModules.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleInArray.boolAssigned</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="3" Level="Verbose" Param0="CheckModuleInArray.boolAssigned" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleInArray.boolAssigned == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleInArray.boolAssigned</Value1>
							<Value2>false</Value2>
							<GotoStep>GoToCheckNextModule</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckAlreadyTested">
					<!--Check if module already tested-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllModuleIdents.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleAlreadyTested.boolAlreadyChecked</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="4" Level="Verbose" Param0="CheckModuleAlreadyTested.boolAlreadyChecked" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleAlreadyTested.boolAlreadyChecked == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleAlreadyTested.boolAlreadyChecked</Value1>
							<Value2>true</Value2>
							<GotoStep>GoToCheckNextModule</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_MODULES">
					<!--Print Module Ident-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="5" Level="Verbose" Param0="ModuleCounter" Param1="strXmlValue">Module[{0}]: Ident: {1}</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="Check_extOD_FileRef">
					<CallTestFunction Name="CheckForExtRefDict">
						<Parameter>loc_ModuleXmlFile</Parameter>
						<Parameter>loc_XPathModuleIdent</Parameter>
						<Parameter>ModuleCounter</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="INIT_RXPDO_COUNTER">
					<!--Init of nested loop counter for RxPdo of current module-->
					<SetVariable Target="i32TmpRxPdoIndex">1</SetVariable>
				</TestStep>
				<TestStep Name="RxPdoLoopStart">
					<!--__Loop START for current module RxPdo__-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpRxPdoIndex">{0}[{1}]/RxPdo[{2}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>GoToCheckNextModule</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>GoToCheckNextModule</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.Index.Uint16">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpRxPdoIndex">{0}[{1}]/RxPdo[{2}]/Index</XPath>
					</GetXmlValue>
					<Compare>
						<NotEqual>
							<Value1>strXmlValue.Index.Uint16</Value1>
							<Value2>0</Value2>
							<GotoStep>LOOPSTART</GotoStep>
						</NotEqual>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue.Index.Uint16</Value1>
							<Value2>null</Value2>
							<GotoStep>GoToCheckNextModule</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue.Index.Uint16</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>GoToCheckNextModule</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="LOOPSTART">
					<!--Dump loop start info-->
					<WriteLine Id="6" Level="Output" Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpRxPdoIndex" Param3="strXmlValue.Index.Uint16">Checking Exclude element of {0}[{1}]/RxPdo[{2}] : 0x{3:x4}.</WriteLine>
				</TestStep>
				<TestStep>
					<!--Check if current Exclude element is valid-->
					<CallTestFunction Name="CheckRxPdoExcludeElement_gen">
						<Parameter>loc_ModuleXmlFile</Parameter>
						<Parameter>loc_XPathModuleIdent</Parameter>
						<Parameter>ModuleCounter</Parameter>
						<Parameter>i32TmpRxPdoIndex</Parameter>
						<OutParameter>TmpResult</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<SetVariable Target="AtLeastOneModuleFound">true</SetVariable>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>TmpResult</Value1>
							<Value2>false</Value2>
							<WriteLine Id="7" Level="Output" Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpRxPdoIndex">Exclude information of {0}[{1}]/RxPdo[{2}] are invalid.</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<!--update result-->
					<Compare>
						<Equal>
							<Value1>TmpResult</Value1>
							<Value2>false</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="LOOPEND">
					<!--__END of "RxPdoLoopStart", increment loop counter__-->
					<SetVariable Target="i32TmpRxPdoIndex">i32TmpRxPdoIndex + 1</SetVariable>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>RxPdoLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="GoToCheckNextModule">
					<!--__END of "ModuleLoopStart", add ModuleIdent to tested Array__-->
					<AddArrayItem TargetArray="AllModuleIdents.Uint32Array">AllModuleIdents.Uint32</AddArrayItem>
				</TestStep>
				<TestStep>
					<!--Increment loop counter-->
					<SetVariable Target="ModuleCounter">ModuleCounter+1</SetVariable>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>ModuleLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="ReturnTestResult">
					<!--dump test result-->
					<Compare>
						<Equal>
							<Value1>AtLeastOneModuleFound</Value1>
							<Value2>false</Value2>
							<SkipCase Id="8">No RxPdo.Exclude found.</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>false</Value2>
							<RaiseError Id="9">Test RxPdo.Exclude failed</RaiseError>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>true</Value2>
							<ReturnSuccess Id="10">Test RxPdo.Exclude succeed.</ReturnSuccess>
						</Equal>
					</Compare>
				</TestStep>
			</TestCase>
		</TestGroup>
		<TestGroup GroupId="102" Name="(Local) Module TxPdo Tests">
			<Comment>Check the correct usage and values of the TxPDO elements for modules defined locally in ESI</Comment>
			<TestCase Name="Check Attributes" CaseId="1">
				<?MAX_OUTPUT_ID 27?>
				<Description>
					<Purpose>Correct usage of module TxPdo attributes</Purpose>
					<PreCondition>The device description includes locally defined module object dictionary and contains at least one TxPdo element.</PreCondition>
					<Action>1. @Su
2. @Fixed
3. @OSFac,@OSMin,@OSMax,@OSIndexInc</Action>
					<PostCondition>1. if @Su defined a matching FMMU shall be referenced
2. if @Fixed is true at least one entry should be defined
3. if defined @OSxxx shall be greater/equal 0
   and @OSMin less/equal @OSFac greater/equal @OSMax</PostCondition>
					<References>
						<Reference Specification="ETG.2000"></Reference>
						<Reference Specification="ETG.5001"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="Toggle_LOC_EXT">
					<!--Flag for InitGlobalVariables for default XPaths of local or external file-->
					<SetVariable Target="LocExt_InitToggle">false</SetVariable>
					<WriteLine Id="0" Level="Output">Checking for external file with modules</WriteLine>
				</TestStep>
				<TestStep Name="SkipNoSlots">
					<!--Skip Test if "CurrentConfig.SlotCount" == 0-->
					<Compare>
						<Equal>
							<Value1>CurrentConfig.SlotCount</Value1>
							<Value2>0</Value2>
							<SkipCase Id="1">Test skipped. No slots defined.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="SkipSoE">
					<!--Skip Test if SoE Device-->
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Mailbox.SoE</Value1>
							<Value2>true</Value2>
							<SkipCase Id="2">Test skipped for SoE Devices.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="INIT_AVAIL_GLOB_ARRAY">
					<CallTestFunction Name="AvailableDuTModuleIdents"></CallTestFunction>
				</TestStep>
				<TestStep Name="InitGlobalVariables">
					<!--Init global XPaths-->
					<CallTestFunction Name="InitGlobalVariablesForModuleODTest">
						<Parameter>LocExt_InitToggle</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="INIT_RESULT">
					<!--"result" = true-->
					<SetVariable Target="result">true</SetVariable>
				</TestStep>
				<TestStep Name="INIT_LOOP_COUNTER">
					<!--"ModuleCounter" = 1-->
					<SetVariable Target="ModuleCounter">1</SetVariable>
				</TestStep>
				<TestStep Name="CHECK_IF_EXISTS">
					<!--Checking if module exist-->
					<Compare>
						<Equal>
							<Value1>loc_XPathModuleIdent</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>TEST_END</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="InitTestedArray">
					<!--Array of already processed modules, no doubles-->
					<InitArray TargetArray="AllModuleIdents.Uint32Array"></InitArray>
				</TestStep>
				<TestStep Name="ModuleLoopStart">
					<!--__Loop START for LOCAL Modules__-->
				</TestStep>
				<TestStep Name="CHECK_IF_MODULE_EXISTS">
					<!--Checking if module exist-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>TEST_END</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>TEST_END</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_AVAILABLE_MDL">
					<!--Get ModuleIdent and Flag to SKIP testing of assigned modules-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="AllModuleIdents.Uint32">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>TestAvailableMdls</Value1>
							<Value2>false</Value2>
							<GotoStep>TEST_MODULES</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckItemInArray">
					<!--Check if module in list of assigned modules-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllAvailableDuTModules.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleInArray.boolAssigned</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="3" Level="Verbose" Param0="CheckModuleInArray.boolAssigned" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleInArray.boolAssigned == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleInArray.boolAssigned</Value1>
							<Value2>false</Value2>
							<GotoStep>TxPdoLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckAlreadyTested">
					<!--Check if module already tested-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllModuleIdents.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleAlreadyTested.boolAlreadyChecked</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="4" Level="Verbose" Param0="CheckModuleAlreadyTested.boolAlreadyChecked" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleAlreadyTested.boolAlreadyChecked == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleAlreadyTested.boolAlreadyChecked</Value1>
							<Value2>true</Value2>
							<GotoStep>TxPdoLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_MODULES">
					<!--Print Module Ident-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="5" Level="Verbose" Param0="ModuleCounter" Param1="strXmlValue">Module[{0}]: Ident: {1}</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="Check_extOD_FileRef">
					<CallTestFunction Name="CheckForExtRefDict">
						<Parameter>loc_ModuleXmlFile</Parameter>
						<Parameter>loc_XPathModuleIdent</Parameter>
						<Parameter>ModuleCounter</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="InitSubItemLoopCounter">
					<!--Init of nested loop counter for TxPdo of current module-->
					<SetVariable Target="i32TmpModuleIndex">1</SetVariable>
				</TestStep>
				<TestStep Name="AttributeLoopStart">
					<!--__Loop START for current module TxPdo__-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/TxPdo[{2}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>TxPdoLoopEnd</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>TxPdoLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<!--Check if TxPdo@Su is defined-->
					<Description Id="6" Level="Output">Check @Su attribute.</Description>
					<!--Skip Su test if Sm is not defined-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/TxPdo[{2}]/@Sm</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<WriteLine Id="7" Level="Verbose" Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">Skip Su test because default Sm not defined ({0}[{1}]/TxPdo[{2}]/@Sm not defined).</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<WriteLine Id="8" Level="Verbose" Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">Skip Su test because default Sm not defined ({0}[{1}]/TxPdo[{2}]/@Sm not defined).</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>TEST_OS_INDEXINC</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>TEST_OS_INDEXINC</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<!--Skip Su test if Su is not defined-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/TxPdo[{2}]/@Su</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<WriteLine Id="9" Level="Verbose" Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/TxPdo[{2}]/@Su not defined.</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<WriteLine Id="10" Level="Verbose" Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/TxPdo[{2}]/@Su not defined.</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>TEST_OS_INDEXINC</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>TEST_OS_INDEXINC</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<WriteLine Id="11" Level="Output" Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">Check if {0}[{1}]/TxPdo[{2}]/@Su reference a valid Fmmu.</WriteLine>
				</TestStep>
				<TestStep>
					<!--Convert to Uint16-->
					<SetVariable Target="strXmlValue.Su.Uint16">strXmlValue</SetVariable>
				</TestStep>
				<TestStep>
					<!--Get Referenced Fmmu-->
					<CallTestFunction Name="GetFmmuBySu">
						<Parameter>strXmlValue.Su.Uint16</Parameter>
						<Parameter>Inputs</Parameter>
						<OutParameter>i32TmpIndex</OutParameter>
					</CallTestFunction>
				</TestStep>
				<TestStep>
					<!--Check if FMMU exists-->
					<Compare>
						<Lower>
							<Value1>i32TmpIndex</Value1>
							<Value2>0</Value2>
							<WriteLine Id="12" Level="Error" Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/TxPdo[{2}]/@Su doesn't reference an existing/matching Fmmu.</WriteLine>
						</Lower>
					</Compare>
					<Compare>
						<Lower>
							<Value1>i32TmpIndex</Value1>
							<Value2>0</Value2>
							<SetVariable Target="AtLeastOneModuleFound">true</SetVariable>
						</Lower>
					</Compare>
					<Compare>
						<Lower>
							<Value1>i32TmpIndex</Value1>
							<Value2>0</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Lower>
					</Compare>
					<Compare>
						<Lower>
							<Value1>i32TmpIndex</Value1>
							<Value2>0</Value2>
							<GotoStep>TEST_OS_INDEXINC</GotoStep>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_OS_INDEXINC">
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/TxPdo[{2}]/@OSIndexInc</XPath>
					</GetXmlValue>
				</TestStep>
				<TestStep>
					<!--Convert to Int32-->
					<SetVariable Target="strXmlValue.OSIndexInc.Int32">strXmlValue</SetVariable>
				</TestStep>
				<TestStep>
					<!--Check TxPdo@OSIndexInc-->
					<Description Id="13" Level="Output">Check @OSxxxx attributes.</Description>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>TEST_OS_MIN</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>TEST_OS_MIN</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Lower>
							<Value1>strXmlValue.OSIndexInc.Int32</Value1>
							<Value2>0</Value2>
							<WriteLine Id="14" Level="Error" Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex" Param3="strXmlValue.OSIndexInc.Int32">{0}[{1}]/TxPdo[{2}]/@OSIndexInc shall be &gt;= 0 (current value : {3})</WriteLine>
						</Lower>
					</Compare>
					<Compare>
						<Lower>
							<Value1>strXmlValue.OSIndexInc.Int32</Value1>
							<Value2>0</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_OS_MIN">
					<!--Get TxPdo@OSMin-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValueOSMin">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/TxPdo[{2}]/@OSMin</XPath>
					</GetXmlValue>
				</TestStep>
				<TestStep>
					<!--Get TxPdo@OSFac-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValueOSFac">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/TxPdo[{2}]/@OSFac</XPath>
					</GetXmlValue>
				</TestStep>
				<TestStep>
					<!--Get TxPdo@OSMax-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValueOSMax">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/TxPdo[{2}]/@OSMax</XPath>
					</GetXmlValue>
				</TestStep>
				<TestStep>
					<!--Convert to Int32-->
					<SetVariable Target="strXmlValue.OSMin.Int32">strXmlValueOSMin</SetVariable>
				</TestStep>
				<TestStep>
					<!--Convert to Int32-->
					<SetVariable Target="strXmlValue.OSFac.Int32">strXmlValueOSFac</SetVariable>
				</TestStep>
				<TestStep>
					<!--Convert to Int32-->
					<SetVariable Target="strXmlValue.OSMax.Int32">strXmlValueOSMax</SetVariable>
				</TestStep>
				<TestStep>
					<!--Check TxPdo@OSMin-->
					<Compare>
						<Equal>
							<Value1>strXmlValueOSMin</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>TEST_OS_FAC</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValueOSMin</Value1>
							<Value2>null</Value2>
							<GotoStep>TEST_OS_FAC</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<SetVariable Target="AtLeastOneModuleFound">true</SetVariable>
						</Equal>
					</Compare>
					<Compare>
						<Lower>
							<Value1>strXmlValue.OSMin.Int32</Value1>
							<Value2>0</Value2>
							<WriteLine Id="15" Level="Error" Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex" Param3="strXmlValue.OSMin.Int32">{0}[{1}]/TxPdo[{2}]/@OSMin shall be &gt;= 0 (current value : {3})</WriteLine>
						</Lower>
					</Compare>
					<Compare>
						<Lower>
							<Value1>strXmlValue.OSMin.Int32</Value1>
							<Value2>0</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Lower>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValueOSFac</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>TEST_OS_FAC</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValueOSFac</Value1>
							<Value2>null</Value2>
							<GotoStep>TEST_OS_FAC</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<SetVariable Target="AtLeastOneModuleFound">true</SetVariable>
						</Equal>
					</Compare>
					<Compare>
						<Lower>
							<Value1>strXmlValue.OSFac.Int32</Value1>
							<Value2>strXmlValue.OSMin.Int32</Value2>
							<WriteLine Id="16" Level="Error" Param0="ModuleCounter" Param1="i32TmpModuleIndex" Param2="strXmlValue.OSMin.Int32" Param3="strXmlValue.OSFac.Int32">EtherCATModule/Modules/Module[{0}]/TxPdo[{1}]/@OSMin: (current value : {2}) shall be less or equal OSFac (current value : {3})</WriteLine>
						</Lower>
					</Compare>
					<Compare>
						<Lower>
							<Value1>strXmlValue.OSFac.Int32</Value1>
							<Value2>strXmlValue.OSMin.Int32</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_OS_FAC">
					<!--Check TxPdo@OSFac-->
					<Compare>
						<Equal>
							<Value1>strXmlValueOSFac</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>TEST_OS_MAX</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValueOSFac</Value1>
							<Value2>null</Value2>
							<GotoStep>TEST_OS_MAX</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<SetVariable Target="AtLeastOneModuleFound">true</SetVariable>
						</Equal>
					</Compare>
					<Compare>
						<Lower>
							<Value1>strXmlValue.OSFac.Int32</Value1>
							<Value2>0</Value2>
							<WriteLine Id="17" Level="Error" Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex" Param3="strXmlValue.OSFac.Int32">{0}[{1}]/TxPdo[{2}]/@OSFac shall be &gt;= 0 (current value : {3})</WriteLine>
						</Lower>
					</Compare>
					<Compare>
						<Lower>
							<Value1>strXmlValue.OSFac.Int32</Value1>
							<Value2>0</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Lower>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValueOSMax</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>TEST_OS_MAX</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValueOSMax</Value1>
							<Value2>null</Value2>
							<GotoStep>TEST_OS_MAX</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<SetVariable Target="AtLeastOneModuleFound">true</SetVariable>
						</Equal>
					</Compare>
					<Compare>
						<Greater>
							<Value1>strXmlValue.OSFac.Int32</Value1>
							<Value2>strXmlValue.OSMax.Int32</Value2>
							<WriteLine Id="18" Level="Error" Param0="ModuleCounter" Param1="i32TmpModuleIndex" Param2="strXmlValue.OSMax.Int32" Param3="strXmlValue.OSFac.Int32">EtherCATModule/Modules/Module[{0}]/TxPdo[{1}] OSMax (current value : {2}) shall be greater or equal OSFac (current value : {3})</WriteLine>
						</Greater>
					</Compare>
					<Compare>
						<Greater>
							<Value1>strXmlValue.OSFac.Int32</Value1>
							<Value2>strXmlValue.OSMax.Int32</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Greater>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_OS_MAX">
					<!--Check TxPdo@OSMax-->
					<Compare>
						<Equal>
							<Value1>strXmlValueOSMax</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>TEST_FIXED_FLAG</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValueOSMax</Value1>
							<Value2>null</Value2>
							<GotoStep>TEST_FIXED_FLAG</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<SetVariable Target="AtLeastOneModuleFound">true</SetVariable>
						</Equal>
					</Compare>
					<Compare>
						<Lower>
							<Value1>strXmlValue.OSMax.Int32</Value1>
							<Value2>0</Value2>
							<WriteLine Id="19" Level="Error" Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex" Param3="strXmlValue.OSMax.Int32">{0}[{1}]/TxPdo[{2}]/@OSMax shall be &gt;= 0 (current value : {3})</WriteLine>
						</Lower>
					</Compare>
					<Compare>
						<Lower>
							<Value1>strXmlValue.OSMax.Int32</Value1>
							<Value2>0</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Lower>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValueOSMin</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>TEST_FIXED_FLAG</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValueOSMin</Value1>
							<Value2>null</Value2>
							<GotoStep>TEST_FIXED_FLAG</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<SetVariable Target="AtLeastOneModuleFound">true</SetVariable>
						</Equal>
					</Compare>
					<Compare>
						<Greater>
							<Value1>strXmlValue.OSMin.Int32</Value1>
							<Value2>strXmlValue.OSMax.Int32</Value2>
							<WriteLine Id="20" Level="Error" Param0="ModuleCounter" Param1="i32TmpModuleIndex" Param2="strXmlValue.OSMin.Int32" Param3="strXmlValue.OSMax.Int32">EtherCATModule/Modules/Module[{0}]/TxPdo[{1}]  OSMin (current value : {2}) shall be less or equal OSMax (current value : {3})</WriteLine>
						</Greater>
					</Compare>
					<Compare>
						<Greater>
							<Value1>strXmlValue.OSMin.Int32</Value1>
							<Value2>strXmlValue.OSMax.Int32</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Greater>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_FIXED_FLAG">
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValueFixed.Bool">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/TxPdo[{2}]/@Fixed</XPath>
					</GetXmlValue>
				</TestStep>
				<TestStep>
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="true" ReturnValue="strXmlValueEntries">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/TxPdo[{2}]/Entry</XPath>
					</GetXmlValue>
				</TestStep>
				<TestStep>
					<!--If Entries defined the fixed flag doesn't need to be checked-->
					<Description Id="21" Level="Output">Check @Fixed attribute.</Description>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="22" Level="Verbose" Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex" Param3="strXmlValueFixed.Bool">{0}[{1}]/TxPdo[{2}]: Fixed flag == {3}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="23" Level="Verbose" Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex" Param3="strXmlValueEntries">{0}[{1}]/TxPdo[{2}]/Entry: {3}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValueEntries</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>FIXED_FLAG</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValueEntries</Value1>
							<Value2>null</Value2>
							<GotoStep>FIXED_FLAG</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>LOOPEND</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="FIXED_FLAG">
					<!--If no entries defined fixed flag shall be false-->
					<Compare>
						<Equal>
							<Value1>strXmlValueFixed.Bool</Value1>
							<Value2>true</Value2>
							<WriteLine Id="24" Level="Warning" Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/TxPdo[{2}]: Fixed flag should not be set if no entry is defined.</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<SetVariable Target="AtLeastOneModuleFound">true</SetVariable>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="LOOPEND">
					<!--__END of "AttributeLoopStart", increment loop counter__-->
					<SetVariable Target="i32TmpModuleIndex">i32TmpModuleIndex + 1</SetVariable>
					<!--goto loop header by default-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>AttributeLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TxPdoLoopEnd">
					<!--__END of "ModuleLoopStart", add ModuleIdent to tested Array__-->
					<AddArrayItem TargetArray="AllModuleIdents.Uint32Array">AllModuleIdents.Uint32</AddArrayItem>
				</TestStep>
				<TestStep>
					<!--Increment loop counter-->
					<SetVariable Target="ModuleCounter">ModuleCounter + 1</SetVariable>
					<!--goto loop header by default-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>ModuleLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_END">
					<!--dump test result-->
					<Compare>
						<Equal>
							<Value1>AtLeastOneModuleFound</Value1>
							<Value2>false</Value2>
							<SkipCase Id="25">No Attributes in TxPdo found.</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>false</Value2>
							<RaiseError Id="26">Test TxPdo(s) attributes failed.</RaiseError>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>true</Value2>
							<ReturnSuccess Id="27">Test TxPdo(s) attributes succeed.</ReturnSuccess>
						</Equal>
					</Compare>
				</TestStep>
			</TestCase>
			<TestCase Name="Check Index" CaseId="2">
				<?MAX_OUTPUT_ID 13?>
				<Description>
					<Purpose>Correct module TxPdo index range</Purpose>
					<PreCondition>The device description includes locally defined module object dictionary and contains at least one TxPdo element.</PreCondition>
					<Action>Check @Index</Action>
					<PostCondition>@Index shall be between 0x1600 and 0x17FF</PostCondition>
					<References>
						<Reference Specification="ETG.2000"></Reference>
						<Reference Specification="ETG.1000"></Reference>
						<Reference Specification="ETG.5001"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="Toggle_LOC_EXT">
					<!--Flag for InitGlobalVariables for default XPaths of local or external file-->
					<SetVariable Target="LocExt_InitToggle">false</SetVariable>
					<WriteLine Id="0" Level="Output">Checking for external file with modules</WriteLine>
				</TestStep>
				<TestStep Name="SkipEmulation">
					<!--Skip Test for slave with device emulation-->
					<CallTestFunction Name="GetDeviceEmulationFlags">
						<!--if false the device emulation bit will be read out from the ESI file-->
						<Parameter>false</Parameter>
						<OutParameter>boolVar</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>boolVar</Value1>
							<Value2>true</Value2>
							<SkipCase Id="1">DuT is a simple device test skipped.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="SkipNoSlots">
					<!--Skip Test if "CurrentConfig.SlotCount" == 0-->
					<Compare>
						<Equal>
							<Value1>CurrentConfig.SlotCount</Value1>
							<Value2>0</Value2>
							<SkipCase Id="2">Test skipped. No slots defined.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="SkipSoE">
					<!--Skip Test if SoE Device-->
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Mailbox.SoE</Value1>
							<Value2>true</Value2>
							<SkipCase Id="3">Test skipped for SoE Devices.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="INIT_AVAIL_GLOB_ARRAY">
					<CallTestFunction Name="AvailableDuTModuleIdents"></CallTestFunction>
				</TestStep>
				<TestStep Name="InitGlobalVariables">
					<!--Init global XPaths-->
					<CallTestFunction Name="InitGlobalVariablesForModuleODTest">
						<Parameter>LocExt_InitToggle</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="INIT_RESULT">
					<!--"result" = true-->
					<SetVariable Target="result">true</SetVariable>
				</TestStep>
				<TestStep Name="INIT_LOOP_COUNTER">
					<!--"ModuleCounter" = 1-->
					<SetVariable Target="ModuleCounter">1</SetVariable>
				</TestStep>
				<TestStep Name="CHECK_IF_EXISTS">
					<!--Checking if module exist-->
					<Compare>
						<Equal>
							<Value1>loc_XPathModuleIdent</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>TEST_END</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="InitTestedArray">
					<!--Array of already processed modules, no doubles-->
					<InitArray TargetArray="AllModuleIdents.Uint32Array"></InitArray>
				</TestStep>
				<TestStep Name="ModuleLoopStart">
					<!--__Loop START for LOCAL Modules__-->
				</TestStep>
				<TestStep Name="CHECK_IF_MODULE_EXISTS">
					<!--Checking if module exist-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>TEST_END</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>TEST_END</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_AVAILABLE_MDL">
					<!--Get ModuleIdent and Flag to SKIP testing of assigned modules-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="AllModuleIdents.Uint32">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>TestAvailableMdls</Value1>
							<Value2>false</Value2>
							<GotoStep>TEST_MODULES</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckItemInArray">
					<!--Check if module in list of assigned modules-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllAvailableDuTModules.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleInArray.boolAssigned</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="4" Level="Verbose" Param0="CheckModuleInArray.boolAssigned" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleInArray.boolAssigned == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleInArray.boolAssigned</Value1>
							<Value2>false</Value2>
							<GotoStep>TxPdoLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckAlreadyTested">
					<!--Check if module already tested-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllModuleIdents.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleAlreadyTested.boolAlreadyChecked</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="5" Level="Verbose" Param0="CheckModuleAlreadyTested.boolAlreadyChecked" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleAlreadyTested.boolAlreadyChecked == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleAlreadyTested.boolAlreadyChecked</Value1>
							<Value2>true</Value2>
							<GotoStep>TxPdoLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_MODULES">
					<!--Print Module Ident-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="6" Level="Verbose" Param0="ModuleCounter" Param1="strXmlValue">Module[{0}]: Ident: {1}</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="Check_extOD_FileRef">
					<CallTestFunction Name="CheckForExtRefDict">
						<Parameter>loc_ModuleXmlFile</Parameter>
						<Parameter>loc_XPathModuleIdent</Parameter>
						<Parameter>ModuleCounter</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="InitSubItemLoopCounter">
					<!--Init of nested loop counter for TxPdo of current module-->
					<SetVariable Target="i32TmpModuleIndex">1</SetVariable>
				</TestStep>
				<TestStep Name="IndexLoopStart">
					<!--__Loop START for current module TxPdo__-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/TxPdo[{2}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>TxPdoLoopEnd</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>TxPdoLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="LOOPSTART">
					<!--Dump loop start info-->
				</TestStep>
				<TestStep>
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.Index.Uint16">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/TxPdo[{2}]/Index</XPath>
					</GetXmlValue>
				</TestStep>
				<TestStep>
					<!--Check if Index is less than 0x1A00-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<SetVariable Target="AtLeastOneModuleFound">true</SetVariable>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="7" Level="Output" Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex" Param3="strXmlValue.Index.Uint16">{0}[{1}]/TxPdo[{2}]/Index (0x{3:x4})</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Lower>
							<Value1>strXmlValue.Index.Uint16</Value1>
							<Value2>6656</Value2>
							<WriteLine Id="8" Level="Error" Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex" Param3="strXmlValue.Index.Uint16">{0}[{1}]/TxPdo[{2}]/Index (0x{3:x4}) shall be between 0x1A00 and 0x1BFF</WriteLine>
						</Lower>
					</Compare>
					<Compare>
						<Lower>
							<Value1>strXmlValue.Index.Uint16</Value1>
							<Value2>6656</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep>
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.Index.Uint16">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/TxPdo[{2}]/Index</XPath>
					</GetXmlValue>
				</TestStep>
				<TestStep>
					<!--Check if Index is greater than 0x17FF-->
					<Compare>
						<Greater>
							<Value1>strXmlValue.Index.Uint16</Value1>
							<Value2>7167</Value2>
							<WriteLine Id="9" Level="Error" Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex" Param3="strXmlValue.Index.Uint16">{0}[{1}]/TxPdo[{2}]/Index (0x{3:x4}) shall be between 0x1A00 and 0x1BFF</WriteLine>
						</Greater>
					</Compare>
					<Compare>
						<Greater>
							<Value1>strXmlValue.Index.Uint16</Value1>
							<Value2>7167</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Greater>
					</Compare>
				</TestStep>
				<TestStep Name="LOOPEND">
					<!--__END of "IndexLoopStart", increment loop counter__-->
					<SetVariable Target="i32TmpModuleIndex">i32TmpModuleIndex + 1</SetVariable>
					<!--goto loop header by default-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>IndexLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TxPdoLoopEnd">
					<!--__END of "ModuleLoopStart", add ModuleIdent to tested Array__-->
					<AddArrayItem TargetArray="AllModuleIdents.Uint32Array">AllModuleIdents.Uint32</AddArrayItem>
				</TestStep>
				<TestStep>
					<!--Increment loop counter-->
					<SetVariable Target="ModuleCounter">ModuleCounter + 1</SetVariable>
					<!--goto loop header by default-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>ModuleLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_END">
					<!--dump test result-->
					<Compare>
						<Equal>
							<Value1>AtLeastOneModuleFound</Value1>
							<Value2>false</Value2>
							<SkipCase Id="10">No Index in TxPdo found.</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>false</Value2>
							<RaiseError Id="13"></RaiseError>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>true</Value2>
							<ReturnSuccess Id="12">All TxPdo indices are valid.</ReturnSuccess>
						</Equal>
					</Compare>
				</TestStep>
			</TestCase>
			<TestCase Name="Check SM assignment" CaseId="3">
				<?MAX_OUTPUT_ID 8?>
				<Description>
					<Purpose>Correct SyncManager assignment for module TxPdos</Purpose>
					<PreCondition>The device description includes locally defined module object dictionary and contains at least one TxPdo element.</PreCondition>
					<Action>- @Mandatory == true
  test only @Sm
  1.) Is @Sm defined
  2.) Is .ExcludedSm defined
- @Mandatory == false
  iterate over all matching SyncManagers
  - referenced via @Sm
  - not excluded via .ExcludedSm
  - referenced via @Su

3.) @Sm match?
4.) Check @Virtual ?</Action>
					<PostCondition>1.) @Sm shall be defined
2.) .ExcludedSm should not be defined (the PDO is fixed assigned to @Sm)
3.) Directon/Type of shall @Sm match
4.) Valid if:
    - PDO is virtual AND SyncManager is virtual AND Entries defined
	- PDO is virtual AND SyncManager is not virtual and no Entries defined
    Error if SyncManager is @Sm else Warning

At least one valid SyncManager is defined.</PostCondition>
					<References>
						<Reference Specification="ETG.2000"></Reference>
						<Reference Specification="ETG.5001"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="Toggle_LOC_EXT">
					<!--Flag for InitGlobalVariables for default XPaths of local or external file-->
					<SetVariable Target="LocExt_InitToggle">false</SetVariable>
					<WriteLine Id="0" Level="Output">Checking for external file with modules</WriteLine>
				</TestStep>
				<TestStep Name="SkipNoSlots">
					<!--Skip Test if "CurrentConfig.SlotCount" == 0-->
					<Compare>
						<Equal>
							<Value1>CurrentConfig.SlotCount</Value1>
							<Value2>0</Value2>
							<SkipCase Id="1">Test skipped. No slots defined.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="SkipSoE">
					<!--Skip Test if SoE Device-->
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Mailbox.SoE</Value1>
							<Value2>true</Value2>
							<SkipCase Id="2">Test skipped for SoE Devices.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="INIT_AVAIL_GLOB_ARRAY">
					<CallTestFunction Name="AvailableDuTModuleIdents"></CallTestFunction>
				</TestStep>
				<TestStep Name="InitGlobalVariables">
					<!--Init global XPaths-->
					<CallTestFunction Name="InitGlobalVariablesForModuleODTest">
						<Parameter>LocExt_InitToggle</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="INIT_RESULT">
					<!--"result" = true-->
					<SetVariable Target="result">true</SetVariable>
				</TestStep>
				<TestStep Name="INIT_LOOP_COUNTER">
					<!--"ModuleCounter" = 1-->
					<SetVariable Target="ModuleCounter">1</SetVariable>
				</TestStep>
				<TestStep Name="CHECK_IF_EXISTS">
					<!--Checking if module exist-->
					<Compare>
						<Equal>
							<Value1>loc_XPathModuleIdent</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>TEST_END</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="InitTestedArray">
					<!--Array of already processed modules, no doubles-->
					<InitArray TargetArray="AllModuleIdents.Uint32Array"></InitArray>
				</TestStep>
				<TestStep Name="ModuleLoopStart">
					<!--__Loop START for LOCAL Modules__-->
				</TestStep>
				<TestStep Name="CHECK_IF_MODULE_EXISTS">
					<!--Checking if module exist-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>TEST_END</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>TEST_END</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_AVAILABLE_MDL">
					<!--Get ModuleIdent and Flag to SKIP testing of assigned modules-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="AllModuleIdents.Uint32">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>TestAvailableMdls</Value1>
							<Value2>false</Value2>
							<GotoStep>TEST_MODULES</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckItemInArray">
					<!--Check if module in list of assigned modules-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllAvailableDuTModules.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleInArray.boolAssigned</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="3" Level="Verbose" Param0="CheckModuleInArray.boolAssigned" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleInArray.boolAssigned == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleInArray.boolAssigned</Value1>
							<Value2>false</Value2>
							<GotoStep>TxPdoLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckAlreadyTested">
					<!--Check if module already tested-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllModuleIdents.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleAlreadyTested.boolAlreadyChecked</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="4" Level="Verbose" Param0="CheckModuleAlreadyTested.boolAlreadyChecked" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleAlreadyTested.boolAlreadyChecked == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleAlreadyTested.boolAlreadyChecked</Value1>
							<Value2>true</Value2>
							<GotoStep>TxPdoLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_MODULES">
					<!--Print Module Ident-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="5" Level="Verbose" Param0="ModuleCounter" Param1="strXmlValue">Module[{0}]: Ident: {1}</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="Check_extOD_FileRef">
					<CallTestFunction Name="CheckForExtRefDict">
						<Parameter>loc_ModuleXmlFile</Parameter>
						<Parameter>loc_XPathModuleIdent</Parameter>
						<Parameter>ModuleCounter</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="InitSubItemLoopCounter">
					<!--Init of nested loop counter for TxPdo of current module-->
					<SetVariable Target="i32TmpModuleIndex">1</SetVariable>
				</TestStep>
				<TestStep Name="SMAssignLoopStart">
					<!--__Loop START for current module TxPdo__-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/TxPdo[{2}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>TxPdoLoopEnd</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>TxPdoLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="LOOPSTART">
					<!--Dump loop start info-->
				</TestStep>
				<TestStep>
					<!--Check if Referenced SM are valid-->
					<CallTestFunction Name="CheckModuleTxPdoSmAssignment_gen">
						<Parameter>loc_ModuleXmlFile</Parameter>
						<Parameter>loc_XPathModuleIdent</Parameter>
						<Parameter>ModuleCounter</Parameter>
						<Parameter>i32TmpModuleIndex</Parameter>
						<OutParameter>TmpResult</OutParameter>
					</CallTestFunction>
				</TestStep>
				<TestStep>
					<!--update result-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<SetVariable Target="AtLeastOneModuleFound">true</SetVariable>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>TmpResult</Value1>
							<Value2>false</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="LOOPEND">
					<!--__END of "SMAssignLoopStart", increment loop counter__-->
					<SetVariable Target="i32TmpModuleIndex">i32TmpModuleIndex + 1</SetVariable>
					<!--goto loop header by default-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>SMAssignLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TxPdoLoopEnd">
					<!--__END of "ModuleLoopStart", add ModuleIdent to tested Array__-->
					<AddArrayItem TargetArray="AllModuleIdents.Uint32Array">AllModuleIdents.Uint32</AddArrayItem>
				</TestStep>
				<TestStep>
					<!--Increment loop counter-->
					<SetVariable Target="ModuleCounter">ModuleCounter + 1</SetVariable>
					<!--goto loop header by default-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>ModuleLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_END">
					<!--dump test result-->
					<Compare>
						<Equal>
							<Value1>AtLeastOneModuleFound</Value1>
							<Value2>false</Value2>
							<SkipCase Id="6">No SM Assignment in TxPdo found.</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>false</Value2>
							<RaiseError Id="7">Test TxPdo(s) Sm assignment failed</RaiseError>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>true</Value2>
							<ReturnSuccess Id="8">Test TxPdo(s) Sm assignment succeed.</ReturnSuccess>
						</Equal>
					</Compare>
				</TestStep>
			</TestCase>
			<TestCase Name="Check Pdo entry Data Types" CaseId="4">
				<?MAX_OUTPUT_ID 41?>
				<Description>
					<Purpose>Validation of all module TxPdo mapping entries of ESI file.</Purpose>
					<PreCondition>The device description includes locally defined module object dictionary and contains at least one RxPDO element.</PreCondition>
					<Action>- checks entry count of each TxPdo element
- checks all existing entries of each defined TxPdo element
- compares the base data types to the bit length of each entry</Action>
					<PostCondition>- The DuT contains entries
- All DataType Entries shall provide the correct bit length</PostCondition>
					<References>
						<Reference Specification="ETG.2000" Chapter="5.6.7 Base Data Types"></Reference>
						<Reference Specification="ETG.5001"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="Toggle_LOC_EXT">
					<!--Flag for InitGlobalVariables for default XPaths of local or external file-->
					<SetVariable Target="LocExt_InitToggle">false</SetVariable>
					<WriteLine Id="0" Level="Output">Checking for external file with modules</WriteLine>
				</TestStep>
				<TestStep Name="SkipNoSlots">
					<!--Skip Test if "CurrentConfig.SlotCount" == 0-->
					<Compare>
						<Equal>
							<Value1>CurrentConfig.SlotCount</Value1>
							<Value2>0</Value2>
							<SkipCase Id="1">Test skipped. No slots defined.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="SkipSoE">
					<!--Skip Test if SoE Device-->
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Mailbox.SoE</Value1>
							<Value2>true</Value2>
							<SkipCase Id="2">Test skipped for SoE Devices.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="INIT_AVAIL_GLOB_ARRAY">
					<CallTestFunction Name="AvailableDuTModuleIdents"></CallTestFunction>
				</TestStep>
				<TestStep Name="InitGlobalVariables">
					<!--Init global XPaths-->
					<CallTestFunction Name="InitGlobalVariablesForModuleODTest">
						<Parameter>LocExt_InitToggle</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="INIT_MODULE_COUNTER">
					<!--"ModuleCounter" = 1-->
					<SetVariable Target="ModuleCounter">1</SetVariable>
				</TestStep>
				<TestStep Name="CHECK_IF_EXISTS">
					<!--Checking if module exist-->
					<Compare>
						<Equal>
							<Value1>loc_XPathModuleIdent</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>ReturnTestResult</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="InitTestedArray">
					<!--Array of already processed modules, no doubles-->
					<InitArray TargetArray="AllModuleIdents.Uint32Array"></InitArray>
				</TestStep>
				<TestStep Name="ModuleLoopStart">
					<!--__Loop START for LOCAL Modules__-->
				</TestStep>
				<TestStep Name="CHECK_IF_MODULE_EXISTS">
					<!--Checking if module exist-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>ReturnTestResult</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>ReturnTestResult</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_AVAILABLE_MDL">
					<!--Get ModuleIdent and Flag to SKIP testing of assigned modules-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="AllModuleIdents.Uint32">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>TestAvailableMdls</Value1>
							<Value2>false</Value2>
							<GotoStep>TEST_MODULES</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckItemInArray">
					<!--Check if module in list of assigned modules-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllAvailableDuTModules.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleInArray.boolAssigned</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="3" Level="Verbose" Param0="CheckModuleInArray.boolAssigned" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleInArray.boolAssigned == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleInArray.boolAssigned</Value1>
							<Value2>false</Value2>
							<GotoStep>GoToCheckNextModule</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckAlreadyTested">
					<!--Check if module already tested-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllModuleIdents.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleAlreadyTested.boolAlreadyChecked</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="4" Level="Verbose" Param0="CheckModuleAlreadyTested.boolAlreadyChecked" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleAlreadyTested.boolAlreadyChecked == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleAlreadyTested.boolAlreadyChecked</Value1>
							<Value2>true</Value2>
							<GotoStep>GoToCheckNextModule</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_MODULES">
					<!--Print Module Ident-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="5" Level="Verbose" Param0="ModuleCounter" Param1="strXmlValue">Module[{0}]: Ident: {1}</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="Check_extOD_FileRef">
					<CallTestFunction Name="CheckForExtRefDict">
						<Parameter>loc_ModuleXmlFile</Parameter>
						<Parameter>loc_XPathModuleIdent</Parameter>
						<Parameter>ModuleCounter</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="INIT_TxPdo_COUNTER">
					<!--Init of 1. nested loop counter for TxPdo of current module-->
					<SetVariable Target="i32TmpTxPdoIndex">1</SetVariable>
				</TestStep>
				<TestStep Name="TxPdoLoopStart">
					<!--__Loop START for current module TxPdo__-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpTxPdoIndex">{0}[{1}]/TxPdo[{2}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>GoToCheckNextModule</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>GoToCheckNextModule</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="INIT_ENTRY_COUNTER">
					<!--Init of 2. nested loop counter for TxPdo entries of current module-->
					<SetVariable Target="i32TmpEntryIndex">1</SetVariable>
				</TestStep>
				<TestStep Name="EntryLoopStart">
					<!--__Loop START for current module TxPdo entry__-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpTxPdoIndex" Param3="i32TmpEntryIndex">{0}[{1}]/TxPdo[{2}]/Entry[{3}]/Index</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="6" Level="Output" Param0="ModuleCounter" Param1="i32TmpTxPdoIndex" Param2="i32TmpEntryIndex" Param3="strXmlValue">Module[{0}]/TxPdo[{1}]/Entry[{2}]: {3}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>GetAndWriteResult</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>GetAndWriteResult</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="WriteDescPdoObject">
					<!--Dump testing info-->
					<Description Id="7" Level="Verbose" Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpTxPdoIndex" Param3="i32TmpEntryIndex">Checking {3}. entry of {0}[{1}]/TxPdo[{2}]...</Description>
				</TestStep>
				<TestStep Name="CheckIsGap">
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.Index.Uint16">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpTxPdoIndex" Param3="i32TmpEntryIndex">{0}[{1}]/TxPdo[{2}]/Entry[{3}]/Index</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="8" Level="Output" Param0="strXmlValue.Index.Uint16">Value of "strXmlValue.Index.Uint16": {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>strXmlValue.Index.Uint16</Value1>
							<Value2>0</Value2>
							<GotoStep>CheckIfArrayBaseDataType</GotoStep>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="WriteGapEntry">
					<!--Dump gap entry info-->
					<WriteLine Id="9" Level="Verbose" Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpTxPdoIndex" Param3="i32TmpEntryIndex">{0}[{1}]/TxPdo[{2}]/Entry[{3}] is a gap entry.</WriteLine>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>IncrementEntryIndex</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckIfArrayBaseDataType">
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.EntryDT.String">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpTxPdoIndex" Param3="i32TmpEntryIndex">{0}[{1}]/TxPdo[{2}]/Entry[{3}]/DataType</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="10" Level="Output" Param0="strXmlValue.EntryDT.String">Checking {0} if valid Array DataType...</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<!--Call test function "CheckForValidArrayDataTYpe"-->
					<CallTestFunction Name="CheckForValidArrayDataType">
						<Parameter>strXmlValue.EntryDT.String</Parameter>
						<OutParameter>boolComplexType</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="11" Level="Output" Param0="boolComplexType">Is Array type DataType: {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>boolComplexType</Value1>
							<Value2>true</Value2>
							<GotoStep>CheckIfArrayBitLengthLarger31B</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckBaseDataTypeBitLen">
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.BitLen.Uint32">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpTxPdoIndex" Param3="i32TmpEntryIndex">{0}[{1}]/TxPdo[{2}]/Entry[{3}]/BitLen</XPath>
					</GetXmlValue>
				</TestStep>
				<TestStep>
					<!--Call test function "BaseDataType.CheckSize"-->
					<CallTestFunction Name="BaseDataType.CheckSize">
						<Parameter>strXmlValue.BitLen.Uint32</Parameter>
						<Parameter>strXmlValue.EntryDT.String</Parameter>
						<OutParameter>StringBaseTypeErrorString</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="12" Level="Output" Param0="strXmlValue.BitLen.Uint32" Param1="strXmlValue.EntryDT.String">Checked BitLength: {0} vs DataType: {1}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="13" Level="Output" Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpTxPdoIndex" Param3="i32TmpEntryIndex">Checked BaseDataType Length of {0}[{1}]/TxPdo[{2}]/Entry[{3}]</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>StringBaseTypeErrorString</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>WriteBaseDataTypeError</GotoStep>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="IncrementDataTypeSuccessfullCounter">
					<!--Successful counter-->
					<SetVariable Target="uint16SuccCount">uint16SuccCount+1</SetVariable>
					<WriteLine Id="14" Level="Verbose" Param0="i32TmpTxPdoIndex" Param1="i32TmpEntryIndex" Param2="strXmlValue.EntryDT.String" Param3="strXmlValue.BitLen.Uint32">Entry TxPdo[{0}]/Entry[{1}] has the DataType {2} and the right BitLength ({3}).</WriteLine>
				</TestStep>
				<TestStep Name="IncrementTestedCounter">
					<!--Tested values counter-->
					<SetVariable Target="uint16TestedValues">uint16TestedValues+1</SetVariable>
				</TestStep>
				<TestStep Name="GoToNextEntry">
					<!--__END of "EntryLoopStart"__-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>IncrementEntryIndex</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="WriteBaseDataTypeError">
					<!--Dump Error message for DT-->
					<WriteLine Id="15" Level="Error" Param0="i32TmpTxPdoIndex" Param1="i32TmpEntryIndex" Param2="StringBaseTypeErrorString">TxPdo[{0}]/Entry[{1}]: {2}</WriteLine>
				</TestStep>
				<TestStep Name="IncrementGeneralCounter">
					<!--General Error counter-->
					<SetVariable Target="uint16Errors">uint16Errors+1</SetVariable>
				</TestStep>
				<TestStep Name="IncrementDataTypeErrorCounter">
					<!--DT error Counter-->
					<SetVariable Target="uint16ErrCount">uint16ErrCount+1</SetVariable>
				</TestStep>
				<TestStep Name="IncrementEntryIndex">
					<!--Increment 2. nested loop counter for "EntryLoopStart"-->
					<SetVariable Target="i32TmpEntryIndex">i32TmpEntryIndex+1</SetVariable>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>EntryLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="GetAndWriteResult">
					<!--dump test results-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="16" Level="Output" Param0="uint16SuccCount" Param1="uint16ErrCount">uint16SuccCount: {0} and uint16ErrCount: {1}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>uint16ErrCount</Value1>
							<Value2>0</Value2>
							<WriteLine Id="17" Level="Output" Param0="ModuleCounter" Param1="i32TmpTxPdoIndex" Param2="uint16SuccCount" Param3="uint16ErrCount">PDO object Module[{0}]/TxPdo[{1}]: {3} Entry data type(s) do not match to the expected bit length. {2} data type(s) match to the right bit length.</WriteLine>
						</NotEqual>
					</Compare>
					<Compare>
						<Equal>
							<Value1>(uint16SuccCount+uint16ErrCount)</Value1>
							<Value2>0</Value2>
							<WriteLine Id="18" Level="Output" Param0="i32TmpTxPdoIndex" Param1="i32TmpEntryIndex">TxPdo[{0}]/Entry{1}: No entry data type checked.</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>(uint16SuccCount+uint16ErrCount)</Value1>
							<Value2>0</Value2>
							<GotoStep>IncrementTxPdoIndex</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>uint16ErrCount</Value1>
							<Value2>0</Value2>
							<WriteLine Id="19" Level="Output" Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpTxPdoIndex" Param3="uint16SuccCount">PDO object {0}[{1}]/TxPdo[{2}]: All entry data type(s) ({3}) match to the expected bit length.</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="IncrementTxPdoIndex">
					<!--Increment 1. nested loop counter for "TxPdoLoopStart"-->
					<SetVariable Target="i32TmpTxPdoIndex">i32TmpTxPdoIndex+1</SetVariable>
				</TestStep>
				<TestStep Name="ResetSuccessCountForNextPdo">
					<!--Reset Successful counter-->
					<SetVariable Target="uint16SuccCount">0</SetVariable>
				</TestStep>
				<TestStep Name="ResetErrorCountForNextPdo">
					<!--Reset DT Error counter-->
					<SetVariable Target="uint16ErrCount">0</SetVariable>
				</TestStep>
				<TestStep Name="GoToCheckNextPdo">
					<!--__END of "TxPdoLoopStart"__-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>TxPdoLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="GoToCheckNextModule">
					<!--__END of "ModuleLoopStart", add ModuleIdent to tested Array__-->
					<AddArrayItem TargetArray="AllModuleIdents.Uint32Array">AllModuleIdents.Uint32</AddArrayItem>
				</TestStep>
				<TestStep>
					<!--Increment loop counter-->
					<SetVariable Target="ModuleCounter">ModuleCounter+1</SetVariable>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>ModuleLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="ReturnTestResult">
					<!--The "uint16TestedValues" is not increased for Gap/padding entries. Total number of entries tested is different from total entries present in the ESI, Module file.-->
					<Compare>
						<Greater>
							<Value1>uint16Errors</Value1>
							<Value2>0</Value2>
							<RaiseError Id="41"></RaiseError>
						</Greater>
					</Compare>
					<Compare>
						<Equal>
							<Value1>uint16TestedValues</Value1>
							<Value2>0</Value2>
							<SkipCase Id="21">Skipped case: No entry found.</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<ReturnSuccess Id="22" Param0="uint16TestedValues">All ({0}) entr(y/ies) of TxPdo object(s) match to the right bit length (Gap entries excluded).</ReturnSuccess>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckIfArrayBitLengthLarger31B">
					<!--31B == 248 bit-->
					<SetVariable Target="int32SavedSubIndex">i32TmpEntryIndex</SetVariable>
				</TestStep>
				<TestStep>
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.EntryBitLenCopy.Uint32">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpTxPdoIndex" Param3="i32TmpEntryIndex">{0}[{1}]/TxPdo[{2}]/Entry[{3}]/BitLen</XPath>
					</GetXmlValue>
				</TestStep>
				<TestStep>
					<SetVariable Target="Uint32ArrayBitLength">strXmlValue.EntryBitLenCopy.Uint32</SetVariable>
				</TestStep>
				<TestStep Name="CheckArrayIfSplittedBitSize">
					<SetVariable Target="i32TmpEntryIndex">i32TmpEntryIndex+1</SetVariable>
				</TestStep>
				<TestStep>
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.EntryNmmr.String">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpTxPdoIndex" Param3="i32TmpEntryIndex">{0}[{1}]/TxPdo[{2}]/Entry[{3}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="23" Level="Output" Param0="strXmlValue.EntryNmmr.String">Value of "strXmlValue.EntryNmmr.String": {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="24" Level="Output" Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpTxPdoIndex" Param3="i32TmpEntryIndex">{0}[{1}]/TxPdo[{2}]/Entry[{3}]</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue.EntryNmmr.String</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>ResetSubIndexAndGoBack</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue.EntryNmmr.String</Value1>
							<Value2>null</Value2>
							<GotoStep>ResetSubIndexAndGoBack</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.EntryIndex.Uint16">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpTxPdoIndex" Param3="i32TmpEntryIndex">{0}[{1}]/TxPdo[{2}]/Entry[{3}]/Index</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="25" Level="Output" Param0="strXmlValue.EntryIndex.Uint16">Value of "strXmlValue.EntryIndex.Uint16": {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>strXmlValue.EntryIndex.Uint16</Value1>
							<Value2>0</Value2>
							<GotoStep>ResetSubIndexAndGoBack</GotoStep>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep>
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.EntrySubindex.Uint16">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpTxPdoIndex" Param3="i32TmpEntryIndex">{0}[{1}]/TxPdo[{2}]/Entry[{3}]/SubIndex</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="26" Level="Output" Param0="strXmlValue.EntrySubindex.Uint16">Value of "strXmlValue.EntrySubindex.Uint16": {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>strXmlValue.EntrySubindex.Uint16</Value1>
							<Value2>0</Value2>
							<GotoStep>ResetSubIndexAndGoBack</GotoStep>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="EndOf_CheckArrayIfSplittedBitSize">
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="27" Level="Verbose">Checking for split Array.</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Greater>
							<Value1>strXmlValue.EntryBitLenCopy.Uint32</Value1>
							<Value2>240</Value2>
							<WriteLine Id="28" Level="Warning" Param0="strXmlValue.EntryBitLenCopy.Uint32">Bit length of {0} is invalid. In case of splitted Array a Bit length greater than 240 Bits is not allowed.</WriteLine>
						</Greater>
					</Compare>
				</TestStep>
				<TestStep Name="CheckIfArrayEnd">
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.EntryNmmr.String">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpTxPdoIndex" Param3="i32TmpEntryIndex">{0}[{1}]/TxPdo[{2}]/Entry[{3}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue.EntryNmmr.String</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>DecreaseSubIndexAndCheckArrayDataTypeBitSize</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue.EntryNmmr.String</Value1>
							<Value2>null</Value2>
							<GotoStep>DecreaseSubIndexAndCheckArrayDataTypeBitSize</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.EntryIndex.Uint16">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpTxPdoIndex" Param3="i32TmpEntryIndex">{0}[{1}]/TxPdo[{2}]/Entry[{3}]/Index</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue.EntryIndex.Uint16</Value1>
							<Value2>null</Value2>
							<GotoStep>DecreaseSubIndexAndCheckArrayDataTypeBitSize</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>strXmlValue.EntryIndex.Uint16</Value1>
							<Value2>0</Value2>
							<GotoStep>DecreaseSubIndexAndCheckArrayDataTypeBitSize</GotoStep>
						</NotEqual>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue.EntryIndex.Uint16</Value1>
							<Value2>0</Value2>
							<GotoStep>CheckIfArrayEnd_Continue</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.EntrySubindex.Uint16">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpTxPdoIndex" Param3="i32TmpEntryIndex">{0}[{1}]/TxPdo[{2}]/Entry[{3}]/SubIndex</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue.EntrySubindex.Uint16</Value1>
							<Value2>null</Value2>
							<GotoStep>DecreaseSubIndexAndCheckArrayDataTypeBitSize</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>strXmlValue.EntrySubindex.Uint16</Value1>
							<Value2>0</Value2>
							<GotoStep>DecreaseSubIndexAndCheckArrayDataTypeBitSize</GotoStep>
						</NotEqual>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue.EntrySubindex.Uint16</Value1>
							<Value2>0</Value2>
							<GotoStep>CheckIfArrayEnd_Continue</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckIfArrayEnd_Continue">
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.BitLen.Uint32">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpTxPdoIndex" Param3="i32TmpEntryIndex">{0}[{1}]/TxPdo[{2}]/Entry[{3}]/BitLen</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="29" Level="Verbose">Checking if Array ended.</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="30" Level="Verbose" Param0="i32TmpEntryIndex">i32TmpEntryIndex == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="31" Level="Verbose" Param0="strXmlValue.EntryIndex.Uint16">strXmlValue.EntryIndex.Uint16 == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="32" Level="Verbose" Param0="strXmlValue.EntrySubindex.Uint16">strXmlValue.EntrySubindex.Uint16 == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Greater>
							<Value1>strXmlValue.BitLen.Uint32</Value1>
							<Value2>240</Value2>
							<WriteLine Id="33" Level="Warning" Param0="strXmlValue.BitLen.Uint32">Bit length of {0} is invalid. In case of splitted Array a Bit length greater than 240 Bits is not allowed.</WriteLine>
						</Greater>
					</Compare>
				</TestStep>
				<TestStep>
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.EntryDTSave.String">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpTxPdoIndex" Param3="int32SavedSubIndex">{0}[{1}]/TxPdo[{2}]/Entry[{3}]/DataType</XPath>
					</GetXmlValue>
				</TestStep>
				<TestStep>
					<CallTestFunction Name="BaseDataType.CheckSize">
						<Parameter>Uint32ArrayBitLength</Parameter>
						<Parameter>strXmlValue.EntryDTSave.String</Parameter>
						<OutParameter>StringBaseTypeErrorString</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="34" Level="Verbose" Param0="StringBaseTypeErrorString">StringBaseTypeErrorString = {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>StringBaseTypeErrorString</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>DecreaseSubIndexAndCheckArrayDataTypeBitSize</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<SetVariable Target="Uint32ArrayBitLength">Uint32ArrayBitLength+strXmlValue.BitLen.Uint32</SetVariable>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="35" Level="Verbose" Param0="Uint32ArrayBitLength">Uint32ArrayBitLength == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>strXmlValue.EntryBitLenCopy.Uint32</Value1>
							<Value2>240</Value2>
							<GotoStep>CheckArrayDataTypeBitSize</GotoStep>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep>
					<SetVariable Target="i32TmpEntryIndex">i32TmpEntryIndex+1</SetVariable>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>CheckIfArrayEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="DecreaseSubIndexAndCheckArrayDataTypeBitSize">
					<SetVariable Target="i32TmpEntryIndex">i32TmpEntryIndex-1</SetVariable>
				</TestStep>
				<TestStep Name="CheckArrayDataTypeBitSize">
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.EntryDTSave.String">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpTxPdoIndex" Param3="int32SavedSubIndex">{0}[{1}]/TxPdo[{2}]/Entry[{3}]/DataType</XPath>
					</GetXmlValue>
				</TestStep>
				<TestStep>
					<CallTestFunction Name="BaseDataType.CheckSize">
						<Parameter>Uint32ArrayBitLength</Parameter>
						<Parameter>strXmlValue.EntryDTSave.String</Parameter>
						<OutParameter>StringBaseTypeErrorString</OutParameter>
					</CallTestFunction>
					<Compare>
						<NotEqual>
							<Value1>StringBaseTypeErrorString</Value1>
							<Value2>EmptyString</Value2>
							<WriteLine Id="36" Level="Error" Param0="i32TmpTxPdoIndex" Param1="int32SavedSubIndex+1" Param2="StringBaseTypeErrorString">TxPdo[{0}]/Entry{1}: {2}</WriteLine>
						</NotEqual>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>StringBaseTypeErrorString</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>IncrementGeneralCounter</GotoStep>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="WriteArrayDataTypeBitLengthSuccess">
					<SetVariable Target="uint16SuccCount">uint16SuccCount+1</SetVariable>
					<WriteLine Id="37" Level="Verbose" Param0="i32TmpTxPdoIndex" Param1="int32SavedSubIndex+1" Param2="strXmlValue.EntryDTSave.String" Param3="Uint32ArrayBitLength">TxPdo[{0}]/Entry{1} has the DataType {2} and the right BitLength ({3}).</WriteLine>
				</TestStep>
				<TestStep Name="CheckNextEntryWithDataType">
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>IncrementTestedCounter</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="ResetSubIndexAndGoBack">
					<SetVariable Target="i32TmpEntryIndex">int32SavedSubIndex</SetVariable>
				</TestStep>
				<TestStep>
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.BitLen.Uint32">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpTxPdoIndex" Param3="i32TmpEntryIndex">{0}[{1}]/TxPdo[{2}]/Entry[{3}]/BitLen</XPath>
					</GetXmlValue>
				</TestStep>
				<TestStep>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="38" Level="Output" Param0="strXmlValue.BitLen.Uint32">Value of "strXmlValue.BitLen.Uint32": {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="39" Level="Output" Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpTxPdoIndex" Param3="i32TmpEntryIndex">{0}[{1}]/TxPdo[{2}]/Entry[{3}]/BitLen</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.EntryDTCopy.String">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpTxPdoIndex" Param3="i32TmpEntryIndex">{0}[{1}]/TxPdo[{2}]/Entry[{3}]/DataType</XPath>
					</GetXmlValue>
				</TestStep>
				<TestStep>
					<Compare>
						<Greater>
							<Value1>strXmlValue.BitLen.Uint32</Value1>
							<Value2>255</Value2>
							<WriteLine Id="40" Level="Output" Param0="strXmlValue.BitLen.Uint32" Param1="strXmlValue.EntryDTCopy.String">BitSize ({0}) of data type '{1}' is greater than 255.</WriteLine>
						</Greater>
					</Compare>
					<Compare>
						<Greater>
							<Value1>strXmlValue.BitLen.Uint32</Value1>
							<Value2>255</Value2>
							<SetVariable Target="StringBaseTypeErrorString" Param0="strXmlValue.BitLen.Uint32" Param1="strXmlValue.EntryDTCopy.String">BitSize ({0}) of data type '{1}' shall not be greater than 255.</SetVariable>
						</Greater>
					</Compare>
					<Compare>
						<Greater>
							<Value1>strXmlValue.BitLen.Uint32</Value1>
							<Value2>255</Value2>
							<GotoStep>WriteBaseDataTypeError</GotoStep>
						</Greater>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>CheckBaseDataTypeBitLen</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
			</TestCase>
			<TestCase Name="Check Pdo Exclude" CaseId="5">
				<?MAX_OUTPUT_ID 10?>
				<Description>
					<Purpose>Validate .Exclude element of module TxPdo</Purpose>
					<PreCondition>The device description includes locally defined module object dictionary and contains at least one TxPdo element.</PreCondition>
					<Action>Check TxPdos included in .Exclude</Action>
					<PostCondition>Each excluded TxPdo shall exclude the current TxPdo</PostCondition>
					<References>
						<Reference Specification="ETG.2000"></Reference>
						<Reference Specification="ETG.5001"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="Toggle_LOC_EXT">
					<!--Flag for InitGlobalVariables for default XPaths of local or external file-->
					<SetVariable Target="LocExt_InitToggle">false</SetVariable>
					<WriteLine Id="0" Level="Output">Checking for external file with modules</WriteLine>
				</TestStep>
				<TestStep Name="SkipNoSlots">
					<!--Skip Test if "CurrentConfig.SlotCount" == 0-->
					<Compare>
						<Equal>
							<Value1>CurrentConfig.SlotCount</Value1>
							<Value2>0</Value2>
							<SkipCase Id="1">Test skipped. No slots defined.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="SkipSoE">
					<!--Skip Test if SoE Device-->
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Mailbox.SoE</Value1>
							<Value2>true</Value2>
							<SkipCase Id="2">Test skipped for SoE Devices.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="INIT_AVAIL_GLOB_ARRAY">
					<CallTestFunction Name="AvailableDuTModuleIdents"></CallTestFunction>
				</TestStep>
				<TestStep Name="InitGlobalVariables">
					<!--Init global XPaths-->
					<CallTestFunction Name="InitGlobalVariablesForModuleODTest">
						<Parameter>LocExt_InitToggle</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="INIT_RESULT">
					<!--"result" = true-->
					<SetVariable Target="result">true</SetVariable>
				</TestStep>
				<TestStep Name="INIT_MODULE_COUNTER">
					<!--"ModuleCounter" = 1-->
					<SetVariable Target="ModuleCounter">1</SetVariable>
				</TestStep>
				<TestStep Name="CHECK_IF_EXISTS">
					<!--Checking if module exist-->
					<Compare>
						<Equal>
							<Value1>loc_XPathModuleIdent</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>ReturnTestResult</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="InitTestedArray">
					<!--Array of already processed modules, no doubles-->
					<InitArray TargetArray="AllModuleIdents.Uint32Array"></InitArray>
				</TestStep>
				<TestStep Name="ModuleLoopStart">
					<!--__Loop START for LOCAL Modules__-->
				</TestStep>
				<TestStep Name="CHECK_IF_MODULE_EXISTS">
					<!--Checking if module exist-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>ReturnTestResult</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>ReturnTestResult</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_AVAILABLE_MDL">
					<!--Get ModuleIdent and Flag to SKIP testing of assigned modules-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="AllModuleIdents.Uint32">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>TestAvailableMdls</Value1>
							<Value2>false</Value2>
							<GotoStep>TEST_MODULES</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckItemInArray">
					<!--Check if module in list of assigned modules-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllAvailableDuTModules.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleInArray.boolAssigned</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="3" Level="Verbose" Param0="CheckModuleInArray.boolAssigned" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleInArray.boolAssigned == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleInArray.boolAssigned</Value1>
							<Value2>false</Value2>
							<GotoStep>GoToCheckNextModule</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckAlreadyTested">
					<!--Check if module already tested-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllModuleIdents.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleAlreadyTested.boolAlreadyChecked</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="4" Level="Verbose" Param0="CheckModuleAlreadyTested.boolAlreadyChecked" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleAlreadyTested.boolAlreadyChecked == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleAlreadyTested.boolAlreadyChecked</Value1>
							<Value2>true</Value2>
							<GotoStep>GoToCheckNextModule</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_MODULES">
					<!--Print Module Ident-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="5" Level="Verbose" Param0="ModuleCounter" Param1="strXmlValue">Module[{0}]: Ident: {1}</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="Check_extOD_FileRef">
					<CallTestFunction Name="CheckForExtRefDict">
						<Parameter>loc_ModuleXmlFile</Parameter>
						<Parameter>loc_XPathModuleIdent</Parameter>
						<Parameter>ModuleCounter</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="INIT_TxPdo_COUNTER">
					<!--Init of nested loop counter for TxPdo of current module-->
					<SetVariable Target="i32TmpTxPdoIndex">1</SetVariable>
				</TestStep>
				<TestStep Name="TxPdoLoopStart">
					<!--__Loop START for current module TxPdo__-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpTxPdoIndex">{0}[{1}]/TxPdo[{2}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>GoToCheckNextModule</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>GoToCheckNextModule</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.Index.Uint16">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpTxPdoIndex">{0}[{1}]/TxPdo[{2}]/Index</XPath>
					</GetXmlValue>
					<Compare>
						<NotEqual>
							<Value1>strXmlValue.Index.Uint16</Value1>
							<Value2>0</Value2>
							<GotoStep>LOOPSTART</GotoStep>
						</NotEqual>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue.Index.Uint16</Value1>
							<Value2>null</Value2>
							<GotoStep>GoToCheckNextModule</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue.Index.Uint16</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>GoToCheckNextModule</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="LOOPSTART">
					<!--Dump loop start info-->
					<WriteLine Id="6" Level="Output" Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpTxPdoIndex" Param3="strXmlValue.Index.Uint16">Checking Exclude element of {0}[{1}]/TxPdo[{2}] : 0x{3:x4}.</WriteLine>
				</TestStep>
				<TestStep>
					<!--Check if current Exclude element is valid-->
					<CallTestFunction Name="CheckTxPdoExcludeElement_gen">
						<Parameter>loc_ModuleXmlFile</Parameter>
						<Parameter>loc_XPathModuleIdent</Parameter>
						<Parameter>ModuleCounter</Parameter>
						<Parameter>i32TmpTxPdoIndex</Parameter>
						<OutParameter>TmpResult</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<SetVariable Target="AtLeastOneModuleFound">true</SetVariable>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>TmpResult</Value1>
							<Value2>false</Value2>
							<WriteLine Id="7" Level="Output" Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpTxPdoIndex">Exclude information of {0}[{1}]/TxPdo[{2}] are invalid.</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<!--update result-->
					<Compare>
						<Equal>
							<Value1>TmpResult</Value1>
							<Value2>false</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="LOOPEND">
					<!--__END of "TxPdoLoopStart", increment loop counter__-->
					<SetVariable Target="i32TmpTxPdoIndex">i32TmpTxPdoIndex + 1</SetVariable>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>TxPdoLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="GoToCheckNextModule">
					<!--__END of "ModuleLoopStart", add ModuleIdent to tested Array__-->
					<AddArrayItem TargetArray="AllModuleIdents.Uint32Array">AllModuleIdents.Uint32</AddArrayItem>
				</TestStep>
				<TestStep>
					<!--increment module-->
					<SetVariable Target="ModuleCounter">ModuleCounter+1</SetVariable>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>ModuleLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="ReturnTestResult">
					<!--dump test result-->
					<Compare>
						<Equal>
							<Value1>AtLeastOneModuleFound</Value1>
							<Value2>false</Value2>
							<SkipCase Id="8">No TxPdo.Exclude found.</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>false</Value2>
							<RaiseError Id="9">Test TxPdo.Exclude failed</RaiseError>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>true</Value2>
							<ReturnSuccess Id="10">Test TxPdo.Exclude succeed.</ReturnSuccess>
						</Equal>
					</Compare>
				</TestStep>
			</TestCase>
		</TestGroup>
		<TestGroup GroupId="103" Name="(Local) Module Device Object Tests">
			<Comment>Check the Object definitions of the modules defined locally in ESI</Comment>
			<TestCase Name="General Object Attributes" CaseId="1">
				<?MAX_OUTPUT_ID 20?>
				<Description>
					<PreCondition>The device description includes locally defined module object dictionary</PreCondition>
					<Action>1.) Get the object Index
2.) Get the object Name</Action>
					<PostCondition>1.) The Index shall be between 0x1000 and 0xFFFF
2.) The Name shall not be empty</PostCondition>
					<References>
						<Reference Specification="ETG.2000"></Reference>
						<Reference Specification="ETG.1020"></Reference>
						<Reference Specification="ETG.5001"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="Toggle_LOC_EXT">
					<!--Flag for InitGlobalVariables for default XPaths of local or external file-->
					<SetVariable Target="LocExt_InitToggle">false</SetVariable>
					<WriteLine Id="0" Level="Output">Checking for external file with modules.</WriteLine>
				</TestStep>
				<TestStep Name="SkipNoSlots">
					<!--Skip Test if "CurrentConfig.SlotCount" == 0-->
					<Compare>
						<Equal>
							<Value1>CurrentConfig.SlotCount</Value1>
							<Value2>0</Value2>
							<SkipCase Id="1">Test skipped. No slots defined.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="SkipSoE">
					<!--Skip Test if SoE Device-->
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Mailbox.SoE</Value1>
							<Value2>true</Value2>
							<SkipCase Id="2">Test skipped for SoE Devices.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="INIT_AVAIL_GLOB_ARRAY">
					<CallTestFunction Name="AvailableDuTModuleIdents"></CallTestFunction>
				</TestStep>
				<TestStep Name="InitGlobalVariables">
					<!--Init global XPaths-->
					<CallTestFunction Name="InitGlobalVariablesForModuleODTest">
						<Parameter>LocExt_InitToggle</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="INIT_RESULT">
					<!--"result" = true-->
					<SetVariable Target="result">true</SetVariable>
				</TestStep>
				<TestStep Name="INIT_LOOP_COUNTER">
					<!--"ModuleCounter" = 1-->
					<SetVariable Target="ModuleCounter">1</SetVariable>
				</TestStep>
				<TestStep Name="CHECK_IF_EXISTS">
					<!--Checking if module exist-->
					<Compare>
						<Equal>
							<Value1>loc_XPathModuleIdent</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>END</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="InitTestedArray">
					<!--Array of already processed modules, no doubles-->
					<InitArray TargetArray="AllModuleIdents.Uint32Array"></InitArray>
				</TestStep>
				<TestStep Name="ObjectLoopStart">
					<!--__Loop START for LOCAL Modules__-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>END</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>END</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_AVAILABLE_MDL">
					<!--Get ModuleIdent and Flag to SKIP testing of assigned modules-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="AllModuleIdents.Uint32">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>TestAvailableMdls</Value1>
							<Value2>false</Value2>
							<GotoStep>TEST_MODULES</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckItemInArray">
					<!--Check if module in list of assigned modules-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllAvailableDuTModules.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleInArray.boolAssigned</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="3" Level="Verbose" Param0="CheckModuleInArray.boolAssigned" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleInArray.boolAssigned == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleInArray.boolAssigned</Value1>
							<Value2>false</Value2>
							<GotoStep>ObjectLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckAlreadyTested">
					<!--Check if module already tested-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllModuleIdents.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleAlreadyTested.boolAlreadyChecked</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="4" Level="Verbose" Param0="CheckModuleAlreadyTested.boolAlreadyChecked" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleAlreadyTested.boolAlreadyChecked == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleAlreadyTested.boolAlreadyChecked</Value1>
							<Value2>true</Value2>
							<GotoStep>ObjectLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_MODULES">
					<!--Print Module Ident-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="5" Level="Verbose" Param0="ModuleCounter" Param1="strXmlValue">Module[{0}]: Ident: {1}</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="Check_extOD_FileRef">
					<CallTestFunction Name="CheckForExtRefDict">
						<Parameter>loc_ModuleXmlFile</Parameter>
						<Parameter>loc_XPathModuleIdent</Parameter>
						<Parameter>ModuleCounter</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="InitSubItemLoopCounter">
					<!--Init of nested loop counter for the object of current module-->
					<SetVariable Target="i32TmpModuleIndex">1</SetVariable>
				</TestStep>
				<TestStep Name="SubItemLoopStart">
					<!--__Loop START for current module object__-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/Profile/Dictionary/Objects/Object[{2}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>ObjectLoopEnd</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>ObjectLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="GET_OBJ_INDEX">
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.ObjIndex.Uint16">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/Profile/Dictionary/Objects/Object[{2}]/Index</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="6" Level="Output" Param0="strXmlValue.ObjIndex.Uint16">Value of "strXmlValue.ObjIndex.Uint16": 0x{0:x4}</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="COMPARE_OBJ_INDEX">
					<!--Dump an Error if no Object index is defined-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<SetVariable Target="ModuleObjectInfo.ObjFound">true</SetVariable>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue.ObjIndex.Uint16</Value1>
							<Value2>null</Value2>
							<WriteLine Id="7" Level="Error" Param0="ModuleCounter">Object[{0}].Index shall be defined.</WriteLine>
						</Equal>
					</Compare>
					<!--Update Result-->
					<Compare>
						<Equal>
							<Value1>strXmlValue.ObjIndex.Uint16</Value1>
							<Value2>null</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Equal>
					</Compare>
					<!--goto "GET_OBJ_NAME"-->
					<Compare>
						<Equal>
							<Value1>strXmlValue.ObjIndex.Uint16</Value1>
							<Value2>null</Value2>
							<GotoStep>GET_OBJ_NAME</GotoStep>
						</Equal>
					</Compare>
					<!--Dump an error if the index is less 0x1000-->
					<Compare>
						<Lower>
							<Value1>strXmlValue.ObjIndex.Uint16</Value1>
							<Value2>#x1000</Value2>
							<WriteLine Id="8" Level="Error" Param0="ModuleCounter" Param1="strXmlValue.ObjIndex.Uint16">Object[{0}].Index (0x{1:x4}) shall be within 0x1000 and 0xFFFF.</WriteLine>
						</Lower>
					</Compare>
					<!--Update Result-->
					<Compare>
						<Lower>
							<Value1>strXmlValue.ObjIndex.Uint16</Value1>
							<Value2>#x1000</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Lower>
					</Compare>
					<!--Dump valid Info-->
					<Compare>
						<GreaterOrEqual>
							<Value1>strXmlValue.ObjIndex.Uint16</Value1>
							<Value2>#x1000</Value2>
							<WriteLine Id="9" Level="Output" Param0="ModuleCounter" Param1="strXmlValue.ObjIndex.Uint16">Object[{0}].Index (0x{1:x4}) is valid.</WriteLine>
						</GreaterOrEqual>
					</Compare>
				</TestStep>
				<TestStep Name="GET_OBJ_NAME">
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/Profile/Dictionary/Objects/Object[{2}]/Name</XPath>
					</GetXmlValue>
					<!--Dump an Error if no Object name is defined-->
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<WriteLine Id="10" Level="Error" Param0="ModuleCounter">Object[{0}] : No Name defined.</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<WriteLine Id="11" Level="Error" Param0="ModuleCounter">Object[{0}] : No Name defined.</WriteLine>
						</Equal>
					</Compare>
					<!--Update Result-->
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Equal>
					</Compare>
					<!--goto "ObjectLoopEnd"-->
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>GET_OBJ_READ_RESTRICTION</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>GET_OBJ_READ_RESTRICTION</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="COMPARE_OBJ_NAME">
					<!--Dump an Error if the Object name is empty-->
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<WriteLine Id="12" Level="Error" Param0="ModuleCounter">Object[{0}].Name shall not be empty.</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<WriteLine Id="13" Level="Error" Param0="ModuleCounter">Object[{0}].Name shall not be empty.</WriteLine>
						</Equal>
					</Compare>
					<!--Update Result-->
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Equal>
					</Compare>
					<!--Write valid Info-->
					<Compare>
						<NotEqual>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<WriteLine Id="14" Level="Output" Param0="ModuleCounter" Param1="strXmlValue">Object[{0}].Name '{1}' is valid.</WriteLine>
						</NotEqual>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<WriteLine Id="15" Level="Output" Param0="ModuleCounter" Param1="strXmlValue">Object[{0}].Name '{1}' is valid.</WriteLine>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="GET_OBJ_READ_RESTRICTION">
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/Profile/Dictionary/Objects/Object[{2}]/Flags/Access/@ReadRestrictions</XPath>
					</GetXmlValue>
					<!--goto "ObjectLoopEnd"-->
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>GET_OBJ_WRITE_RESTRICTION</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>GET_OBJ_WRITE_RESTRICTION</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="COMPARE_READ_RESTRICTION">
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>"PreOp"</Value2>
							<WriteLine Id="16" Level="Error" Param0="ModuleCounter">Object[{0}]/Flags/Access/@ReadRestrictions shall not be'PreOp' (use 'PreOP' instead).</WriteLine>
						</Equal>
					</Compare>
					<!--Update Result-->
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>"PreOp"</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="GET_OBJ_WRITE_RESTRICTION">
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/Profile/Dictionary/Objects/Object[{2}]/Flags/Access/@WriteRestrictions</XPath>
					</GetXmlValue>
				</TestStep>
				<TestStep Name="COMPARE_WRITE_RESTRICTION">
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>"PreOp"</Value2>
							<WriteLine Id="17" Level="Error" Param0="ModuleCounter">Object[{0}]/Flags/Access/@WriteRestrictions shall not be'PreOp' (use 'PreOP' instead).</WriteLine>
						</Equal>
					</Compare>
					<!--Update Result-->
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>"PreOp"</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="SubItemLoopCounterEnd">
					<!--__END of "SubItemLoopStart", increment loop counter__-->
					<SetVariable Target="i32TmpModuleIndex">i32TmpModuleIndex + 1</SetVariable>
					<!--goto loop start by default -->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>SubItemLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="ObjectLoopEnd">
					<!--__END of "ObjectLoopStart", add ModuleIdent to tested Array__-->
					<AddArrayItem TargetArray="AllModuleIdents.Uint32Array">AllModuleIdents.Uint32</AddArrayItem>
				</TestStep>
				<TestStep>
					<!--Increment loop counter-->
					<SetVariable Target="ModuleCounter">ModuleCounter + 1</SetVariable>
					<!--Goto Loop start if counter is less than Number of DataTypes -->
					<!--Goto loop start by default -->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>ObjectLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="END">
					<!--Dump Test case result-->
					<Compare>
						<Equal>
							<Value1>ModuleObjectInfo.ObjFound</Value1>
							<Value2>false</Value2>
							<SkipCase Id="18">No Variable object found.</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>true</Value2>
							<ReturnSuccess Id="19">Object indices and names are valid.</ReturnSuccess>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>false</Value2>
							<RaiseError Id="20">General Object Attributes Test failed.</RaiseError>
						</Equal>
					</Compare>
				</TestStep>
			</TestCase>
			<TestCase Name="Object DataType and BitSize" CaseId="2">
				<?MAX_OUTPUT_ID 17?>
				<Description>
					<PreCondition>The device description includes locally defined module object dictionary</PreCondition>
					<Action>1.) Get object Type
2.) Get object Bitsize</Action>
					<PostCondition>1.) The object Type shall be defined in the DataType list
2.) The Bitsize shall be equal to the DataType size</PostCondition>
					<References>
						<Reference Specification="ETG.2000"></Reference>
						<Reference Specification="ETG.1020"></Reference>
						<Reference Specification="ETG.5001"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="Toggle_LOC_EXT">
					<!--Flag for InitGlobalVariables for default XPaths of local or external file-->
					<SetVariable Target="LocExt_InitToggle">false</SetVariable>
					<WriteLine Id="0" Level="Output">Checking for external file with modules.</WriteLine>
				</TestStep>
				<TestStep Name="SkipNoSlots">
					<!--Skip Test if "CurrentConfig.SlotCount" == 0-->
					<Compare>
						<Equal>
							<Value1>CurrentConfig.SlotCount</Value1>
							<Value2>0</Value2>
							<SkipCase Id="1">Test skipped. No slots defined.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="SkipSoE">
					<!--Skip Test if SoE Device-->
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Mailbox.SoE</Value1>
							<Value2>true</Value2>
							<SkipCase Id="2">Test skipped for SoE Devices.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="INIT_AVAIL_GLOB_ARRAY">
					<CallTestFunction Name="AvailableDuTModuleIdents"></CallTestFunction>
				</TestStep>
				<TestStep Name="InitGlobalVariables">
					<!--Init global XPaths-->
					<CallTestFunction Name="InitGlobalVariablesForModuleODTest">
						<Parameter>LocExt_InitToggle</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="INIT_RESULT">
					<!--"result" = true-->
					<SetVariable Target="result">true</SetVariable>
				</TestStep>
				<TestStep Name="INIT_LOOP_COUNTER">
					<!--"ModuleCounter" = 1-->
					<SetVariable Target="ModuleCounter">1</SetVariable>
				</TestStep>
				<TestStep Name="CHECK_IF_EXISTS">
					<!--Checking if module exist-->
					<Compare>
						<Equal>
							<Value1>loc_XPathModuleIdent</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>END</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="InitTestedArray">
					<!--Array of already processed modules, no doubles-->
					<InitArray TargetArray="AllModuleIdents.Uint32Array"></InitArray>
				</TestStep>
				<TestStep Name="ObjectLoopStart">
					<!--__Loop START for LOCAL Modules__-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>END</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>END</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_AVAILABLE_MDL">
					<!--Get ModuleIdent and Flag to SKIP testing of assigned modules-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="AllModuleIdents.Uint32">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>TestAvailableMdls</Value1>
							<Value2>false</Value2>
							<GotoStep>TEST_MODULES</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckItemInArray">
					<!--Check if module in list of assigned modules-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllAvailableDuTModules.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleInArray.boolAssigned</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="3" Level="Verbose" Param0="CheckModuleInArray.boolAssigned" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleInArray.boolAssigned == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleInArray.boolAssigned</Value1>
							<Value2>false</Value2>
							<GotoStep>ObjectLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckAlreadyTested">
					<!--Check if module already tested-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllModuleIdents.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleAlreadyTested.boolAlreadyChecked</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="4" Level="Verbose" Param0="CheckModuleAlreadyTested.boolAlreadyChecked" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleAlreadyTested.boolAlreadyChecked == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleAlreadyTested.boolAlreadyChecked</Value1>
							<Value2>true</Value2>
							<GotoStep>ObjectLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_MODULES">
					<!--Print Module Ident-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="5" Level="Verbose" Param0="ModuleCounter" Param1="strXmlValue">Module[{0}]: Ident: {1}</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="Check_extOD_FileRef">
					<CallTestFunction Name="CheckForExtRefDict">
						<Parameter>loc_ModuleXmlFile</Parameter>
						<Parameter>loc_XPathModuleIdent</Parameter>
						<Parameter>ModuleCounter</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="InitSubItemLoopCounter">
					<!--Init of nested loop counter for the object of current module-->
					<SetVariable Target="i32TmpModuleIndex">1</SetVariable>
				</TestStep>
				<TestStep Name="SubItemLoopStart">
					<!--__Loop START for current module object__-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/Profile/Dictionary/Objects/Object[{2}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>ObjectLoopEnd</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>ObjectLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="GET_OBJ_INDEX">
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.ObjIndex.Uint16">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/Profile/Dictionary/Objects/Object[{2}]/Index</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="6" Level="Output" Param0="strXmlValue.ObjIndex.Uint16">Value of "strXmlValue.ObjIndex.Uint16": 0x{0:x4}</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="GET_OBJ_DATATYPE">
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/Profile/Dictionary/Objects/Object[{2}]/Type</XPath>
					</GetXmlValue>
					<!--Dump an Error if no Type is defined-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<SetVariable Target="ModuleObjectInfo.ObjFound">true</SetVariable>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<WriteLine Id="7" Level="Error" Param0="strXmlValue.ObjIndex.Uint16">0x{0:x4}.Type shall be defined.</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<WriteLine Id="8" Level="Error" Param0="strXmlValue.ObjIndex.Uint16">0x{0:x4}.Type shall be defined.</WriteLine>
						</Equal>
					</Compare>
					<!--Update Result-->
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Equal>
					</Compare>
					<!--goto "ObjectLoopEnd"-->
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>ObjectLoopEnd</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>ObjectLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CREATE_DT_PATH">
					<SetVariable Target="loc_XPathDtTmp" Param0="loc_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Profile/Dictionary/DataTypes/DataType</SetVariable>
				</TestStep>
				<TestStep Name="GET_TYPE_BITSIZE">
					<Description Id="9" Level="Verbose" Param0="strXmlValue" Param1="strXmlValue.ObjIndex.Uint16">0x{1:x4}.Type '{0}' get BitSize.</Description>
					<CallTestFunction Name="DataTypeName.GetBitSize">
						<Parameter>strXmlValue</Parameter>
						<Parameter>loc_ModuleXmlFile</Parameter>
						<Parameter>loc_XPathDtTmp</Parameter>
						<OutParameter>ModuleObjectDTBitSize.TypeBitSize</OutParameter>
					</CallTestFunction>
					<!--Dump an Error if DataType was not found-->
					<Compare>
						<Lower>
							<Value1>ModuleObjectDTBitSize.TypeBitSize</Value1>
							<Value2>0</Value2>
							<WriteLine Id="10" Level="Error" Param0="strXmlValue.ObjIndex.Uint16" Param1="strXmlValue">0x{0:x4}.Type "{1}" was not found in DataTypes element.</WriteLine>
						</Lower>
					</Compare>
					<!--Update Result-->
					<Compare>
						<Lower>
							<Value1>ModuleObjectDTBitSize.TypeBitSize</Value1>
							<Value2>0</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Lower>
					</Compare>
					<!--goto "ObjectLoopEnd"-->
					<Compare>
						<Lower>
							<Value1>ModuleObjectDTBitSize.TypeBitSize</Value1>
							<Value2>0</Value2>
							<GotoStep>ObjectLoopEnd</GotoStep>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep Name="GET_BITSIZE">
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/Profile/Dictionary/Objects/Object[{2}]/BitSize</XPath>
					</GetXmlValue>
					<!--Dump an Error if no Object BitSize is defined-->
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<WriteLine Id="11" Level="Error" Param0="ModuleCounter">Object[{0}].BitSize shall be defined.</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<WriteLine Id="12" Level="Error" Param0="ModuleCounter">Object[{0}].BitSize shall be defined.</WriteLine>
						</Equal>
					</Compare>
					<!--Update Result-->
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Equal>
					</Compare>
					<!--goto "ObjectLoopEnd"-->
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>ObjectLoopEnd</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>ObjectLoopEnd</GotoStep>
						</Equal>
					</Compare>
					<!--Convert String to Int32-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<SetVariable Target="ModuleObjectDTBitSize.ObjBitSize">strXmlValue</SetVariable>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="COMPARE_BITSIZE">
					<!--Dump an Error if the BitSize not match-->
					<Compare>
						<NotEqual>
							<Value1>ModuleObjectDTBitSize.TypeBitSize</Value1>
							<Value2>ModuleObjectDTBitSize.ObjBitSize</Value2>
							<WriteLine Id="13" Level="Error" Param0="strXmlValue.ObjIndex.Uint16" Param1="ModuleObjectDTBitSize.ObjBitSize" Param2="ModuleObjectDTBitSize.TypeBitSize">0x{0:X4}.BitSize ({1}) shall be equal to DataType BitSize ({2}).</WriteLine>
						</NotEqual>
					</Compare>
					<!--Update Result-->
					<Compare>
						<NotEqual>
							<Value1>ModuleObjectDTBitSize.TypeBitSize</Value1>
							<Value2>ModuleObjectDTBitSize.ObjBitSize</Value2>
							<SetVariable Target="result">false</SetVariable>
						</NotEqual>
					</Compare>
					<!--Dump an Output if data type matches-->
					<Compare>
						<Equal>
							<Value1>ModuleObjectDTBitSize.TypeBitSize</Value1>
							<Value2>ModuleObjectDTBitSize.ObjBitSize</Value2>
							<WriteLine Id="14" Level="Output" Param0="strXmlValue.ObjIndex.Uint16" Param1="ModuleObjectDTBitSize.ObjBitSize">0x{0:X4}.BitSize ({1}) matching data type bit size.</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="SubItemLoopCounterEnd">
					<!--__END of "SubItemLoopStart", increment loop counter__-->
					<SetVariable Target="i32TmpModuleIndex">i32TmpModuleIndex + 1</SetVariable>
					<!--goto loop start by default -->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>SubItemLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="ObjectLoopEnd">
					<!--__END of "ObjectLoopStart", add ModuleIdent to tested Array__-->
					<AddArrayItem TargetArray="AllModuleIdents.Uint32Array">AllModuleIdents.Uint32</AddArrayItem>
				</TestStep>
				<TestStep>
					<!--Increment loop counter-->
					<SetVariable Target="ModuleCounter">ModuleCounter + 1</SetVariable>
					<!--Goto Loop start if counter is less than Number of DataTypes -->
					<!--Goto loop start by default -->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>ObjectLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="END">
					<!--Dump Test case result-->
					<Compare>
						<Equal>
							<Value1>ModuleObjectInfo.ObjFound</Value1>
							<Value2>false</Value2>
							<SkipCase Id="15">No Variable object found.</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>true</Value2>
							<ReturnSuccess Id="16">Object DataType and BitSize are valid.</ReturnSuccess>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>false</Value2>
							<RaiseError></RaiseError>
						</Equal>
					</Compare>
				</TestStep>
			</TestCase>
			<TestCase Name="Object Info (Variable)" CaseId="3">
				<?MAX_OUTPUT_ID 19?>
				<Description>
					<PreCondition>At least one object (Code: VARIABLE) is defined and includes an info element</PreCondition>
					<Action>1.) Get 'SubItem'
2.) Get 'DefaultData'
3.) Get 'MinData'
4.) Get 'MaxData'
5.) Get 'DefaultValue'
6.) Get 'MinValue'
7.) Get 'MaxValue'
8.) Get 'DefaultString'</Action>
					<PostCondition>1.) 'SubItem' shall not be defined
2.) 'DefaultData' shall not exceed the used DataType
3.) 'MinData' shall not exceed the used DataType
4.) 'MaxData' shall not exceed the used DataType
5.) 'DefaultValue' shall not exceed the used DataType and shall only used for DataType with a fixed length
6.) 'MinValue' shall not exceed the used DataType and shall only used for DataType with a fixed length
7.) 'MaxValue' shall not exceed the used DataType and shall only used for DataType with a fixed length
8.) 'DefaultString' shall not exceed the used DataType and shall only used for STRING(n)</PostCondition>
					<References>
						<Reference Specification="ETG.2000"></Reference>
						<Reference Specification="ETG.1020"></Reference>
						<Reference Specification="ETG.5001"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="Toggle_LOC_EXT">
					<!--Flag for InitGlobalVariables for default XPaths of local or external file-->
					<SetVariable Target="LocExt_InitToggle">false</SetVariable>
					<WriteLine Id="0" Level="Output">Checking for external file with modules.</WriteLine>
				</TestStep>
				<TestStep Name="SkipNoSlots">
					<!--Skip Test if "CurrentConfig.SlotCount" == 0-->
					<Compare>
						<Equal>
							<Value1>CurrentConfig.SlotCount</Value1>
							<Value2>0</Value2>
							<SkipCase Id="1">Test skipped. No slots defined.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="SkipSoE">
					<!--Skip Test if SoE Device-->
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Mailbox.SoE</Value1>
							<Value2>true</Value2>
							<SkipCase Id="2">Test skipped for SoE Devices.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="INIT_AVAIL_GLOB_ARRAY">
					<CallTestFunction Name="AvailableDuTModuleIdents"></CallTestFunction>
				</TestStep>
				<TestStep Name="InitGlobalVariables">
					<!--Init global XPaths-->
					<CallTestFunction Name="InitGlobalVariablesForModuleODTest">
						<Parameter>LocExt_InitToggle</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="INIT_RESULT">
					<!--"result" = true-->
					<SetVariable Target="result">true</SetVariable>
				</TestStep>
				<TestStep Name="INIT_LOOP_COUNTER">
					<!--"ModuleCounter" = 1-->
					<SetVariable Target="ModuleCounter">1</SetVariable>
				</TestStep>
				<TestStep Name="CHECK_IF_EXISTS">
					<!--Checking if module exist-->
					<Compare>
						<Equal>
							<Value1>loc_XPathModuleIdent</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>END</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="INIT_OBJ_FOUND">
					<!--Init variable "Object found" for dump of test results-->
					<SetVariable Target="ModuleObjectInfo.ObjFound">false</SetVariable>
				</TestStep>
				<TestStep Name="InitTestedArray">
					<!--Array of already processed modules, no doubles-->
					<InitArray TargetArray="AllModuleIdents.Uint32Array"></InitArray>
				</TestStep>
				<TestStep Name="ObjectLoopStart">
					<!--__Loop START for LOCAL Modules__-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>END</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>END</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_AVAILABLE_MDL">
					<!--Get ModuleIdent and Flag to SKIP testing of assigned modules-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="AllModuleIdents.Uint32">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>TestAvailableMdls</Value1>
							<Value2>false</Value2>
							<GotoStep>TEST_MODULES</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckItemInArray">
					<!--Check if module in list of assigned modules-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllAvailableDuTModules.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleInArray.boolAssigned</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="3" Level="Verbose" Param0="CheckModuleInArray.boolAssigned" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleInArray.boolAssigned == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleInArray.boolAssigned</Value1>
							<Value2>false</Value2>
							<GotoStep>ObjectLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckAlreadyTested">
					<!--Check if module already tested-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllModuleIdents.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleAlreadyTested.boolAlreadyChecked</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="4" Level="Verbose" Param0="CheckModuleAlreadyTested.boolAlreadyChecked" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleAlreadyTested.boolAlreadyChecked == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleAlreadyTested.boolAlreadyChecked</Value1>
							<Value2>true</Value2>
							<GotoStep>ObjectLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_MODULES">
					<!--Print Module Ident-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="5" Level="Verbose" Param0="ModuleCounter" Param1="strXmlValue">Module[{0}]: Ident: {1}</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="Check_extOD_FileRef">
					<CallTestFunction Name="CheckForExtRefDict">
						<Parameter>loc_ModuleXmlFile</Parameter>
						<Parameter>loc_XPathModuleIdent</Parameter>
						<Parameter>ModuleCounter</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="InitSubItemLoopCounter">
					<!--Init of nested loop counter for the object of current module-->
					<SetVariable Target="i32TmpModuleIndex">1</SetVariable>
				</TestStep>
				<TestStep Name="SubItemLoopStart">
					<!--__Loop START for current module object__-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.Obj.String">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/Profile/Dictionary/Objects/Object[{2}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="6" Level="Output" Param0="strXmlValue.Obj.String" Param1="i32TmpModuleIndex">Value of "strXmlValue" = {0}; for Object[{1}]</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue.Obj.String</Value1>
							<Value2>null</Value2>
							<GotoStep>ObjectLoopEnd</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue.Obj.String</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>ObjectLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="GET_OBJ_DATATYPE">
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.ObjBaseType.String">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/Profile/Dictionary/Objects/Object[{2}]/Type</XPath>
					</GetXmlValue>
					<!--Dump an Error if no Type is defined-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="7" Level="Output" Param0="strXmlValue.ObjBaseType.String">Value of "strXmlValue.ObjBaseType.String" = {0}; for Object[n]</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue.ObjBaseType.String</Value1>
							<Value2>null</Value2>
							<WriteLine Id="8" Level="Verbose" Param0="ModuleCounter">Object[{0}].Type shall be defined.</WriteLine>
						</Equal>
					</Compare>
					<!--goto "ObjectLoopEnd"-->
					<Compare>
						<Equal>
							<Value1>strXmlValue.ObjBaseType.String</Value1>
							<Value2>null</Value2>
							<GotoStep>SubItemLoopCounterEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CHECK_IF_BASE_TYPE">
					<RegexIsMatch ReturnValue="IsMatch">
						<Pattern>^(BOOL|BIT|BIT[1-8]|BYTE|BITARR8|BITARR16|WORD|BITARR32|DOWRD|SINT|INT|INT24|DINT|INT40|INT48|INT56|LINT|USINT|UINT|UINT24|UDINT|UINT40|UINT48|UINT56|ULINT|REAL|LREAL|(DT[0-9A-F]{1,4}EN([0-9]{2}))|(ARRAY \[0\.\.[0-9]+\] OF (BYTE|SINT|UINT|INT|DINT|UDINT))|(STRING\([0-9]+\)))$</Pattern>
						<InputString>strXmlValue.ObjBaseType.String</InputString>
					</RegexIsMatch>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="9" Level="Output" Param0="IsMatch">Value of "IsMatch" = {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="10" Level="Output" Param0="ModuleObjectInfo.ObjFound">Value of "ModuleObjectInfo.ObjFound" = {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>IsMatch</Value1>
							<Value2>false</Value2>
							<GotoStep>SubItemLoopCounterEnd</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>IsMatch</Value1>
							<Value2>true</Value2>
							<SetVariable Target="ModuleObjectInfo.ObjFound">true</SetVariable>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="11" Level="Output" Param0="ModuleObjectInfo.ObjFound">Value of "ModuleObjectInfo.ObjFound" = {0}</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="GET_OBJ_INDEX">
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.ObjIndex.Uint16">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/Profile/Dictionary/Objects/Object[{2}]/Index</XPath>
					</GetXmlValue>
					<!--Dump an info if no index is defined-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="12" Level="Output" Param0="strXmlValue.ObjIndex.Uint16">Value of "strXmlValue.ObjIndex.Uint16": 0x{0:x4}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue.ObjIndex.Uint16</Value1>
							<Value2>null</Value2>
							<WriteLine Id="13" Level="Verbose" Param0="ModuleCounter">Object[{0}].Index shall be defined.</WriteLine>
						</Equal>
					</Compare>
					<!--Skip if no Index is defined-->
					<Compare>
						<Equal>
							<Value1>strXmlValue.ObjIndex.Uint16</Value1>
							<Value2>null</Value2>
							<GotoStep>SubItemLoopCounterEnd</GotoStep>
						</Equal>
					</Compare>
					<!--Create Info String-->
					<Compare>
						<NotEqual>
							<Value1>strXmlValue.ObjIndex.Uint16</Value1>
							<Value2>null</Value2>
							<SetVariable Target="ModuleObjectInfo.strHexObjIndex" Param0="strXmlValue.ObjIndex.Uint16">0x{0:x4}.Info</SetVariable>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="CREATE_INFO_PATH">
					<SetVariable Target="ModuleObjectInfo.XPathInfo" Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/Profile/Dictionary/Objects/Object[{2}]/Info</SetVariable>
				</TestStep>
				<TestStep Name="CREATE_BASETYPE_PATH">
					<SetVariable Target="ModuleObjectInfo.XPathType" Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/Profile/Dictionary/Objects/Object[{2}]/Type</SetVariable>
				</TestStep>
				<TestStep Name="GET_INFO_ELEMENT">
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ModuleObjectInfo.XPathInfo">{0}</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="14" Level="Output" Param0="strXmlValue">Value of "strXmlValue" - Info element: {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>SubItemLoopCounterEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CHECK_IF_SUBITEM_IS_DEFINED">
					<!--For objects with no entries (Variable) no SubItem shall be defined-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="ModuleObjectInfo.strXmlValue">
						<XPath Param0="ModuleObjectInfo.XPathInfo">{0}/SubItem</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="15" Level="Output" Param0="ModuleObjectInfo.strXmlValue">ModuleObjectInfo.strXmlValue ==  {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>ModuleObjectInfo.strXmlValue</Value1>
							<Value2>null</Value2>
							<WriteLine Id="16" Level="Error" Param0="ModuleObjectInfo.strHexObjIndex">{0} shall have no SubItems.</WriteLine>
						</NotEqual>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>ModuleObjectInfo.strXmlValue</Value1>
							<Value2>null</Value2>
							<SetVariable Target="result">false</SetVariable>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="CheckInfoElement">
					<!--Call "ValidateObjectInfoType" function-->
					<CallTestFunction Name="ValidateObjectInfoType">
						<Parameter>ModuleObjectInfo.XPathInfo</Parameter>
						<Parameter>loc_ModuleXmlFile</Parameter>
						<Parameter>strXmlValue.ObjBaseType.String</Parameter>
						<Parameter>ModuleObjectInfo.strHexObjIndex</Parameter>
						<OutParameter>TmpResult</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>TmpResult</Value1>
							<Value2>false</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="SubItemLoopCounterEnd">
					<!--__END of "SubItemLoopStart", increment loop counter__-->
					<SetVariable Target="i32TmpModuleIndex">i32TmpModuleIndex + 1</SetVariable>
					<!--goto loop start by default -->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>SubItemLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="ObjectLoopEnd">
					<!--__END of "ObjectLoopStart", add ModuleIdent to tested Array__-->
					<AddArrayItem TargetArray="AllModuleIdents.Uint32Array">AllModuleIdents.Uint32</AddArrayItem>
				</TestStep>
				<TestStep>
					<!--Increment loop counter-->
					<SetVariable Target="ModuleCounter">ModuleCounter + 1</SetVariable>
					<!--Goto loop start by default -->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>ObjectLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="END">
					<!--Dump Test case result-->
					<Compare>
						<Equal>
							<Value1>ModuleObjectInfo.ObjFound</Value1>
							<Value2>false</Value2>
							<SkipCase Id="17">No Variable object found.</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>true</Value2>
							<ReturnSuccess Id="18">Variable objects are valid</ReturnSuccess>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>false</Value2>
							<RaiseError Id="19">Object Info for VARIABLE Test failed.</RaiseError>
						</Equal>
					</Compare>
				</TestStep>
			</TestCase>
			<TestCase Name="Object Info (Array/Record)" CaseId="4">
				<?MAX_OUTPUT_ID 16?>
				<Description>
					<PreCondition>At least one object (Code: ARRAY/RECORD) is defined and includes an info element</PreCondition>
					<Action>1.) Get 'DefaultData'
2.) Get 'MinData'
3.) Get 'MaxData'
4.) Get 'DefaultValue'
5.) Get 'MinValue'
6.) Get 'MaxValue'
7.) Get 'DefaultString'
8.) Foreach 'SubItem'
	8.1.) Get 'DefaultData'
	8.2.) Get 'MinData'
	8.3.) Get 'MaxData'
	8.4.) Get 'DefaultValue'
	8.5.) Get 'MinValue'
	8.6.) Get 'MaxValue'
	8.7.) Get 'DefaultString'</Action>
					<PostCondition>1.) 'DefaultData' shall not exceed the used DataType
2.) 'MinData' shall not be defined
3.) 'MaxData' shall not be defined
4.) 'DefaultValue' shall not be defined
5.) 'MinValue' shall not be defined
6.) 'MaxValue' shall not be defined
7.) 'DefaultString' shall not be defined
8.) 'SubItem' shall not be defined
	8.1.) 'DefaultData' shall not exceed the used DataType
	8.2.) 'MinData' shall not exceed the used DataType
	8.3.) 'MaxData' shall not exceed the used DataType
	8.4.) 'DefaultValue' shall not exceed the used DataType and shall only used for DataType with a fixed length
	8.5.) 'MinValue' shall not exceed the used DataType and shall only used for DataType with a fixed length
	8.6.) 'MaxValue' shall not exceed the used DataType and shall only used for DataType with a fixed length
	8.7.) 'DefaultString' shall not exceed the used DataType and shall only used for STRING(n)</PostCondition>
					<References>
						<Reference Specification="ETG.2000"></Reference>
						<Reference Specification="ETG.1020"></Reference>
						<Reference Specification="ETG.5001"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="Toggle_LOC_EXT">
					<!--Flag for InitGlobalVariables for default XPaths of local or external file-->
					<SetVariable Target="LocExt_InitToggle">false</SetVariable>
					<WriteLine Id="0" Level="Output">Checking for external file with modules.</WriteLine>
				</TestStep>
				<TestStep Name="SkipNoSlots">
					<!--Skip Test if "CurrentConfig.SlotCount" == 0-->
					<Compare>
						<Equal>
							<Value1>CurrentConfig.SlotCount</Value1>
							<Value2>0</Value2>
							<SkipCase Id="1">Test skipped. No slots defined.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="SkipSoE">
					<!--Skip Test if SoE Device-->
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Mailbox.SoE</Value1>
							<Value2>true</Value2>
							<SkipCase Id="2">Test skipped for SoE Devices.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="INIT_AVAIL_GLOB_ARRAY">
					<CallTestFunction Name="AvailableDuTModuleIdents"></CallTestFunction>
				</TestStep>
				<TestStep Name="InitGlobalVariables">
					<!--Init global XPaths-->
					<CallTestFunction Name="InitGlobalVariablesForModuleODTest">
						<Parameter>LocExt_InitToggle</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="INIT_RESULT">
					<!--"result" = true-->
					<SetVariable Target="result">true</SetVariable>
				</TestStep>
				<TestStep Name="INIT_LOOP_COUNTER">
					<!--"ModuleCounter" = 1-->
					<SetVariable Target="ModuleCounter">1</SetVariable>
				</TestStep>
				<TestStep Name="CHECK_IF_EXISTS">
					<!--Checking if module exist-->
					<Compare>
						<Equal>
							<Value1>loc_XPathModuleIdent</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>END</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="INIT_OBJ_FOUND">
					<!--Init variable "Object found" for dump of test results-->
					<SetVariable Target="ModuleObjectInfo.ObjFound">false</SetVariable>
				</TestStep>
				<TestStep Name="InitTestedArray">
					<!--Array of already processed modules, no doubles-->
					<InitArray TargetArray="AllModuleIdents.Uint32Array"></InitArray>
				</TestStep>
				<TestStep Name="ObjectLoopStart">
					<!--__Loop START for LOCAL Modules__-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>END</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>END</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_AVAILABLE_MDL">
					<!--Get ModuleIdent and Flag to SKIP testing of assigned modules-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="AllModuleIdents.Uint32">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>TestAvailableMdls</Value1>
							<Value2>false</Value2>
							<GotoStep>TEST_MODULES</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckItemInArray">
					<!--Check if module in list of assigned modules-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllAvailableDuTModules.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleInArray.boolAssigned</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="3" Level="Verbose" Param0="CheckModuleInArray.boolAssigned" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleInArray.boolAssigned == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleInArray.boolAssigned</Value1>
							<Value2>false</Value2>
							<GotoStep>ObjectLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckAlreadyTested">
					<!--Check if module already tested-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllModuleIdents.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleAlreadyTested.boolAlreadyChecked</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="4" Level="Verbose" Param0="CheckModuleAlreadyTested.boolAlreadyChecked" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleAlreadyTested.boolAlreadyChecked == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleAlreadyTested.boolAlreadyChecked</Value1>
							<Value2>true</Value2>
							<GotoStep>ObjectLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_MODULES">
					<!--Print Module Ident-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="5" Level="Verbose" Param0="ModuleCounter" Param1="strXmlValue">Module[{0}]: Ident: {1}</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="Check_extOD_FileRef">
					<CallTestFunction Name="CheckForExtRefDict">
						<Parameter>loc_ModuleXmlFile</Parameter>
						<Parameter>loc_XPathModuleIdent</Parameter>
						<Parameter>ModuleCounter</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="InitSubItemLoopCounter">
					<!--Init of nested loop counter for the object of current module-->
					<SetVariable Target="i32TmpModuleIndex">1</SetVariable>
				</TestStep>
				<TestStep Name="SubItemLoopStart">
					<!--__Loop START for current module object__-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.Obj.String">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/Profile/Dictionary/Objects/Object[{2}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="6" Level="Output" Param0="strXmlValue.Obj.String" Param1="i32TmpModuleIndex">Value of "strXmlValue" = {0}; for Object[{1}]</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue.Obj.String</Value1>
							<Value2>null</Value2>
							<GotoStep>ObjectLoopEnd</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue.Obj.String</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>ObjectLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="GET_OBJ_DATATYPE">
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.ObjBaseType.String">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/Profile/Dictionary/Objects/Object[{2}]/Type</XPath>
					</GetXmlValue>
					<!--Dump an Error if no Type is defined-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="7" Level="Output" Param0="strXmlValue.ObjBaseType.String">Value of "strXmlValue.ObjBaseType.String" = {0}; for Object[n]</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue.ObjBaseType.String</Value1>
							<Value2>null</Value2>
							<WriteLine Id="8" Level="Verbose" Param0="ModuleCounter">Object[{0}].Type shall be defined.</WriteLine>
						</Equal>
					</Compare>
					<!--goto "ObjectLoopEnd"-->
					<Compare>
						<Equal>
							<Value1>strXmlValue.ObjBaseType.String</Value1>
							<Value2>null</Value2>
							<GotoStep>SubItemLoopCounterEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="SKIP_IF_BASE_TYPE">
					<RegexIsMatch ReturnValue="IsMatch">
						<Pattern>^(BOOL|BIT|BIT[1-8]|BYTE|BITARR8|BITARR16|WORD|BITARR32|DOWRD|SINT|INT|INT24|DINT|INT40|INT48|INT56|LINT|USINT|UINT|UINT24|UDINT|UINT40|UINT48|UINT56|ULINT|REAL|LREAL|(DT[0-9A-F]{1,4}EN([0-9]{2}))|(ARRAY \[0\.\.[0-9]+\] OF (BYTE|SINT|UINT|INT|DINT|UDINT))|(STRING\([0-9]+\)))$</Pattern>
						<InputString>strXmlValue.ObjBaseType.String</InputString>
					</RegexIsMatch>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="9" Level="Output" Param0="IsMatch">Value of "IsMatch" = {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>IsMatch</Value1>
							<Value2>true</Value2>
							<GotoStep>SubItemLoopCounterEnd</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>IsMatch</Value1>
							<Value2>false</Value2>
							<SetVariable Target="ModuleObjectInfo.ObjFound">true</SetVariable>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="10" Level="Output" Param0="ModuleObjectInfo.ObjFound">Value of "ModuleObjectInfo.ObjFound" = {0}</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="GET_OBJ_INDEX">
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.ObjIndex.Uint16">
						<XPath Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/Profile/Dictionary/Objects/Object[{2}]/Index</XPath>
					</GetXmlValue>
					<!--Dump an info if no index is defined-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="11" Level="Output" Param0="strXmlValue.ObjIndex.Uint16">Value of "strXmlValue.ObjIndex.Uint16": 0x{0:x4}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue.ObjIndex.Uint16</Value1>
							<Value2>null</Value2>
							<WriteLine Id="12" Level="Verbose" Param0="ModuleCounter">Object[{0}].Index shall be defined.</WriteLine>
						</Equal>
					</Compare>
					<!--Skip if no Index is defined-->
					<Compare>
						<Equal>
							<Value1>strXmlValue.ObjIndex.Uint16</Value1>
							<Value2>null</Value2>
							<GotoStep>SubItemLoopCounterEnd</GotoStep>
						</Equal>
					</Compare>
					<!--Create Info String-->
					<Compare>
						<NotEqual>
							<Value1>strXmlValue.ObjIndex.Uint16</Value1>
							<Value2>null</Value2>
							<SetVariable Target="ModuleObjectInfo.strHexObjIndex" Param0="strXmlValue.ObjIndex.Uint16">0x{0:x4}.Info</SetVariable>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="CREATE_INFO_PATH">
					<SetVariable Target="ModuleObjectInfo.XPathInfo" Param0="loc_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/Profile/Dictionary/Objects/Object[{2}]/Info</SetVariable>
				</TestStep>
				<TestStep Name="GET_INFO_ELEMENT">
					<!--Call ValidateObjectInfoType (all elements except of the SubItem elements will be checked)-->
					<GetXmlValue FileName="loc_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ModuleObjectInfo.XPathInfo">{0}</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="13" Level="Output" Param0="strXmlValue">Value of "strXmlValue" - Info element: {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>SubItemLoopCounterEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CHECK_INFO_ELEMENT">
					<!--Call ValidateObjectInfoType (all elements except of the SubItem elements will be checked)-->
					<CallTestFunction Name="ValidateObjectInfoType">
						<Parameter>ModuleObjectInfo.XPathInfo</Parameter>
						<Parameter>loc_ModuleXmlFile</Parameter>
						<Parameter>strXmlValue.ObjBaseType.String</Parameter>
						<Parameter>ModuleObjectInfo.strHexObjIndex</Parameter>
						<OutParameter>TmpResult</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>TmpResult</Value1>
							<Value2>false</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CREATE_SUBITEM_PATH">
					<SetVariable Target="ModuleObjectInfo.Subitem" Param0="ModuleObjectInfo.XPathInfo">{0}/SubItem</SetVariable>
				</TestStep>
				<TestStep Name="CHECK_SUBITEM">
					<CallTestFunction Name="ValidateSubItemElements">
						<Parameter>ModuleObjectInfo.Subitem</Parameter>
						<Parameter>loc_ModuleXmlFile</Parameter>
						<Parameter>strXmlValue.ObjBaseType.String</Parameter>
						<Parameter>ModuleObjectInfo.strHexObjIndex</Parameter>
						<OutParameter>TmpResult</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>TmpResult</Value1>
							<Value2>false</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="SubItemLoopCounterEnd">
					<!--__END of "SubItemLoopStart", increment loop counter__-->
					<SetVariable Target="i32TmpModuleIndex">i32TmpModuleIndex + 1</SetVariable>
					<!--goto loop start by default -->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>SubItemLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="ObjectLoopEnd">
					<!--__END of "ObjectLoopStart", add ModuleIdent to tested Array__-->
					<AddArrayItem TargetArray="AllModuleIdents.Uint32Array">AllModuleIdents.Uint32</AddArrayItem>
				</TestStep>
				<TestStep>
					<!--Increment loop counter-->
					<SetVariable Target="ModuleCounter">ModuleCounter + 1</SetVariable>
					<!--Goto loop start by default -->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>ObjectLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="END">
					<!--Dump Test case result-->
					<Compare>
						<Equal>
							<Value1>ModuleObjectInfo.ObjFound</Value1>
							<Value2>false</Value2>
							<SkipCase Id="14">No Variable object found.</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>true</Value2>
							<ReturnSuccess Id="15">Variable objects are valid</ReturnSuccess>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>false</Value2>
							<RaiseError Id="16">Object Info for ARRAY/RECORD Test failed.</RaiseError>
						</Equal>
					</Compare>
				</TestStep>
			</TestCase>
		</TestGroup>
		<TestGroup GroupId="200" Name="(External) Module DataType Tests">
			<Comment>Check the DataType definitions of the modules defined within an external file</Comment>
			<TestCase Name="All DataType Names" CaseId="1">
				<?MAX_OUTPUT_ID 11?>
				<Description>
					<PreCondition>The device description includes module object dictionary defined within an external module file</PreCondition>
					<Action>Check name of module DataTypes</Action>
					<PostCondition>The name shall be either:
- Base DataType listed in the ETG.1020
- DTxxxx
- DTxxxxARR
- DTxxxxENnn

xxxx is a 16Bit hex value (usually the object index)
nn is the number of Bits used for the Enum</PostCondition>
					<References>
						<Reference Specification="ETG.2000"></Reference>
						<Reference Specification="ETG.1020"></Reference>
						<Reference Specification="ETG.5001"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="Toggle_LOC_EXT">
					<!--Flag for InitGlobalVariables for default XPaths of local or external file-->
					<SetVariable Target="LocExt_InitToggle">true</SetVariable>
					<WriteLine Id="0" Level="Output">Checking for external file with modules.</WriteLine>
				</TestStep>
				<TestStep Name="SkipNoSlots">
					<!--Skip Test if "CurrentConfig.SlotCount" == 0-->
					<Compare>
						<Equal>
							<Value1>CurrentConfig.SlotCount</Value1>
							<Value2>0</Value2>
							<SkipCase Id="1">Test skipped. No slots defined.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="SkipSoE">
					<!--Skip Test if SoE Device-->
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Mailbox.SoE</Value1>
							<Value2>true</Value2>
							<SkipCase Id="2">Test skipped for SoE Devices.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="INIT_AVAIL_GLOB_ARRAY">
					<CallTestFunction Name="AvailableDuTModuleIdents"></CallTestFunction>
				</TestStep>
				<TestStep Name="InitGlobalVariables">
					<!--Init global XPaths-->
					<CallTestFunction Name="InitGlobalVariablesForModuleODTest">
						<Parameter>LocExt_InitToggle</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="INIT_RESULT">
					<!--"result" = true-->
					<SetVariable Target="result">true</SetVariable>
				</TestStep>
				<TestStep Name="FileLoopStart">
					<GetXmlValue ReturnValue="ext_ModuleXmlFile" Markup="false">
						<XPath Param0="ext_ModuleXmlFile.XPath" Param1="ext_ModuleXmlFile.FileCounter">{0}[{1}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>ext_ModuleXmlFile</Value1>
							<Value2>null</Value2>
							<GotoStep>END</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>ext_ModuleXmlFile</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>END</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="3" Level="Output" Param0="ext_ModuleXmlFile">Checking external module file: {0}</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="INIT_LOOP_COUNTER">
					<!--"ModuleCounter" = 1-->
					<SetVariable Target="ModuleCounter">1</SetVariable>
				</TestStep>
				<TestStep Name="CHECK_IF_EXISTS">
					<!--Checking if modules exist-->
					<Compare>
						<Equal>
							<Value1>ext_XPathModuleIdent</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>FileLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="InitTestedArray">
					<!--Array of already processed modules, no doubles-->
					<InitArray TargetArray="AllModuleIdents.Uint32Array"></InitArray>
				</TestStep>
				<TestStep Name="DataTypeLoopStart">
					<!--__Loop START for EXTERNAL Modules__-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>FileLoopEnd</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>FileLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_AVAILABLE_MDL">
					<!--Get ModuleIdent and Flag to SKIP testing of assigned modules-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="AllModuleIdents.Uint32">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>TestAvailableMdls</Value1>
							<Value2>false</Value2>
							<GotoStep>TEST_MODULES</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckItemInArray">
					<!--Check if module in list of assigned modules-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllAvailableDuTModules.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleInArray.boolAssigned</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="4" Level="Verbose" Param0="CheckModuleInArray.boolAssigned" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleInArray.boolAssigned == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleInArray.boolAssigned</Value1>
							<Value2>false</Value2>
							<GotoStep>DataTypeLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckAlreadyTested">
					<!--Check if module already tested-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllModuleIdents.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleAlreadyTested.boolAlreadyChecked</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="5" Level="Verbose" Param0="CheckModuleAlreadyTested.boolAlreadyChecked" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleAlreadyTested.boolAlreadyChecked == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleAlreadyTested.boolAlreadyChecked</Value1>
							<Value2>true</Value2>
							<GotoStep>DataTypeLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_MODULES">
					<!--Print Module Ident-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="6" Level="Verbose" Param0="ModuleCounter" Param1="strXmlValue">Module[{0}]: Ident: {1}</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="Check_extOD_FileRef">
					<CallTestFunction Name="CheckForExtRefDict">
						<Parameter>ext_ModuleXmlFile</Parameter>
						<Parameter>ext_XPathModuleIdent</Parameter>
						<Parameter>ModuleCounter</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="InitSubItemLoopCounter">
					<!--Init of nested loop counter for DataTypes of current module-->
					<SetVariable Target="i32TmpModuleIndex">1</SetVariable>
				</TestStep>
				<TestStep Name="SubItemLoopStart">
					<!--__Loop START for current module DataTypes__-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/Profile/Dictionary/DataTypes/DataType[{2}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>DataTypeLoopEnd</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>DataTypeLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="GET_CURRENT_DT_NAME">
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/Profile/Dictionary/DataTypes/DataType[{2}]/Name</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="7" Level="Verbose" Param0="strXmlValue">Check name {0}.</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<SetVariable Target="AtLeastOneModuleFound">true</SetVariable>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<!--Check if fixed BaseDataType is used-->
					<RegexIsMatch ReturnValue="IsMatch">
						<Pattern>^(BOOL|BIT|BIT[1-8]|BYTE|BITARR8|BITARR16|WORD|BITARR32|DWORD|SINT|INT|INT24|DINT|INT40|INT48|INT56|LINT|USINT|UINT|UINT24|UDINT|UINT40|UINT48|UINT56|ULINT|REAL|LREAL|GUID)$</Pattern>
						<InputString>strXmlValue</InputString>
					</RegexIsMatch>
					<Compare>
						<Equal>
							<Value1>IsMatch</Value1>
							<Value2>true</Value2>
							<GotoStep>SubItemLoopCounterEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<!--Check if "ARRAY [0...n] of BYTE|UINT" is used-->
					<RegexIsMatch ReturnValue="IsMatch">
						<Pattern>^(ARRAY \[0\.\.[0-9]+\] OF (BYTE|SINT|UINT|INT|DINT|UDINT))$</Pattern>
						<InputString>strXmlValue</InputString>
					</RegexIsMatch>
					<Compare>
						<Equal>
							<Value1>IsMatch</Value1>
							<Value2>true</Value2>
							<GotoStep>SubItemLoopCounterEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<!--Check if "STRING(n)" is used-->
					<RegexIsMatch ReturnValue="IsMatch">
						<Pattern>^(STRING\([0-9]+\))$</Pattern>
						<InputString>strXmlValue</InputString>
					</RegexIsMatch>
					<Compare>
						<Equal>
							<Value1>IsMatch</Value1>
							<Value2>true</Value2>
							<GotoStep>SubItemLoopCounterEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<!--Check if "DTxxxx" is used-->
					<RegexIsMatch ReturnValue="IsMatch">
						<Pattern>^(DT[0-9A-Fa-fXx]{1,4})$</Pattern>
						<InputString>strXmlValue</InputString>
					</RegexIsMatch>
					<Compare>
						<Equal>
							<Value1>IsMatch</Value1>
							<Value2>true</Value2>
							<GotoStep>SubItemLoopCounterEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<!--Check if "DTxxxARR" is used-->
					<RegexIsMatch ReturnValue="IsMatch">
						<Pattern>^(DT[0-9A-Fa-fXx]{1,4}ARR)$</Pattern>
						<InputString>strXmlValue</InputString>
					</RegexIsMatch>
					<Compare>
						<Equal>
							<Value1>IsMatch</Value1>
							<Value2>true</Value2>
							<GotoStep>SubItemLoopCounterEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<!--Check if "DTxxxENnn" is used-->
					<RegexIsMatch ReturnValue="IsMatch">
						<Pattern>^(DT[0-9A-Fa-fXx]{4}EN([0-9]{2}))$</Pattern>
						<InputString>strXmlValue</InputString>
					</RegexIsMatch>
					<Compare>
						<Equal>
							<Value1>IsMatch</Value1>
							<Value2>true</Value2>
							<GotoStep>SubItemLoopCounterEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<!--No specified DataType name is used => Dump Error-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="8" Level="Error" Param0="strXmlValue">DataType name "{0}" is not valid.</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="SubItemLoopCounterEnd">
					<!--__END of "SubItemLoopStart", increment loop counter__-->
					<SetVariable Target="i32TmpModuleIndex">i32TmpModuleIndex + 1</SetVariable>
					<!--goto loop start by default -->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>SubItemLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="DataTypeLoopEnd">
					<!--__END of "DataTypeLoopStart", add ModuleIdent to tested Array__-->
					<AddArrayItem TargetArray="AllModuleIdents.Uint32Array">AllModuleIdents.Uint32</AddArrayItem>
				</TestStep>
				<TestStep>
					<!--Increment loop counter-->
					<SetVariable Target="ModuleCounter">ModuleCounter + 1</SetVariable>
					<!--Goto Loop start if counter is less than Number of DataTypes -->
					<!--Goto loop start by default -->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>DataTypeLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="FileLoopEnd">
					<!--Increment file counter-->
					<SetVariable Target="ext_ModuleXmlFile.FileCounter">ext_ModuleXmlFile.FileCounter + 1</SetVariable>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>FileLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="END">
					<!--Dump Test case result-->
					<Compare>
						<Equal>
							<Value1>AtLeastOneModuleFound</Value1>
							<Value2>false</Value2>
							<SkipCase Id="9">No DataType found.</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>true</Value2>
							<ReturnSuccess Id="10">DataType AccessType Test successful.</ReturnSuccess>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>false</Value2>
							<RaiseError></RaiseError>
						</Equal>
					</Compare>
				</TestStep>
			</TestCase>
			<TestCase Name="Check Access Flag" CaseId="2">
				<?MAX_OUTPUT_ID 13?>
				<Description>
					<PreCondition>The device description includes module object dictionary defined within an external module file</PreCondition>
					<Action>Check if the write/read restriction "PreOp" is used</Action>
					<PostCondition>In case of an PreOP write/read restriction the syntax "PreOP" (not "PreOp") shall be used</PostCondition>
					<References>
						<Reference Specification="ETG.2000"></Reference>
						<Reference Specification="ETG.1020"></Reference>
						<Reference Specification="ETG.5001"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="Toggle_LOC_EXT">
					<!--Flag for InitGlobalVariables for default XPaths of local or external file-->
					<SetVariable Target="LocExt_InitToggle">true</SetVariable>
					<WriteLine Id="0" Level="Output">Checking for external file with modules.</WriteLine>
				</TestStep>
				<TestStep Name="SkipNoSlots">
					<!--Skip Test if "CurrentConfig.SlotCount" == 0-->
					<Compare>
						<Equal>
							<Value1>CurrentConfig.SlotCount</Value1>
							<Value2>0</Value2>
							<SkipCase Id="1">Test skipped. No slots defined.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="SkipSoE">
					<!--Skip Test if SoE Device-->
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Mailbox.SoE</Value1>
							<Value2>true</Value2>
							<SkipCase Id="2">Test skipped for SoE Devices.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="INIT_AVAIL_GLOB_ARRAY">
					<CallTestFunction Name="AvailableDuTModuleIdents"></CallTestFunction>
				</TestStep>
				<TestStep Name="InitGlobalVariables">
					<!--Init global XPaths-->
					<CallTestFunction Name="InitGlobalVariablesForModuleODTest">
						<Parameter>LocExt_InitToggle</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="INIT_RESULT">
					<!--"result" = true-->
					<SetVariable Target="result">true</SetVariable>
				</TestStep>
				<TestStep Name="FileLoopStart">
					<GetXmlValue ReturnValue="ext_ModuleXmlFile" Markup="false">
						<XPath Param0="ext_ModuleXmlFile.XPath" Param1="ext_ModuleXmlFile.FileCounter">{0}[{1}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>ext_ModuleXmlFile</Value1>
							<Value2>null</Value2>
							<GotoStep>END</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>ext_ModuleXmlFile</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>END</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="3" Level="Output" Param0="ext_ModuleXmlFile">Checking external module file: {0}</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="INIT_LOOP_COUNTER">
					<!--"ModuleCounter" = 1-->
					<SetVariable Target="ModuleCounter">1</SetVariable>
				</TestStep>
				<TestStep Name="CHECK_IF_EXISTS">
					<!--Checking if modules exist-->
					<Compare>
						<Equal>
							<Value1>ext_XPathModuleIdent</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>FileLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="InitTestedArray">
					<!--Array of already processed modules, no doubles-->
					<InitArray TargetArray="AllModuleIdents.Uint32Array"></InitArray>
				</TestStep>
				<TestStep Name="DataTypeLoopStart">
					<!--__Loop START for EXTERNAL Modules__-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>FileLoopEnd</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>FileLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_AVAILABLE_MDL">
					<!--Get ModuleIdent and Flag to SKIP testing of assigned modules-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="AllModuleIdents.Uint32">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>TestAvailableMdls</Value1>
							<Value2>false</Value2>
							<GotoStep>TEST_MODULES</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckItemInArray">
					<!--Check if module in list of assigned modules-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllAvailableDuTModules.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleInArray.boolAssigned</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="4" Level="Verbose" Param0="CheckModuleInArray.boolAssigned" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleInArray.boolAssigned == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleInArray.boolAssigned</Value1>
							<Value2>false</Value2>
							<GotoStep>DataTypeLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckAlreadyTested">
					<!--Check if module already tested-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllModuleIdents.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleAlreadyTested.boolAlreadyChecked</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="5" Level="Verbose" Param0="CheckModuleAlreadyTested.boolAlreadyChecked" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleAlreadyTested.boolAlreadyChecked == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleAlreadyTested.boolAlreadyChecked</Value1>
							<Value2>true</Value2>
							<GotoStep>DataTypeLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_MODULES">
					<!--Print Module Ident-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="6" Level="Verbose" Param0="ModuleCounter" Param1="strXmlValue">Module[{0}]: Ident: {1}</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="Check_extOD_FileRef">
					<CallTestFunction Name="CheckForExtRefDict">
						<Parameter>ext_ModuleXmlFile</Parameter>
						<Parameter>ext_XPathModuleIdent</Parameter>
						<Parameter>ModuleCounter</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="InitSubItemLoopCounter">
					<!--Init of 1. nested loop counter for DataTypes of current module-->
					<SetVariable Target="i32TmpModuleIndex">1</SetVariable>
				</TestStep>
				<TestStep Name="SubItemLoopStart">
					<!--__Loop START for current module DataTypes__-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/Profile/Dictionary/DataTypes/DataType[{2}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>DataTypeLoopEnd</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>DataTypeLoopEnd</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<SetVariable Target="AtLeastOneModuleFound">true</SetVariable>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="InitAccessRightLoopCounter">
					<!--Init of 2. nested loop counter for DataType Subitems of current module-->
					<SetVariable Target="i32TmpModuleIndexDeep">1</SetVariable>
				</TestStep>
				<TestStep Name="AccessRightLoopStart">
					<!--__Loop START for current module DataType Subitems__-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex" Param3="i32TmpModuleIndexDeep">{0}[{1}]/Profile/Dictionary/DataTypes/DataType[{2}]/SubItem[{3}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>SubItemLoopCounterEnd</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>SubItemLoopCounterEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="GET_CURRENT_WriteRestriction">
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex" Param3="i32TmpModuleIndexDeep">{0}[{1}]/Profile/Dictionary/DataTypes/DataType[{2}]/SubItem[{3}]/Flags/Access/@WriteRestrictions</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="7" Level="Verbose" Param0="ModuleCounter" Param1="i32TmpModuleIndex" Param2="i32TmpModuleIndexDeep" Param3="strXmlValue">EtherCATModule/Modules/Module[{0}]/Profile/Dictionary/DataTypes/DataType[{1}]/SubItem[{2}]/Flags/Access/@WriteRestrictions: '{3}'.</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>PreOp</Value2>
							<WriteLine Id="8" Level="Error" Param0="ext_XPathModuleIdent" Param1="(ModuleCounter-1)" Param2="(i32TmpModuleIndex-1)" Param3="(i32TmpModuleIndexDeep-1)">{0}[{1}]/Profile/Dictionary/DataTypes/DataType[{2}]/SubItem[{3}] WriteRestriction 'PreOp' is not valid use 'PreOP' instead.</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>PreOp</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="GET_CURRENT_ReadRestriction">
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex" Param3="i32TmpModuleIndexDeep">{0}[{1}]/Profile/Dictionary/DataTypes/DataType[{2}]/SubItem[{3}]/Flags/Access/@ReadRestrictions</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="9" Level="Verbose" Param0="ModuleCounter" Param1="i32TmpModuleIndex" Param2="i32TmpModuleIndexDeep" Param3="strXmlValue">EtherCATModule/Modules/Module[{0}]/Profile/Dictionary/DataTypes/DataType[{1}]/SubItem[{2}]/Flags/Access/@ReadRestrictions '{3}'.</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>PreOp</Value2>
							<WriteLine Id="10" Level="Error" Param0="ext_XPathModuleIdent" Param1="(ModuleCounter-1)" Param2="(i32TmpModuleIndex-1)" Param3="(i32TmpModuleIndexDeep-1)">{0}[{1}]/Profile/Dictionary/DataTypes/DataType[{2}]/SubItem[{3}] ReadRestriction 'PreOp' is not valid use 'PreOP' instead.</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>PreOp</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="AccessRightLoopCounterEnd">
					<!--__END of "AccessRightLoopStart", increment loop counter__-->
					<SetVariable Target="i32TmpModuleIndexDeep">i32TmpModuleIndexDeep + 1</SetVariable>
					<!--goto deep loop start-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>AccessRightLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="SubItemLoopCounterEnd">
					<!--__END of "SubItemLoopStart", increment loop counter__-->
					<SetVariable Target="i32TmpModuleIndex">i32TmpModuleIndex + 1</SetVariable>
					<!--goto loop start by default -->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>SubItemLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="DataTypeLoopEnd">
					<!--__END of "DataTypeLoopStart", add ModuleIdent to tested Array__-->
					<AddArrayItem TargetArray="AllModuleIdents.Uint32Array">AllModuleIdents.Uint32</AddArrayItem>
				</TestStep>
				<TestStep>
					<!--Increment loop counter-->
					<SetVariable Target="ModuleCounter">ModuleCounter + 1</SetVariable>
					<!--Goto Loop start if counter is less than Number of DataTypes -->
					<!--Goto loop start by default -->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>DataTypeLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="FileLoopEnd">
					<!--Increment file counter-->
					<SetVariable Target="ext_ModuleXmlFile.FileCounter">ext_ModuleXmlFile.FileCounter + 1</SetVariable>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>FileLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="END">
					<!--Dump Test case result-->
					<Compare>
						<Equal>
							<Value1>AtLeastOneModuleFound</Value1>
							<Value2>false</Value2>
							<SkipCase Id="11">No DataType found.</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>true</Value2>
							<ReturnSuccess Id="12">DataType AccessType Test successful.</ReturnSuccess>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>false</Value2>
							<RaiseError></RaiseError>
						</Equal>
					</Compare>
				</TestStep>
			</TestCase>
			<TestCase Name="BaseDataTypes (fixed length)" CaseId="3">
				<?MAX_OUTPUT_ID 12?>
				<Description>
					<PreCondition>The device description includes module object dictionary defined within an external module file</PreCondition>
					<Action>1.)Get BaseType, ArrayInfo, SubItem, EnumInfo
2.)Get BitSize</Action>
					<PostCondition>1.) Non of elements BaseType, ArrayInfo, SubItem, EnumInfo shall be defined

2.) BitSize shall match the specified DataType</PostCondition>
					<References>
						<Reference Specification="ETG.2000"></Reference>
						<Reference Specification="ETG.1020"></Reference>
						<Reference Specification="ETG.5001"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="Toggle_LOC_EXT">
					<!--Flag for InitGlobalVariables for default XPaths of local or external file-->
					<SetVariable Target="LocExt_InitToggle">true</SetVariable>
					<WriteLine Id="0" Level="Output">Checking for external file with modules.</WriteLine>
				</TestStep>
				<TestStep Name="SkipNoSlots">
					<!--Skip Test if "CurrentConfig.SlotCount" == 0-->
					<Compare>
						<Equal>
							<Value1>CurrentConfig.SlotCount</Value1>
							<Value2>0</Value2>
							<SkipCase Id="1">Test skipped. No slots defined.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="SkipSoE">
					<!--Skip Test if SoE Device-->
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Mailbox.SoE</Value1>
							<Value2>true</Value2>
							<SkipCase Id="2">Test skipped for SoE Devices.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="INIT_AVAIL_GLOB_ARRAY">
					<CallTestFunction Name="AvailableDuTModuleIdents"></CallTestFunction>
				</TestStep>
				<TestStep Name="InitGlobalVariables">
					<!--Init global XPaths-->
					<CallTestFunction Name="InitGlobalVariablesForModuleODTest">
						<Parameter>LocExt_InitToggle</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="INIT_RESULT">
					<!--"result" = true-->
					<SetVariable Target="result">true</SetVariable>
				</TestStep>
				<TestStep Name="FileLoopStart">
					<GetXmlValue ReturnValue="ext_ModuleXmlFile" Markup="false">
						<XPath Param0="ext_ModuleXmlFile.XPath" Param1="ext_ModuleXmlFile.FileCounter">{0}[{1}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>ext_ModuleXmlFile</Value1>
							<Value2>null</Value2>
							<GotoStep>END</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>ext_ModuleXmlFile</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>END</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="3" Level="Output" Param0="ext_ModuleXmlFile">Checking external module file: {0}</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="INIT_LOOP_COUNTER">
					<!--"ModuleCounter" = 1-->
					<SetVariable Target="ModuleCounter">1</SetVariable>
				</TestStep>
				<TestStep Name="CHECK_IF_EXISTS">
					<!--Checking if modules exist-->
					<Compare>
						<Equal>
							<Value1>ext_XPathModuleIdent</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>FileLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="InitTestedArray">
					<!--Array of already processed modules, no doubles-->
					<InitArray TargetArray="AllModuleIdents.Uint32Array"></InitArray>
				</TestStep>
				<TestStep Name="DataTypeLoopStart">
					<!--__Loop START for EXTERNAL Modules__-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>FileLoopEnd</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>FileLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_AVAILABLE_MDL">
					<!--Get ModuleIdent and Flag to SKIP testing of assigned modules-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="AllModuleIdents.Uint32">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>TestAvailableMdls</Value1>
							<Value2>false</Value2>
							<GotoStep>TEST_MODULES</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckItemInArray">
					<!--Check if module in list of assigned modules-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllAvailableDuTModules.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleInArray.boolAssigned</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="4" Level="Verbose" Param0="CheckModuleInArray.boolAssigned" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleInArray.boolAssigned == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleInArray.boolAssigned</Value1>
							<Value2>false</Value2>
							<GotoStep>DataTypeLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckAlreadyTested">
					<!--Check if module already tested-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllModuleIdents.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleAlreadyTested.boolAlreadyChecked</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="5" Level="Verbose" Param0="CheckModuleAlreadyTested.boolAlreadyChecked" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleAlreadyTested.boolAlreadyChecked == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleAlreadyTested.boolAlreadyChecked</Value1>
							<Value2>true</Value2>
							<GotoStep>DataTypeLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_MODULES">
					<!--Print Module Ident-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="6" Level="Verbose" Param0="ModuleCounter" Param1="strXmlValue">Module[{0}]: Ident: {1}</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="Check_extOD_FileRef">
					<CallTestFunction Name="CheckForExtRefDict">
						<Parameter>ext_ModuleXmlFile</Parameter>
						<Parameter>ext_XPathModuleIdent</Parameter>
						<Parameter>ModuleCounter</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="InitSubItemLoopCounter">
					<!--Init of nested loop counter for DataTypes of current module-->
					<SetVariable Target="i32TmpModuleIndex">1</SetVariable>
				</TestStep>
				<TestStep Name="SubItemLoopStart">
					<!--__Loop START for current module DataTypes__-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/Profile/Dictionary/DataTypes/DataType[{2}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>DataTypeLoopEnd</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>DataTypeLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="GET_CURRENT_DT_NAME">
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/Profile/Dictionary/DataTypes/DataType[{2}]/Name</XPath>
					</GetXmlValue>
				</TestStep>
				<TestStep Name="CREATE_XPATH_FOR_DT_ELEMENT">
					<SetVariable Target="ext_XPathDtTmp" Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/Profile/Dictionary/DataTypes/DataType[{2}]</SetVariable>
				</TestStep>
				<TestStep>
					<!--Check if fixed BaseDataType is used-->
					<RegexIsMatch ReturnValue="IsMatch">
						<Pattern>^(BOOL|BIT|BIT[1-8]|BYTE|BITARR8|BITARR16|WORD|BITARR32|DWORD|SINT|INT|INT24|DINT|INT40|INT48|INT56|LINT|USINT|UINT|UINT24|UDINT|UINT40|UINT48|UINT56|ULINT|REAL|LREAL|GUID)$</Pattern>
						<InputString>strXmlValue</InputString>
					</RegexIsMatch>
					<Compare>
						<Equal>
							<Value1>IsMatch</Value1>
							<Value2>false</Value2>
							<GotoStep>SubItemLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="FIXED_BASETYPE">
					<!--Handle fixed base data type-->
					<Description Id="7" Level="Output" Param0="strXmlValue">Check definition of "{0}".</Description>
					<CallTestFunction Name="CheckFixedBaseDataType">
						<Parameter>ext_ModuleXmlFile</Parameter>
						<Parameter>ext_XPathDtTmp</Parameter>
						<OutParameter>TmpResult</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>TmpResult</Value1>
							<Value2>false</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<SetVariable Target="AtLeastOneModuleFound">true</SetVariable>
						</Equal>
					</Compare>
					<!--Test fixed base type definition finished-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>SubItemLoopEnd</GotoStep>
						</Equal>
					</Compare>
					<!--Dump info if test was successful-->
					<Compare>
						<Equal>
							<Value1>TmpResult</Value1>
							<Value2>true</Value2>
							<WriteLine Id="8" Level="Output">DataType definition valid.</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="SubItemLoopEnd">
					<!--__END of "SubItemLoopStart", increment loop counter__-->
					<SetVariable Target="i32TmpModuleIndex">i32TmpModuleIndex + 1</SetVariable>
					<!--goto loop header by default-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>SubItemLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="DataTypeLoopEnd">
					<!--__END of "DataTypeLoopStart", add ModuleIdent to tested Array__-->
					<AddArrayItem TargetArray="AllModuleIdents.Uint32Array">AllModuleIdents.Uint32</AddArrayItem>
				</TestStep>
				<TestStep>
					<!--Increment loop counter-->
					<SetVariable Target="ModuleCounter">ModuleCounter + 1</SetVariable>
					<!--goto loop header by default-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>DataTypeLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="FileLoopEnd">
					<!--Increment file counter-->
					<SetVariable Target="ext_ModuleXmlFile.FileCounter">ext_ModuleXmlFile.FileCounter + 1</SetVariable>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>FileLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="END">
					<!--Dump Test case result-->
					<Compare>
						<Equal>
							<Value1>AtLeastOneModuleFound</Value1>
							<Value2>false</Value2>
							<SkipCase Id="9">No "fixed" BaseDataType found.</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>true</Value2>
							<ReturnSuccess Id="10">DataType Test successful.</ReturnSuccess>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>false</Value2>
							<RaiseError Id="12"></RaiseError>
						</Equal>
					</Compare>
				</TestStep>
			</TestCase>
			<TestCase Name="BaseDataTypes (ARRAY [0..n] OF xxx)" CaseId="4">
				<?MAX_OUTPUT_ID 12?>
				<Description>
					<PreCondition>The device description includes module object dictionary defined within an external module file</PreCondition>
					<Action>1.) Get SubItem, EnumInfo
2.) Get BaseType
3.) Get ArrayInfo
4.) Get BitSize</Action>
					<PostCondition>1.) Non of elements SubItem, EnumInfo shall be defined

2.) The BaseType shall match the DataType name
	ARRAY [0..n] OF BYTE : BYTE or USINT
	ARRAY [0..n] OF UINT : UINT
	ARRAY [0..n] OF INT : INT
	ARRAY [0..n] OF SINT : SINT
	ARRAY [0..n] OF DINT : DINT
	ARRAY [0..n] OF UDINT : UDINT


3.) ArrayInfo shall be defined. 
	ArrayInfo.LBound shall be 0
	ArrayInfo.Elements shall match n+1

4.) The BitSize shall match ArrayInfo.Elements * size of BaseType </PostCondition>
					<References>
						<Reference Specification="ETG.2000"></Reference>
						<Reference Specification="ETG.1020"></Reference>
						<Reference Specification="ETG.5001"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="Toggle_LOC_EXT">
					<!--Flag for InitGlobalVariables for default XPaths of local or external file-->
					<SetVariable Target="LocExt_InitToggle">true</SetVariable>
					<WriteLine Id="0" Level="Output">Checking for external file with modules.</WriteLine>
				</TestStep>
				<TestStep Name="SkipNoSlots">
					<!--Skip Test if "CurrentConfig.SlotCount" == 0-->
					<Compare>
						<Equal>
							<Value1>CurrentConfig.SlotCount</Value1>
							<Value2>0</Value2>
							<SkipCase Id="1">Test skipped. No slots defined.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="SkipSoE">
					<!--Skip Test if SoE Device-->
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Mailbox.SoE</Value1>
							<Value2>true</Value2>
							<SkipCase Id="2">Test skipped for SoE Devices.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="INIT_AVAIL_GLOB_ARRAY">
					<CallTestFunction Name="AvailableDuTModuleIdents"></CallTestFunction>
				</TestStep>
				<TestStep Name="InitGlobalVariables">
					<!--Init global XPaths-->
					<CallTestFunction Name="InitGlobalVariablesForModuleODTest">
						<Parameter>LocExt_InitToggle</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="INIT_RESULT">
					<!--"result" = true-->
					<SetVariable Target="result">true</SetVariable>
				</TestStep>
				<TestStep Name="FileLoopStart">
					<GetXmlValue ReturnValue="ext_ModuleXmlFile" Markup="false">
						<XPath Param0="ext_ModuleXmlFile.XPath" Param1="ext_ModuleXmlFile.FileCounter">{0}[{1}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>ext_ModuleXmlFile</Value1>
							<Value2>null</Value2>
							<GotoStep>END</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>ext_ModuleXmlFile</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>END</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="3" Level="Output" Param0="ext_ModuleXmlFile">Checking external module file: {0}</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="INIT_LOOP_COUNTER">
					<!--"ModuleCounter" = 1-->
					<SetVariable Target="ModuleCounter">1</SetVariable>
				</TestStep>
				<TestStep Name="CHECK_IF_EXISTS">
					<!--Checking if modules exist-->
					<Compare>
						<Equal>
							<Value1>ext_XPathModuleIdent</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>FileLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="InitTestedArray">
					<!--Array of already processed modules, no doubles-->
					<InitArray TargetArray="AllModuleIdents.Uint32Array"></InitArray>
				</TestStep>
				<TestStep Name="DataTypeLoopStart">
					<!--__Loop START for EXTERNAL Modules__-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>FileLoopEnd</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>FileLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_AVAILABLE_MDL">
					<!--Get ModuleIdent and Flag to SKIP testing of assigned modules-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="AllModuleIdents.Uint32">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>TestAvailableMdls</Value1>
							<Value2>false</Value2>
							<GotoStep>TEST_MODULES</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckItemInArray">
					<!--Check if module in list of assigned modules-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllAvailableDuTModules.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleInArray.boolAssigned</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="4" Level="Verbose" Param0="CheckModuleInArray.boolAssigned" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleInArray.boolAssigned == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleInArray.boolAssigned</Value1>
							<Value2>false</Value2>
							<GotoStep>DataTypeLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckAlreadyTested">
					<!--Check if module already tested-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllModuleIdents.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleAlreadyTested.boolAlreadyChecked</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="5" Level="Verbose" Param0="CheckModuleAlreadyTested.boolAlreadyChecked" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleAlreadyTested.boolAlreadyChecked == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleAlreadyTested.boolAlreadyChecked</Value1>
							<Value2>true</Value2>
							<GotoStep>DataTypeLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_MODULES">
					<!--Print Module Ident-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="6" Level="Verbose" Param0="ModuleCounter" Param1="strXmlValue">Module[{0}]: Ident: {1}</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="Check_extOD_FileRef">
					<CallTestFunction Name="CheckForExtRefDict">
						<Parameter>ext_ModuleXmlFile</Parameter>
						<Parameter>ext_XPathModuleIdent</Parameter>
						<Parameter>ModuleCounter</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="InitSubItemLoopCounter">
					<!--Init of nested loop counter for DataTypes of current module-->
					<SetVariable Target="i32TmpModuleIndex">1</SetVariable>
				</TestStep>
				<TestStep Name="SubItemLoopStart">
					<!--__Loop START for current module DataTypes__-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/Profile/Dictionary/DataTypes/DataType[{2}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>DataTypeLoopEnd</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>DataTypeLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="GET_CURRENT_DT_NAME">
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/Profile/Dictionary/DataTypes/DataType[{2}]/Name</XPath>
					</GetXmlValue>
				</TestStep>
				<TestStep Name="CREATE_XPATH_FOR_DT_ELEMENT">
					<SetVariable Target="ext_XPathDtTmp" Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/Profile/Dictionary/DataTypes/DataType[{2}]</SetVariable>
				</TestStep>
				<TestStep>
					<!--Check if "ARRAY [0...n] of BYTE|UINT" is used-->
					<RegexIsMatch ReturnValue="IsMatch">
						<Pattern>^(ARRAY \[0\.\.[0-9]+\] OF (BYTE|SINT|UINT|INT|DINT|UDINT))$</Pattern>
						<InputString>strXmlValue</InputString>
					</RegexIsMatch>
					<Compare>
						<Equal>
							<Value1>IsMatch</Value1>
							<Value2>false</Value2>
							<GotoStep>SubItemLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="ARRAY_BASETYPE">
					<!--Handle array base data type-->
					<Description Id="7" Level="Output" Param0="strXmlValue">Check definition of "{0}".</Description>
					<CallTestFunction Name="CheckArrayBaseDataType">
						<Parameter>ext_ModuleXmlFile</Parameter>
						<Parameter>ext_XPathDtTmp</Parameter>
						<OutParameter>TmpResult</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>TmpResult</Value1>
							<Value2>false</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Equal>
					</Compare>
					<!--Indicate that at least one DT found-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<SetVariable Target="AtLeastOneModuleFound">true</SetVariable>
						</Equal>
					</Compare>
					<!--Dump info if test was successful-->
					<Compare>
						<Equal>
							<Value1>TmpResult</Value1>
							<Value2>true</Value2>
							<WriteLine Id="8" Level="Output">DataType definition valid.</WriteLine>
						</Equal>
					</Compare>
					<!--Test array base type definition finished-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>SubItemLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="SubItemLoopEnd">
					<!--__END of "SubItemLoopStart", increment loop counter__-->
					<SetVariable Target="i32TmpModuleIndex">i32TmpModuleIndex + 1</SetVariable>
					<!--goto loop header by default-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>SubItemLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="DataTypeLoopEnd">
					<!--__END of "DataTypeLoopStart", add ModuleIdent to tested Array__-->
					<AddArrayItem TargetArray="AllModuleIdents.Uint32Array">AllModuleIdents.Uint32</AddArrayItem>
				</TestStep>
				<TestStep>
					<!--Increment loop counter-->
					<SetVariable Target="ModuleCounter">ModuleCounter + 1</SetVariable>
					<!--goto loop header by default-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>DataTypeLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="FileLoopEnd">
					<!--Increment file counter-->
					<SetVariable Target="ext_ModuleXmlFile.FileCounter">ext_ModuleXmlFile.FileCounter + 1</SetVariable>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>FileLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="END">
					<!--Dump Test case result-->
					<Compare>
						<Equal>
							<Value1>AtLeastOneModuleFound</Value1>
							<Value2>false</Value2>
							<SkipCase Id="9">No "ARRAY" BaseDataType found.</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>true</Value2>
							<ReturnSuccess Id="10">DataType Test successful.</ReturnSuccess>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>false</Value2>
							<RaiseError Id="12"></RaiseError>
						</Equal>
					</Compare>
				</TestStep>
			</TestCase>
			<TestCase Name="BaseDataTypes (STRING(n))" CaseId="5">
				<?MAX_OUTPUT_ID 13?>
				<Description>
					<PreCondition>The device description includes module object dictionary defined within an external module file</PreCondition>
					<Action>1.)Get BaseType, ArrayInfo, SubItem, EnumInfo
2.)Get BitSize</Action>
					<PostCondition>1.)Non of the Elements BaseType, ArrayInfo, SubItem, EnumInfo shall be defined
2.)The BitSize shall be n*8</PostCondition>
					<References>
						<Reference Specification="ETG.2000"></Reference>
						<Reference Specification="ETG.1020"></Reference>
						<Reference Specification="ETG.5001"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="Toggle_LOC_EXT">
					<!--Flag for InitGlobalVariables for default XPaths of local or external file-->
					<SetVariable Target="LocExt_InitToggle">true</SetVariable>
					<WriteLine Id="0" Level="Output">Checking for external file with modules.</WriteLine>
				</TestStep>
				<TestStep Name="SkipNoSlots">
					<!--Skip Test if "CurrentConfig.SlotCount" == 0-->
					<Compare>
						<Equal>
							<Value1>CurrentConfig.SlotCount</Value1>
							<Value2>0</Value2>
							<SkipCase Id="1">Test skipped. No slots defined.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="SkipSoE">
					<!--Skip Test if SoE Device-->
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Mailbox.SoE</Value1>
							<Value2>true</Value2>
							<SkipCase Id="2">Test skipped for SoE Devices.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="INIT_AVAIL_GLOB_ARRAY">
					<CallTestFunction Name="AvailableDuTModuleIdents"></CallTestFunction>
				</TestStep>
				<TestStep Name="InitGlobalVariables">
					<!--Init global XPaths-->
					<CallTestFunction Name="InitGlobalVariablesForModuleODTest">
						<Parameter>LocExt_InitToggle</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="INIT_RESULT">
					<!--"result" = true-->
					<SetVariable Target="result">true</SetVariable>
				</TestStep>
				<TestStep Name="FileLoopStart">
					<GetXmlValue ReturnValue="ext_ModuleXmlFile" Markup="false">
						<XPath Param0="ext_ModuleXmlFile.XPath" Param1="ext_ModuleXmlFile.FileCounter">{0}[{1}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>ext_ModuleXmlFile</Value1>
							<Value2>null</Value2>
							<GotoStep>END</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>ext_ModuleXmlFile</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>END</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="3" Level="Output" Param0="ext_ModuleXmlFile">Checking external module file: {0}</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="INIT_LOOP_COUNTER">
					<!--"ModuleCounter" = 1-->
					<SetVariable Target="ModuleCounter">1</SetVariable>
				</TestStep>
				<TestStep Name="CHECK_IF_EXISTS">
					<!--Checking if modules exist-->
					<Compare>
						<Equal>
							<Value1>ext_XPathModuleIdent</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>FileLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="InitTestedArray">
					<!--Array of already processed modules, no doubles-->
					<InitArray TargetArray="AllModuleIdents.Uint32Array"></InitArray>
				</TestStep>
				<TestStep Name="DataTypeLoopStart">
					<!--__Loop START for EXTERNAL Modules__-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>FileLoopEnd</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>FileLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_AVAILABLE_MDL">
					<!--Get ModuleIdent and Flag to SKIP testing of assigned modules-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="AllModuleIdents.Uint32">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>TestAvailableMdls</Value1>
							<Value2>false</Value2>
							<GotoStep>TEST_MODULES</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckItemInArray">
					<!--Check if module in list of assigned modules-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllAvailableDuTModules.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleInArray.boolAssigned</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="4" Level="Verbose" Param0="CheckModuleInArray.boolAssigned" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleInArray.boolAssigned == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleInArray.boolAssigned</Value1>
							<Value2>false</Value2>
							<GotoStep>DataTypeLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckAlreadyTested">
					<!--Check if module already tested-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllModuleIdents.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleAlreadyTested.boolAlreadyChecked</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="5" Level="Verbose" Param0="CheckModuleAlreadyTested.boolAlreadyChecked" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleAlreadyTested.boolAlreadyChecked == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleAlreadyTested.boolAlreadyChecked</Value1>
							<Value2>true</Value2>
							<GotoStep>DataTypeLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_MODULES">
					<!--Print Module Ident-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="6" Level="Verbose" Param0="ModuleCounter" Param1="strXmlValue">Module[{0}]: Ident: {1}</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="Check_extOD_FileRef">
					<CallTestFunction Name="CheckForExtRefDict">
						<Parameter>ext_ModuleXmlFile</Parameter>
						<Parameter>ext_XPathModuleIdent</Parameter>
						<Parameter>ModuleCounter</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="InitSubItemLoopCounter">
					<!--Init of nested loop counter for DataTypes of current module-->
					<SetVariable Target="i32TmpModuleIndex">1</SetVariable>
				</TestStep>
				<TestStep Name="SubItemLoopStart">
					<!--__Loop START for current module DataTypes__-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/Profile/Dictionary/DataTypes/DataType[{2}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>DataTypeLoopEnd</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>DataTypeLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="GET_CURRENT_DT_NAME">
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/Profile/Dictionary/DataTypes/DataType[{2}]/Name</XPath>
					</GetXmlValue>
				</TestStep>
				<TestStep Name="CREATE_XPATH_FOR_DT_ELEMENT">
					<SetVariable Target="ext_XPathDtTmp" Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/Profile/Dictionary/DataTypes/DataType[{2}]</SetVariable>
				</TestStep>
				<TestStep>
					<!--Check if "STRING(n)" is used-->
					<RegexIsMatch ReturnValue="IsMatch">
						<Pattern>^(STRING\([0-9]+\))$</Pattern>
						<InputString>strXmlValue</InputString>
					</RegexIsMatch>
					<Compare>
						<Equal>
							<Value1>IsMatch</Value1>
							<Value2>false</Value2>
							<GotoStep>SubItemLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="STRING_BASETYPE">
					<!--Handle string base data type-->
					<Description Id="7" Level="Output" Param0="strXmlValue">Check definition of "{0}".</Description>
					<CallTestFunction Name="CheckStringBaseDataType">
						<Parameter>ext_ModuleXmlFile</Parameter>
						<Parameter>ext_XPathDtTmp</Parameter>
						<OutParameter>TmpResult</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="8" Param0="TmpResult" Level="Verbose">String(n) DataType test result : {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>TmpResult</Value1>
							<Value2>false</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Equal>
					</Compare>
					<!--Dump info if test was successful-->
					<Compare>
						<Equal>
							<Value1>TmpResult</Value1>
							<Value2>true</Value2>
							<WriteLine Id="9" Level="Output">DataType definition valid.</WriteLine>
						</Equal>
					</Compare>
					<!--Indicate that at least one DT was found-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<SetVariable Target="AtLeastOneModuleFound">true</SetVariable>
						</Equal>
					</Compare>
					<!--Test string base type definition finished-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>SubItemLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="SubItemLoopEnd">
					<!--__END of "SubItemLoopStart", increment loop counter__-->
					<SetVariable Target="i32TmpModuleIndex">i32TmpModuleIndex + 1</SetVariable>
					<!--goto loop header by default-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>SubItemLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="DataTypeLoopEnd">
					<!--__END of "DataTypeLoopStart", add ModuleIdent to tested Array__-->
					<AddArrayItem TargetArray="AllModuleIdents.Uint32Array">AllModuleIdents.Uint32</AddArrayItem>
				</TestStep>
				<TestStep>
					<!--Increment loop counter-->
					<SetVariable Target="ModuleCounter">ModuleCounter + 1</SetVariable>
					<!--goto loop header by default-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>DataTypeLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="FileLoopEnd">
					<!--Increment file counter-->
					<SetVariable Target="ext_ModuleXmlFile.FileCounter">ext_ModuleXmlFile.FileCounter + 1</SetVariable>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>FileLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="END">
					<!--Dump Test case result-->
					<Compare>
						<Equal>
							<Value1>AtLeastOneModuleFound</Value1>
							<Value2>false</Value2>
							<SkipCase Id="10">No "STRING" BaseDataType found.</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>true</Value2>
							<ReturnSuccess Id="11">DataType Test successful.</ReturnSuccess>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>false</Value2>
							<RaiseError Id="13"></RaiseError>
						</Equal>
					</Compare>
				</TestStep>
			</TestCase>
			<TestCase Name="Array/Record DataTypes" CaseId="6">
				<?MAX_OUTPUT_ID 14?>
				<Description>
					<PreCondition>The device description includes module object dictionary defined within an external module file</PreCondition>
					<Action>1.) DTxxxxARR
1a.) Get SubItem, EnumInfo
1b.) Get BaseType
1c.) Get ArrayInfo
1d.) Get BitSize

2.) DTxxxx
2a.) Get ArrayInfo, EnumInfo, BaseType
2b.) Get SubItem
2c.) Get BitSize</Action>
					<PostCondition>1a.) Non of elements SubItem, EnumInfo shall be defined
1b.) The BaseType shall be a Base DataType with a fixed length
1c.) ArrayInfo shall be defined. 
	ArrayInfo.LBound shall be 1
	ArrayInfo.Elements shall match n+1 and shall be less 256
1d.) The BitSize shall match ArrayInfo.Elements * size of BaseType 

2a.) Non of the Elements ArrayInfo, EnumInfo, BaseType shall be defined
2b.) At least two SubItems shall be defined
	- First SubItem:
	    SubIdx shall be 0
		Name shall be "SubIndex 000" or "Number of Entries"
		Type shall be "USINT"
		BitSize shall be 8
		BitOffs shall be 0
	- Second SubItem:
		BitOffs shall be 16
		Name shall not be empty
		BitSize shall match size of Type
		SubItem not defined (Array object)
			Type shall be DTxxxxARR
	-Following SubItems (only for record objects)
		BitOffs shall be at least greater than the following BitSize + BitOffs.
		Type shall be Base DataType
		Name shall not be empty
		BitSize shall match size of Type
			
2c.) The BitSize shall match the total size of the SubItems</PostCondition>
					<References>
						<Reference Specification="ETG.2000"></Reference>
						<Reference Specification="ETG.1020"></Reference>
						<Reference Specification="ETG.5001"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="Toggle_LOC_EXT">
					<!--Flag for InitGlobalVariables for default XPaths of local or external file-->
					<SetVariable Target="LocExt_InitToggle">true</SetVariable>
					<WriteLine Id="0" Level="Output">Checking for external file with modules.</WriteLine>
				</TestStep>
				<TestStep Name="SkipNoSlots">
					<!--Skip Test if "CurrentConfig.SlotCount" == 0-->
					<Compare>
						<Equal>
							<Value1>CurrentConfig.SlotCount</Value1>
							<Value2>0</Value2>
							<SkipCase Id="1">Test skipped. No slots defined.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="SkipSoE">
					<!--Skip Test if SoE Device-->
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Mailbox.SoE</Value1>
							<Value2>true</Value2>
							<SkipCase Id="2">Test skipped for SoE Devices.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="INIT_AVAIL_GLOB_ARRAY">
					<CallTestFunction Name="AvailableDuTModuleIdents"></CallTestFunction>
				</TestStep>
				<TestStep Name="InitGlobalVariables">
					<!--Init global XPaths-->
					<CallTestFunction Name="InitGlobalVariablesForModuleODTest">
						<Parameter>LocExt_InitToggle</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="INIT_RESULT">
					<!--"result" = true-->
					<SetVariable Target="result">true</SetVariable>
				</TestStep>
				<TestStep Name="FileLoopStart">
					<GetXmlValue ReturnValue="ext_ModuleXmlFile" Markup="false">
						<XPath Param0="ext_ModuleXmlFile.XPath" Param1="ext_ModuleXmlFile.FileCounter">{0}[{1}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>ext_ModuleXmlFile</Value1>
							<Value2>null</Value2>
							<GotoStep>END</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>ext_ModuleXmlFile</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>END</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="3" Level="Output" Param0="ext_ModuleXmlFile">Checking external module file: {0}</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="INIT_LOOP_COUNTER">
					<!--"ModuleCounter" = 1-->
					<SetVariable Target="ModuleCounter">1</SetVariable>
				</TestStep>
				<TestStep Name="CHECK_IF_EXISTS">
					<!--Checking if modules exist-->
					<Compare>
						<Equal>
							<Value1>ext_XPathModuleIdent</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>FileLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="InitTestedArray">
					<!--Array of already processed modules, no doubles-->
					<InitArray TargetArray="AllModuleIdents.Uint32Array"></InitArray>
				</TestStep>
				<TestStep Name="DataTypeLoopStart">
					<!--__Loop START for EXTERNAL Modules__-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>FileLoopEnd</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>FileLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_AVAILABLE_MDL">
					<!--Get ModuleIdent and Flag to SKIP testing of assigned modules-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="AllModuleIdents.Uint32">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>TestAvailableMdls</Value1>
							<Value2>false</Value2>
							<GotoStep>TEST_MODULES</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckItemInArray">
					<!--Check if module in list of assigned modules-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllAvailableDuTModules.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleInArray.boolAssigned</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="4" Level="Verbose" Param0="CheckModuleInArray.boolAssigned" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleInArray.boolAssigned == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleInArray.boolAssigned</Value1>
							<Value2>false</Value2>
							<GotoStep>DataTypeLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckAlreadyTested">
					<!--Check if module already tested-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllModuleIdents.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleAlreadyTested.boolAlreadyChecked</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="5" Level="Verbose" Param0="CheckModuleAlreadyTested.boolAlreadyChecked" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleAlreadyTested.boolAlreadyChecked == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleAlreadyTested.boolAlreadyChecked</Value1>
							<Value2>true</Value2>
							<GotoStep>DataTypeLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_MODULES">
					<!--Print Module Ident-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="6" Level="Verbose" Param0="ModuleCounter" Param1="strXmlValue">Module[{0}]: Ident: {1}</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="Check_extOD_FileRef">
					<CallTestFunction Name="CheckForExtRefDict">
						<Parameter>ext_ModuleXmlFile</Parameter>
						<Parameter>ext_XPathModuleIdent</Parameter>
						<Parameter>ModuleCounter</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="InitSubItemLoopCounter">
					<!--Init of nested loop counter for DataTypes of current module-->
					<SetVariable Target="i32TmpModuleIndex">1</SetVariable>
				</TestStep>
				<TestStep Name="SubItemLoopStart">
					<!--__Loop START for current module DataTypes__-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/Profile/Dictionary/DataTypes/DataType[{2}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>DataTypeLoopEnd</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>DataTypeLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="GET_CURRENT_DT_NAME">
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/Profile/Dictionary/DataTypes/DataType[{2}]/Name</XPath>
					</GetXmlValue>
				</TestStep>
				<TestStep Name="CREATE_XPATH_FOR_DT_ELEMENT">
					<SetVariable Target="ext_XPathDtTmp" Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/Profile/Dictionary/DataTypes/DataType[{2}]</SetVariable>
				</TestStep>
				<TestStep>
					<!--Check if "DTxxxx" is used-->
					<RegexIsMatch ReturnValue="IsMatch">
						<Pattern>^(DT[0-9A-Fa-fXx]{1,4})$</Pattern>
						<InputString>strXmlValue</InputString>
					</RegexIsMatch>
					<Compare>
						<Equal>
							<Value1>IsMatch</Value1>
							<Value2>true</Value2>
							<GotoStep>DTxxxx_TYPE</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<!--Check if "DTxxxARR" is used-->
					<RegexIsMatch ReturnValue="IsMatch">
						<Pattern>^(DT[0-9A-Fa-fXx]{1,4}ARR)$</Pattern>
						<InputString>strXmlValue</InputString>
					</RegexIsMatch>
					<Compare>
						<Equal>
							<Value1>IsMatch</Value1>
							<Value2>true</Value2>
							<GotoStep>DTxxxARR_TYPE</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<!--proceed with next DT-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>SubItemLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="DTxxxx_TYPE">
					<!--Handle DTxxx data type-->
					<Description Id="7" Level="Output" Param0="strXmlValue">Check definition of "{0}".</Description>
					<CallTestFunction Name="CheckDTxxxxDataType">
						<Parameter>ext_ModuleXmlFile</Parameter>
						<Parameter>ext_XPathDtTmp</Parameter>
						<OutParameter>TmpResult</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>TmpResult</Value1>
							<Value2>false</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Equal>
					</Compare>
					<!--Dump info if test was successful-->
					<Compare>
						<Equal>
							<Value1>TmpResult</Value1>
							<Value2>true</Value2>
							<WriteLine Id="8" Level="Output">DataType definition valid.</WriteLine>
						</Equal>
					</Compare>
					<!--Indicate that at least one DT found-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<SetVariable Target="AtLeastOneModuleFound">true</SetVariable>
						</Equal>
					</Compare>
					<!--Test DTxxx type definition finished-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>SubItemLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="DTxxxARR_TYPE">
					<!--Handle DTxxxARR data type-->
					<Description Id="9" Level="Output" Param0="strXmlValue">Check definition of "{0}".</Description>
					<CallTestFunction Name="CheckDTxxxxARRDataType">
						<Parameter>ext_ModuleXmlFile</Parameter>
						<Parameter>ext_XPathDtTmp</Parameter>
						<OutParameter>TmpResult</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>TmpResult</Value1>
							<Value2>false</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Equal>
					</Compare>
					<!--Dump info if test was successful-->
					<Compare>
						<Equal>
							<Value1>TmpResult</Value1>
							<Value2>true</Value2>
							<WriteLine Id="10" Level="Output">DataType definition valid.</WriteLine>
						</Equal>
					</Compare>
					<!--Indicate that at least one DT found-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<SetVariable Target="AtLeastOneModuleFound">true</SetVariable>
						</Equal>
					</Compare>
					<!--Test DTxxxARR type definition finished-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>SubItemLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="SubItemLoopEnd">
					<!--__END of "SubItemLoopStart", increment loop counter__-->
					<SetVariable Target="i32TmpModuleIndex">i32TmpModuleIndex + 1</SetVariable>
					<!--goto loop header by default-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>SubItemLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="DataTypeLoopEnd">
					<!--__END of "DataTypeLoopStart", add ModuleIdent to tested Array__-->
					<AddArrayItem TargetArray="AllModuleIdents.Uint32Array">AllModuleIdents.Uint32</AddArrayItem>
				</TestStep>
				<TestStep>
					<!--Increment loop counter-->
					<SetVariable Target="ModuleCounter">ModuleCounter + 1</SetVariable>
					<!--goto loop header-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>DataTypeLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="FileLoopEnd">
					<!--Increment file counter-->
					<SetVariable Target="ext_ModuleXmlFile.FileCounter">ext_ModuleXmlFile.FileCounter + 1</SetVariable>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>FileLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="END">
					<!--Dump Test case result-->
					<Compare>
						<Equal>
							<Value1>AtLeastOneModuleFound</Value1>
							<Value2>false</Value2>
							<SkipCase Id="11">No Array or Record DataType found.</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>true</Value2>
							<ReturnSuccess Id="12">DataType Test successful.</ReturnSuccess>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>false</Value2>
							<RaiseError Id="14"></RaiseError>
						</Equal>
					</Compare>
				</TestStep>
			</TestCase>
			<TestCase Name="Enum DataTypes" CaseId="7">
				<?MAX_OUTPUT_ID 12?>
				<Description>
					<PreCondition>The device description includes module object dictionary defined within an external module file</PreCondition>
					<Action>1.)Get ArrayInfo, SubItem
2.)Get BitSize
3.)Get BaseType
4.)Get EnumInfo</Action>
					<PostCondition>1.)Non of the Elements ArrayInfo, SubItem shall be defined
2.)The BitSize shall equal nn and less or equal size of BaseType
3.)The BaseType shall be USINT, UINT or UDINT
4.)EnumInfo shall be defined
	EnumInfo.Enum shall be within the range of values limited by nn
	Enum.Text shall not be empty</PostCondition>
					<References>
						<Reference Specification="ETG.2000"></Reference>
						<Reference Specification="ETG.1020"></Reference>
						<Reference Specification="ETG.5001"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="Toggle_LOC_EXT">
					<!--Flag for InitGlobalVariables for default XPaths of local or external file-->
					<SetVariable Target="LocExt_InitToggle">true</SetVariable>
					<WriteLine Id="0" Level="Output">Checking for external file with modules.</WriteLine>
				</TestStep>
				<TestStep Name="SkipNoSlots">
					<!--Skip Test if "CurrentConfig.SlotCount" == 0-->
					<Compare>
						<Equal>
							<Value1>CurrentConfig.SlotCount</Value1>
							<Value2>0</Value2>
							<SkipCase Id="1">Test skipped. No slots defined.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="SkipSoE">
					<!--Skip Test if SoE Device-->
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Mailbox.SoE</Value1>
							<Value2>true</Value2>
							<SkipCase Id="2">Test skipped for SoE Devices.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="INIT_AVAIL_GLOB_ARRAY">
					<CallTestFunction Name="AvailableDuTModuleIdents"></CallTestFunction>
				</TestStep>
				<TestStep Name="InitGlobalVariables">
					<!--Init global XPaths-->
					<CallTestFunction Name="InitGlobalVariablesForModuleODTest">
						<Parameter>LocExt_InitToggle</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="INIT_RESULT">
					<!--"result" = true-->
					<SetVariable Target="result">true</SetVariable>
				</TestStep>
				<TestStep Name="FileLoopStart">
					<GetXmlValue ReturnValue="ext_ModuleXmlFile" Markup="false">
						<XPath Param0="ext_ModuleXmlFile.XPath" Param1="ext_ModuleXmlFile.FileCounter">{0}[{1}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>ext_ModuleXmlFile</Value1>
							<Value2>null</Value2>
							<GotoStep>END</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>ext_ModuleXmlFile</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>END</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="3" Level="Output" Param0="ext_ModuleXmlFile">Checking external module file: {0}</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="INIT_LOOP_COUNTER">
					<!--"ModuleCounter" = 1-->
					<SetVariable Target="ModuleCounter">1</SetVariable>
				</TestStep>
				<TestStep Name="CHECK_IF_EXISTS">
					<!--Checking if modules exist-->
					<Compare>
						<Equal>
							<Value1>ext_XPathModuleIdent</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>FileLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="InitTestedArray">
					<!--Array of already processed modules, no doubles-->
					<InitArray TargetArray="AllModuleIdents.Uint32Array"></InitArray>
				</TestStep>
				<TestStep Name="DataTypeLoopStart">
					<!--__Loop START for EXTERNAL Modules__-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>FileLoopEnd</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>FileLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_AVAILABLE_MDL">
					<!--Get ModuleIdent and Flag to SKIP testing of assigned modules-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="AllModuleIdents.Uint32">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>TestAvailableMdls</Value1>
							<Value2>false</Value2>
							<GotoStep>TEST_MODULES</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckItemInArray">
					<!--Check if module in list of assigned modules-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllAvailableDuTModules.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleInArray.boolAssigned</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="4" Level="Verbose" Param0="CheckModuleInArray.boolAssigned" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleInArray.boolAssigned == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleInArray.boolAssigned</Value1>
							<Value2>false</Value2>
							<GotoStep>DataTypeLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckAlreadyTested">
					<!--Check if module already tested-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllModuleIdents.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleAlreadyTested.boolAlreadyChecked</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="5" Level="Verbose" Param0="CheckModuleAlreadyTested.boolAlreadyChecked" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleAlreadyTested.boolAlreadyChecked == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleAlreadyTested.boolAlreadyChecked</Value1>
							<Value2>true</Value2>
							<GotoStep>DataTypeLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_MODULES">
					<!--Print Module Ident-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="6" Level="Verbose" Param0="ModuleCounter" Param1="strXmlValue">Module[{0}]: Ident: {1}</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="Check_extOD_FileRef">
					<CallTestFunction Name="CheckForExtRefDict">
						<Parameter>ext_ModuleXmlFile</Parameter>
						<Parameter>ext_XPathModuleIdent</Parameter>
						<Parameter>ModuleCounter</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="InitSubItemLoopCounter">
					<!--Init of nested loop counter for DataTypes of current module-->
					<SetVariable Target="i32TmpModuleIndex">1</SetVariable>
				</TestStep>
				<TestStep Name="SubItemLoopStart">
					<!--__Loop START for current module DataTypes__-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/Profile/Dictionary/DataTypes/DataType[{2}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>DataTypeLoopEnd</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>DataTypeLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="GET_CURRENT_DT_NAME">
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/Profile/Dictionary/DataTypes/DataType[{2}]/Name</XPath>
					</GetXmlValue>
				</TestStep>
				<TestStep Name="CREATE_XPATH_FOR_DT_ELEMENT">
					<SetVariable Target="ext_XPathDtTmp" Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/Profile/Dictionary/DataTypes/DataType[{2}]</SetVariable>
				</TestStep>
				<TestStep>
					<!--Check if "DTxxxENnn" is used-->
					<RegexIsMatch ReturnValue="IsMatch">
						<Pattern>^(DT[0-9A-Fa-fXx]{4}EN([0-9]{2}))$</Pattern>
						<InputString>strXmlValue</InputString>
					</RegexIsMatch>
					<Compare>
						<Equal>
							<Value1>IsMatch</Value1>
							<Value2>false</Value2>
							<GotoStep>SubItemLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="DTxxxENnn_TYPE">
					<!--Handle DTxxxENnn data type-->
					<Description Id="7" Level="Output" Param0="strXmlValue">Check definition of "{0}".</Description>
					<CallTestFunction Name="CheckDTxxxxENnnDataType">
						<Parameter>ext_ModuleXmlFile</Parameter>
						<Parameter>ext_XPathDtTmp</Parameter>
						<OutParameter>TmpResult</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>TmpResult</Value1>
							<Value2>false</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Equal>
					</Compare>
					<!--Dump info if test was successful-->
					<Compare>
						<Equal>
							<Value1>TmpResult</Value1>
							<Value2>true</Value2>
							<WriteLine Id="8" Level="Output">DataType definition valid.</WriteLine>
						</Equal>
					</Compare>
					<!--Indicate that at least one DT found-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<SetVariable Target="AtLeastOneModuleFound">true</SetVariable>
						</Equal>
					</Compare>
					<!--Test DTxxxENnn type definition finished-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>SubItemLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="SubItemLoopEnd">
					<!--__END of "SubItemLoopStart", increment loop counter__-->
					<SetVariable Target="i32TmpModuleIndex">i32TmpModuleIndex + 1</SetVariable>
					<!--goto loop header by default-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>SubItemLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="DataTypeLoopEnd">
					<!--__END of "DataTypeLoopStart", add ModuleIdent to tested Array__-->
					<AddArrayItem TargetArray="AllModuleIdents.Uint32Array">AllModuleIdents.Uint32</AddArrayItem>
				</TestStep>
				<TestStep>
					<!--Increment loop counter-->
					<SetVariable Target="ModuleCounter">ModuleCounter + 1</SetVariable>
					<!--goto loop header by default-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>DataTypeLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="FileLoopEnd">
					<!--Increment file counter-->
					<SetVariable Target="ext_ModuleXmlFile.FileCounter">ext_ModuleXmlFile.FileCounter + 1</SetVariable>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>FileLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="END">
					<!--Dump Test case result-->
					<Compare>
						<Equal>
							<Value1>AtLeastOneModuleFound</Value1>
							<Value2>false</Value2>
							<SkipCase Id="9">No Enum DataType found.</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>true</Value2>
							<ReturnSuccess Id="10">DataType Test successful.</ReturnSuccess>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>false</Value2>
							<RaiseError Id="12"></RaiseError>
						</Equal>
					</Compare>
				</TestStep>
			</TestCase>
		</TestGroup>
		<TestGroup GroupId="201" Name="(External) Module RxPdo Tests">
			<Comment>Check the correct usage and values of the RxPDO elements for modules defined within an external file</Comment>
			<TestCase Name="Check Attributes" CaseId="1">
				<?MAX_OUTPUT_ID 28?>
				<Description>
					<Purpose>Correct usage of the module RxPdo attributes</Purpose>
					<PreCondition>The device description contains at least one RxPDO element.</PreCondition>
					<Action>1. @Su
2. @Fixed
3. @OSFac,@OSMin,@OSMax,@OSIndexInc</Action>
					<PostCondition>1. if @Su defined a matching FMMU shall be referenced
2. if @Fixed is true at least one entry should be defined
3. if defined @OSxxx shall be greater/equal 0
   and @OSMin less/equal @OSFac greater/equal @OSMax</PostCondition>
					<References>
						<Reference Specification="ETG.2000"></Reference>
						<Reference Specification="ETG.5001"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="Toggle_LOC_EXT">
					<!--Flag for InitGlobalVariables for default XPaths of local or external file-->
					<SetVariable Target="LocExt_InitToggle">true</SetVariable>
					<WriteLine Id="0" Level="Output">Checking for external file with modules</WriteLine>
				</TestStep>
				<TestStep Name="SkipNoSlots">
					<!--Skip Test if "CurrentConfig.SlotCount" == 0-->
					<Compare>
						<Equal>
							<Value1>CurrentConfig.SlotCount</Value1>
							<Value2>0</Value2>
							<SkipCase Id="1">Test skipped. No slots defined.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="SkipSoE">
					<!--Skip Test if SoE Device-->
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Mailbox.SoE</Value1>
							<Value2>true</Value2>
							<SkipCase Id="2">Test skipped for SoE Devices.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="INIT_AVAIL_GLOB_ARRAY">
					<CallTestFunction Name="AvailableDuTModuleIdents"></CallTestFunction>
				</TestStep>
				<TestStep Name="InitGlobalVariables">
					<!--Init global XPaths-->
					<CallTestFunction Name="InitGlobalVariablesForModuleODTest">
						<Parameter>LocExt_InitToggle</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="INIT_RESULT">
					<!--"result" = true-->
					<SetVariable Target="result">true</SetVariable>
				</TestStep>
				<TestStep Name="FileLoopStart">
					<GetXmlValue ReturnValue="ext_ModuleXmlFile" Markup="false">
						<XPath Param0="ext_ModuleXmlFile.XPath" Param1="ext_ModuleXmlFile.FileCounter">{0}[{1}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>ext_ModuleXmlFile</Value1>
							<Value2>null</Value2>
							<GotoStep>TEST_END</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>ext_ModuleXmlFile</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>TEST_END</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="3" Level="Output" Param0="ext_ModuleXmlFile">Checking external module file: {0}</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="INIT_LOOP_COUNTER">
					<!--"ModuleCounter" = 1-->
					<SetVariable Target="ModuleCounter">1</SetVariable>
				</TestStep>
				<TestStep Name="CHECK_IF_EXISTS">
					<!--Checking if modules exist-->
					<Compare>
						<Equal>
							<Value1>ext_XPathModuleIdent</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>FileLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="InitTestedArray">
					<!--Array of already processed modules, no doubles-->
					<InitArray TargetArray="AllModuleIdents.Uint32Array"></InitArray>
				</TestStep>
				<TestStep Name="ModuleLoopStart">
					<!--__Loop START for EXTERNAL Modules__-->
				</TestStep>
				<TestStep Name="CHECK_IF_MODULE_EXISTS">
					<!--Checking if module exist-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>FileLoopEnd</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>FileLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_AVAILABLE_MDL">
					<!--Get ModuleIdent and Flag to SKIP testing of assigned modules-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="AllModuleIdents.Uint32">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>TestAvailableMdls</Value1>
							<Value2>false</Value2>
							<GotoStep>TEST_MODULES</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckItemInArray">
					<!--Check if module in list of assigned modules-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllAvailableDuTModules.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleInArray.boolAssigned</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="4" Level="Verbose" Param0="CheckModuleInArray.boolAssigned" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleInArray.boolAssigned == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleInArray.boolAssigned</Value1>
							<Value2>false</Value2>
							<GotoStep>RxPdoLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckAlreadyTested">
					<!--Check if module already tested-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllModuleIdents.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleAlreadyTested.boolAlreadyChecked</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="5" Level="Verbose" Param0="CheckModuleAlreadyTested.boolAlreadyChecked" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleAlreadyTested.boolAlreadyChecked == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleAlreadyTested.boolAlreadyChecked</Value1>
							<Value2>true</Value2>
							<GotoStep>RxPdoLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_MODULES">
					<!--Print Module Ident-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="6" Level="Verbose" Param0="ModuleCounter" Param1="strXmlValue">Module[{0}]: Ident: {1}</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="Check_extOD_FileRef">
					<CallTestFunction Name="CheckForExtRefDict">
						<Parameter>ext_ModuleXmlFile</Parameter>
						<Parameter>ext_XPathModuleIdent</Parameter>
						<Parameter>ModuleCounter</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="InitSubItemLoopCounter">
					<!--Init of nested loop counter for RxPdo of current module-->
					<SetVariable Target="i32TmpModuleIndex">1</SetVariable>
				</TestStep>
				<TestStep Name="AttributeLoopStart">
					<!--__Loop START for current module RxPdo__-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/RxPdo[{2}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>RxPdoLoopEnd</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>RxPdoLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<!--Check if RxPdo@Su is defined-->
					<Description Id="7" Level="Output">Check @Su attribute.</Description>
					<!--Skip Su test if Sm is not defined-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/RxPdo[{2}]/@Sm</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<WriteLine Id="8" Level="Verbose" Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">Skip Su test because default Sm not defined ({0}[{1}]/RxPdo[{2}]/@Sm not defined).</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<WriteLine Id="9" Level="Verbose" Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">Skip Su test because default Sm not defined ({0}[{1}]/RxPdo[{2}]/@Sm not defined).</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>TEST_OS_INDEXINC</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>TEST_OS_INDEXINC</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<!--Skip Su test if Su is not defined-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/RxPdo[{2}]/@Su</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<WriteLine Id="10" Level="Verbose" Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/RxPdo[{2}]/@Su not defined.</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<WriteLine Id="11" Level="Verbose" Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/RxPdo[{2}]/@Su not defined.</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>TEST_OS_INDEXINC</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>TEST_OS_INDEXINC</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<WriteLine Id="12" Level="Output" Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">Check if {0}[{1}]/RxPdo[{2}]/@Su reference a valid Fmmu.</WriteLine>
				</TestStep>
				<TestStep>
					<!--Convert to Uint16-->
					<SetVariable Target="strXmlValue.Su.Uint16">strXmlValue</SetVariable>
				</TestStep>
				<TestStep>
					<!--Get Referenced Fmmu-->
					<CallTestFunction Name="GetFmmuBySu">
						<Parameter>strXmlValue.Su.Uint16</Parameter>
						<Parameter>Outputs</Parameter>
						<OutParameter>i32TmpIndex</OutParameter>
					</CallTestFunction>
				</TestStep>
				<TestStep>
					<!--Check if FMMU exists-->
					<Compare>
						<Lower>
							<Value1>i32TmpIndex</Value1>
							<Value2>0</Value2>
							<WriteLine Id="13" Level="Error" Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/RxPdo[{2}]/@Su doesn't reference an existing/matching Fmmu.</WriteLine>
						</Lower>
					</Compare>
					<Compare>
						<Lower>
							<Value1>i32TmpIndex</Value1>
							<Value2>0</Value2>
							<SetVariable Target="AtLeastOneModuleFound">true</SetVariable>
						</Lower>
					</Compare>
					<Compare>
						<Lower>
							<Value1>i32TmpIndex</Value1>
							<Value2>0</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Lower>
					</Compare>
					<Compare>
						<Lower>
							<Value1>i32TmpIndex</Value1>
							<Value2>0</Value2>
							<GotoStep>TEST_OS_INDEXINC</GotoStep>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_OS_INDEXINC">
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/RxPdo[{2}]/@OSIndexInc</XPath>
					</GetXmlValue>
				</TestStep>
				<TestStep>
					<!--Convert to Int32-->
					<SetVariable Target="strXmlValue.OSIndexInc.Int32">strXmlValue</SetVariable>
				</TestStep>
				<TestStep>
					<!--Check RxPdo@OSIndexInc-->
					<Description Id="14" Level="Output">Check @OSxxxx attributes.</Description>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>TEST_OS_MIN</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>TEST_OS_MIN</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Lower>
							<Value1>strXmlValue.OSIndexInc.Int32</Value1>
							<Value2>0</Value2>
							<WriteLine Id="15" Level="Error" Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex" Param3="strXmlValue.OSIndexInc.Int32">{0}[{1}]/RxPdo[{2}]/@OSIndexInc shall be &gt;= 0 (current value : {3})</WriteLine>
						</Lower>
					</Compare>
					<Compare>
						<Lower>
							<Value1>strXmlValue.OSIndexInc.Int32</Value1>
							<Value2>0</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_OS_MIN">
					<!--Get RxPdo@OSMin-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValueOSMin">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/RxPdo[{2}]/@OSMin</XPath>
					</GetXmlValue>
				</TestStep>
				<TestStep>
					<!--Get RxPdo@OSFac-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValueOSFac">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/RxPdo[{2}]/@OSFac</XPath>
					</GetXmlValue>
				</TestStep>
				<TestStep>
					<!--Get RxPdo@OSMax-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValueOSMax">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/RxPdo[{2}]/@OSMax</XPath>
					</GetXmlValue>
				</TestStep>
				<TestStep>
					<!--Convert to Int32-->
					<SetVariable Target="strXmlValue.OSMin.Int32">strXmlValueOSMin</SetVariable>
				</TestStep>
				<TestStep>
					<!--Convert to Int32-->
					<SetVariable Target="strXmlValue.OSFac.Int32">strXmlValueOSFac</SetVariable>
				</TestStep>
				<TestStep>
					<!--Convert to Int32-->
					<SetVariable Target="strXmlValue.OSMax.Int32">strXmlValueOSMax</SetVariable>
				</TestStep>
				<TestStep>
					<!--Check RxPdo@OSMin-->
					<Compare>
						<Equal>
							<Value1>strXmlValueOSMin</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>TEST_OS_FAC</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValueOSMin</Value1>
							<Value2>null</Value2>
							<GotoStep>TEST_OS_FAC</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<SetVariable Target="AtLeastOneModuleFound">true</SetVariable>
						</Equal>
					</Compare>
					<Compare>
						<Lower>
							<Value1>strXmlValue.OSMin.Int32</Value1>
							<Value2>0</Value2>
							<WriteLine Id="16" Level="Error" Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex" Param3="strXmlValue.OSMin.Int32">{0}[{1}]/RxPdo[{2}]/@OSMin shall be &gt;= 0 (current value : {3})</WriteLine>
						</Lower>
					</Compare>
					<Compare>
						<Lower>
							<Value1>strXmlValue.OSMin.Int32</Value1>
							<Value2>0</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Lower>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValueOSFac</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>TEST_OS_FAC</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValueOSFac</Value1>
							<Value2>null</Value2>
							<GotoStep>TEST_OS_FAC</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<SetVariable Target="AtLeastOneModuleFound">true</SetVariable>
						</Equal>
					</Compare>
					<Compare>
						<Lower>
							<Value1>strXmlValue.OSFac.Int32</Value1>
							<Value2>strXmlValue.OSMin.Int32</Value2>
							<WriteLine Id="17" Level="Error" Param0="ModuleCounter" Param1="i32TmpModuleIndex" Param2="strXmlValue.OSMin.Int32" Param3="strXmlValue.OSFac.Int32">EtherCATModule/Modules/Module[{0}]/RxPdo[{1}]/@OSMin: (current value : {2}) shall be less or equal OSFac (current value : {3})</WriteLine>
						</Lower>
					</Compare>
					<Compare>
						<Lower>
							<Value1>strXmlValue.OSFac.Int32</Value1>
							<Value2>strXmlValue.OSMin.Int32</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_OS_FAC">
					<!--Check RxPdo@OSFac-->
					<Compare>
						<Equal>
							<Value1>strXmlValueOSFac</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>TEST_OS_MAX</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValueOSFac</Value1>
							<Value2>null</Value2>
							<GotoStep>TEST_OS_MAX</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<SetVariable Target="AtLeastOneModuleFound">true</SetVariable>
						</Equal>
					</Compare>
					<Compare>
						<Lower>
							<Value1>strXmlValue.OSFac.Int32</Value1>
							<Value2>0</Value2>
							<WriteLine Id="18" Level="Error" Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex" Param3="strXmlValue.OSFac.Int32">{0}[{1}]/RxPdo[{2}]/@OSFac shall be &gt;= 0 (current value : {3})</WriteLine>
						</Lower>
					</Compare>
					<Compare>
						<Lower>
							<Value1>strXmlValue.OSFac.Int32</Value1>
							<Value2>0</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Lower>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValueOSMax</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>TEST_OS_MAX</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValueOSMax</Value1>
							<Value2>null</Value2>
							<GotoStep>TEST_OS_MAX</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<SetVariable Target="AtLeastOneModuleFound">true</SetVariable>
						</Equal>
					</Compare>
					<Compare>
						<Greater>
							<Value1>strXmlValue.OSFac.Int32</Value1>
							<Value2>strXmlValue.OSMax.Int32</Value2>
							<WriteLine Id="19" Level="Error" Param0="ModuleCounter" Param1="i32TmpModuleIndex" Param2="strXmlValue.OSMax.Int32" Param3="strXmlValue.OSFac.Int32">EtherCATModule/Modules/Module[{0}]/RxPdo[{1}] OSMax (current value : {2}) shall be greater or equal OSFac (current value : {3})</WriteLine>
						</Greater>
					</Compare>
					<Compare>
						<Greater>
							<Value1>strXmlValue.OSFac.Int32</Value1>
							<Value2>strXmlValue.OSMax.Int32</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Greater>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_OS_MAX">
					<!--Check RxPdo@OSMax-->
					<Compare>
						<Equal>
							<Value1>strXmlValueOSMax</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>TEST_FIXED_FLAG</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValueOSMax</Value1>
							<Value2>null</Value2>
							<GotoStep>TEST_FIXED_FLAG</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<SetVariable Target="AtLeastOneModuleFound">true</SetVariable>
						</Equal>
					</Compare>
					<Compare>
						<Lower>
							<Value1>strXmlValue.OSMax.Int32</Value1>
							<Value2>0</Value2>
							<WriteLine Id="20" Level="Error" Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex" Param3="strXmlValue.OSMax.Int32">{0}[{1}]/RxPdo[{2}]/@OSMax shall be &gt;= 0 (current value : {3})</WriteLine>
						</Lower>
					</Compare>
					<Compare>
						<Lower>
							<Value1>strXmlValue.OSMax.Int32</Value1>
							<Value2>0</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Lower>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValueOSMin</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>TEST_FIXED_FLAG</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValueOSMin</Value1>
							<Value2>null</Value2>
							<GotoStep>TEST_FIXED_FLAG</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<SetVariable Target="AtLeastOneModuleFound">true</SetVariable>
						</Equal>
					</Compare>
					<Compare>
						<Greater>
							<Value1>strXmlValue.OSMin.Int32</Value1>
							<Value2>strXmlValue.OSMax.Int32</Value2>
							<WriteLine Id="21" Level="Error" Param0="ModuleCounter" Param1="i32TmpModuleIndex" Param2="strXmlValue.OSMin.Int32" Param3="strXmlValue.OSMax.Int32">EtherCATModule/Modules/Module[{0}]/RxPdo[{1}]  OSMin (current value : {2}) shall be less or equal OSMax (current value : {3})</WriteLine>
						</Greater>
					</Compare>
					<Compare>
						<Greater>
							<Value1>strXmlValue.OSMin.Int32</Value1>
							<Value2>strXmlValue.OSMax.Int32</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Greater>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_FIXED_FLAG">
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValueFixed.Bool">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/RxPdo[{2}]/@Fixed</XPath>
					</GetXmlValue>
				</TestStep>
				<TestStep>
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="true" ReturnValue="strXmlValueEntries">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/RxPdo[{2}]/Entry</XPath>
					</GetXmlValue>
				</TestStep>
				<TestStep>
					<!--If Entries defined the fixed flag doesn't need to be checked-->
					<Description Id="22" Level="Output">Check @Fixed attribute.</Description>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="23" Level="Verbose" Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex" Param3="strXmlValueFixed.Bool">{0}[{1}]/RxPdo[{2}]: Fixed flag == {3}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="24" Level="Verbose" Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex" Param3="strXmlValueEntries">{0}[{1}]/RxPdo[{2}]/Entry: {3}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValueEntries</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>FIXED_FLAG</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValueEntries</Value1>
							<Value2>null</Value2>
							<GotoStep>FIXED_FLAG</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>LOOPEND</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="FIXED_FLAG">
					<!--If no entries defined fixed flag shall be false-->
					<Compare>
						<Equal>
							<Value1>strXmlValueFixed.Bool</Value1>
							<Value2>true</Value2>
							<WriteLine Id="25" Level="Warning" Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/RxPdo[{2}]: Fixed flag should not be set if no entry is defined.</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<SetVariable Target="AtLeastOneModuleFound">true</SetVariable>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="LOOPEND">
					<!--__END of "AttributeLoopStart", increment loop counter__-->
					<SetVariable Target="i32TmpModuleIndex">i32TmpModuleIndex + 1</SetVariable>
					<!--goto loop header by default-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>AttributeLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="RxPdoLoopEnd">
					<!--__END of "ModuleLoopStart", add ModuleIdent to tested Array__-->
					<AddArrayItem TargetArray="AllModuleIdents.Uint32Array">AllModuleIdents.Uint32</AddArrayItem>
				</TestStep>
				<TestStep>
					<!--Increment loop counter-->
					<SetVariable Target="ModuleCounter">ModuleCounter + 1</SetVariable>
					<!--goto loop header by default-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>ModuleLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="FileLoopEnd">
					<!--Increment file counter-->
					<SetVariable Target="ext_ModuleXmlFile.FileCounter">ext_ModuleXmlFile.FileCounter + 1</SetVariable>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>FileLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_END">
					<!--dump test result-->
					<Compare>
						<Equal>
							<Value1>AtLeastOneModuleFound</Value1>
							<Value2>false</Value2>
							<SkipCase Id="26">No Attributes in RxPdo found.</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>false</Value2>
							<RaiseError Id="27">Test RxPdo(s) attributes failed.</RaiseError>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>true</Value2>
							<ReturnSuccess Id="28">Test RxPdo(s) attributes succeed.</ReturnSuccess>
						</Equal>
					</Compare>
				</TestStep>
			</TestCase>
			<TestCase Name="Check Index" CaseId="2">
				<?MAX_OUTPUT_ID 14?>
				<Description>
					<Purpose>Correct module RxPDO index range</Purpose>
					<PreCondition>The device description contains at least one RxPDO element.</PreCondition>
					<Action>Check @Index</Action>
					<PostCondition>@Index shall be between 0x1600 and 0x17FF</PostCondition>
					<References>
						<Reference Specification="ETG.2000"></Reference>
						<Reference Specification="ETG.1000"></Reference>
						<Reference Specification="ETG.5001"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="Toggle_LOC_EXT">
					<!--Flag for InitGlobalVariables for default XPaths of local or external file-->
					<SetVariable Target="LocExt_InitToggle">true</SetVariable>
					<WriteLine Id="0" Level="Output">Checking for external file with modules</WriteLine>
				</TestStep>
				<TestStep Name="SkipEmulation">
					<!--Skip Test for slave with device emulation-->
					<CallTestFunction Name="GetDeviceEmulationFlags">
						<!--if false the device emulation bit will be read out from the ESI file-->
						<Parameter>false</Parameter>
						<OutParameter>boolVar</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>boolVar</Value1>
							<Value2>true</Value2>
							<SkipCase Id="1">DuT is a simple device test skipped.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="SkipNoSlots">
					<!--Skip Test if "CurrentConfig.SlotCount" == 0-->
					<Compare>
						<Equal>
							<Value1>CurrentConfig.SlotCount</Value1>
							<Value2>0</Value2>
							<SkipCase Id="2">Test skipped. No slots defined.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="SkipSoE">
					<!--Skip Test if SoE Device-->
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Mailbox.SoE</Value1>
							<Value2>true</Value2>
							<SkipCase Id="3">Test skipped for SoE Devices.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="INIT_AVAIL_GLOB_ARRAY">
					<CallTestFunction Name="AvailableDuTModuleIdents"></CallTestFunction>
				</TestStep>
				<TestStep Name="InitGlobalVariables">
					<!--Init global XPaths-->
					<CallTestFunction Name="InitGlobalVariablesForModuleODTest">
						<Parameter>LocExt_InitToggle</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="INIT_RESULT">
					<!--"result" = true-->
					<SetVariable Target="result">true</SetVariable>
				</TestStep>
				<TestStep Name="FileLoopStart">
					<GetXmlValue ReturnValue="ext_ModuleXmlFile" Markup="false">
						<XPath Param0="ext_ModuleXmlFile.XPath" Param1="ext_ModuleXmlFile.FileCounter">{0}[{1}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>ext_ModuleXmlFile</Value1>
							<Value2>null</Value2>
							<GotoStep>TEST_END</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>ext_ModuleXmlFile</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>TEST_END</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="4" Level="Output" Param0="ext_ModuleXmlFile">Checking external module file: {0}</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="INIT_LOOP_COUNTER">
					<!--"ModuleCounter" = 1-->
					<SetVariable Target="ModuleCounter">1</SetVariable>
				</TestStep>
				<TestStep Name="CHECK_IF_EXISTS">
					<!--Checking if module exist-->
					<Compare>
						<Equal>
							<Value1>ext_XPathModuleIdent</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>FileLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="InitTestedArray">
					<!--Array of already processed modules, no doubles-->
					<InitArray TargetArray="AllModuleIdents.Uint32Array"></InitArray>
				</TestStep>
				<TestStep Name="ModuleLoopStart">
					<!--__Loop START for EXTERNAL Modules__-->
				</TestStep>
				<TestStep Name="CHECK_IF_MODULE_EXISTS">
					<!--Checking if module exist-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>FileLoopEnd</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>FileLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_AVAILABLE_MDL">
					<!--Get ModuleIdent and Flag to SKIP testing of assigned modules-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="AllModuleIdents.Uint32">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>TestAvailableMdls</Value1>
							<Value2>false</Value2>
							<GotoStep>TEST_MODULES</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckItemInArray">
					<!--Check if module in list of assigned modules-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllAvailableDuTModules.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleInArray.boolAssigned</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="5" Level="Verbose" Param0="CheckModuleInArray.boolAssigned" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleInArray.boolAssigned == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleInArray.boolAssigned</Value1>
							<Value2>false</Value2>
							<GotoStep>RxPdoLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckAlreadyTested">
					<!--Check if module already tested-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllModuleIdents.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleAlreadyTested.boolAlreadyChecked</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="6" Level="Verbose" Param0="CheckModuleAlreadyTested.boolAlreadyChecked" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleAlreadyTested.boolAlreadyChecked == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleAlreadyTested.boolAlreadyChecked</Value1>
							<Value2>true</Value2>
							<GotoStep>RxPdoLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_MODULES">
					<!--Print Module Ident-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="7" Level="Verbose" Param0="ModuleCounter" Param1="strXmlValue">Module[{0}]: Ident: {1}</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="Check_extOD_FileRef">
					<CallTestFunction Name="CheckForExtRefDict">
						<Parameter>ext_ModuleXmlFile</Parameter>
						<Parameter>ext_XPathModuleIdent</Parameter>
						<Parameter>ModuleCounter</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="InitSubItemLoopCounter">
					<!--Init of nested loop counter for RxPdo of current module-->
					<SetVariable Target="i32TmpModuleIndex">1</SetVariable>
				</TestStep>
				<TestStep Name="IndexLoopStart">
					<!--__Loop START for current module RxPdo__-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/RxPdo[{2}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>RxPdoLoopEnd</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>RxPdoLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="LOOPSTART">
					<!--Dump loop start info-->
				</TestStep>
				<TestStep>
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.Index.Uint16">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/RxPdo[{2}]/Index</XPath>
					</GetXmlValue>
				</TestStep>
				<TestStep>
					<!--Check if Index is less than 0x1600-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<SetVariable Target="AtLeastOneModuleFound">true</SetVariable>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="8" Level="Output" Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex" Param3="strXmlValue.Index.Uint16">{0}[{1}]/RxPdo[{2}]/Index (0x{3:x4})</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Lower>
							<Value1>strXmlValue.Index.Uint16</Value1>
							<Value2>5632</Value2>
							<WriteLine Id="9" Level="Error" Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex" Param3="strXmlValue.Index.Uint16">{0}[{1}]/RxPdo[{2}]/Index (0x{3:x4}) shall be between 0x1600 and 0x17FF</WriteLine>
						</Lower>
					</Compare>
					<Compare>
						<Lower>
							<Value1>strXmlValue.Index.Uint16</Value1>
							<Value2>5632</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep>
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.Index.Uint16">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/RxPdo[{2}]/Index</XPath>
					</GetXmlValue>
				</TestStep>
				<TestStep>
					<!--Check if Index is greater than 0x17FF-->
					<Compare>
						<Greater>
							<Value1>strXmlValue.Index.Uint16</Value1>
							<Value2>6143</Value2>
							<WriteLine Id="10" Level="Error" Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex" Param3="strXmlValue.Index.Uint16">{0}[{1}]/RxPdo[{2}]/Index (0x{3:x4}) shall be between 0x1600 and 0x17FF</WriteLine>
						</Greater>
					</Compare>
					<Compare>
						<Greater>
							<Value1>strXmlValue.Index.Uint16</Value1>
							<Value2>6143</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Greater>
					</Compare>
				</TestStep>
				<TestStep Name="LOOPEND">
					<!--__END of "IndexLoopStart", increment loop counter__-->
					<SetVariable Target="i32TmpModuleIndex">i32TmpModuleIndex + 1</SetVariable>
					<!--goto loop header by default-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>IndexLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="RxPdoLoopEnd">
					<!--__END of "ModuleLoopStart", add ModuleIdent to tested Array__-->
					<AddArrayItem TargetArray="AllModuleIdents.Uint32Array">AllModuleIdents.Uint32</AddArrayItem>
				</TestStep>
				<TestStep>
					<!--Increment loop counter-->
					<SetVariable Target="ModuleCounter">ModuleCounter + 1</SetVariable>
					<!--goto loop header by default-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>ModuleLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="FileLoopEnd">
					<!--Increment file counter-->
					<SetVariable Target="ext_ModuleXmlFile.FileCounter">ext_ModuleXmlFile.FileCounter + 1</SetVariable>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>FileLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_END">
					<!--dump test result-->
					<Compare>
						<Equal>
							<Value1>AtLeastOneModuleFound</Value1>
							<Value2>false</Value2>
							<SkipCase Id="11">No Index in RxPdo found.</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>false</Value2>
							<RaiseError Id="14"></RaiseError>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>true</Value2>
							<ReturnSuccess Id="13">All RxPdo indices are valid.</ReturnSuccess>
						</Equal>
					</Compare>
				</TestStep>
			</TestCase>
			<TestCase Name="Check SM assignment" CaseId="3">
				<?MAX_OUTPUT_ID 9?>
				<Description>
					<Purpose>Correct SyncManager assignment for module RxPDOs</Purpose>
					<PreCondition>The device description contains at least one RxPDO element.</PreCondition>
					<Action>- @Mandatory == true
  test only @Sm
  1.) Is @Sm defined
  2.) Is .ExcludedSm defined
- @Mandatory == false
  iterate over all matching SyncManagers
  - referenced via @Sm
  - not excluded via .ExcludedSm
  - referenced via @Su

3.) @Sm match?
4.) Check @Virtual ?</Action>
					<PostCondition>1.) @Sm shall be defined
2.) .ExcludedSm should not be defined (the PDO is fixed assigned to @Sm)
3.) Directon/Type of shall @Sm match
4.) Valid if:
    - PDO is virtual AND SyncManager is virtual AND Entries defined
	- PDO is virtual AND SyncManager is not virtual and no Entries defined
    Error if SyncManager is @Sm else Warning

At least one valid SyncManager is defined.</PostCondition>
					<References>
						<Reference Specification="ETG.2000"></Reference>
						<Reference Specification="ETG.5001"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="Toggle_LOC_EXT">
					<!--Flag for InitGlobalVariables for default XPaths of local or external file-->
					<SetVariable Target="LocExt_InitToggle">true</SetVariable>
					<WriteLine Id="0" Level="Output">Checking for external file with modules</WriteLine>
				</TestStep>
				<TestStep Name="SkipNoSlots">
					<!--Skip Test if "CurrentConfig.SlotCount" == 0-->
					<Compare>
						<Equal>
							<Value1>CurrentConfig.SlotCount</Value1>
							<Value2>0</Value2>
							<SkipCase Id="1">Test skipped. No slots defined.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="SkipSoE">
					<!--Skip Test if SoE Device-->
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Mailbox.SoE</Value1>
							<Value2>true</Value2>
							<SkipCase Id="2">Test skipped for SoE Devices.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="INIT_AVAIL_GLOB_ARRAY">
					<CallTestFunction Name="AvailableDuTModuleIdents"></CallTestFunction>
				</TestStep>
				<TestStep Name="InitGlobalVariables">
					<!--Init global XPaths-->
					<CallTestFunction Name="InitGlobalVariablesForModuleODTest">
						<Parameter>LocExt_InitToggle</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="INIT_RESULT">
					<!--"result" = true-->
					<SetVariable Target="result">true</SetVariable>
				</TestStep>
				<TestStep Name="FileLoopStart">
					<GetXmlValue ReturnValue="ext_ModuleXmlFile" Markup="false">
						<XPath Param0="ext_ModuleXmlFile.XPath" Param1="ext_ModuleXmlFile.FileCounter">{0}[{1}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>ext_ModuleXmlFile</Value1>
							<Value2>null</Value2>
							<GotoStep>TEST_END</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>ext_ModuleXmlFile</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>TEST_END</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="3" Level="Output" Param0="ext_ModuleXmlFile">Checking external module file: {0}</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="INIT_LOOP_COUNTER">
					<!--"ModuleCounter" = 1-->
					<SetVariable Target="ModuleCounter">1</SetVariable>
				</TestStep>
				<TestStep Name="CHECK_IF_EXISTS">
					<!--Checking if module exist-->
					<Compare>
						<Equal>
							<Value1>ext_XPathModuleIdent</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>FileLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="InitTestedArray">
					<!--Array of already processed modules, no doubles-->
					<InitArray TargetArray="AllModuleIdents.Uint32Array"></InitArray>
				</TestStep>
				<TestStep Name="ModuleLoopStart">
					<!--__Loop START for EXTERNAL Modules__-->
				</TestStep>
				<TestStep Name="CHECK_IF_MODULE_EXISTS">
					<!--Checking if module exist-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>FileLoopEnd</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>FileLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_AVAILABLE_MDL">
					<!--Get ModuleIdent and Flag to SKIP testing of assigned modules-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="AllModuleIdents.Uint32">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>TestAvailableMdls</Value1>
							<Value2>false</Value2>
							<GotoStep>TEST_MODULES</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckItemInArray">
					<!--Check if module in list of assigned modules-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllAvailableDuTModules.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleInArray.boolAssigned</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="4" Level="Verbose" Param0="CheckModuleInArray.boolAssigned" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleInArray.boolAssigned == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleInArray.boolAssigned</Value1>
							<Value2>false</Value2>
							<GotoStep>RxPdoLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckAlreadyTested">
					<!--Check if module already tested-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllModuleIdents.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleAlreadyTested.boolAlreadyChecked</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="5" Level="Verbose" Param0="CheckModuleAlreadyTested.boolAlreadyChecked" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleAlreadyTested.boolAlreadyChecked == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleAlreadyTested.boolAlreadyChecked</Value1>
							<Value2>true</Value2>
							<GotoStep>RxPdoLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_MODULES">
					<!--Print Module Ident-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="6" Level="Verbose" Param0="ModuleCounter" Param1="strXmlValue">Module[{0}]: Ident: {1}</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="Check_extOD_FileRef">
					<CallTestFunction Name="CheckForExtRefDict">
						<Parameter>ext_ModuleXmlFile</Parameter>
						<Parameter>ext_XPathModuleIdent</Parameter>
						<Parameter>ModuleCounter</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="InitSubItemLoopCounter">
					<!--Init of nested loop counter for RxPdo of current module-->
					<SetVariable Target="i32TmpModuleIndex">1</SetVariable>
				</TestStep>
				<TestStep Name="SMAssignLoopStart">
					<!--__Loop START for current module RxPdo__-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/RxPdo[{2}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>RxPdoLoopEnd</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>RxPdoLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="LOOPSTART">
					<!--Dump loop start info-->
				</TestStep>
				<TestStep>
					<!--Check if Referenced SM are valid-->
					<CallTestFunction Name="CheckModuleRxPdoSmAssignment_gen">
						<Parameter>ext_ModuleXmlFile</Parameter>
						<Parameter>ext_XPathModuleIdent</Parameter>
						<Parameter>ModuleCounter</Parameter>
						<Parameter>i32TmpModuleIndex</Parameter>
						<OutParameter>TmpResult</OutParameter>
					</CallTestFunction>
				</TestStep>
				<TestStep>
					<!--update result-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<SetVariable Target="AtLeastOneModuleFound">true</SetVariable>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>TmpResult</Value1>
							<Value2>false</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="LOOPEND">
					<!--__END of "SMAssignLoopStart", increment loop counter__-->
					<SetVariable Target="i32TmpModuleIndex">i32TmpModuleIndex + 1</SetVariable>
					<!--goto loop header by default-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>SMAssignLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="RxPdoLoopEnd">
					<!--__END of "ModuleLoopStart", add ModuleIdent to tested Array__-->
					<AddArrayItem TargetArray="AllModuleIdents.Uint32Array">AllModuleIdents.Uint32</AddArrayItem>
				</TestStep>
				<TestStep>
					<!--Increment loop counter-->
					<SetVariable Target="ModuleCounter">ModuleCounter + 1</SetVariable>
					<!--goto loop header by default-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>ModuleLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="FileLoopEnd">
					<!--Increment file counter-->
					<SetVariable Target="ext_ModuleXmlFile.FileCounter">ext_ModuleXmlFile.FileCounter + 1</SetVariable>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>FileLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_END">
					<!--dump test result-->
					<Compare>
						<Equal>
							<Value1>AtLeastOneModuleFound</Value1>
							<Value2>false</Value2>
							<SkipCase Id="7">No SM Assignment in RxPdo found.</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>false</Value2>
							<RaiseError Id="8">Test RxPdo(s) Sm assignment failed</RaiseError>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>true</Value2>
							<ReturnSuccess Id="9">Test RxPdo(s) Sm assignment succeed.</ReturnSuccess>
						</Equal>
					</Compare>
				</TestStep>
			</TestCase>
			<TestCase Name="Check Pdo entry Data Types" CaseId="4">
				<?MAX_OUTPUT_ID 42?>
				<Description>
					<Purpose>Validation of all module RxPDO mapping entries of ESI file.</Purpose>
					<PreCondition>- RxPDO(s) shall be defined
</PreCondition>
					<Action>- checks entry count of each RxPdo element
- checks all existing entries of each defined RxPdo element
- compares the base data types to the bit length of each entry</Action>
					<PostCondition>- The DuT contains entries
- All DataType Entries shall provide the correct bit length</PostCondition>
					<References>
						<Reference Specification="ETG.2000" Chapter="5.6.7 Base Data Types"></Reference>
						<Reference Specification="ETG.5001"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="Toggle_LOC_EXT">
					<!--Flag for InitGlobalVariables for default XPaths of local or external file-->
					<SetVariable Target="LocExt_InitToggle">true</SetVariable>
					<WriteLine Id="0" Level="Output">Checking for external file with modules</WriteLine>
				</TestStep>
				<TestStep Name="SkipNoSlots">
					<!--Skip Test if "CurrentConfig.SlotCount" == 0-->
					<Compare>
						<Equal>
							<Value1>CurrentConfig.SlotCount</Value1>
							<Value2>0</Value2>
							<SkipCase Id="1">Test skipped. No slots defined.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="SkipSoE">
					<!--Skip Test if SoE Device-->
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Mailbox.SoE</Value1>
							<Value2>true</Value2>
							<SkipCase Id="2">Test skipped for SoE Devices.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="INIT_AVAIL_GLOB_ARRAY">
					<CallTestFunction Name="AvailableDuTModuleIdents"></CallTestFunction>
				</TestStep>
				<TestStep Name="InitGlobalVariables">
					<!--Init global XPaths-->
					<CallTestFunction Name="InitGlobalVariablesForModuleODTest">
						<Parameter>LocExt_InitToggle</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="FileLoopStart">
					<GetXmlValue ReturnValue="ext_ModuleXmlFile" Markup="false">
						<XPath Param0="ext_ModuleXmlFile.XPath" Param1="ext_ModuleXmlFile.FileCounter">{0}[{1}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>ext_ModuleXmlFile</Value1>
							<Value2>null</Value2>
							<GotoStep>ReturnTestResult</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>ext_ModuleXmlFile</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>ReturnTestResult</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="3" Level="Output" Param0="ext_ModuleXmlFile">Checking external module file: {0}</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="INIT_MODULE_COUNTER">
					<!--"ModuleCounter" = 1-->
					<SetVariable Target="ModuleCounter">1</SetVariable>
				</TestStep>
				<TestStep Name="CHECK_IF_EXISTS">
					<!--Checking if module exist-->
					<Compare>
						<Equal>
							<Value1>ext_XPathModuleIdent</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>FileLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="InitTestedArray">
					<!--Array of already processed modules, no doubles-->
					<InitArray TargetArray="AllModuleIdents.Uint32Array"></InitArray>
				</TestStep>
				<TestStep Name="ModuleLoopStart">
					<!--__Loop START for EXTERNAL Modules__-->
				</TestStep>
				<TestStep Name="CHECK_IF_MODULE_EXISTS">
					<!--Checking if module exist-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>FileLoopEnd</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>FileLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_AVAILABLE_MDL">
					<!--Get ModuleIdent and Flag to SKIP testing of assigned modules-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="AllModuleIdents.Uint32">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>TestAvailableMdls</Value1>
							<Value2>false</Value2>
							<GotoStep>TEST_MODULES</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckItemInArray">
					<!--Check if module in list of assigned modules-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllAvailableDuTModules.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleInArray.boolAssigned</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="4" Level="Verbose" Param0="CheckModuleInArray.boolAssigned" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleInArray.boolAssigned == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleInArray.boolAssigned</Value1>
							<Value2>false</Value2>
							<GotoStep>GoToCheckNextModule</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckAlreadyTested">
					<!--Check if module already tested-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllModuleIdents.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleAlreadyTested.boolAlreadyChecked</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="5" Level="Verbose" Param0="CheckModuleAlreadyTested.boolAlreadyChecked" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleAlreadyTested.boolAlreadyChecked == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleAlreadyTested.boolAlreadyChecked</Value1>
							<Value2>true</Value2>
							<GotoStep>GoToCheckNextModule</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_MODULES">
					<!--Print Module Ident-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="6" Level="Verbose" Param0="ModuleCounter" Param1="strXmlValue">Module[{0}]: Ident: {1}</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="Check_extOD_FileRef">
					<CallTestFunction Name="CheckForExtRefDict">
						<Parameter>ext_ModuleXmlFile</Parameter>
						<Parameter>ext_XPathModuleIdent</Parameter>
						<Parameter>ModuleCounter</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="INIT_RXPDO_COUNTER">
					<!--Init of 1. nested loop counter for RxPdo of current module-->
					<SetVariable Target="i32TmpRxPdoIndex">1</SetVariable>
				</TestStep>
				<TestStep Name="RxPdoLoopStart">
					<!--__Loop START for current module RxPdo__-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpRxPdoIndex">{0}[{1}]/RxPdo[{2}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>GoToCheckNextModule</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>GoToCheckNextModule</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="INIT_ENTRY_COUNTER">
					<!--Init of 2. nested loop counter for RxPdo entries of current module-->
					<SetVariable Target="i32TmpEntryIndex">1</SetVariable>
				</TestStep>
				<TestStep Name="EntryLoopStart">
					<!--__Loop START for current module RxPdo entry__-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpRxPdoIndex" Param3="i32TmpEntryIndex">{0}[{1}]/RxPdo[{2}]/Entry[{3}]/Index</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="7" Level="Output" Param0="ModuleCounter" Param1="i32TmpRxPdoIndex" Param2="i32TmpEntryIndex" Param3="strXmlValue">Module[{0}]/RxPdo[{1}]/Entry[{2}]: {3}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>GetAndWriteResult</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>GetAndWriteResult</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="WriteDescPdoObject">
					<!--Dump testing info-->
					<Description Id="8" Level="Verbose" Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpRxPdoIndex" Param3="i32TmpEntryIndex">Checking {3}. entry of {0}[{1}]/RxPdo[{2}]...</Description>
				</TestStep>
				<TestStep Name="CheckIsGap">
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.Index.Uint16">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpRxPdoIndex" Param3="i32TmpEntryIndex">{0}[{1}]/RxPdo[{2}]/Entry[{3}]/Index</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="9" Level="Output" Param0="strXmlValue.Index.Uint16">Value of "strXmlValue.Index.Uint16": {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>strXmlValue.Index.Uint16</Value1>
							<Value2>0</Value2>
							<GotoStep>CheckIfArrayBaseDataType</GotoStep>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="WriteGapEntry">
					<!--Dump gap entry info-->
					<WriteLine Id="10" Level="Verbose" Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpRxPdoIndex" Param3="i32TmpEntryIndex">{0}[{1}]/RxPdo[{2}]/Entry[{3}] is a gap entry.</WriteLine>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>IncrementEntryIndex</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckIfArrayBaseDataType">
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.EntryDT.String">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpRxPdoIndex" Param3="i32TmpEntryIndex">{0}[{1}]/RxPdo[{2}]/Entry[{3}]/DataType</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="11" Level="Output" Param0="strXmlValue.EntryDT.String">Value of "strXmlValue.EntryDT.String": {0}</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<!--Call test function "CheckForValidArrayDataTYpe"-->
					<CallTestFunction Name="CheckForValidArrayDataType">
						<Parameter>strXmlValue.EntryDT.String</Parameter>
						<OutParameter>boolComplexType</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="12" Level="Output" Param0="boolComplexType">Check is Array: {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>boolComplexType</Value1>
							<Value2>true</Value2>
							<GotoStep>CheckIfArrayBitLengthLarger31B</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckBaseDataTypeBitLen">
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.BitLen.Uint32">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpRxPdoIndex" Param3="i32TmpEntryIndex">{0}[{1}]/RxPdo[{2}]/Entry[{3}]/BitLen</XPath>
					</GetXmlValue>
				</TestStep>
				<TestStep>
					<!--Call test function "BaseDataType.CheckSize"-->
					<CallTestFunction Name="BaseDataType.CheckSize">
						<Parameter>strXmlValue.BitLen.Uint32</Parameter>
						<Parameter>strXmlValue.EntryDT.String</Parameter>
						<OutParameter>StringBaseTypeErrorString</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="13" Level="Output" Param0="strXmlValue.BitLen.Uint32" Param1="strXmlValue.EntryDT.String">Checked BitLength: {0} vs DataType: {1}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="14" Level="Output" Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpRxPdoIndex" Param3="i32TmpEntryIndex">Checked BaseDataType Length of {0}[{1}]/RxPdo[{2}]/Entry[{3}]</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>StringBaseTypeErrorString</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>WriteBaseDataTypeError</GotoStep>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="IncrementDataTypeSuccessfullCounter">
					<!--Successful counter-->
					<SetVariable Target="uint16SuccCount">uint16SuccCount+1</SetVariable>
					<WriteLine Id="15" Level="Verbose" Param0="i32TmpRxPdoIndex" Param1="i32TmpEntryIndex" Param2="strXmlValue.EntryDT.String" Param3="strXmlValue.BitLen.Uint32">Entry RxPdo[{0}]/Entry[{1}] has the DataType {2} and the right BitLength ({3}).</WriteLine>
				</TestStep>
				<TestStep Name="IncrementTestedCounter">
					<!--Tested values counter-->
					<SetVariable Target="uint16TestedValues">uint16TestedValues+1</SetVariable>
				</TestStep>
				<TestStep Name="GoToNextEntry">
					<!--__END of "EntryLoopStart"__-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>IncrementEntryIndex</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="WriteBaseDataTypeError">
					<!--Dump Error message for DT-->
					<WriteLine Id="16" Level="Error" Param0="i32TmpRxPdoIndex" Param1="i32TmpEntryIndex" Param2="StringBaseTypeErrorString">RxPdo[{0}]/Entry[{1}]: {2}</WriteLine>
				</TestStep>
				<TestStep Name="IncrementGeneralCounter">
					<!--General Error counter-->
					<SetVariable Target="uint16Errors">uint16Errors+1</SetVariable>
				</TestStep>
				<TestStep Name="IncrementDataTypeErrorCounter">
					<!--DT error Counter-->
					<SetVariable Target="uint16ErrCount">uint16ErrCount+1</SetVariable>
				</TestStep>
				<TestStep Name="IncrementEntryIndex">
					<!--Increment 2. nested loop counter for "EntryLoopStart"-->
					<SetVariable Target="i32TmpEntryIndex">i32TmpEntryIndex+1</SetVariable>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>EntryLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="GetAndWriteResult">
					<!--dump test results-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="17" Level="Output" Param0="uint16SuccCount" Param1="uint16ErrCount">uint16SuccCount: {0} and uint16ErrCount: {1}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>uint16ErrCount</Value1>
							<Value2>0</Value2>
							<WriteLine Id="18" Level="Output" Param0="ModuleCounter" Param1="i32TmpRxPdoIndex" Param2="uint16SuccCount" Param3="uint16ErrCount">PDO object Module[{0}]/RxPdo[{1}]: {3} Entry data type(s) do not match to the expected bit length. {2} data type(s) match to the right bit length.</WriteLine>
						</NotEqual>
					</Compare>
					<Compare>
						<Equal>
							<Value1>(uint16SuccCount+uint16ErrCount)</Value1>
							<Value2>0</Value2>
							<WriteLine Id="19" Level="Output" Param0="i32TmpRxPdoIndex" Param1="i32TmpEntryIndex">RxPdo[{0}]/Entry[{1}]: No entry data type checked.</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>(uint16SuccCount+uint16ErrCount)</Value1>
							<Value2>0</Value2>
							<GotoStep>IncrementRxPdoIndex</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>uint16ErrCount</Value1>
							<Value2>0</Value2>
							<WriteLine Id="20" Level="Output" Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpRxPdoIndex" Param3="uint16SuccCount">PDO object {0}[{1}]/RxPdo[{2}]: All entry data type(s) ({3}) match to the expected bit length.</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="IncrementRxPdoIndex">
					<!--Increment 1. nested loop counter for "RxPdoLoopStart"-->
					<SetVariable Target="i32TmpRxPdoIndex">i32TmpRxPdoIndex+1</SetVariable>
				</TestStep>
				<TestStep Name="ResetSuccessCountForNextPdo">
					<!--Reset Successful counter-->
					<SetVariable Target="uint16SuccCount">0</SetVariable>
				</TestStep>
				<TestStep Name="ResetErrorCountForNextPdo">
					<!--Reset DT Error counter-->
					<SetVariable Target="uint16ErrCount">0</SetVariable>
				</TestStep>
				<TestStep Name="GoToCheckNextPdo">
					<!--__END of "RxPdoLoopStart"__-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>RxPdoLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="GoToCheckNextModule">
					<!--__END of "ModuleLoopStart", add ModuleIdent to tested Array__-->
					<AddArrayItem TargetArray="AllModuleIdents.Uint32Array">AllModuleIdents.Uint32</AddArrayItem>
				</TestStep>
				<TestStep>
					<!--Increment loop counter-->
					<SetVariable Target="ModuleCounter">ModuleCounter+1</SetVariable>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>ModuleLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="FileLoopEnd">
					<!--Increment file counter-->
					<SetVariable Target="ext_ModuleXmlFile.FileCounter">ext_ModuleXmlFile.FileCounter + 1</SetVariable>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>FileLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="ReturnTestResult">
					<!--The "uint16TestedValues" is not increased for Gap/padding entries. Total number of entries tested is different from total entries present in the ESI, Module file.-->
					<Compare>
						<Greater>
							<Value1>uint16Errors</Value1>
							<Value2>0</Value2>
							<RaiseError Id="42"></RaiseError>
						</Greater>
					</Compare>
					<Compare>
						<Equal>
							<Value1>uint16TestedValues</Value1>
							<Value2>0</Value2>
							<SkipCase Id="22">Skipped case: No entry found.</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<ReturnSuccess Id="23" Param0="uint16TestedValues">All ({0}) entr(y/ies) of RxPDO object(s) match to the right bit length (Gap entries excluded).</ReturnSuccess>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckIfArrayBitLengthLarger31B">
					<!--31B == 248 bit-->
					<SetVariable Target="int32SavedSubIndex">i32TmpEntryIndex</SetVariable>
				</TestStep>
				<TestStep>
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.BitLen.Uint32">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpRxPdoIndex" Param3="i32TmpEntryIndex">{0}[{1}]/RxPdo[{2}]/Entry[{3}]/BitLen</XPath>
					</GetXmlValue>
				</TestStep>
				<TestStep>
					<SetVariable Target="Uint32ArrayBitLength">strXmlValue.BitLen.Uint32</SetVariable>
				</TestStep>
				<TestStep Name="CheckArrayIfSplittedBitSize">
					<SetVariable Target="i32TmpEntryIndex">i32TmpEntryIndex+1</SetVariable>
				</TestStep>
				<TestStep>
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.EntryNmmr.String">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpRxPdoIndex" Param3="i32TmpEntryIndex">{0}[{1}]/RxPdo[{2}]/Entry[{3}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="24" Level="Output" Param0="strXmlValue.EntryNmmr.String">Value of "strXmlValue.EntryNmmr.String": {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="25" Level="Output" Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpRxPdoIndex" Param3="i32TmpEntryIndex">{0}[{1}]/RxPdo[{2}]/Entry[{3}]</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue.EntryNmmr.String</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>ResetSubIndexAndGoBack</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue.EntryNmmr.String</Value1>
							<Value2>null</Value2>
							<GotoStep>ResetSubIndexAndGoBack</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.EntryIndex.Uint16">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpRxPdoIndex" Param3="i32TmpEntryIndex">{0}[{1}]/RxPdo[{2}]/Entry[{3}]/Index</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="26" Level="Output" Param0="strXmlValue.EntryIndex.Uint16">Value of "strXmlValue.EntryIndex.Uint16": {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>strXmlValue.EntrySubindex.Uint16</Value1>
							<Value2>0</Value2>
							<GotoStep>ResetSubIndexAndGoBack</GotoStep>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep>
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.EntrySubindex.Uint16">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpRxPdoIndex" Param3="i32TmpEntryIndex">{0}[{1}]/RxPdo[{2}]/Entry[{3}]/SubIndex</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="27" Level="Output" Param0="strXmlValue.EntrySubindex.Uint16">Value of "strXmlValue.EntrySubindex.Uint16": {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>strXmlValue.EntrySubindex.Uint16</Value1>
							<Value2>0</Value2>
							<GotoStep>ResetSubIndexAndGoBack</GotoStep>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="EndOf_CheckArrayIfSplittedBitSize">
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="28" Level="Verbose">Checking for split Array.</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Greater>
							<Value1>strXmlValue.BitLen.Uint32</Value1>
							<Value2>240</Value2>
							<WriteLine Id="29" Level="Warning" Param0="strXmlValue.BitLen.Uint32">Bit length of {0} is invalid. A Bit length greater than 240 Bits is not allowed.</WriteLine>
						</Greater>
					</Compare>
				</TestStep>
				<TestStep Name="CheckIfArrayEnd">
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.EntryNmmr.String">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpRxPdoIndex" Param3="i32TmpEntryIndex">{0}[{1}]/RxPdo[{2}]/Entry[{3}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue.EntryNmmr.String</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>DecreaseSubIndexAndCheckArrayDataTypeBitSize</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue.EntryNmmr.String</Value1>
							<Value2>null</Value2>
							<GotoStep>DecreaseSubIndexAndCheckArrayDataTypeBitSize</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.EntryIndex.Uint16">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpRxPdoIndex" Param3="i32TmpEntryIndex">{0}[{1}]/RxPdo[{2}]/Entry[{3}]/Index</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue.EntryIndex.Uint16</Value1>
							<Value2>null</Value2>
							<GotoStep>DecreaseSubIndexAndCheckArrayDataTypeBitSize</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>strXmlValue.EntryIndex.Uint16</Value1>
							<Value2>0</Value2>
							<GotoStep>DecreaseSubIndexAndCheckArrayDataTypeBitSize</GotoStep>
						</NotEqual>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue.EntryIndex.Uint16</Value1>
							<Value2>0</Value2>
							<GotoStep>CheckIfArrayEnd_Continue</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.EntrySubindex.Uint16">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpRxPdoIndex" Param3="i32TmpEntryIndex">{0}[{1}]/RxPdo[{2}]/Entry[{3}]/SubIndex</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue.EntrySubindex.Uint16</Value1>
							<Value2>null</Value2>
							<GotoStep>DecreaseSubIndexAndCheckArrayDataTypeBitSize</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>strXmlValue.EntrySubindex.Uint16</Value1>
							<Value2>0</Value2>
							<GotoStep>DecreaseSubIndexAndCheckArrayDataTypeBitSize</GotoStep>
						</NotEqual>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue.EntrySubindex.Uint16</Value1>
							<Value2>0</Value2>
							<GotoStep>CheckIfArrayEnd_Continue</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckIfArrayEnd_Continue">
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.EntryBitLenCopy.Uint32">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpRxPdoIndex" Param3="i32TmpEntryIndex">{0}[{1}]/RxPdo[{2}]/Entry[{3}]/BitLen</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="30" Level="Verbose">Checking if Array ended.</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="31" Level="Verbose" Param0="i32TmpEntryIndex">i32TmpEntryIndex == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="32" Level="Verbose" Param0="strXmlValue.EntryIndex.Uint16">strXmlValue.EntryIndex.Uint16 == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="33" Level="Verbose" Param0="strXmlValue.EntrySubindex.Uint16">strXmlValue.EntrySubindex.Uint16 == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Greater>
							<Value1>strXmlValue.EntryBitLenCopy.Uint32</Value1>
							<Value2>240</Value2>
							<WriteLine Id="34" Level="Warning" Param0="strXmlValue.EntryBitLenCopy.Uint32">Bit length of {0} is invalid. A Bit length greater than 240 Bits is not allowed.</WriteLine>
						</Greater>
					</Compare>
				</TestStep>
				<TestStep>
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.EntryDTSave.String">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpRxPdoIndex" Param3="int32SavedSubIndex">{0}[{1}]/RxPdo[{2}]/Entry[{3}]/DataType</XPath>
					</GetXmlValue>
				</TestStep>
				<TestStep>
					<CallTestFunction Name="BaseDataType.CheckSize">
						<Parameter>Uint32ArrayBitLength</Parameter>
						<Parameter>strXmlValue.EntryDTSave.String</Parameter>
						<OutParameter>StringBaseTypeErrorString</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="35" Level="Verbose" Param0="StringBaseTypeErrorString">StringBaseTypeErrorString = {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>StringBaseTypeErrorString</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>DecreaseSubIndexAndCheckArrayDataTypeBitSize</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<SetVariable Target="Uint32ArrayBitLength">Uint32ArrayBitLength+strXmlValue.EntryBitLenCopy.Uint32</SetVariable>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="36" Level="Verbose" Param0="Uint32ArrayBitLength">Uint32ArrayBitLength == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>strXmlValue.EntryBitLenCopy.Uint32</Value1>
							<Value2>240</Value2>
							<GotoStep>CheckArrayDataTypeBitSize</GotoStep>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep>
					<SetVariable Target="i32TmpEntryIndex">i32TmpEntryIndex+1</SetVariable>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>CheckIfArrayEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="DecreaseSubIndexAndCheckArrayDataTypeBitSize">
					<SetVariable Target="i32TmpEntryIndex">i32TmpEntryIndex-1</SetVariable>
				</TestStep>
				<TestStep Name="CheckArrayDataTypeBitSize">
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.EntryDTSave.String">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpRxPdoIndex" Param3="int32SavedSubIndex">{0}[{1}]/RxPdo[{2}]/Entry[{3}]/DataType</XPath>
					</GetXmlValue>
				</TestStep>
				<TestStep>
					<CallTestFunction Name="BaseDataType.CheckSize">
						<Parameter>Uint32ArrayBitLength</Parameter>
						<Parameter>strXmlValue.EntryDTSave.String</Parameter>
						<OutParameter>StringBaseTypeErrorString</OutParameter>
					</CallTestFunction>
					<Compare>
						<NotEqual>
							<Value1>StringBaseTypeErrorString</Value1>
							<Value2>EmptyString</Value2>
							<WriteLine Id="37" Level="Error" Param0="i32TmpRxPdoIndex" Param1="int32SavedSubIndex+1" Param2="StringBaseTypeErrorString">RxPdo[{0}]/Entry[{1}]: {2}</WriteLine>
						</NotEqual>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>StringBaseTypeErrorString</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>IncrementGeneralCounter</GotoStep>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="WriteArrayDataTypeBitLengthSuccess">
					<SetVariable Target="uint16SuccCount">uint16SuccCount+1</SetVariable>
					<WriteLine Id="38" Level="Verbose" Param0="i32TmpRxPdoIndex" Param1="int32SavedSubIndex+1" Param2="strXmlValue.EntryDTSave.String" Param3="Uint32ArrayBitLength">RxPdo[{0}]/Entry[{1}] has the DataType {2} and the right BitLength ({3}).</WriteLine>
				</TestStep>
				<TestStep Name="CheckNextEntryWithDataType">
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>IncrementTestedCounter</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="ResetSubIndexAndGoBack">
					<SetVariable Target="i32TmpEntryIndex">int32SavedSubIndex</SetVariable>
				</TestStep>
				<TestStep>
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.EntryBitLenCopy2.Uint32">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpRxPdoIndex" Param3="i32TmpEntryIndex">{0}[{1}]/RxPdo[{2}]/Entry[{3}]/BitLen</XPath>
					</GetXmlValue>
				</TestStep>
				<TestStep>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="39" Level="Output" Param0="strXmlValue.EntryBitLenCopy2.Uint32">Value of "strXmlValue.EntryBitLenCopy2.Uint32": {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="40" Level="Output" Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpRxPdoIndex" Param3="i32TmpEntryIndex">{0}[{1}]/RxPdo[{2}]/Entry[{3}]/BitLen</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.EntryDTCopy.String">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpRxPdoIndex" Param3="i32TmpEntryIndex">{0}[{1}]/RxPdo[{2}]/Entry[{3}]/DataType</XPath>
					</GetXmlValue>
				</TestStep>
				<TestStep>
					<Compare>
						<Greater>
							<Value1>strXmlValue.EntryBitLenCopy2.Uint32</Value1>
							<Value2>255</Value2>
							<WriteLine Id="41" Level="Output" Param0="strXmlValue.EntryBitLenCopy2.Uint32" Param1="strXmlValue.EntryDTCopy.String">BitSize ({0}) of data type '{1}' is greater than 255.</WriteLine>
						</Greater>
					</Compare>
					<Compare>
						<Greater>
							<Value1>strXmlValue.EntryBitLenCopy2.Uint32</Value1>
							<Value2>255</Value2>
							<SetVariable Target="StringBaseTypeErrorString" Param0="strXmlValue.EntryBitLenCopy2.Uint32" Param1="strXmlValue.EntryDTCopy.String">BitSize ({0}) of data type '{1}' shall not be greater than 255.</SetVariable>
						</Greater>
					</Compare>
					<Compare>
						<Greater>
							<Value1>strXmlValue.EntryBitLenCopy2.Uint32</Value1>
							<Value2>255</Value2>
							<GotoStep>WriteBaseDataTypeError</GotoStep>
						</Greater>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>CheckBaseDataTypeBitLen</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
			</TestCase>
			<TestCase Name="Check Pdo Exclude" CaseId="5">
				<?MAX_OUTPUT_ID 11?>
				<Description>
					<Purpose>Validate .Exclude element of module RxPdo</Purpose>
					<PreCondition>The device description contains at least one RxPDO element.</PreCondition>
					<Action>Check RxPDOs included in .Exclude</Action>
					<PostCondition>Each excluded RxPDO shall exclude the current RxPDO</PostCondition>
					<References>
						<Reference Specification="ETG.2000"></Reference>
						<Reference Specification="ETG.5001"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="Toggle_LOC_EXT">
					<!--Flag for InitGlobalVariables for default XPaths of local or external file-->
					<SetVariable Target="LocExt_InitToggle">true</SetVariable>
					<WriteLine Id="0" Level="Output">Checking for external file with modules</WriteLine>
				</TestStep>
				<TestStep Name="SkipNoSlots">
					<!--Skip Test if "CurrentConfig.SlotCount" == 0-->
					<Compare>
						<Equal>
							<Value1>CurrentConfig.SlotCount</Value1>
							<Value2>0</Value2>
							<SkipCase Id="1">Test skipped. No slots defined.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="SkipSoE">
					<!--Skip Test if SoE Device-->
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Mailbox.SoE</Value1>
							<Value2>true</Value2>
							<SkipCase Id="2">Test skipped for SoE Devices.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="INIT_AVAIL_GLOB_ARRAY">
					<CallTestFunction Name="AvailableDuTModuleIdents"></CallTestFunction>
				</TestStep>
				<TestStep Name="InitGlobalVariables">
					<!--Init global XPaths-->
					<CallTestFunction Name="InitGlobalVariablesForModuleODTest">
						<Parameter>LocExt_InitToggle</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="INIT_RESULT">
					<!--"result" = true-->
					<SetVariable Target="result">true</SetVariable>
				</TestStep>
				<TestStep Name="FileLoopStart">
					<GetXmlValue ReturnValue="ext_ModuleXmlFile" Markup="false">
						<XPath Param0="ext_ModuleXmlFile.XPath" Param1="ext_ModuleXmlFile.FileCounter">{0}[{1}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>ext_ModuleXmlFile</Value1>
							<Value2>null</Value2>
							<GotoStep>ReturnTestResult</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>ext_ModuleXmlFile</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>ReturnTestResult</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="3" Level="Output" Param0="ext_ModuleXmlFile">Checking external module file: {0}</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="INIT_MODULE_COUNTER">
					<!--"ModuleCounter" = 1-->
					<SetVariable Target="ModuleCounter">1</SetVariable>
				</TestStep>
				<TestStep Name="CHECK_IF_EXISTS">
					<!--Checking if module exist-->
					<Compare>
						<Equal>
							<Value1>ext_XPathModuleIdent</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>FileLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="InitTestedArray">
					<!--Array of already processed modules, no doubles-->
					<InitArray TargetArray="AllModuleIdents.Uint32Array"></InitArray>
				</TestStep>
				<TestStep Name="ModuleLoopStart">
					<!--__Loop START for EXTERNAL Modules__-->
				</TestStep>
				<TestStep Name="CHECK_IF_MODULE_EXISTS">
					<!--Checking if module exist-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>FileLoopEnd</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>FileLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_AVAILABLE_MDL">
					<!--Get ModuleIdent and Flag to SKIP testing of assigned modules-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="AllModuleIdents.Uint32">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>TestAvailableMdls</Value1>
							<Value2>false</Value2>
							<GotoStep>TEST_MODULES</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckItemInArray">
					<!--Check if module in list of assigned modules-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllAvailableDuTModules.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleInArray.boolAssigned</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="4" Level="Verbose" Param0="CheckModuleInArray.boolAssigned" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleInArray.boolAssigned == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleInArray.boolAssigned</Value1>
							<Value2>false</Value2>
							<GotoStep>GoToCheckNextModule</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckAlreadyTested">
					<!--Check if module already tested-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllModuleIdents.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleAlreadyTested.boolAlreadyChecked</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="5" Level="Verbose" Param0="CheckModuleAlreadyTested.boolAlreadyChecked" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleAlreadyTested.boolAlreadyChecked == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleAlreadyTested.boolAlreadyChecked</Value1>
							<Value2>true</Value2>
							<GotoStep>GoToCheckNextModule</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_MODULES">
					<!--Print Module Ident-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="6" Level="Verbose" Param0="ModuleCounter" Param1="strXmlValue">Module[{0}]: Ident: {1}</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="Check_extOD_FileRef">
					<CallTestFunction Name="CheckForExtRefDict">
						<Parameter>ext_ModuleXmlFile</Parameter>
						<Parameter>ext_XPathModuleIdent</Parameter>
						<Parameter>ModuleCounter</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="INIT_RXPDO_COUNTER">
					<!--Init of nested loop counter for RxPdo of current module-->
					<SetVariable Target="i32TmpRxPdoIndex">1</SetVariable>
				</TestStep>
				<TestStep Name="RxPdoLoopStart">
					<!--__Loop START for current module RxPdo__-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpRxPdoIndex">{0}[{1}]/RxPdo[{2}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>GoToCheckNextModule</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>GoToCheckNextModule</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.Index.Uint16">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpRxPdoIndex">{0}[{1}]/RxPdo[{2}]/Index</XPath>
					</GetXmlValue>
					<Compare>
						<NotEqual>
							<Value1>strXmlValue.Index.Uint16</Value1>
							<Value2>0</Value2>
							<GotoStep>LOOPSTART</GotoStep>
						</NotEqual>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue.Index.Uint16</Value1>
							<Value2>null</Value2>
							<GotoStep>GoToCheckNextModule</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue.Index.Uint16</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>GoToCheckNextModule</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="LOOPSTART">
					<!--Dump loop start info-->
					<WriteLine Id="7" Level="Output" Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpRxPdoIndex" Param3="strXmlValue.Index.Uint16">Checking Exclude element of {0}[{1}]/RxPdo[{2}] : 0x{3:x4}.</WriteLine>
				</TestStep>
				<TestStep>
					<!--Check if current Exclude element is valid-->
					<CallTestFunction Name="CheckRxPdoExcludeElement_gen">
						<Parameter>ext_ModuleXmlFile</Parameter>
						<Parameter>ext_XPathModuleIdent</Parameter>
						<Parameter>ModuleCounter</Parameter>
						<Parameter>i32TmpRxPdoIndex</Parameter>
						<OutParameter>TmpResult</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<SetVariable Target="AtLeastOneModuleFound">true</SetVariable>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>TmpResult</Value1>
							<Value2>false</Value2>
							<WriteLine Id="8" Level="Output" Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpRxPdoIndex">Exclude information of {0}[{1}]/RxPdo[{2}] are invalid.</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<!--update result-->
					<Compare>
						<Equal>
							<Value1>TmpResult</Value1>
							<Value2>false</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="LOOPEND">
					<!--__END of "RxPdoLoopStart", increment loop counter__-->
					<SetVariable Target="i32TmpRxPdoIndex">i32TmpRxPdoIndex + 1</SetVariable>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>RxPdoLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="GoToCheckNextModule">
					<!--__END of "ModuleLoopStart", add ModuleIdent to tested Array__-->
					<AddArrayItem TargetArray="AllModuleIdents.Uint32Array">AllModuleIdents.Uint32</AddArrayItem>
				</TestStep>
				<TestStep>
					<!--increment module-->
					<SetVariable Target="ModuleCounter">ModuleCounter+1</SetVariable>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>ModuleLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="FileLoopEnd">
					<!--Increment file counter-->
					<SetVariable Target="ext_ModuleXmlFile.FileCounter">ext_ModuleXmlFile.FileCounter + 1</SetVariable>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>FileLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="ReturnTestResult">
					<!--dump test result-->
					<Compare>
						<Equal>
							<Value1>AtLeastOneModuleFound</Value1>
							<Value2>false</Value2>
							<SkipCase Id="9">No RxPdo.Exclude found.</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>false</Value2>
							<RaiseError Id="10">Test RxPdo.Exclude failed</RaiseError>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>true</Value2>
							<ReturnSuccess Id="11">Test RxPdo.Exclude succeed.</ReturnSuccess>
						</Equal>
					</Compare>
				</TestStep>
			</TestCase>
		</TestGroup>
		<TestGroup GroupId="202" Name="(External) Module TxPdo Tests">
			<Comment>Check the correct usage and values of the TxPDO elements for modules defined within an external file</Comment>
			<TestCase Name="Check Attributes" CaseId="1">
				<?MAX_OUTPUT_ID 28?>
				<Description>
					<Purpose>Correct usage of module TxPdo attributes</Purpose>
					<PreCondition>The device description includes module object dictionary defined within an external module file, it contains at least one TxPdo element.</PreCondition>
					<Action>1. @Su
2. @Fixed
3. @OSFac,@OSMin,@OSMax,@OSIndexInc</Action>
					<PostCondition>1. if @Su defined a matching FMMU shall be referenced
2. if @Fixed is true at least one entry should be defined
3. if defined @OSxxx shall be greater/equal 0
   and @OSMin less/equal @OSFac greater/equal @OSMax</PostCondition>
					<References>
						<Reference Specification="ETG.2000"></Reference>
						<Reference Specification="ETG.5001"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="Toggle_LOC_EXT">
					<!--Flag for InitGlobalVariables for default XPaths of local or external file-->
					<SetVariable Target="LocExt_InitToggle">true</SetVariable>
					<WriteLine Id="0" Level="Output">Checking for external file with modules</WriteLine>
				</TestStep>
				<TestStep Name="SkipNoSlots">
					<!--Skip Test if "CurrentConfig.SlotCount" == 0-->
					<Compare>
						<Equal>
							<Value1>CurrentConfig.SlotCount</Value1>
							<Value2>0</Value2>
							<SkipCase Id="1">Test skipped. No slots defined.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="SkipSoE">
					<!--Skip Test if SoE Device-->
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Mailbox.SoE</Value1>
							<Value2>true</Value2>
							<SkipCase Id="2">Test skipped for SoE Devices.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="INIT_AVAIL_GLOB_ARRAY">
					<CallTestFunction Name="AvailableDuTModuleIdents"></CallTestFunction>
				</TestStep>
				<TestStep Name="InitGlobalVariables">
					<!--Init global XPaths-->
					<CallTestFunction Name="InitGlobalVariablesForModuleODTest">
						<Parameter>LocExt_InitToggle</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="INIT_RESULT">
					<!--"result" = true-->
					<SetVariable Target="result">true</SetVariable>
				</TestStep>
				<TestStep Name="FileLoopStart">
					<GetXmlValue ReturnValue="ext_ModuleXmlFile" Markup="false">
						<XPath Param0="ext_ModuleXmlFile.XPath" Param1="ext_ModuleXmlFile.FileCounter">{0}[{1}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>ext_ModuleXmlFile</Value1>
							<Value2>null</Value2>
							<GotoStep>TEST_END</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>ext_ModuleXmlFile</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>TEST_END</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="3" Level="Output" Param0="ext_ModuleXmlFile">Checking external module file: {0}</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="INIT_LOOP_COUNTER">
					<!--"ModuleCounter" = 1-->
					<SetVariable Target="ModuleCounter">1</SetVariable>
				</TestStep>
				<TestStep Name="CHECK_IF_EXISTS">
					<!--Checking if module exist-->
					<Compare>
						<Equal>
							<Value1>ext_XPathModuleIdent</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>FileLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="InitTestedArray">
					<!--Array of already processed modules, no doubles-->
					<InitArray TargetArray="AllModuleIdents.Uint32Array"></InitArray>
				</TestStep>
				<TestStep Name="ModuleLoopStart">
					<!--__Loop START for EXTERNAL Modules__-->
				</TestStep>
				<TestStep Name="CHECK_IF_MODULE_EXISTS">
					<!--Checking if module exist-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>FileLoopEnd</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>FileLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_AVAILABLE_MDL">
					<!--Get ModuleIdent and Flag to SKIP testing of assigned modules-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="AllModuleIdents.Uint32">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>TestAvailableMdls</Value1>
							<Value2>false</Value2>
							<GotoStep>TEST_MODULES</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckItemInArray">
					<!--Check if module in list of assigned modules-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllAvailableDuTModules.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleInArray.boolAssigned</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="4" Level="Verbose" Param0="CheckModuleInArray.boolAssigned" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleInArray.boolAssigned == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleInArray.boolAssigned</Value1>
							<Value2>false</Value2>
							<GotoStep>TxPdoLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckAlreadyTested">
					<!--Check if module already tested-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllModuleIdents.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleAlreadyTested.boolAlreadyChecked</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="5" Level="Verbose" Param0="CheckModuleAlreadyTested.boolAlreadyChecked" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleAlreadyTested.boolAlreadyChecked == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleAlreadyTested.boolAlreadyChecked</Value1>
							<Value2>true</Value2>
							<GotoStep>TxPdoLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_MODULES">
					<!--Print Module Ident-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="6" Level="Verbose" Param0="ModuleCounter" Param1="strXmlValue">Module[{0}]: Ident: {1}</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="Check_extOD_FileRef">
					<CallTestFunction Name="CheckForExtRefDict">
						<Parameter>ext_ModuleXmlFile</Parameter>
						<Parameter>ext_XPathModuleIdent</Parameter>
						<Parameter>ModuleCounter</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="InitSubItemLoopCounter">
					<!--Init of nested loop counter for TxPdo of current module-->
					<SetVariable Target="i32TmpModuleIndex">1</SetVariable>
				</TestStep>
				<TestStep Name="AttributeLoopStart">
					<!--__Loop START for current module TxPdo__-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/TxPdo[{2}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>TxPdoLoopEnd</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>TxPdoLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<!--Check if TxPdo@Su is defined-->
					<Description Id="7" Level="Output">Check @Su attribute.</Description>
					<!--Skip Su test if Sm is not defined-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/TxPdo[{2}]/@Sm</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<WriteLine Id="8" Level="Verbose" Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">Skip Su test because default Sm not defined ({0}[{1}]/TxPdo[{2}]/@Sm not defined).</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<WriteLine Id="9" Level="Verbose" Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">Skip Su test because default Sm not defined ({0}[{1}]/TxPdo[{2}]/@Sm not defined).</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>TEST_OS_INDEXINC</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>TEST_OS_INDEXINC</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<!--Skip Su test if Su is not defined-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/TxPdo[{2}]/@Su</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<WriteLine Id="10" Level="Verbose" Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/TxPdo[{2}]/@Su not defined.</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<WriteLine Id="11" Level="Verbose" Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/TxPdo[{2}]/@Su not defined.</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>TEST_OS_INDEXINC</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>TEST_OS_INDEXINC</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<WriteLine Id="12" Level="Output" Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">Check if {0}[{1}]/TxPdo[{2}]/@Su reference a valid Fmmu.</WriteLine>
				</TestStep>
				<TestStep>
					<!--Convert to Uint16-->
					<SetVariable Target="strXmlValue.Su.Uint16">strXmlValue</SetVariable>
				</TestStep>
				<TestStep>
					<!--Get Referenced Fmmu-->
					<CallTestFunction Name="GetFmmuBySu">
						<Parameter>strXmlValue.Su.Uint16</Parameter>
						<Parameter>Inputs</Parameter>
						<OutParameter>i32TmpIndex</OutParameter>
					</CallTestFunction>
				</TestStep>
				<TestStep>
					<!--Check if FMMU exists-->
					<Compare>
						<Lower>
							<Value1>i32TmpIndex</Value1>
							<Value2>0</Value2>
							<WriteLine Id="13" Level="Error" Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/TxPdo[{2}]/@Su doesn't reference an existing/matching Fmmu.</WriteLine>
						</Lower>
					</Compare>
					<Compare>
						<Lower>
							<Value1>i32TmpIndex</Value1>
							<Value2>0</Value2>
							<SetVariable Target="AtLeastOneModuleFound">true</SetVariable>
						</Lower>
					</Compare>
					<Compare>
						<Lower>
							<Value1>i32TmpIndex</Value1>
							<Value2>0</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Lower>
					</Compare>
					<Compare>
						<Lower>
							<Value1>i32TmpIndex</Value1>
							<Value2>0</Value2>
							<GotoStep>TEST_OS_INDEXINC</GotoStep>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_OS_INDEXINC">
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/TxPdo[{2}]/@OSIndexInc</XPath>
					</GetXmlValue>
				</TestStep>
				<TestStep>
					<!--Convert to Int32-->
					<SetVariable Target="strXmlValue.OSIndexInc.Int32">strXmlValue</SetVariable>
				</TestStep>
				<TestStep>
					<!--Check TxPdo@OSIndexInc-->
					<Description Id="14" Level="Output">Check @OSxxxx attributes.</Description>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>TEST_OS_MIN</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>TEST_OS_MIN</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Lower>
							<Value1>strXmlValue.OSIndexInc.Int32</Value1>
							<Value2>0</Value2>
							<WriteLine Id="15" Level="Error" Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex" Param3="strXmlValue.OSIndexInc.Int32">{0}[{1}]/TxPdo[{2}]/@OSIndexInc shall be &gt;= 0 (current value : {3})</WriteLine>
						</Lower>
					</Compare>
					<Compare>
						<Lower>
							<Value1>strXmlValue.OSIndexInc.Int32</Value1>
							<Value2>0</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_OS_MIN">
					<!--Get TxPdo@OSMin-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValueOSMin">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/TxPdo[{2}]/@OSMin</XPath>
					</GetXmlValue>
				</TestStep>
				<TestStep>
					<!--Get TxPdo@OSFac-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValueOSFac">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/TxPdo[{2}]/@OSFac</XPath>
					</GetXmlValue>
				</TestStep>
				<TestStep>
					<!--Get TxPdo@OSMax-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValueOSMax">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/TxPdo[{2}]/@OSMax</XPath>
					</GetXmlValue>
				</TestStep>
				<TestStep>
					<!--Convert to Int32-->
					<SetVariable Target="strXmlValue.OSMin.Int32">strXmlValueOSMin</SetVariable>
				</TestStep>
				<TestStep>
					<!--Convert to Int32-->
					<SetVariable Target="strXmlValue.OSFac.Int32">strXmlValueOSFac</SetVariable>
				</TestStep>
				<TestStep>
					<!--Convert to Int32-->
					<SetVariable Target="strXmlValue.OSMax.Int32">strXmlValueOSMax</SetVariable>
				</TestStep>
				<TestStep>
					<!--Check TxPdo@OSMin-->
					<Compare>
						<Equal>
							<Value1>strXmlValueOSMin</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>TEST_OS_FAC</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValueOSMin</Value1>
							<Value2>null</Value2>
							<GotoStep>TEST_OS_FAC</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<SetVariable Target="AtLeastOneModuleFound">true</SetVariable>
						</Equal>
					</Compare>
					<Compare>
						<Lower>
							<Value1>strXmlValue.OSMin.Int32</Value1>
							<Value2>0</Value2>
							<WriteLine Id="16" Level="Error" Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex" Param3="strXmlValue.OSMin.Int32">{0}[{1}]/TxPdo[{2}]/@OSMin shall be &gt;= 0 (current value : {3})</WriteLine>
						</Lower>
					</Compare>
					<Compare>
						<Lower>
							<Value1>strXmlValue.OSMin.Int32</Value1>
							<Value2>0</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Lower>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValueOSFac</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>TEST_OS_FAC</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValueOSFac</Value1>
							<Value2>null</Value2>
							<GotoStep>TEST_OS_FAC</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<SetVariable Target="AtLeastOneModuleFound">true</SetVariable>
						</Equal>
					</Compare>
					<Compare>
						<Lower>
							<Value1>strXmlValue.OSFac.Int32</Value1>
							<Value2>strXmlValue.OSMin.Int32</Value2>
							<WriteLine Id="17" Level="Error" Param0="ModuleCounter" Param1="i32TmpModuleIndex" Param2="strXmlValue.OSMin.Int32" Param3="strXmlValue.OSFac.Int32">EtherCATModule/Modules/Module[{0}]/TxPdo[{1}]/@OSMin: (current value : {2}) shall be less or equal OSFac (current value : {3})</WriteLine>
						</Lower>
					</Compare>
					<Compare>
						<Lower>
							<Value1>strXmlValue.OSFac.Int32</Value1>
							<Value2>strXmlValue.OSMin.Int32</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_OS_FAC">
					<!--Check TxPdo@OSFac-->
					<Compare>
						<Equal>
							<Value1>strXmlValueOSFac</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>TEST_OS_MAX</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValueOSFac</Value1>
							<Value2>null</Value2>
							<GotoStep>TEST_OS_MAX</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<SetVariable Target="AtLeastOneModuleFound">true</SetVariable>
						</Equal>
					</Compare>
					<Compare>
						<Lower>
							<Value1>strXmlValue.OSFac.Int32</Value1>
							<Value2>0</Value2>
							<WriteLine Id="18" Level="Error" Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex" Param3="strXmlValue.OSFac.Int32">{0}[{1}]/TxPdo[{2}]/@OSFac shall be &gt;= 0 (current value : {3})</WriteLine>
						</Lower>
					</Compare>
					<Compare>
						<Lower>
							<Value1>strXmlValue.OSFac.Int32</Value1>
							<Value2>0</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Lower>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValueOSMax</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>TEST_OS_MAX</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValueOSMax</Value1>
							<Value2>null</Value2>
							<GotoStep>TEST_OS_MAX</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<SetVariable Target="AtLeastOneModuleFound">true</SetVariable>
						</Equal>
					</Compare>
					<Compare>
						<Greater>
							<Value1>strXmlValue.OSFac.Int32</Value1>
							<Value2>strXmlValue.OSMax.Int32</Value2>
							<WriteLine Id="19" Level="Error" Param0="ModuleCounter" Param1="i32TmpModuleIndex" Param2="strXmlValue.OSMax.Int32" Param3="strXmlValue.OSFac.Int32">EtherCATModule/Modules/Module[{0}]/TxPdo[{1}] OSMax (current value : {2}) shall be greater or equal OSFac (current value : {3})</WriteLine>
						</Greater>
					</Compare>
					<Compare>
						<Greater>
							<Value1>strXmlValue.OSFac.Int32</Value1>
							<Value2>strXmlValue.OSMax.Int32</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Greater>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_OS_MAX">
					<!--Check TxPdo@OSMax-->
					<Compare>
						<Equal>
							<Value1>strXmlValueOSMax</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>TEST_FIXED_FLAG</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValueOSMax</Value1>
							<Value2>null</Value2>
							<GotoStep>TEST_FIXED_FLAG</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<SetVariable Target="AtLeastOneModuleFound">true</SetVariable>
						</Equal>
					</Compare>
					<Compare>
						<Lower>
							<Value1>strXmlValue.OSMax.Int32</Value1>
							<Value2>0</Value2>
							<WriteLine Id="20" Level="Error" Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex" Param3="strXmlValue.OSMax.Int32">{0}[{1}]/TxPdo[{2}]/@OSMax shall be &gt;= 0 (current value : {3})</WriteLine>
						</Lower>
					</Compare>
					<Compare>
						<Lower>
							<Value1>strXmlValue.OSMax.Int32</Value1>
							<Value2>0</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Lower>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValueOSMin</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>TEST_FIXED_FLAG</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValueOSMin</Value1>
							<Value2>null</Value2>
							<GotoStep>TEST_FIXED_FLAG</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<SetVariable Target="AtLeastOneModuleFound">true</SetVariable>
						</Equal>
					</Compare>
					<Compare>
						<Greater>
							<Value1>strXmlValue.OSMin.Int32</Value1>
							<Value2>strXmlValue.OSMax.Int32</Value2>
							<WriteLine Id="21" Level="Error" Param0="ModuleCounter" Param1="i32TmpModuleIndex" Param2="strXmlValue.OSMin.Int32" Param3="strXmlValue.OSMax.Int32">EtherCATModule/Modules/Module[{0}]/TxPdo[{1}]  OSMin (current value : {2}) shall be less or equal OSMax (current value : {3})</WriteLine>
						</Greater>
					</Compare>
					<Compare>
						<Greater>
							<Value1>strXmlValue.OSMin.Int32</Value1>
							<Value2>strXmlValue.OSMax.Int32</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Greater>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_FIXED_FLAG">
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValueFixed.Bool">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/TxPdo[{2}]/@Fixed</XPath>
					</GetXmlValue>
				</TestStep>
				<TestStep>
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="true" ReturnValue="strXmlValueEntries">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/TxPdo[{2}]/Entry</XPath>
					</GetXmlValue>
				</TestStep>
				<TestStep>
					<!--If Entries defined the fixed flag doesn't need to be checked-->
					<Description Id="22" Level="Output">Check @Fixed attribute.</Description>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="23" Level="Verbose" Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex" Param3="strXmlValueFixed.Bool">{0}[{1}]/TxPdo[{2}]: Fixed flag == {3}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="24" Level="Verbose" Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex" Param3="strXmlValueEntries">{0}[{1}]/TxPdo[{2}]/Entry: {3}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValueEntries</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>FIXED_FLAG</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValueEntries</Value1>
							<Value2>null</Value2>
							<GotoStep>FIXED_FLAG</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>LOOPEND</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="FIXED_FLAG">
					<!--If no entries defined fixed flag shall be false-->
					<Compare>
						<Equal>
							<Value1>strXmlValueFixed.Bool</Value1>
							<Value2>true</Value2>
							<WriteLine Id="25" Level="Warning" Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/TxPdo[{2}]: Fixed flag should not be set if no entry is defined.</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<SetVariable Target="AtLeastOneModuleFound">true</SetVariable>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="LOOPEND">
					<!--__END of "AttributeLoopStart", increment loop counter__-->
					<SetVariable Target="i32TmpModuleIndex">i32TmpModuleIndex + 1</SetVariable>
					<!--goto loop header by default-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>AttributeLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TxPdoLoopEnd">
					<!--__END of "ModuleLoopStart", add ModuleIdent to tested Array__-->
					<AddArrayItem TargetArray="AllModuleIdents.Uint32Array">AllModuleIdents.Uint32</AddArrayItem>
				</TestStep>
				<TestStep>
					<!--Increment loop counter-->
					<SetVariable Target="ModuleCounter">ModuleCounter + 1</SetVariable>
					<!--goto loop header by default-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>ModuleLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="FileLoopEnd">
					<!--Increment file counter-->
					<SetVariable Target="ext_ModuleXmlFile.FileCounter">ext_ModuleXmlFile.FileCounter + 1</SetVariable>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>FileLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_END">
					<!--dump test result-->
					<Compare>
						<Equal>
							<Value1>AtLeastOneModuleFound</Value1>
							<Value2>false</Value2>
							<SkipCase Id="26">No Attributes in RxPdo found.</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>false</Value2>
							<RaiseError Id="27">Test TxPdo(s) attributes failed.</RaiseError>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>true</Value2>
							<ReturnSuccess Id="28">Test TxPdo(s) attributes succeed.</ReturnSuccess>
						</Equal>
					</Compare>
				</TestStep>
			</TestCase>
			<TestCase Name="Check Index" CaseId="2">
				<?MAX_OUTPUT_ID 14?>
				<Description>
					<Purpose>Correct module TxPdo index range</Purpose>
					<PreCondition>The device description includes module object dictionary defined within an external module file, it contains at least one TxPdo element.</PreCondition>
					<Action>Check @Index</Action>
					<PostCondition>@Index shall be between 0x1600 and 0x17FF</PostCondition>
					<References>
						<Reference Specification="ETG.2000"></Reference>
						<Reference Specification="ETG.1000"></Reference>
						<Reference Specification="ETG.5001"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="Toggle_LOC_EXT">
					<!--Flag for InitGlobalVariables for default XPaths of local or external file-->
					<SetVariable Target="LocExt_InitToggle">true</SetVariable>
					<WriteLine Id="0" Level="Output">Checking for external file with modules</WriteLine>
				</TestStep>
				<TestStep Name="SkipEmulation">
					<!--Skip Test for slave with device emulation-->
					<CallTestFunction Name="GetDeviceEmulationFlags">
						<!--if false the device emulation bit will be read out from the ESI file-->
						<Parameter>false</Parameter>
						<OutParameter>boolVar</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>boolVar</Value1>
							<Value2>true</Value2>
							<SkipCase Id="1">DuT is a simple device test skipped.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="SkipNoSlots">
					<!--Skip Test if "CurrentConfig.SlotCount" == 0-->
					<Compare>
						<Equal>
							<Value1>CurrentConfig.SlotCount</Value1>
							<Value2>0</Value2>
							<SkipCase Id="2">Test skipped. No slots defined.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="SkipSoE">
					<!--Skip Test if SoE Device-->
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Mailbox.SoE</Value1>
							<Value2>true</Value2>
							<SkipCase Id="3">Test skipped for SoE Devices.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="INIT_AVAIL_GLOB_ARRAY">
					<CallTestFunction Name="AvailableDuTModuleIdents"></CallTestFunction>
				</TestStep>
				<TestStep Name="InitGlobalVariables">
					<!--Init global XPaths-->
					<CallTestFunction Name="InitGlobalVariablesForModuleODTest">
						<Parameter>LocExt_InitToggle</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="INIT_RESULT">
					<!--"result" = true-->
					<SetVariable Target="result">true</SetVariable>
				</TestStep>
				<TestStep Name="FileLoopStart">
					<GetXmlValue ReturnValue="ext_ModuleXmlFile" Markup="false">
						<XPath Param0="ext_ModuleXmlFile.XPath" Param1="ext_ModuleXmlFile.FileCounter">{0}[{1}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>ext_ModuleXmlFile</Value1>
							<Value2>null</Value2>
							<GotoStep>TEST_END</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>ext_ModuleXmlFile</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>TEST_END</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="4" Level="Output" Param0="ext_ModuleXmlFile">Checking external module file: {0}</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="INIT_LOOP_COUNTER">
					<!--"ModuleCounter" = 1-->
					<SetVariable Target="ModuleCounter">1</SetVariable>
				</TestStep>
				<TestStep Name="CHECK_IF_EXISTS">
					<!--Checking if module exist-->
					<Compare>
						<Equal>
							<Value1>ext_XPathModuleIdent</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>FileLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="InitTestedArray">
					<!--Array of already processed modules, no doubles-->
					<InitArray TargetArray="AllModuleIdents.Uint32Array"></InitArray>
				</TestStep>
				<TestStep Name="ModuleLoopStart">
					<!--__Loop START for EXTERNAL Modules__-->
				</TestStep>
				<TestStep Name="CHECK_IF_MODULE_EXISTS">
					<!--Checking if module exist-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>FileLoopEnd</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>FileLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_AVAILABLE_MDL">
					<!--Get ModuleIdent and Flag to SKIP testing of assigned modules-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="AllModuleIdents.Uint32">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>TestAvailableMdls</Value1>
							<Value2>false</Value2>
							<GotoStep>TEST_MODULES</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckItemInArray">
					<!--Check if module in list of assigned modules-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllAvailableDuTModules.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleInArray.boolAssigned</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="5" Level="Verbose" Param0="CheckModuleInArray.boolAssigned" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleInArray.boolAssigned == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleInArray.boolAssigned</Value1>
							<Value2>false</Value2>
							<GotoStep>TxPdoLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckAlreadyTested">
					<!--Check if module already tested-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllModuleIdents.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleAlreadyTested.boolAlreadyChecked</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="6" Level="Verbose" Param0="CheckModuleAlreadyTested.boolAlreadyChecked" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleAlreadyTested.boolAlreadyChecked == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleAlreadyTested.boolAlreadyChecked</Value1>
							<Value2>true</Value2>
							<GotoStep>TxPdoLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_MODULES">
					<!--Print Module Ident-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="7" Level="Verbose" Param0="ModuleCounter" Param1="strXmlValue">Module[{0}]: Ident: {1}</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="Check_extOD_FileRef">
					<CallTestFunction Name="CheckForExtRefDict">
						<Parameter>ext_ModuleXmlFile</Parameter>
						<Parameter>ext_XPathModuleIdent</Parameter>
						<Parameter>ModuleCounter</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="InitSubItemLoopCounter">
					<!--Init of nested loop counter for TxPdo of current module-->
					<SetVariable Target="i32TmpModuleIndex">1</SetVariable>
				</TestStep>
				<TestStep Name="IndexLoopStart">
					<!--__Loop START for current module TxPdo__-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/TxPdo[{2}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>TxPdoLoopEnd</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>TxPdoLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="LOOPSTART">
					<!--Dump loop start info-->
				</TestStep>
				<TestStep>
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.Index.Uint16">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/TxPdo[{2}]/Index</XPath>
					</GetXmlValue>
				</TestStep>
				<TestStep>
					<!--Check if Index is less than 0x1A00-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<SetVariable Target="AtLeastOneModuleFound">true</SetVariable>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="8" Level="Output" Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex" Param3="strXmlValue.Index.Uint16">{0}[{1}]/TxPdo[{2}]/Index (0x{3:x4})</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Lower>
							<Value1>strXmlValue.Index.Uint16</Value1>
							<Value2>6656</Value2>
							<WriteLine Id="9" Level="Error" Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex" Param3="strXmlValue.Index.Uint16">{0}[{1}]/TxPdo[{2}]/Index (0x{3:x4}) shall be between 0x1A00 and 0x1BFF</WriteLine>
						</Lower>
					</Compare>
					<Compare>
						<Lower>
							<Value1>strXmlValue.Index.Uint16</Value1>
							<Value2>6656</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep>
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.Index.Uint16">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/TxPdo[{2}]/Index</XPath>
					</GetXmlValue>
				</TestStep>
				<TestStep>
					<!--Check if Index is greater than 0x1BFF-->
					<Compare>
						<Greater>
							<Value1>strXmlValue.Index.Uint16</Value1>
							<Value2>7167</Value2>
							<WriteLine Id="10" Level="Error" Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex" Param3="strXmlValue.Index.Uint16">{0}[{1}]/TxPdo[{2}]/Index (0x{3:x4}) shall be between 0x1A00 and 0x1BFF</WriteLine>
						</Greater>
					</Compare>
					<Compare>
						<Greater>
							<Value1>strXmlValue.Index.Uint16</Value1>
							<Value2>7167</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Greater>
					</Compare>
				</TestStep>
				<TestStep Name="LOOPEND">
					<!--__END of "IndexLoopStart", increment loop counter__-->
					<SetVariable Target="i32TmpModuleIndex">i32TmpModuleIndex + 1</SetVariable>
					<!--goto loop header by default-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>IndexLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TxPdoLoopEnd">
					<!--__END of "ModuleLoopStart", add ModuleIdent to tested Array__-->
					<AddArrayItem TargetArray="AllModuleIdents.Uint32Array">AllModuleIdents.Uint32</AddArrayItem>
				</TestStep>
				<TestStep>
					<!--Increment loop counter-->
					<SetVariable Target="ModuleCounter">ModuleCounter + 1</SetVariable>
					<!--goto loop header by default-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>ModuleLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="FileLoopEnd">
					<!--Increment file counter-->
					<SetVariable Target="ext_ModuleXmlFile.FileCounter">ext_ModuleXmlFile.FileCounter + 1</SetVariable>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>FileLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_END">
					<!--dump test result-->
					<Compare>
						<Equal>
							<Value1>AtLeastOneModuleFound</Value1>
							<Value2>false</Value2>
							<SkipCase Id="11">No Index in TxPdo found.</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>false</Value2>
							<RaiseError Id="14"></RaiseError>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>true</Value2>
							<ReturnSuccess Id="13">All TxPdo indices are valid.</ReturnSuccess>
						</Equal>
					</Compare>
				</TestStep>
			</TestCase>
			<TestCase Name="Check SM assignment" CaseId="3">
				<?MAX_OUTPUT_ID 9?>
				<Description>
					<Purpose>Correct SyncManager assignment for moduleTxPdos</Purpose>
					<PreCondition>The device description includes module object dictionary defined within an external module file, it contains at least one TxPdo element.</PreCondition>
					<Action>- @Mandatory == true
  test only @Sm
  1.) Is @Sm defined
  2.) Is .ExcludedSm defined
- @Mandatory == false
  iterate over all matching SyncManagers
  - referenced via @Sm
  - not excluded via .ExcludedSm
  - referenced via @Su

3.) @Sm match?
4.) Check @Virtual ?</Action>
					<PostCondition>1.) @Sm shall be defined
2.) .ExcludedSm should not be defined (the PDO is fixed assigned to @Sm)
3.) Directon/Type of shall @Sm match
4.) Valid if:
    - PDO is virtual AND SyncManager is virtual AND Entries defined
	- PDO is virtual AND SyncManager is not virtual and no Entries defined
    Error if SyncManager is @Sm else Warning

At least one valid SyncManager is defined.</PostCondition>
					<References>
						<Reference Specification="ETG.2000"></Reference>
						<Reference Specification="ETG.5001"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="Toggle_LOC_EXT">
					<!--Flag for InitGlobalVariables for default XPaths of local or external file-->
					<SetVariable Target="LocExt_InitToggle">true</SetVariable>
					<WriteLine Id="0" Level="Output">Checking for external file with modules</WriteLine>
				</TestStep>
				<TestStep Name="SkipNoSlots">
					<!--Skip Test if "CurrentConfig.SlotCount" == 0-->
					<Compare>
						<Equal>
							<Value1>CurrentConfig.SlotCount</Value1>
							<Value2>0</Value2>
							<SkipCase Id="1">Test skipped. No slots defined.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="SkipSoE">
					<!--Skip Test if SoE Device-->
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Mailbox.SoE</Value1>
							<Value2>true</Value2>
							<SkipCase Id="2">Test skipped for SoE Devices.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="INIT_AVAIL_GLOB_ARRAY">
					<CallTestFunction Name="AvailableDuTModuleIdents"></CallTestFunction>
				</TestStep>
				<TestStep Name="InitGlobalVariables">
					<!--Init global XPaths-->
					<CallTestFunction Name="InitGlobalVariablesForModuleODTest">
						<Parameter>LocExt_InitToggle</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="INIT_RESULT">
					<!--"result" = true-->
					<SetVariable Target="result">true</SetVariable>
				</TestStep>
				<TestStep Name="FileLoopStart">
					<GetXmlValue ReturnValue="ext_ModuleXmlFile" Markup="false">
						<XPath Param0="ext_ModuleXmlFile.XPath" Param1="ext_ModuleXmlFile.FileCounter">{0}[{1}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>ext_ModuleXmlFile</Value1>
							<Value2>null</Value2>
							<GotoStep>TEST_END</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>ext_ModuleXmlFile</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>TEST_END</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="3" Level="Output" Param0="ext_ModuleXmlFile">Checking external module file: {0}</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="INIT_LOOP_COUNTER">
					<!--"ModuleCounter" = 1-->
					<SetVariable Target="ModuleCounter">1</SetVariable>
				</TestStep>
				<TestStep Name="CHECK_IF_EXISTS">
					<!--Checking if module exist-->
					<Compare>
						<Equal>
							<Value1>ext_XPathModuleIdent</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>FileLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="InitTestedArray">
					<!--Array of already processed modules, no doubles-->
					<InitArray TargetArray="AllModuleIdents.Uint32Array"></InitArray>
				</TestStep>
				<TestStep Name="ModuleLoopStart">
					<!--__Loop START for EXTERNAL Modules__-->
				</TestStep>
				<TestStep Name="CHECK_IF_MODULE_EXISTS">
					<!--Checking if module exist-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>FileLoopEnd</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>FileLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_AVAILABLE_MDL">
					<!--Get ModuleIdent and Flag to SKIP testing of assigned modules-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="AllModuleIdents.Uint32">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>TestAvailableMdls</Value1>
							<Value2>false</Value2>
							<GotoStep>TEST_MODULES</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckItemInArray">
					<!--Check if module in list of assigned modules-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllAvailableDuTModules.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleInArray.boolAssigned</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="4" Level="Verbose" Param0="CheckModuleInArray.boolAssigned" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleInArray.boolAssigned == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleInArray.boolAssigned</Value1>
							<Value2>false</Value2>
							<GotoStep>TxPdoLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckAlreadyTested">
					<!--Check if module already tested-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllModuleIdents.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleAlreadyTested.boolAlreadyChecked</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="5" Level="Verbose" Param0="CheckModuleAlreadyTested.boolAlreadyChecked" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleAlreadyTested.boolAlreadyChecked == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleAlreadyTested.boolAlreadyChecked</Value1>
							<Value2>true</Value2>
							<GotoStep>TxPdoLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_MODULES">
					<!--Print Module Ident-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="6" Level="Verbose" Param0="ModuleCounter" Param1="strXmlValue">Module[{0}]: Ident: {1}</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="Check_extOD_FileRef">
					<CallTestFunction Name="CheckForExtRefDict">
						<Parameter>ext_ModuleXmlFile</Parameter>
						<Parameter>ext_XPathModuleIdent</Parameter>
						<Parameter>ModuleCounter</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="InitSubItemLoopCounter">
					<!--Init of nested loop counter for TxPdo of current module-->
					<SetVariable Target="i32TmpModuleIndex">1</SetVariable>
				</TestStep>
				<TestStep Name="SMAssignLoopStart">
					<!--__Loop START for current module TxPdo__-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/TxPdo[{2}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>TxPdoLoopEnd</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>TxPdoLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="LOOPSTART">
					<!--Dump loop start info-->
				</TestStep>
				<TestStep>
					<!--Check if Referenced SM are valid-->
					<CallTestFunction Name="CheckModuleTxPdoSmAssignment_gen">
						<Parameter>ext_ModuleXmlFile</Parameter>
						<Parameter>ext_XPathModuleIdent</Parameter>
						<Parameter>ModuleCounter</Parameter>
						<Parameter>i32TmpModuleIndex</Parameter>
						<OutParameter>TmpResult</OutParameter>
					</CallTestFunction>
				</TestStep>
				<TestStep>
					<!--update result-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<SetVariable Target="AtLeastOneModuleFound">true</SetVariable>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>TmpResult</Value1>
							<Value2>false</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="LOOPEND">
					<!--__END of "SMAssignLoopStart", increment loop counter__-->
					<SetVariable Target="i32TmpModuleIndex">i32TmpModuleIndex + 1</SetVariable>
					<!--goto loop header by default-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>SMAssignLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TxPdoLoopEnd">
					<!--__END of "ModuleLoopStart", add ModuleIdent to tested Array__-->
					<AddArrayItem TargetArray="AllModuleIdents.Uint32Array">AllModuleIdents.Uint32</AddArrayItem>
				</TestStep>
				<TestStep>
					<!--Increment loop counter-->
					<SetVariable Target="ModuleCounter">ModuleCounter + 1</SetVariable>
					<!--goto loop header by default-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>ModuleLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="FileLoopEnd">
					<!--Increment file counter-->
					<SetVariable Target="ext_ModuleXmlFile.FileCounter">ext_ModuleXmlFile.FileCounter + 1</SetVariable>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>FileLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_END">
					<!--dump test result-->
					<Compare>
						<Equal>
							<Value1>AtLeastOneModuleFound</Value1>
							<Value2>false</Value2>
							<SkipCase Id="7">No SM Assignment in TxPdo found.</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>false</Value2>
							<RaiseError Id="8">Test TxPdo(s) Sm assignment failed</RaiseError>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>true</Value2>
							<ReturnSuccess Id="9">Test TxPdo(s) Sm assignment succeed.</ReturnSuccess>
						</Equal>
					</Compare>
				</TestStep>
			</TestCase>
			<TestCase Name="Check Pdo entry Data Types" CaseId="4">
				<?MAX_OUTPUT_ID 42?>
				<Description>
					<Purpose>Validation of all module TxPdo mapping entries of ESI file.</Purpose>
					<PreCondition>The device description includes module object dictionary defined within an external module file, it contains at least one TxPdo element.</PreCondition>
					<Action>- checks entry count of each TxPdo element
- checks all existing entries of each defined TxPdo element
- compares the base data types to the bit length of each entry</Action>
					<PostCondition>- The DuT contains entries
- All DataType Entries shall provide the correct bit length</PostCondition>
					<References>
						<Reference Specification="ETG.2000" Chapter="5.6.7 Base Data Types"></Reference>
						<Reference Specification="ETG.5001"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="Toggle_LOC_EXT">
					<!--Flag for InitGlobalVariables for default XPaths of local or external file-->
					<SetVariable Target="LocExt_InitToggle">true</SetVariable>
					<WriteLine Id="0" Level="Output">Checking for external file with modules</WriteLine>
				</TestStep>
				<TestStep Name="SkipNoSlots">
					<!--Skip Test if "CurrentConfig.SlotCount" == 0-->
					<Compare>
						<Equal>
							<Value1>CurrentConfig.SlotCount</Value1>
							<Value2>0</Value2>
							<SkipCase Id="1">Test skipped. No slots defined.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="SkipSoE">
					<!--Skip Test if SoE Device-->
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Mailbox.SoE</Value1>
							<Value2>true</Value2>
							<SkipCase Id="2">Test skipped for SoE Devices.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="INIT_AVAIL_GLOB_ARRAY">
					<CallTestFunction Name="AvailableDuTModuleIdents"></CallTestFunction>
				</TestStep>
				<TestStep Name="InitGlobalVariables">
					<!--Init global XPaths-->
					<CallTestFunction Name="InitGlobalVariablesForModuleODTest">
						<Parameter>LocExt_InitToggle</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="FileLoopStart">
					<GetXmlValue ReturnValue="ext_ModuleXmlFile" Markup="false">
						<XPath Param0="ext_ModuleXmlFile.XPath" Param1="ext_ModuleXmlFile.FileCounter">{0}[{1}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>ext_ModuleXmlFile</Value1>
							<Value2>null</Value2>
							<GotoStep>ReturnTestResult</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>ext_ModuleXmlFile</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>ReturnTestResult</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="3" Level="Output" Param0="ext_ModuleXmlFile">Checking external module file: {0}</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="INIT_MODULE_COUNTER">
					<!--"ModuleCounter" = 1-->
					<SetVariable Target="ModuleCounter">1</SetVariable>
				</TestStep>
				<TestStep Name="CHECK_IF_EXISTS">
					<!--Checking if module exist-->
					<Compare>
						<Equal>
							<Value1>ext_XPathModuleIdent</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>FileLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="InitTestedArray">
					<!--Array of already processed modules, no doubles-->
					<InitArray TargetArray="AllModuleIdents.Uint32Array"></InitArray>
				</TestStep>
				<TestStep Name="ModuleLoopStart">
					<!--__Loop START for EXTERNAL Modules__-->
				</TestStep>
				<TestStep Name="CHECK_IF_MODULE_EXISTS">
					<!--Checking if module exist-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>FileLoopEnd</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>FileLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_AVAILABLE_MDL">
					<!--Get ModuleIdent and Flag to SKIP testing of assigned modules-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="AllModuleIdents.Uint32">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>TestAvailableMdls</Value1>
							<Value2>false</Value2>
							<GotoStep>TEST_MODULES</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckItemInArray">
					<!--Check if module in list of assigned modules-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllAvailableDuTModules.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleInArray.boolAssigned</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="4" Level="Verbose" Param0="CheckModuleInArray.boolAssigned" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleInArray.boolAssigned == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleInArray.boolAssigned</Value1>
							<Value2>false</Value2>
							<GotoStep>GoToCheckNextModule</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckAlreadyTested">
					<!--Check if module already tested-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllModuleIdents.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleAlreadyTested.boolAlreadyChecked</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="5" Level="Verbose" Param0="CheckModuleAlreadyTested.boolAlreadyChecked" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleAlreadyTested.boolAlreadyChecked == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleAlreadyTested.boolAlreadyChecked</Value1>
							<Value2>true</Value2>
							<GotoStep>GoToCheckNextModule</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_MODULES">
					<!--Print Module Ident-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="6" Level="Verbose" Param0="ModuleCounter" Param1="strXmlValue">Module[{0}]: Ident: {1}</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="Check_extOD_FileRef">
					<CallTestFunction Name="CheckForExtRefDict">
						<Parameter>ext_ModuleXmlFile</Parameter>
						<Parameter>ext_XPathModuleIdent</Parameter>
						<Parameter>ModuleCounter</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="INIT_TxPdo_COUNTER">
					<!--Init of 1. nested loop counter for TxPdo of current module-->
					<SetVariable Target="i32TmpTxPdoIndex">1</SetVariable>
				</TestStep>
				<TestStep Name="TxPdoLoopStart">
					<!--__Loop START for current module TxPdo__-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpTxPdoIndex">{0}[{1}]/TxPdo[{2}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>GoToCheckNextModule</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>GoToCheckNextModule</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="INIT_ENTRY_COUNTER">
					<!--Init of 2. nested loop counter for TxPdo entries of current module-->
					<SetVariable Target="i32TmpEntryIndex">1</SetVariable>
				</TestStep>
				<TestStep Name="EntryLoopStart">
					<!--__Loop START for current module TxPdo entry__-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpTxPdoIndex" Param3="i32TmpEntryIndex">{0}[{1}]/TxPdo[{2}]/Entry[{3}]/Index</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="7" Level="Output" Param0="ModuleCounter" Param1="i32TmpTxPdoIndex" Param2="i32TmpEntryIndex" Param3="strXmlValue">Module[{0}]/TxPdo[{1}]/Entry[{2}]: {3}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>GetAndWriteResult</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>GetAndWriteResult</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="WriteDescPdoObject">
					<!--Dump testing info-->
					<Description Id="8" Level="Verbose" Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpTxPdoIndex" Param3="i32TmpEntryIndex">Checking {3}. entry of {0}[{1}]/TxPdo[{2}]...</Description>
				</TestStep>
				<TestStep Name="CheckIsGap">
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.Index.Uint16">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpTxPdoIndex" Param3="i32TmpEntryIndex">{0}[{1}]/TxPdo[{2}]/Entry[{3}]/Index</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="9" Level="Output" Param0="strXmlValue.Index.Uint16">Value of "strXmlValue.Index.Uint16": {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>strXmlValue.Index.Uint16</Value1>
							<Value2>0</Value2>
							<GotoStep>CheckIfArrayBaseDataType</GotoStep>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="WriteGapEntry">
					<!--Dump gap entry info-->
					<WriteLine Id="10" Level="Verbose" Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpTxPdoIndex" Param3="i32TmpEntryIndex">{0}[{1}]/TxPdo[{2}]/Entry[{3}] is a gap entry.</WriteLine>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>IncrementEntryIndex</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckIfArrayBaseDataType">
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.EntryDT.String">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpTxPdoIndex" Param3="i32TmpEntryIndex">{0}[{1}]/TxPdo[{2}]/Entry[{3}]/DataType</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="11" Level="Output" Param0="strXmlValue.EntryDT.String">Value of "strXmlValue.EntryDT.String": {0}</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<!--Call test function "CheckForValidArrayDataTYpe"-->
					<CallTestFunction Name="CheckForValidArrayDataType">
						<Parameter>strXmlValue.EntryDT.String</Parameter>
						<OutParameter>boolComplexType</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="12" Level="Output" Param0="boolComplexType">Check is Array: {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>boolComplexType</Value1>
							<Value2>true</Value2>
							<GotoStep>CheckIfArrayBitLengthLarger31B</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckBaseDataTypeBitLen">
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.BitLen.Uint32">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpTxPdoIndex" Param3="i32TmpEntryIndex">{0}[{1}]/TxPdo[{2}]/Entry[{3}]/BitLen</XPath>
					</GetXmlValue>
				</TestStep>
				<TestStep>
					<!--Call test function "BaseDataType.CheckSize"-->
					<CallTestFunction Name="BaseDataType.CheckSize">
						<Parameter>strXmlValue.BitLen.Uint32</Parameter>
						<Parameter>strXmlValue.EntryDT.String</Parameter>
						<OutParameter>StringBaseTypeErrorString</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="13" Level="Output" Param0="strXmlValue.BitLen.Uint32" Param1="strXmlValue.EntryDT.String">Checked BitLength: {0} vs DataType: {1}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="14" Level="Output" Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpTxPdoIndex" Param3="i32TmpEntryIndex">Checked BaseDataType Length of {0}[{1}]/TxPdo[{2}]/Entry[{3}]</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>StringBaseTypeErrorString</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>WriteBaseDataTypeError</GotoStep>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="IncrementDataTypeSuccessfullCounter">
					<!--Successful counter-->
					<SetVariable Target="uint16SuccCount">uint16SuccCount+1</SetVariable>
					<WriteLine Id="15" Level="Verbose" Param0="i32TmpTxPdoIndex" Param1="i32TmpEntryIndex" Param2="strXmlValue.EntryDT.String" Param3="strXmlValue.BitLen.Uint32">Entry TxPdo[{0}]/Entry[{1}] has the DataType {2} and the right BitLength ({3}).</WriteLine>
				</TestStep>
				<TestStep Name="IncrementTestedCounter">
					<!--Tested values counter-->
					<SetVariable Target="uint16TestedValues">uint16TestedValues+1</SetVariable>
				</TestStep>
				<TestStep Name="GoToNextEntry">
					<!--__END of "EntryLoopStart"__-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>IncrementEntryIndex</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="WriteBaseDataTypeError">
					<!--Dump Error message for DT-->
					<WriteLine Id="16" Level="Error" Param0="i32TmpTxPdoIndex" Param1="i32TmpEntryIndex" Param2="StringBaseTypeErrorString">TxPdo[{0}]/Entry[{1}]: {2}</WriteLine>
				</TestStep>
				<TestStep Name="IncrementGeneralCounter">
					<!--General Error counter-->
					<SetVariable Target="uint16Errors">uint16Errors+1</SetVariable>
				</TestStep>
				<TestStep Name="IncrementDataTypeErrorCounter">
					<!--DT error Counter-->
					<SetVariable Target="uint16ErrCount">uint16ErrCount+1</SetVariable>
				</TestStep>
				<TestStep Name="IncrementEntryIndex">
					<!--Increment 2. nested loop counter for "EntryLoopStart"-->
					<SetVariable Target="i32TmpEntryIndex">i32TmpEntryIndex+1</SetVariable>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>EntryLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="GetAndWriteResult">
					<!--dump test results-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="17" Level="Output" Param0="uint16SuccCount" Param1="uint16ErrCount">uint16SuccCount: {0} and uint16ErrCount: {1}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>uint16ErrCount</Value1>
							<Value2>0</Value2>
							<WriteLine Id="18" Level="Output" Param0="ModuleCounter" Param1="i32TmpTxPdoIndex" Param2="uint16SuccCount" Param3="uint16ErrCount">PDO object Module[{0}]/TxPdo[{1}]: {3} Entry data type(s) do not match to the expected bit length. {2} data type(s) match to the right bit length.</WriteLine>
						</NotEqual>
					</Compare>
					<Compare>
						<Equal>
							<Value1>(uint16SuccCount+uint16ErrCount)</Value1>
							<Value2>0</Value2>
							<WriteLine Id="19" Level="Output" Param0="i32TmpTxPdoIndex" Param1="i32TmpEntryIndex">TxPdo[{0}]/Entry{1}: No entry data type checked.</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>(uint16SuccCount+uint16ErrCount)</Value1>
							<Value2>0</Value2>
							<GotoStep>IncrementTxPdoIndex</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>uint16ErrCount</Value1>
							<Value2>0</Value2>
							<WriteLine Id="20" Level="Output" Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpTxPdoIndex" Param3="uint16SuccCount">PDO object {0}[{1}]/TxPdo[{2}]: All entry data type(s) ({3}) match to the expected bit length.</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="IncrementTxPdoIndex">
					<!--Increment 1. nested loop counter for "TxPdoLoopStart"-->
					<SetVariable Target="i32TmpTxPdoIndex">i32TmpTxPdoIndex+1</SetVariable>
				</TestStep>
				<TestStep Name="ResetSuccessCountForNextPdo">
					<!--Reset Successful counter-->
					<SetVariable Target="uint16SuccCount">0</SetVariable>
				</TestStep>
				<TestStep Name="ResetErrorCountForNextPdo">
					<!--Reset DT Error counter-->
					<SetVariable Target="uint16ErrCount">0</SetVariable>
				</TestStep>
				<TestStep Name="GoToCheckNextPdo">
					<!--__END of "TxPdoLoopStart"__-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>TxPdoLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="GoToCheckNextModule">
					<!--__END of "ModuleLoopStart", add ModuleIdent to tested Array__-->
					<AddArrayItem TargetArray="AllModuleIdents.Uint32Array">AllModuleIdents.Uint32</AddArrayItem>
				</TestStep>
				<TestStep>
					<!--Increment loop counter-->
					<SetVariable Target="ModuleCounter">ModuleCounter+1</SetVariable>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>ModuleLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="FileLoopEnd">
					<!--Increment file counter-->
					<SetVariable Target="ext_ModuleXmlFile.FileCounter">ext_ModuleXmlFile.FileCounter + 1</SetVariable>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>FileLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="ReturnTestResult">
					<!--The "uint16TestedValues" is not increased for Gap/padding entries. Total number of entries tested is different from total entries present in the ESI, Module file.-->
					<Compare>
						<Greater>
							<Value1>uint16Errors</Value1>
							<Value2>0</Value2>
							<RaiseError Id="42"></RaiseError>
						</Greater>
					</Compare>
					<Compare>
						<Equal>
							<Value1>uint16TestedValues</Value1>
							<Value2>0</Value2>
							<SkipCase Id="22">Skipped case: No entry found.</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<ReturnSuccess Id="23" Param0="uint16TestedValues">All ({0}) entr(y/ies) of TxPdo object(s) match to the right bit length (Gap entries excluded).</ReturnSuccess>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckIfArrayBitLengthLarger31B">
					<!--31B == 248 bit-->
					<SetVariable Target="int32SavedSubIndex">i32TmpEntryIndex</SetVariable>
				</TestStep>
				<TestStep>
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.BitLen.Uint32">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpTxPdoIndex" Param3="i32TmpEntryIndex">{0}[{1}]/TxPdo[{2}]/Entry[{3}]/BitLen</XPath>
					</GetXmlValue>
				</TestStep>
				<TestStep>
					<SetVariable Target="Uint32ArrayBitLength">strXmlValue.BitLen.Uint32</SetVariable>
				</TestStep>
				<TestStep Name="CheckArrayIfSplittedBitSize">
					<SetVariable Target="i32TmpEntryIndex">i32TmpEntryIndex+1</SetVariable>
				</TestStep>
				<TestStep>
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.EntryNmmr.String">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpTxPdoIndex" Param3="i32TmpEntryIndex">{0}[{1}]/TxPdo[{2}]/Entry[{3}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="24" Level="Output" Param0="strXmlValue.EntryNmmr.String">Value of "strXmlValue.EntryNmmr.String": {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="25" Level="Output" Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpTxPdoIndex" Param3="i32TmpEntryIndex">{0}[{1}]/TxPdo[{2}]/Entry[{3}]</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue.EntryNmmr.String</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>ResetSubIndexAndGoBack</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue.EntryNmmr.String</Value1>
							<Value2>null</Value2>
							<GotoStep>ResetSubIndexAndGoBack</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.EntryIndex.Uint16">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpTxPdoIndex" Param3="i32TmpEntryIndex">{0}[{1}]/TxPdo[{2}]/Entry[{3}]/Index</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="26" Level="Output" Param0="strXmlValue.EntryIndex.Uint16">Value of "strXmlValue.EntryIndex.Uint16": {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>strXmlValue.EntryIndex.Uint16</Value1>
							<Value2>0</Value2>
							<GotoStep>ResetSubIndexAndGoBack</GotoStep>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep>
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.EntrySubindex.Uint16">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpTxPdoIndex" Param3="i32TmpEntryIndex">{0}[{1}]/TxPdo[{2}]/Entry[{3}]/SubIndex</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="27" Level="Output" Param0="strXmlValue.EntrySubindex.Uint16">Value of "strXmlValue.EntrySubindex.Uint16": {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>strXmlValue.EntrySubindex.Uint16</Value1>
							<Value2>0</Value2>
							<GotoStep>ResetSubIndexAndGoBack</GotoStep>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="EndOf_CheckArrayIfSplittedBitSize">
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="28" Level="Verbose">Checking for split Array.</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Greater>
							<Value1>strXmlValue.BitLen.Uint32</Value1>
							<Value2>240</Value2>
							<WriteLine Id="29" Level="Warning" Param0="strXmlValue.BitLen.Uint32">Bit length of {0} is invalid. A Bit length greater than 240 Bits is not allowed.</WriteLine>
						</Greater>
					</Compare>
				</TestStep>
				<TestStep Name="CheckIfArrayEnd">
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.EntryNmmr.String">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpTxPdoIndex" Param3="i32TmpEntryIndex">{0}[{1}]/TxPdo[{2}]/Entry[{3}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue.EntryNmmr.String</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>DecreaseSubIndexAndCheckArrayDataTypeBitSize</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue.EntryNmmr.String</Value1>
							<Value2>null</Value2>
							<GotoStep>DecreaseSubIndexAndCheckArrayDataTypeBitSize</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.EntryIndex.Uint16">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpTxPdoIndex" Param3="i32TmpEntryIndex">{0}[{1}]/TxPdo[{2}]/Entry[{3}]/Index</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue.EntryIndex.Uint16</Value1>
							<Value2>null</Value2>
							<GotoStep>DecreaseSubIndexAndCheckArrayDataTypeBitSize</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>strXmlValue.EntryIndex.Uint16</Value1>
							<Value2>0</Value2>
							<GotoStep>DecreaseSubIndexAndCheckArrayDataTypeBitSize</GotoStep>
						</NotEqual>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue.EntryIndex.Uint16</Value1>
							<Value2>0</Value2>
							<GotoStep>CheckIfArrayEnd_Continue</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.EntrySubindex.Uint16">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpTxPdoIndex" Param3="i32TmpEntryIndex">{0}[{1}]/TxPdo[{2}]/Entry[{3}]/SubIndex</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue.EntrySubindex.Uint16</Value1>
							<Value2>null</Value2>
							<GotoStep>DecreaseSubIndexAndCheckArrayDataTypeBitSize</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>strXmlValue.EntrySubindex.Uint16</Value1>
							<Value2>0</Value2>
							<GotoStep>DecreaseSubIndexAndCheckArrayDataTypeBitSize</GotoStep>
						</NotEqual>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue.EntrySubindex.Uint16</Value1>
							<Value2>0</Value2>
							<GotoStep>CheckIfArrayEnd_Continue</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckIfArrayEnd_Continue">
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.EntryBitLenCopy.Uint32">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpTxPdoIndex" Param3="i32TmpEntryIndex">{0}[{1}]/TxPdo[{2}]/Entry[{3}]/BitLen</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="30" Level="Verbose">Checking if Array ended.</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="31" Level="Verbose" Param0="i32TmpEntryIndex">i32TmpEntryIndex == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="32" Level="Verbose" Param0="strXmlValue.EntryIndex.Uint16">strXmlValue.EntryIndex.Uint16 == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="33" Level="Verbose" Param0="strXmlValue.EntrySubindex.Uint16">strXmlValue.EntrySubindex.Uint16 == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Greater>
							<Value1>strXmlValue.EntryBitLenCopy.Uint32</Value1>
							<Value2>240</Value2>
							<WriteLine Id="34" Level="Warning" Param0="strXmlValue.EntryBitLenCopy.Uint32">Bit length of {0} is invalid. A Bit length greater than 240 Bits is not allowed.</WriteLine>
						</Greater>
					</Compare>
				</TestStep>
				<TestStep>
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.EntryDTSave.String">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpTxPdoIndex" Param3="int32SavedSubIndex">{0}[{1}]/TxPdo[{2}]/Entry[{3}]/DataType</XPath>
					</GetXmlValue>
				</TestStep>
				<TestStep>
					<CallTestFunction Name="BaseDataType.CheckSize">
						<Parameter>Uint32ArrayBitLength</Parameter>
						<Parameter>strXmlValue.EntryDTSave.String</Parameter>
						<OutParameter>StringBaseTypeErrorString</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="35" Level="Verbose" Param0="StringBaseTypeErrorString">StringBaseTypeErrorString = {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>StringBaseTypeErrorString</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>DecreaseSubIndexAndCheckArrayDataTypeBitSize</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<SetVariable Target="Uint32ArrayBitLength">Uint32ArrayBitLength+strXmlValue.EntryBitLenCopy.Uint32</SetVariable>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="36" Level="Verbose" Param0="Uint32ArrayBitLength">Uint32ArrayBitLength == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>strXmlValue.EntryBitLenCopy.Uint32</Value1>
							<Value2>240</Value2>
							<GotoStep>CheckArrayDataTypeBitSize</GotoStep>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep>
					<SetVariable Target="i32TmpEntryIndex">i32TmpEntryIndex+1</SetVariable>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>CheckIfArrayEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="DecreaseSubIndexAndCheckArrayDataTypeBitSize">
					<SetVariable Target="i32TmpEntryIndex">i32TmpEntryIndex-1</SetVariable>
				</TestStep>
				<TestStep Name="CheckArrayDataTypeBitSize">
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.EntryDTSave.String">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpTxPdoIndex" Param3="int32SavedSubIndex">{0}[{1}]/TxPdo[{2}]/Entry[{3}]/DataType</XPath>
					</GetXmlValue>
				</TestStep>
				<TestStep>
					<CallTestFunction Name="BaseDataType.CheckSize">
						<Parameter>Uint32ArrayBitLength</Parameter>
						<Parameter>strXmlValue.EntryDTSave.String</Parameter>
						<OutParameter>StringBaseTypeErrorString</OutParameter>
					</CallTestFunction>
					<Compare>
						<NotEqual>
							<Value1>StringBaseTypeErrorString</Value1>
							<Value2>EmptyString</Value2>
							<WriteLine Id="37" Level="Error" Param0="i32TmpRxPdoIndex" Param1="int32SavedSubIndex+1" Param2="StringBaseTypeErrorString">RxPdo[{0}]/Entry[{1}]: {2}</WriteLine>
						</NotEqual>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>StringBaseTypeErrorString</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>IncrementGeneralCounter</GotoStep>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="WriteArrayDataTypeBitLengthSuccess">
					<SetVariable Target="uint16SuccCount">uint16SuccCount+1</SetVariable>
					<WriteLine Id="38" Level="Verbose" Param0="i32TmpTxPdoIndex" Param1="int32SavedSubIndex+1" Param2="strXmlValue.EntryDTSave.String" Param3="Uint32ArrayBitLength">TxPdo[{0}]/Entry{1} has the DataType {2} and the right BitLength ({3}).</WriteLine>
				</TestStep>
				<TestStep Name="CheckNextEntryWithDataType">
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>IncrementTestedCounter</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="ResetSubIndexAndGoBack">
					<SetVariable Target="i32TmpEntryIndex">int32SavedSubIndex</SetVariable>
				</TestStep>
				<TestStep>
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.EntryBitLenCopy2.Uint32">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpTxPdoIndex" Param3="i32TmpEntryIndex">{0}[{1}]/TxPdo[{2}]/Entry[{3}]/BitLen</XPath>
					</GetXmlValue>
				</TestStep>
				<TestStep>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="39" Level="Output" Param0="strXmlValue.EntryBitLenCopy2.Uint32">Value of "strXmlValue.EntryBitLenCopy2.Uint32": {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="40" Level="Output" Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpTxPdoIndex" Param3="i32TmpEntryIndex">{0}[{1}]/TxPdo[{2}]/Entry[{3}]/BitLen</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.EntryDTCopy.String">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpTxPdoIndex" Param3="i32TmpEntryIndex">{0}[{1}]/TxPdo[{2}]/Entry[{3}]/DataType</XPath>
					</GetXmlValue>
				</TestStep>
				<TestStep>
					<Compare>
						<Greater>
							<Value1>strXmlValue.EntryBitLenCopy2.Uint32</Value1>
							<Value2>255</Value2>
							<WriteLine Id="41" Level="Output" Param0="strXmlValue.EntryBitLenCopy2.Uint32" Param1="strXmlValue.EntryDTCopy.String">BitSize ({0}) of data type '{1}' is greater than 255.</WriteLine>
						</Greater>
					</Compare>
					<Compare>
						<Greater>
							<Value1>strXmlValue.EntryBitLenCopy2.Uint32</Value1>
							<Value2>255</Value2>
							<SetVariable Target="StringBaseTypeErrorString" Param0="strXmlValue.EntryBitLenCopy2.Uint32" Param1="strXmlValue.EntryDTCopy.String">BitSize ({0}) of data type '{1}' shall not be greater than 255.</SetVariable>
						</Greater>
					</Compare>
					<Compare>
						<Greater>
							<Value1>strXmlValue.EntryBitLenCopy2.Uint32</Value1>
							<Value2>255</Value2>
							<GotoStep>WriteBaseDataTypeError</GotoStep>
						</Greater>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>CheckBaseDataTypeBitLen</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
			</TestCase>
			<TestCase Name="Check Pdo Exclude" CaseId="5">
				<?MAX_OUTPUT_ID 11?>
				<Description>
					<Purpose>Validate .Exclude element of module TxPdo</Purpose>
					<PreCondition>The device description includes module object dictionary defined within an external module file, it contains at least one TxPdo element.</PreCondition>
					<Action>Check TxPdos included in .Exclude</Action>
					<PostCondition>Each excluded TxPdo shall exclude the current TxPdo</PostCondition>
					<References>
						<Reference Specification="ETG.2000"></Reference>
						<Reference Specification="ETG.5001"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="Toggle_LOC_EXT">
					<!--Flag for InitGlobalVariables for default XPaths of local or external file-->
					<SetVariable Target="LocExt_InitToggle">true</SetVariable>
					<WriteLine Id="0" Level="Output">Checking for external file with modules</WriteLine>
				</TestStep>
				<TestStep Name="SkipNoSlots">
					<!--Skip Test if "CurrentConfig.SlotCount" == 0-->
					<Compare>
						<Equal>
							<Value1>CurrentConfig.SlotCount</Value1>
							<Value2>0</Value2>
							<SkipCase Id="1">Test skipped. No slots defined.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="SkipSoE">
					<!--Skip Test if SoE Device-->
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Mailbox.SoE</Value1>
							<Value2>true</Value2>
							<SkipCase Id="2">Test skipped for SoE Devices.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="INIT_AVAIL_GLOB_ARRAY">
					<CallTestFunction Name="AvailableDuTModuleIdents"></CallTestFunction>
				</TestStep>
				<TestStep Name="InitGlobalVariables">
					<!--Init global XPaths-->
					<CallTestFunction Name="InitGlobalVariablesForModuleODTest">
						<Parameter>LocExt_InitToggle</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="INIT_RESULT">
					<!--"result" = true-->
					<SetVariable Target="result">true</SetVariable>
				</TestStep>
				<TestStep Name="FileLoopStart">
					<GetXmlValue ReturnValue="ext_ModuleXmlFile" Markup="false">
						<XPath Param0="ext_ModuleXmlFile.XPath" Param1="ext_ModuleXmlFile.FileCounter">{0}[{1}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>ext_ModuleXmlFile</Value1>
							<Value2>null</Value2>
							<GotoStep>ReturnTestResult</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>ext_ModuleXmlFile</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>ReturnTestResult</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="3" Level="Output" Param0="ext_ModuleXmlFile">Checking external module file: {0}</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="INIT_MODULE_COUNTER">
					<!--"ModuleCounter" = 1-->
					<SetVariable Target="ModuleCounter">1</SetVariable>
				</TestStep>
				<TestStep Name="CHECK_IF_EXISTS">
					<!--Checking if module exist-->
					<Compare>
						<Equal>
							<Value1>ext_XPathModuleIdent</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>FileLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="InitTestedArray">
					<!--Array of already processed modules, no doubles-->
					<InitArray TargetArray="AllModuleIdents.Uint32Array"></InitArray>
				</TestStep>
				<TestStep Name="ModuleLoopStart">
					<!--__Loop START for LOCAL Modules__-->
				</TestStep>
				<TestStep Name="CHECK_IF_MODULE_EXISTS">
					<!--Checking if module exist-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>FileLoopEnd</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>FileLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_AVAILABLE_MDL">
					<!--Get ModuleIdent and Flag to SKIP testing of assigned modules-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="AllModuleIdents.Uint32">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>TestAvailableMdls</Value1>
							<Value2>false</Value2>
							<GotoStep>TEST_MODULES</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckItemInArray">
					<!--Check if module in list of assigned modules-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllAvailableDuTModules.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleInArray.boolAssigned</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="4" Level="Verbose" Param0="CheckModuleInArray.boolAssigned" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleInArray.boolAssigned == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleInArray.boolAssigned</Value1>
							<Value2>false</Value2>
							<GotoStep>GoToCheckNextModule</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckAlreadyTested">
					<!--Check if module already tested-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllModuleIdents.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleAlreadyTested.boolAlreadyChecked</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="5" Level="Verbose" Param0="CheckModuleAlreadyTested.boolAlreadyChecked" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleAlreadyTested.boolAlreadyChecked == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleAlreadyTested.boolAlreadyChecked</Value1>
							<Value2>true</Value2>
							<GotoStep>GoToCheckNextModule</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_MODULES">
					<!--Print Module Ident-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="6" Level="Verbose" Param0="ModuleCounter" Param1="strXmlValue">Module[{0}]: Ident: {1}</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="Check_extOD_FileRef">
					<CallTestFunction Name="CheckForExtRefDict">
						<Parameter>ext_ModuleXmlFile</Parameter>
						<Parameter>ext_XPathModuleIdent</Parameter>
						<Parameter>ModuleCounter</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="INIT_TxPdo_COUNTER">
					<!--Init of nested loop counter for TxPdo of current module-->
					<SetVariable Target="i32TmpTxPdoIndex">1</SetVariable>
				</TestStep>
				<TestStep Name="TxPdoLoopStart">
					<!--__Loop START for current module TxPdo__-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpTxPdoIndex">{0}[{1}]/TxPdo[{2}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>GoToCheckNextModule</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>GoToCheckNextModule</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.Index.Uint16">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpTxPdoIndex">{0}[{1}]/TxPdo[{2}]/Index</XPath>
					</GetXmlValue>
					<Compare>
						<NotEqual>
							<Value1>strXmlValue.Index.Uint16</Value1>
							<Value2>0</Value2>
							<GotoStep>LOOPSTART</GotoStep>
						</NotEqual>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue.Index.Uint16</Value1>
							<Value2>null</Value2>
							<GotoStep>GoToCheckNextModule</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue.Index.Uint16</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>GoToCheckNextModule</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="LOOPSTART">
					<!--Dump loop start info-->
					<WriteLine Id="7" Level="Output" Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpTxPdoIndex" Param3="strXmlValue.Index.Uint16">Checking Exclude element of {0}[{1}]/TxPdo[{2}] : 0x{3:x4}.</WriteLine>
				</TestStep>
				<TestStep>
					<!--Check if current Exclude element is valid-->
					<CallTestFunction Name="CheckTxPdoExcludeElement_gen">
						<Parameter>ext_ModuleXmlFile</Parameter>
						<Parameter>ext_XPathModuleIdent</Parameter>
						<Parameter>ModuleCounter</Parameter>
						<Parameter>i32TmpTxPdoIndex</Parameter>
						<OutParameter>TmpResult</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<SetVariable Target="AtLeastOneModuleFound">true</SetVariable>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>TmpResult</Value1>
							<Value2>false</Value2>
							<WriteLine Id="8" Level="Output" Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpTxPdoIndex">Exclude information of {0}[{1}]/TxPdo[{2}] are invalid.</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep>
					<!--update result-->
					<Compare>
						<Equal>
							<Value1>TmpResult</Value1>
							<Value2>false</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="LOOPEND">
					<!--__END of "TxPdoLoopStart", increment loop counter__-->
					<SetVariable Target="i32TmpTxPdoIndex">i32TmpTxPdoIndex + 1</SetVariable>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>TxPdoLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="GoToCheckNextModule">
					<!--__END of "ModuleLoopStart", add ModuleIdent to tested Array__-->
					<AddArrayItem TargetArray="AllModuleIdents.Uint32Array">AllModuleIdents.Uint32</AddArrayItem>
				</TestStep>
				<TestStep>
					<!--increment module-->
					<SetVariable Target="ModuleCounter">ModuleCounter+1</SetVariable>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>ModuleLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="FileLoopEnd">
					<!--Increment file counter-->
					<SetVariable Target="ext_ModuleXmlFile.FileCounter">ext_ModuleXmlFile.FileCounter + 1</SetVariable>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>FileLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="ReturnTestResult">
					<!--dump test result-->
					<Compare>
						<Equal>
							<Value1>AtLeastOneModuleFound</Value1>
							<Value2>false</Value2>
							<SkipCase Id="9">No TxPdo.Exclude found.</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>false</Value2>
							<RaiseError Id="10">Test TxPdo.Exclude failed</RaiseError>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>true</Value2>
							<ReturnSuccess Id="11">Test TxPdo.Exclude succeed.</ReturnSuccess>
						</Equal>
					</Compare>
				</TestStep>
			</TestCase>
		</TestGroup>
		<TestGroup GroupId="203" Name="(External)Module Device Object Tests">
			<Comment>Check the Object definitions of the modules defined within an external file</Comment>
			<TestCase Name="General Object Attributes" CaseId="1">
				<?MAX_OUTPUT_ID 21?>
				<Description>
					<PreCondition>The device description includes module object dictionary defined within an external module file</PreCondition>
					<Action>1.) Get the object Index
2.) Get the object Name</Action>
					<PostCondition>1.) The Index shall be between 0x1000 and 0xFFFF
2.) The Name shall not be empty</PostCondition>
					<References>
						<Reference Specification="ETG.2000"></Reference>
						<Reference Specification="ETG.1020"></Reference>
						<Reference Specification="ETG.5001"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="Toggle_LOC_EXT">
					<!--Flag for InitGlobalVariables for default XPaths of local or external file-->
					<SetVariable Target="LocExt_InitToggle">true</SetVariable>
					<WriteLine Id="0" Level="Output">Checking for external file with modules.</WriteLine>
				</TestStep>
				<TestStep Name="SkipNoSlots">
					<!--Skip Test if "CurrentConfig.SlotCount" == 0-->
					<Compare>
						<Equal>
							<Value1>CurrentConfig.SlotCount</Value1>
							<Value2>0</Value2>
							<SkipCase Id="1">Test skipped. No slots defined.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="SkipSoE">
					<!--Skip Test if SoE Device-->
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Mailbox.SoE</Value1>
							<Value2>true</Value2>
							<SkipCase Id="2">Test skipped for SoE Devices.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="INIT_AVAIL_GLOB_ARRAY">
					<CallTestFunction Name="AvailableDuTModuleIdents"></CallTestFunction>
				</TestStep>
				<TestStep Name="InitGlobalVariables">
					<!--Init global XPaths-->
					<CallTestFunction Name="InitGlobalVariablesForModuleODTest">
						<Parameter>LocExt_InitToggle</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="INIT_RESULT">
					<!--"result" = true-->
					<SetVariable Target="result">true</SetVariable>
				</TestStep>
				<TestStep Name="FileLoopStart">
					<GetXmlValue ReturnValue="ext_ModuleXmlFile" Markup="false">
						<XPath Param0="ext_ModuleXmlFile.XPath" Param1="ext_ModuleXmlFile.FileCounter">{0}[{1}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>ext_ModuleXmlFile</Value1>
							<Value2>null</Value2>
							<GotoStep>END</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>ext_ModuleXmlFile</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>END</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="3" Level="Output" Param0="ext_ModuleXmlFile">Checking external module file: {0}</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="INIT_LOOP_COUNTER">
					<!--"ModuleCounter" = 1-->
					<SetVariable Target="ModuleCounter">1</SetVariable>
				</TestStep>
				<TestStep Name="CHECK_IF_EXISTS">
					<!--Checking if module exist-->
					<Compare>
						<Equal>
							<Value1>ext_XPathModuleIdent</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>FileLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="InitTestedArray">
					<!--Array of already processed modules, no doubles-->
					<InitArray TargetArray="AllModuleIdents.Uint32Array"></InitArray>
				</TestStep>
				<TestStep Name="ObjectLoopStart">
					<!--__Loop START for EXTERNAL Modules__-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>FileLoopEnd</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>FileLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_AVAILABLE_MDL">
					<!--Get ModuleIdent and Flag to SKIP testing of assigned modules-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="AllModuleIdents.Uint32">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>TestAvailableMdls</Value1>
							<Value2>false</Value2>
							<GotoStep>TEST_MODULES</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckItemInArray">
					<!--Check if module in list of assigned modules-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllAvailableDuTModules.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleInArray.boolAssigned</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="4" Level="Verbose" Param0="CheckModuleInArray.boolAssigned" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleInArray.boolAssigned == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleInArray.boolAssigned</Value1>
							<Value2>false</Value2>
							<GotoStep>ObjectLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckAlreadyTested">
					<!--Check if module already tested-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllModuleIdents.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleAlreadyTested.boolAlreadyChecked</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="5" Level="Verbose" Param0="CheckModuleAlreadyTested.boolAlreadyChecked" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleAlreadyTested.boolAlreadyChecked == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleAlreadyTested.boolAlreadyChecked</Value1>
							<Value2>true</Value2>
							<GotoStep>ObjectLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_MODULES">
					<!--Print Module Ident-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="6" Level="Verbose" Param0="ModuleCounter" Param1="strXmlValue">Module[{0}]: Ident: {1}</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="Check_extOD_FileRef">
					<CallTestFunction Name="CheckForExtRefDict">
						<Parameter>ext_ModuleXmlFile</Parameter>
						<Parameter>ext_XPathModuleIdent</Parameter>
						<Parameter>ModuleCounter</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="InitSubItemLoopCounter">
					<!--Init of nested loop counter for the object of current module-->
					<SetVariable Target="i32TmpModuleIndex">1</SetVariable>
				</TestStep>
				<TestStep Name="SubItemLoopStart">
					<!--__Loop START for current module object__-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/Profile/Dictionary/Objects/Object[{2}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>ObjectLoopEnd</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>ObjectLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="GET_OBJ_INDEX">
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.ObjIndex.Uint16">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/Profile/Dictionary/Objects/Object[{2}]/Index</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="7" Level="Output" Param0="strXmlValue.ObjIndex.Uint16">Value of "strXmlValue.ObjIndex.Uint16": 0x{0:x4}</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="COMPARE_OBJ_INDEX">
					<!--Dump an Error if no Object index is defined-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<SetVariable Target="ModuleObjectInfo.ObjFound">true</SetVariable>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue.ObjIndex.Uint16</Value1>
							<Value2>null</Value2>
							<WriteLine Id="8" Level="Error" Param0="ModuleCounter">Object[{0}].Index shall be defined.</WriteLine>
						</Equal>
					</Compare>
					<!--Update Result-->
					<Compare>
						<Equal>
							<Value1>strXmlValue.ObjIndex.Uint16</Value1>
							<Value2>null</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Equal>
					</Compare>
					<!--goto "GET_OBJ_NAME"-->
					<Compare>
						<Equal>
							<Value1>strXmlValue.ObjIndex.Uint16</Value1>
							<Value2>null</Value2>
							<GotoStep>GET_OBJ_NAME</GotoStep>
						</Equal>
					</Compare>
					<!--Dump an error if the index is less 0x1000-->
					<Compare>
						<Lower>
							<Value1>strXmlValue.ObjIndex.Uint16</Value1>
							<Value2>#x1000</Value2>
							<WriteLine Id="9" Level="Error" Param0="ModuleCounter" Param1="strXmlValue.ObjIndex.Uint16">Object[{0}].Index (0x{1:x4}) shall be within 0x1000 and 0xFFFF.</WriteLine>
						</Lower>
					</Compare>
					<!--Update Result-->
					<Compare>
						<Lower>
							<Value1>strXmlValue.ObjIndex.Uint16</Value1>
							<Value2>#x1000</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Lower>
					</Compare>
					<!--Dump valid Info-->
					<Compare>
						<GreaterOrEqual>
							<Value1>strXmlValue.ObjIndex.Uint16</Value1>
							<Value2>#x1000</Value2>
							<WriteLine Id="10" Level="Output" Param0="ModuleCounter" Param1="strXmlValue.ObjIndex.Uint16">Object[{0}].Index (0x{1:x4}) is valid.</WriteLine>
						</GreaterOrEqual>
					</Compare>
				</TestStep>
				<TestStep Name="GET_OBJ_NAME">
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/Profile/Dictionary/Objects/Object[{2}]/Name</XPath>
					</GetXmlValue>
					<!--Dump an Error if no Object name is defined-->
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<WriteLine Id="11" Level="Error" Param0="ModuleCounter">Object[{0}] : No Name defined.</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<WriteLine Id="12" Level="Error" Param0="ModuleCounter">Object[{0}] : No Name defined.</WriteLine>
						</Equal>
					</Compare>
					<!--Update Result-->
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Equal>
					</Compare>
					<!--goto "ObjectLoopEnd"-->
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>GET_OBJ_READ_RESTRICTION</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>GET_OBJ_READ_RESTRICTION</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="COMPARE_OBJ_NAME">
					<!--Dump an Error if the Object name is empty-->
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<WriteLine Id="13" Level="Error" Param0="ModuleCounter">Object[{0}].Name shall not be empty.</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<WriteLine Id="14" Level="Error" Param0="ModuleCounter">Object[{0}].Name shall not be empty.</WriteLine>
						</Equal>
					</Compare>
					<!--Update Result-->
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Equal>
					</Compare>
					<!--Write valid Info-->
					<Compare>
						<NotEqual>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<WriteLine Id="15" Level="Output" Param0="ModuleCounter" Param1="strXmlValue">Object[{0}].Name '{1}' is valid.</WriteLine>
						</NotEqual>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<WriteLine Id="16" Level="Output" Param0="ModuleCounter" Param1="strXmlValue">Object[{0}].Name '{1}' is valid.</WriteLine>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="GET_OBJ_READ_RESTRICTION">
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/Profile/Dictionary/Objects/Object[{2}]/Flags/Access/@ReadRestrictions</XPath>
					</GetXmlValue>
					<!--goto "ObjectLoopEnd"-->
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>GET_OBJ_WRITE_RESTRICTION</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>GET_OBJ_WRITE_RESTRICTION</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="COMPARE_READ_RESTRICTION">
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>"PreOp"</Value2>
							<WriteLine Id="17" Level="Error" Param0="ModuleCounter">Object[{0}]/Flags/Access/@ReadRestrictions shall not be'PreOp' (use 'PreOP' instead).</WriteLine>
						</Equal>
					</Compare>
					<!--Update Result-->
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>"PreOp"</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="GET_OBJ_WRITE_RESTRICTION">
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/Profile/Dictionary/Objects/Object[{2}]/Flags/Access/@WriteRestrictions</XPath>
					</GetXmlValue>
				</TestStep>
				<TestStep Name="COMPARE_WRITE_RESTRICTION">
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>"PreOp"</Value2>
							<WriteLine Id="18" Level="Error" Param0="ModuleCounter">Object[{0}]/Flags/Access/@WriteRestrictions shall not be'PreOp' (use 'PreOP' instead).</WriteLine>
						</Equal>
					</Compare>
					<!--Update Result-->
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>"PreOp"</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="SubItemLoopCounterEnd">
					<!--__END of "SubItemLoopStart", increment loop counter__-->
					<SetVariable Target="i32TmpModuleIndex">i32TmpModuleIndex + 1</SetVariable>
					<!--goto loop start by default -->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>SubItemLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="ObjectLoopEnd">
					<!--__END of "ObjectLoopStart", add ModuleIdent to tested Array__-->
					<AddArrayItem TargetArray="AllModuleIdents.Uint32Array">AllModuleIdents.Uint32</AddArrayItem>
				</TestStep>
				<TestStep>
					<!--Increment loop counter-->
					<SetVariable Target="ModuleCounter">ModuleCounter + 1</SetVariable>
					<!--Goto Loop start if counter is less than Number of DataTypes -->
					<!--Goto loop start by default -->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>ObjectLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="FileLoopEnd">
					<!--Increment file counter-->
					<SetVariable Target="ext_ModuleXmlFile.FileCounter">ext_ModuleXmlFile.FileCounter + 1</SetVariable>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>FileLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="END">
					<!--Dump Test case result-->
					<Compare>
						<Equal>
							<Value1>ModuleObjectInfo.ObjFound</Value1>
							<Value2>false</Value2>
							<SkipCase Id="19">No Variable object found.</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>true</Value2>
							<ReturnSuccess Id="20">Object indices and names are valid.</ReturnSuccess>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>false</Value2>
							<RaiseError Id="21">General Object Attributes Test failed.</RaiseError>
						</Equal>
					</Compare>
				</TestStep>
			</TestCase>
			<TestCase Name="Object DataType and BitSize" CaseId="2">
				<?MAX_OUTPUT_ID 18?>
				<Description>
					<PreCondition>The device description includes module object dictionary defined within an external module file</PreCondition>
					<Action>1.) Get object Type
2.) Get object Bitsize</Action>
					<PostCondition>1.) The object Type shall be defined in the DataType list
2.) The Bitsize shall be equal to the DataType size</PostCondition>
					<References>
						<Reference Specification="ETG.2000"></Reference>
						<Reference Specification="ETG.1020"></Reference>
						<Reference Specification="ETG.5001"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="Toggle_LOC_EXT">
					<!--Flag for InitGlobalVariables for default XPaths of local or external file-->
					<SetVariable Target="LocExt_InitToggle">true</SetVariable>
					<WriteLine Id="0" Level="Output">Checking for external file with modules.</WriteLine>
				</TestStep>
				<TestStep Name="SkipNoSlots">
					<!--Skip Test if "CurrentConfig.SlotCount" == 0-->
					<Compare>
						<Equal>
							<Value1>CurrentConfig.SlotCount</Value1>
							<Value2>0</Value2>
							<SkipCase Id="1">Test skipped. No slots defined.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="SkipSoE">
					<!--Skip Test if SoE Device-->
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Mailbox.SoE</Value1>
							<Value2>true</Value2>
							<SkipCase Id="2">Test skipped for SoE Devices.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="INIT_AVAIL_GLOB_ARRAY">
					<CallTestFunction Name="AvailableDuTModuleIdents"></CallTestFunction>
				</TestStep>
				<TestStep Name="InitGlobalVariables">
					<!--Init global XPaths-->
					<CallTestFunction Name="InitGlobalVariablesForModuleODTest">
						<Parameter>LocExt_InitToggle</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="INIT_RESULT">
					<!--"result" = true-->
					<SetVariable Target="result">true</SetVariable>
				</TestStep>
				<TestStep Name="FileLoopStart">
					<GetXmlValue ReturnValue="ext_ModuleXmlFile" Markup="false">
						<XPath Param0="ext_ModuleXmlFile.XPath" Param1="ext_ModuleXmlFile.FileCounter">{0}[{1}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>ext_ModuleXmlFile</Value1>
							<Value2>null</Value2>
							<GotoStep>END</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>ext_ModuleXmlFile</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>END</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="3" Level="Output" Param0="ext_ModuleXmlFile">Checking external module file: {0}</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="INIT_LOOP_COUNTER">
					<!--"ModuleCounter" = 1-->
					<SetVariable Target="ModuleCounter">1</SetVariable>
				</TestStep>
				<TestStep Name="CHECK_IF_EXISTS">
					<!--Checking if module exist-->
					<Compare>
						<Equal>
							<Value1>ext_XPathModuleIdent</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>FileLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="InitTestedArray">
					<!--Array of already processed modules, no doubles-->
					<InitArray TargetArray="AllModuleIdents.Uint32Array"></InitArray>
				</TestStep>
				<TestStep Name="ObjectLoopStart">
					<!--__Loop START for EXTERNAL Modules__-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>FileLoopEnd</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>FileLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_AVAILABLE_MDL">
					<!--Get ModuleIdent and Flag to SKIP testing of assigned modules-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="AllModuleIdents.Uint32">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>TestAvailableMdls</Value1>
							<Value2>false</Value2>
							<GotoStep>TEST_MODULES</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckItemInArray">
					<!--Check if module in list of assigned modules-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllAvailableDuTModules.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleInArray.boolAssigned</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="4" Level="Verbose" Param0="CheckModuleInArray.boolAssigned" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleInArray.boolAssigned == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleInArray.boolAssigned</Value1>
							<Value2>false</Value2>
							<GotoStep>ObjectLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckAlreadyTested">
					<!--Check if module already tested-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllModuleIdents.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleAlreadyTested.boolAlreadyChecked</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="5" Level="Verbose" Param0="CheckModuleAlreadyTested.boolAlreadyChecked" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleAlreadyTested.boolAlreadyChecked == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleAlreadyTested.boolAlreadyChecked</Value1>
							<Value2>true</Value2>
							<GotoStep>ObjectLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_MODULES">
					<!--Print Module Ident-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="6" Level="Verbose" Param0="ModuleCounter" Param1="strXmlValue">Module[{0}]: Ident: {1}</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="Check_extOD_FileRef">
					<CallTestFunction Name="CheckForExtRefDict">
						<Parameter>ext_ModuleXmlFile</Parameter>
						<Parameter>ext_XPathModuleIdent</Parameter>
						<Parameter>ModuleCounter</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="InitSubItemLoopCounter">
					<!--Init of nested loop counter for the object of current module-->
					<SetVariable Target="i32TmpModuleIndex">1</SetVariable>
				</TestStep>
				<TestStep Name="SubItemLoopStart">
					<!--__Loop START for current module object__-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/Profile/Dictionary/Objects/Object[{2}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>ObjectLoopEnd</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>ObjectLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="GET_OBJ_INDEX">
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.ObjIndex.Uint16">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/Profile/Dictionary/Objects/Object[{2}]/Index</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="7" Level="Output" Param0="strXmlValue.ObjIndex.Uint16">Value of "strXmlValue.ObjIndex.Uint16": 0x{0:x4}</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="GET_OBJ_DATATYPE">
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/Profile/Dictionary/Objects/Object[{2}]/Type</XPath>
					</GetXmlValue>
					<!--Dump an Error if no Type is defined-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<SetVariable Target="ModuleObjectInfo.ObjFound">true</SetVariable>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<WriteLine Id="8" Level="Error" Param0="strXmlValue.ObjIndex.Uint16">0x{0:x4}.Type shall be defined.</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<WriteLine Id="9" Level="Error" Param0="strXmlValue.ObjIndex.Uint16">0x{0:x4}.Type shall be defined.</WriteLine>
						</Equal>
					</Compare>
					<!--Update Result-->
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Equal>
					</Compare>
					<!--goto "ObjectLoopEnd"-->
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>ObjectLoopEnd</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>ObjectLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CREATE_DT_PATH">
					<SetVariable Target="ext_XPathDtTmp" Param0="ext_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Profile/Dictionary/DataTypes/DataType</SetVariable>
				</TestStep>
				<TestStep Name="GET_TYPE_BITSIZE">
					<Description Id="10" Level="Verbose" Param0="strXmlValue" Param1="strXmlValue.ObjIndex.Uint16">0x{1:x4}.Type '{0}' get BitSize.</Description>
					<CallTestFunction Name="DataTypeName.GetBitSize">
						<Parameter>strXmlValue</Parameter>
						<Parameter>ext_ModuleXmlFile</Parameter>
						<Parameter>ext_XPathDtTmp</Parameter>
						<OutParameter>ModuleObjectDTBitSize.TypeBitSize</OutParameter>
					</CallTestFunction>
					<!--Dump an Error if DataType was not found-->
					<Compare>
						<Lower>
							<Value1>ModuleObjectDTBitSize.TypeBitSize</Value1>
							<Value2>0</Value2>
							<WriteLine Id="11" Level="Error" Param0="strXmlValue.ObjIndex.Uint16" Param1="strXmlValue">0x{0:x4}.Type "{1}" was not found in DataTypes element.</WriteLine>
						</Lower>
					</Compare>
					<!--Update Result-->
					<Compare>
						<Lower>
							<Value1>ModuleObjectDTBitSize.TypeBitSize</Value1>
							<Value2>0</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Lower>
					</Compare>
					<!--goto "ObjectLoopEnd"-->
					<Compare>
						<Lower>
							<Value1>ModuleObjectDTBitSize.TypeBitSize</Value1>
							<Value2>0</Value2>
							<GotoStep>ObjectLoopEnd</GotoStep>
						</Lower>
					</Compare>
				</TestStep>
				<TestStep Name="GET_BITSIZE">
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/Profile/Dictionary/Objects/Object[{2}]/BitSize</XPath>
					</GetXmlValue>
					<!--Dump an Error if no Object BitSize is defined-->
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<WriteLine Id="12" Level="Error" Param0="ModuleCounter">Object[{0}].BitSize shall be defined.</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<WriteLine Id="13" Level="Error" Param0="ModuleCounter">Object[{0}].BitSize shall be defined.</WriteLine>
						</Equal>
					</Compare>
					<!--Update Result-->
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Equal>
					</Compare>
					<!--goto "ObjectLoopEnd"-->
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>ObjectLoopEnd</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>ObjectLoopEnd</GotoStep>
						</Equal>
					</Compare>
					<!--Convert String to Int32-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<SetVariable Target="ModuleObjectDTBitSize.ObjBitSize">strXmlValue</SetVariable>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="COMPARE_BITSIZE">
					<!--Dump an Error if the BitSize not match-->
					<Compare>
						<NotEqual>
							<Value1>ModuleObjectDTBitSize.TypeBitSize</Value1>
							<Value2>ModuleObjectDTBitSize.ObjBitSize</Value2>
							<WriteLine Id="14" Level="Error" Param0="strXmlValue.ObjIndex.Uint16" Param1="ModuleObjectDTBitSize.ObjBitSize" Param2="ModuleObjectDTBitSize.TypeBitSize">0x{0:X4}.BitSize ({1}) shall be equal to DataType BitSize ({2}).</WriteLine>
						</NotEqual>
					</Compare>
					<!--Update Result-->
					<Compare>
						<NotEqual>
							<Value1>ModuleObjectDTBitSize.TypeBitSize</Value1>
							<Value2>ModuleObjectDTBitSize.ObjBitSize</Value2>
							<SetVariable Target="result">false</SetVariable>
						</NotEqual>
					</Compare>
					<!--Dump an Output if data type matches-->
					<Compare>
						<Equal>
							<Value1>ModuleObjectDTBitSize.TypeBitSize</Value1>
							<Value2>ModuleObjectDTBitSize.ObjBitSize</Value2>
							<WriteLine Id="15" Level="Output" Param0="strXmlValue.ObjIndex.Uint16" Param1="ModuleObjectDTBitSize.ObjBitSize">0x{0:X4}.BitSize ({1}) matching data type bit size.</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="SubItemLoopCounterEnd">
					<!--__END of "SubItemLoopStart", increment loop counter__-->
					<SetVariable Target="i32TmpModuleIndex">i32TmpModuleIndex + 1</SetVariable>
					<!--goto loop start by default -->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>SubItemLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="ObjectLoopEnd">
					<!--__END of "ObjectLoopStart", add ModuleIdent to tested Array__-->
					<AddArrayItem TargetArray="AllModuleIdents.Uint32Array">AllModuleIdents.Uint32</AddArrayItem>
				</TestStep>
				<TestStep>
					<!--Increment loop counter-->
					<SetVariable Target="ModuleCounter">ModuleCounter + 1</SetVariable>
					<!--Goto Loop start if counter is less than Number of DataTypes -->
					<!--Goto loop start by default -->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>ObjectLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="FileLoopEnd">
					<!--Increment file counter-->
					<SetVariable Target="ext_ModuleXmlFile.FileCounter">ext_ModuleXmlFile.FileCounter + 1</SetVariable>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>FileLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="END">
					<!--Dump Test case result-->
					<Compare>
						<Equal>
							<Value1>ModuleObjectInfo.ObjFound</Value1>
							<Value2>false</Value2>
							<SkipCase Id="16">No Variable object found.</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>true</Value2>
							<ReturnSuccess Id="17">Object DataType and BitSize are valid.</ReturnSuccess>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>false</Value2>
							<RaiseError></RaiseError>
						</Equal>
					</Compare>
				</TestStep>
			</TestCase>
			<TestCase Name="Object Info (Variable)" CaseId="3">
				<?MAX_OUTPUT_ID 20?>
				<Description>
					<PreCondition>At least one object (Code: VARIABLE) is defined and includes an info element</PreCondition>
					<Action>1.) Get 'SubItem'
2.) Get 'DefaultData'
3.) Get 'MinData'
4.) Get 'MaxData'
5.) Get 'DefaultValue'
6.) Get 'MinValue'
7.) Get 'MaxValue'
8.) Get 'DefaultString'</Action>
					<PostCondition>1.) 'SubItem' shall not be defined
2.) 'DefaultData' shall not exceed the used DataType
3.) 'MinData' shall not exceed the used DataType
4.) 'MaxData' shall not exceed the used DataType
5.) 'DefaultValue' shall not exceed the used DataType and shall only used for DataType with a fixed length
6.) 'MinValue' shall not exceed the used DataType and shall only used for DataType with a fixed length
7.) 'MaxValue' shall not exceed the used DataType and shall only used for DataType with a fixed length
8.) 'DefaultString' shall not exceed the used DataType and shall only used for STRING(n)</PostCondition>
					<References>
						<Reference Specification="ETG.2000"></Reference>
						<Reference Specification="ETG.1020"></Reference>
						<Reference Specification="ETG.5001"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="Toggle_LOC_EXT">
					<!--Flag for InitGlobalVariables for default XPaths of local or external file-->
					<SetVariable Target="LocExt_InitToggle">true</SetVariable>
					<WriteLine Id="0" Level="Output">Checking for external file with modules.</WriteLine>
				</TestStep>
				<TestStep Name="SkipNoSlots">
					<!--Skip Test if "CurrentConfig.SlotCount" == 0-->
					<Compare>
						<Equal>
							<Value1>CurrentConfig.SlotCount</Value1>
							<Value2>0</Value2>
							<SkipCase Id="1">Test skipped. No slots defined.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="SkipSoE">
					<!--Skip Test if SoE Device-->
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Mailbox.SoE</Value1>
							<Value2>true</Value2>
							<SkipCase Id="2">Test skipped for SoE Devices.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="INIT_AVAIL_GLOB_ARRAY">
					<CallTestFunction Name="AvailableDuTModuleIdents"></CallTestFunction>
				</TestStep>
				<TestStep Name="InitGlobalVariables">
					<!--Init global XPaths-->
					<CallTestFunction Name="InitGlobalVariablesForModuleODTest">
						<Parameter>LocExt_InitToggle</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="INIT_RESULT">
					<!--"result" = true-->
					<SetVariable Target="result">true</SetVariable>
				</TestStep>
				<TestStep Name="FileLoopStart">
					<GetXmlValue ReturnValue="ext_ModuleXmlFile" Markup="false">
						<XPath Param0="ext_ModuleXmlFile.XPath" Param1="ext_ModuleXmlFile.FileCounter">{0}[{1}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>ext_ModuleXmlFile</Value1>
							<Value2>null</Value2>
							<GotoStep>END</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>ext_ModuleXmlFile</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>END</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="3" Level="Output" Param0="ext_ModuleXmlFile">Checking external module file: {0}</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="INIT_LOOP_COUNTER">
					<!--"ModuleCounter" = 1-->
					<SetVariable Target="ModuleCounter">1</SetVariable>
				</TestStep>
				<TestStep Name="CHECK_IF_EXISTS">
					<!--Checking if module exist-->
					<Compare>
						<Equal>
							<Value1>ext_XPathModuleIdent</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>FileLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="INIT_OBJ_FOUND">
					<!--Init variable "Object found" for dump of test results-->
					<SetVariable Target="ModuleObjectInfo.ObjFound">false</SetVariable>
				</TestStep>
				<TestStep Name="InitTestedArray">
					<!--Array of already processed modules, no doubles-->
					<InitArray TargetArray="AllModuleIdents.Uint32Array"></InitArray>
				</TestStep>
				<TestStep Name="ObjectLoopStart">
					<!--__Loop START for EXTERNAL Modules__-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>FileLoopEnd</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>FileLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_AVAILABLE_MDL">
					<!--Get ModuleIdent and Flag to SKIP testing of assigned modules-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="AllModuleIdents.Uint32">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>TestAvailableMdls</Value1>
							<Value2>false</Value2>
							<GotoStep>TEST_MODULES</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckItemInArray">
					<!--Check if module in list of assigned modules-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllAvailableDuTModules.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleInArray.boolAssigned</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="4" Level="Verbose" Param0="CheckModuleInArray.boolAssigned" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleInArray.boolAssigned == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleInArray.boolAssigned</Value1>
							<Value2>false</Value2>
							<GotoStep>ObjectLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckAlreadyTested">
					<!--Check if module already tested-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllModuleIdents.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleAlreadyTested.boolAlreadyChecked</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="5" Level="Verbose" Param0="CheckModuleAlreadyTested.boolAlreadyChecked" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleAlreadyTested.boolAlreadyChecked == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleAlreadyTested.boolAlreadyChecked</Value1>
							<Value2>true</Value2>
							<GotoStep>ObjectLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_MODULES">
					<!--Print Module Ident-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="6" Level="Verbose" Param0="ModuleCounter" Param1="strXmlValue">Module[{0}]: Ident: {1}</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="Check_extOD_FileRef">
					<CallTestFunction Name="CheckForExtRefDict">
						<Parameter>ext_ModuleXmlFile</Parameter>
						<Parameter>ext_XPathModuleIdent</Parameter>
						<Parameter>ModuleCounter</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="InitSubItemLoopCounter">
					<!--Init of nested loop counter for the object of current module-->
					<SetVariable Target="i32TmpModuleIndex">1</SetVariable>
				</TestStep>
				<TestStep Name="SubItemLoopStart">
					<!--__Loop START for current module object__-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.Obj.String">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/Profile/Dictionary/Objects/Object[{2}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="7" Level="Output" Param0="strXmlValue.Obj.String" Param1="i32TmpModuleIndex">Value of "strXmlValue" = {0}; for Object[{1}]</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue.Obj.String</Value1>
							<Value2>null</Value2>
							<GotoStep>ObjectLoopEnd</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue.Obj.String</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>ObjectLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="GET_OBJ_DATATYPE">
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.ObjBaseType.String">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/Profile/Dictionary/Objects/Object[{2}]/Type</XPath>
					</GetXmlValue>
					<!--Dump an Error if no Type is defined-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="8" Level="Output" Param0="strXmlValue.ObjBaseType.String">Value of "strXmlValue.ObjBaseType.String" = {0}; for Object[n]</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue.ObjBaseType.String</Value1>
							<Value2>null</Value2>
							<WriteLine Id="9" Level="Verbose" Param0="ModuleCounter">Object[{0}].Type shall be defined.</WriteLine>
						</Equal>
					</Compare>
					<!--goto "ObjectLoopEnd"-->
					<Compare>
						<Equal>
							<Value1>strXmlValue.ObjBaseType.String</Value1>
							<Value2>null</Value2>
							<GotoStep>SubItemLoopCounterEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CHECK_IF_BASE_TYPE">
					<RegexIsMatch ReturnValue="IsMatch">
						<Pattern>^(BOOL|BIT|BIT[1-8]|BYTE|BITARR8|BITARR16|WORD|BITARR32|DOWRD|SINT|INT|INT24|DINT|INT40|INT48|INT56|LINT|USINT|UINT|UINT24|UDINT|UINT40|UINT48|UINT56|ULINT|REAL|LREAL|(DT[0-9A-F]{1,4}EN([0-9]{2}))|(ARRAY \[0\.\.[0-9]+\] OF (BYTE|SINT|UINT|INT|DINT|UDINT))|(STRING\([0-9]+\)))$</Pattern>
						<InputString>strXmlValue.ObjBaseType.String</InputString>
					</RegexIsMatch>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="10" Level="Output" Param0="IsMatch">Value of "IsMatch" = {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="11" Level="Output" Param0="ModuleObjectInfo.ObjFound">Value of "ModuleObjectInfo.ObjFound" = {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>IsMatch</Value1>
							<Value2>false</Value2>
							<GotoStep>SubItemLoopCounterEnd</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>IsMatch</Value1>
							<Value2>true</Value2>
							<SetVariable Target="ModuleObjectInfo.ObjFound">true</SetVariable>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="12" Level="Output" Param0="ModuleObjectInfo.ObjFound">Value of "ModuleObjectInfo.ObjFound" = {0}</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="GET_OBJ_INDEX">
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.ObjIndex.Uint16">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/Profile/Dictionary/Objects/Object[{2}]/Index</XPath>
					</GetXmlValue>
					<!--Dump an info if no index is defined-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="13" Level="Output" Param0="strXmlValue.ObjIndex.Uint16">Value of "strXmlValue.ObjIndex.Uint16": 0x{0:x4}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue.ObjIndex.Uint16</Value1>
							<Value2>null</Value2>
							<WriteLine Id="14" Level="Verbose" Param0="ModuleCounter">Object[{0}].Index shall be defined.</WriteLine>
						</Equal>
					</Compare>
					<!--Skip if no Index is defined-->
					<Compare>
						<Equal>
							<Value1>strXmlValue.ObjIndex.Uint16</Value1>
							<Value2>null</Value2>
							<GotoStep>SubItemLoopCounterEnd</GotoStep>
						</Equal>
					</Compare>
					<!--Create Info String-->
					<Compare>
						<NotEqual>
							<Value1>strXmlValue.ObjIndex.Uint16</Value1>
							<Value2>null</Value2>
							<SetVariable Target="ModuleObjectInfo.strHexObjIndex" Param0="strXmlValue.ObjIndex.Uint16">0x{0:x4}.Info</SetVariable>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="CREATE_INFO_PATH">
					<SetVariable Target="ModuleObjectInfo.XPathInfo" Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/Profile/Dictionary/Objects/Object[{2}]/Info</SetVariable>
				</TestStep>
				<TestStep Name="CREATE_BASETYPE_PATH">
					<SetVariable Target="ModuleObjectInfo.XPathType" Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/Profile/Dictionary/Objects/Object[{2}]/Type</SetVariable>
				</TestStep>
				<TestStep Name="GET_INFO_ELEMENT">
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ModuleObjectInfo.XPathInfo">{0}</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="15" Level="Output" Param0="strXmlValue">Value of "strXmlValue" - Info element: {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>SubItemLoopCounterEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CHECK_IF_SUBITEM_IS_DEFINED">
					<!--For objects with no entries (Variable) no SubItem shall be defined-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="ModuleObjectInfo.strXmlValue">
						<XPath Param0="ModuleObjectInfo.XPathInfo">{0}/SubItem</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="16" Level="Output" Param0="ModuleObjectInfo.strXmlValue">ModuleObjectInfo.strXmlValue ==  {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>ModuleObjectInfo.strXmlValue</Value1>
							<Value2>null</Value2>
							<WriteLine Id="17" Level="Error" Param0="ModuleObjectInfo.strHexObjIndex">{0} shall have no SubItems.</WriteLine>
						</NotEqual>
					</Compare>
					<Compare>
						<NotEqual>
							<Value1>ModuleObjectInfo.strXmlValue</Value1>
							<Value2>null</Value2>
							<SetVariable Target="result">false</SetVariable>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="CheckInfoElement">
					<!--Call "ValidateObjectInfoType" function-->
					<CallTestFunction Name="ValidateObjectInfoType">
						<Parameter>ModuleObjectInfo.XPathInfo</Parameter>
						<Parameter>ext_ModuleXmlFile</Parameter>
						<Parameter>strXmlValue.ObjBaseType.String</Parameter>
						<Parameter>ModuleObjectInfo.strHexObjIndex</Parameter>
						<OutParameter>TmpResult</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>TmpResult</Value1>
							<Value2>false</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="SubItemLoopCounterEnd">
					<!--__END of "SubItemLoopStart", increment loop counter__-->
					<SetVariable Target="i32TmpModuleIndex">i32TmpModuleIndex + 1</SetVariable>
					<!--goto loop start by default -->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>SubItemLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="ObjectLoopEnd">
					<!--__END of "ObjectLoopStart", add ModuleIdent to tested Array__-->
					<AddArrayItem TargetArray="AllModuleIdents.Uint32Array">AllModuleIdents.Uint32</AddArrayItem>
				</TestStep>
				<TestStep>
					<!--Increment loop counter-->
					<SetVariable Target="ModuleCounter">ModuleCounter + 1</SetVariable>
					<!--Goto loop start by default -->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>ObjectLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="FileLoopEnd">
					<!--Increment file counter-->
					<SetVariable Target="ext_ModuleXmlFile.FileCounter">ext_ModuleXmlFile.FileCounter + 1</SetVariable>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>FileLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="END">
					<!--Dump Test case result-->
					<Compare>
						<Equal>
							<Value1>ModuleObjectInfo.ObjFound</Value1>
							<Value2>false</Value2>
							<SkipCase Id="18">No Variable object found.</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>true</Value2>
							<ReturnSuccess Id="19">Variable objects are valid</ReturnSuccess>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>false</Value2>
							<RaiseError Id="20">Object Info for VARIABLE Test failed.</RaiseError>
						</Equal>
					</Compare>
				</TestStep>
			</TestCase>
			<TestCase Name="Object Info (Array/Record)" CaseId="4">
				<?MAX_OUTPUT_ID 17?>
				<Description>
					<PreCondition>At least one object (Code: ARRAY/RECORD) is defined and includes an info element</PreCondition>
					<Action>1.) Get 'DefaultData'
2.) Get 'MinData'
3.) Get 'MaxData'
4.) Get 'DefaultValue'
5.) Get 'MinValue'
6.) Get 'MaxValue'
7.) Get 'DefaultString'
8.) Foreach 'SubItem'
	8.1.) Get 'DefaultData'
	8.2.) Get 'MinData'
	8.3.) Get 'MaxData'
	8.4.) Get 'DefaultValue'
	8.5.) Get 'MinValue'
	8.6.) Get 'MaxValue'
	8.7.) Get 'DefaultString'</Action>
					<PostCondition>1.) 'DefaultData' shall not exceed the used DataType
2.) 'MinData' shall not be defined
3.) 'MaxData' shall not be defined
4.) 'DefaultValue' shall not be defined
5.) 'MinValue' shall not be defined
6.) 'MaxValue' shall not be defined
7.) 'DefaultString' shall not be defined
8.) 'SubItem' shall not be defined
	8.1.) 'DefaultData' shall not exceed the used DataType
	8.2.) 'MinData' shall not exceed the used DataType
	8.3.) 'MaxData' shall not exceed the used DataType
	8.4.) 'DefaultValue' shall not exceed the used DataType and shall only used for DataType with a fixed length
	8.5.) 'MinValue' shall not exceed the used DataType and shall only used for DataType with a fixed length
	8.6.) 'MaxValue' shall not exceed the used DataType and shall only used for DataType with a fixed length
	8.7.) 'DefaultString' shall not exceed the used DataType and shall only used for STRING(n)</PostCondition>
					<References>
						<Reference Specification="ETG.2000"></Reference>
						<Reference Specification="ETG.1020"></Reference>
						<Reference Specification="ETG.5001"></Reference>
					</References>
					<Mandatory>true</Mandatory>
				</Description>
				<TestStep Name="Toggle_LOC_EXT">
					<!--Flag for InitGlobalVariables for default XPaths of local or external file-->
					<SetVariable Target="LocExt_InitToggle">true</SetVariable>
					<WriteLine Id="0" Level="Output">Checking for external file with modules.</WriteLine>
				</TestStep>
				<TestStep Name="SkipNoSlots">
					<!--Skip Test if "CurrentConfig.SlotCount" == 0-->
					<Compare>
						<Equal>
							<Value1>CurrentConfig.SlotCount</Value1>
							<Value2>0</Value2>
							<SkipCase Id="1">Test skipped. No slots defined.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="SkipSoE">
					<!--Skip Test if SoE Device-->
					<Compare>
						<Equal>
							<Value1>DeviceDescr.Mailbox.SoE</Value1>
							<Value2>true</Value2>
							<SkipCase Id="2">Test skipped for SoE Devices.</SkipCase>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="INIT_AVAIL_GLOB_ARRAY">
					<CallTestFunction Name="AvailableDuTModuleIdents"></CallTestFunction>
				</TestStep>
				<TestStep Name="InitGlobalVariables">
					<!--Init global XPaths-->
					<CallTestFunction Name="InitGlobalVariablesForModuleODTest">
						<Parameter>LocExt_InitToggle</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="INIT_RESULT">
					<!--"result" = true-->
					<SetVariable Target="result">true</SetVariable>
				</TestStep>
				<TestStep Name="FileLoopStart">
					<GetXmlValue ReturnValue="ext_ModuleXmlFile" Markup="false">
						<XPath Param0="ext_ModuleXmlFile.XPath" Param1="ext_ModuleXmlFile.FileCounter">{0}[{1}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>ext_ModuleXmlFile</Value1>
							<Value2>null</Value2>
							<GotoStep>END</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>ext_ModuleXmlFile</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>END</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="3" Level="Output" Param0="ext_ModuleXmlFile">Checking external module file: {0}</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="INIT_LOOP_COUNTER">
					<!--"ModuleCounter" = 1-->
					<SetVariable Target="ModuleCounter">1</SetVariable>
				</TestStep>
				<TestStep Name="CHECK_IF_EXISTS">
					<!--Checking if module exist-->
					<Compare>
						<Equal>
							<Value1>ext_XPathModuleIdent</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>FileLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="INIT_OBJ_FOUND">
					<!--Init variable "Object found" for dump of test results-->
					<SetVariable Target="ModuleObjectInfo.ObjFound">false</SetVariable>
				</TestStep>
				<TestStep Name="InitTestedArray">
					<!--Array of already processed modules, no doubles-->
					<InitArray TargetArray="AllModuleIdents.Uint32Array"></InitArray>
				</TestStep>
				<TestStep Name="ObjectLoopStart">
					<!--__Loop START for EXTERNAL Modules__-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>FileLoopEnd</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>FileLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_AVAILABLE_MDL">
					<!--Get ModuleIdent and Flag to SKIP testing of assigned modules-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="AllModuleIdents.Uint32">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>TestAvailableMdls</Value1>
							<Value2>false</Value2>
							<GotoStep>TEST_MODULES</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckItemInArray">
					<!--Check if module in list of assigned modules-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllAvailableDuTModules.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleInArray.boolAssigned</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="4" Level="Verbose" Param0="CheckModuleInArray.boolAssigned" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleInArray.boolAssigned == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleInArray.boolAssigned</Value1>
							<Value2>false</Value2>
							<GotoStep>ObjectLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CheckAlreadyTested">
					<!--Check if module already tested-->
					<CallTestFunction Name="CheckItemInArrayUint32">
						<Parameter>AllModuleIdents.Uint32Array</Parameter>
						<Parameter>AllModuleIdents.Uint32</Parameter>
						<OutParameter>CheckModuleAlreadyTested.boolAlreadyChecked</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="5" Level="Verbose" Param0="CheckModuleAlreadyTested.boolAlreadyChecked" Param1="AllModuleIdents.Uint32" Param2="ModuleCounter">#{2} Module: AllModuleIdents.Uint32 == 0x{1:x4} and CheckModuleAlreadyTested.boolAlreadyChecked == {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>CheckModuleAlreadyTested.boolAlreadyChecked</Value1>
							<Value2>true</Value2>
							<GotoStep>ObjectLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="TEST_MODULES">
					<!--Print Module Ident-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter">{0}[{1}]/Type/@ModuleIdent</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<WriteLine Id="6" Level="Verbose" Param0="ModuleCounter" Param1="strXmlValue">Module[{0}]: Ident: {1}</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="Check_extOD_FileRef">
					<CallTestFunction Name="CheckForExtRefDict">
						<Parameter>ext_ModuleXmlFile</Parameter>
						<Parameter>ext_XPathModuleIdent</Parameter>
						<Parameter>ModuleCounter</Parameter>
					</CallTestFunction>
				</TestStep>
				<TestStep Name="InitSubItemLoopCounter">
					<!--Init of nested loop counter for the object of current module-->
					<SetVariable Target="i32TmpModuleIndex">1</SetVariable>
				</TestStep>
				<TestStep Name="SubItemLoopStart">
					<!--__Loop START for current module object__-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.Obj.String">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/Profile/Dictionary/Objects/Object[{2}]</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="7" Level="Output" Param0="strXmlValue.Obj.String" Param1="i32TmpModuleIndex">Value of "strXmlValue" = {0}; for Object[{1}]</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue.Obj.String</Value1>
							<Value2>null</Value2>
							<GotoStep>ObjectLoopEnd</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue.Obj.String</Value1>
							<Value2>EmptyString</Value2>
							<GotoStep>ObjectLoopEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="GET_OBJ_DATATYPE">
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.ObjBaseType.String">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/Profile/Dictionary/Objects/Object[{2}]/Type</XPath>
					</GetXmlValue>
					<!--Dump an Error if no Type is defined-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="8" Level="Output" Param0="strXmlValue.ObjBaseType.String">Value of "strXmlValue.ObjBaseType.String" = {0}; for Object[n]</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue.ObjBaseType.String</Value1>
							<Value2>null</Value2>
							<WriteLine Id="9" Level="Verbose" Param0="ModuleCounter">Object[{0}].Type shall be defined.</WriteLine>
						</Equal>
					</Compare>
					<!--goto "ObjectLoopEnd"-->
					<Compare>
						<Equal>
							<Value1>strXmlValue.ObjBaseType.String</Value1>
							<Value2>null</Value2>
							<GotoStep>SubItemLoopCounterEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="SKIP_IF_BASE_TYPE">
					<RegexIsMatch ReturnValue="IsMatch">
						<Pattern>^(BOOL|BIT|BIT[1-8]|BYTE|BITARR8|BITARR16|WORD|BITARR32|DOWRD|SINT|INT|INT24|DINT|INT40|INT48|INT56|LINT|USINT|UINT|UINT24|UDINT|UINT40|UINT48|UINT56|ULINT|REAL|LREAL|(DT[0-9A-F]{1,4}EN([0-9]{2}))|(ARRAY \[0\.\.[0-9]+\] OF (BYTE|SINT|UINT|INT|DINT|UDINT))|(STRING\([0-9]+\)))$</Pattern>
						<InputString>strXmlValue.ObjBaseType.String</InputString>
					</RegexIsMatch>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="10" Level="Output" Param0="IsMatch">Value of "IsMatch" = {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>IsMatch</Value1>
							<Value2>true</Value2>
							<GotoStep>SubItemLoopCounterEnd</GotoStep>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>IsMatch</Value1>
							<Value2>false</Value2>
							<SetVariable Target="ModuleObjectInfo.ObjFound">true</SetVariable>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="11" Level="Output" Param0="ModuleObjectInfo.ObjFound">Value of "ModuleObjectInfo.ObjFound" = {0}</WriteLine>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="GET_OBJ_INDEX">
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue.ObjIndex.Uint16">
						<XPath Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/Profile/Dictionary/Objects/Object[{2}]/Index</XPath>
					</GetXmlValue>
					<!--Dump an info if no index is defined-->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="12" Level="Output" Param0="strXmlValue.ObjIndex.Uint16">Value of "strXmlValue.ObjIndex.Uint16": 0x{0:x4}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue.ObjIndex.Uint16</Value1>
							<Value2>null</Value2>
							<WriteLine Id="13" Level="Verbose" Param0="ModuleCounter">Object[{0}].Index shall be defined.</WriteLine>
						</Equal>
					</Compare>
					<!--Skip if no Index is defined-->
					<Compare>
						<Equal>
							<Value1>strXmlValue.ObjIndex.Uint16</Value1>
							<Value2>null</Value2>
							<GotoStep>SubItemLoopCounterEnd</GotoStep>
						</Equal>
					</Compare>
					<!--Create Info String-->
					<Compare>
						<NotEqual>
							<Value1>strXmlValue.ObjIndex.Uint16</Value1>
							<Value2>null</Value2>
							<SetVariable Target="ModuleObjectInfo.strHexObjIndex" Param0="strXmlValue.ObjIndex.Uint16">0x{0:x4}.Info</SetVariable>
						</NotEqual>
					</Compare>
				</TestStep>
				<TestStep Name="CREATE_INFO_PATH">
					<SetVariable Target="ModuleObjectInfo.XPathInfo" Param0="ext_XPathModuleIdent" Param1="ModuleCounter" Param2="i32TmpModuleIndex">{0}[{1}]/Profile/Dictionary/Objects/Object[{2}]/Info</SetVariable>
				</TestStep>
				<TestStep Name="GET_INFO_ELEMENT">
					<!--Call ValidateObjectInfoType (all elements except of the SubItem elements will be checked)-->
					<GetXmlValue FileName="ext_ModuleXmlFile" Markup="false" ReturnValue="strXmlValue">
						<XPath Param0="ModuleObjectInfo.XPathInfo">{0}</XPath>
					</GetXmlValue>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>debug_msg</Value2>
							<WriteLine Id="14" Level="Output" Param0="strXmlValue">Value of "strXmlValue" - Info element: {0}</WriteLine>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>strXmlValue</Value1>
							<Value2>null</Value2>
							<GotoStep>SubItemLoopCounterEnd</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CHECK_INFO_ELEMENT">
					<!--Call ValidateObjectInfoType (all elements except of the SubItem elements will be checked)-->
					<CallTestFunction Name="ValidateObjectInfoType">
						<Parameter>ModuleObjectInfo.XPathInfo</Parameter>
						<Parameter>ext_ModuleXmlFile</Parameter>
						<Parameter>strXmlValue.ObjBaseType.String</Parameter>
						<Parameter>ModuleObjectInfo.strHexObjIndex</Parameter>
						<OutParameter>TmpResult</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>TmpResult</Value1>
							<Value2>false</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="CREATE_SUBITEM_PATH">
					<SetVariable Target="ModuleObjectInfo.Subitem" Param0="ModuleObjectInfo.XPathInfo">{0}/SubItem</SetVariable>
				</TestStep>
				<TestStep Name="CHECK_SUBITEM">
					<CallTestFunction Name="ValidateSubItemElements">
						<Parameter>ModuleObjectInfo.Subitem</Parameter>
						<Parameter>ext_ModuleXmlFile</Parameter>
						<Parameter>strXmlValue.ObjBaseType.String</Parameter>
						<Parameter>ModuleObjectInfo.strHexObjIndex</Parameter>
						<OutParameter>TmpResult</OutParameter>
					</CallTestFunction>
					<Compare>
						<Equal>
							<Value1>TmpResult</Value1>
							<Value2>false</Value2>
							<SetVariable Target="result">false</SetVariable>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="SubItemLoopCounterEnd">
					<!--__END of "SubItemLoopStart", increment loop counter__-->
					<SetVariable Target="i32TmpModuleIndex">i32TmpModuleIndex + 1</SetVariable>
					<!--goto loop start by default -->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>SubItemLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="ObjectLoopEnd">
					<!--__END of "ObjectLoopStart", add ModuleIdent to tested Array__-->
					<AddArrayItem TargetArray="AllModuleIdents.Uint32Array">AllModuleIdents.Uint32</AddArrayItem>
				</TestStep>
				<TestStep>
					<!--Increment loop counter-->
					<SetVariable Target="ModuleCounter">ModuleCounter + 1</SetVariable>
					<!--Goto loop start by default -->
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>ObjectLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="FileLoopEnd">
					<!--Increment file counter-->
					<SetVariable Target="ext_ModuleXmlFile.FileCounter">ext_ModuleXmlFile.FileCounter + 1</SetVariable>
					<Compare>
						<Equal>
							<Value1>true</Value1>
							<Value2>true</Value2>
							<GotoStep>FileLoopStart</GotoStep>
						</Equal>
					</Compare>
				</TestStep>
				<TestStep Name="END">
					<!--Dump Test case result-->
					<Compare>
						<Equal>
							<Value1>ModuleObjectInfo.ObjFound</Value1>
							<Value2>false</Value2>
							<SkipCase Id="15">No Variable object found.</SkipCase>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>true</Value2>
							<ReturnSuccess Id="16">Variable objects are valid</ReturnSuccess>
						</Equal>
					</Compare>
					<Compare>
						<Equal>
							<Value1>result</Value1>
							<Value2>false</Value2>
							<RaiseError Id="17">Object Info for ARRAY/RECORD Test failed.</RaiseError>
						</Equal>
					</Compare>
				</TestStep>
			</TestCase>
		</TestGroup>
	</TestGroups>
</EtherCATTest>