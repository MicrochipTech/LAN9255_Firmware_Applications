<?xml version="1.0" encoding="UTF-8" standalone="yes"?><EtherCATTest Name="EtherCAT Base Test Functions" SchemaVersion="1.0.31" xsi:noNamespaceSchemaLocation="EtherCATTest.xsd" RealeaseState="Released" TestId="0001" TestVendorId="1" TestVersion="1.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
	<Comment>This file includes basic test functions that  can be included in EtherCAT Test files. It is not intended to run this file separately.</Comment>
	<History>
		<HistoryEntry Editor="O.H" TestVersion="0.0.0" Date="2012-08-07"></HistoryEntry>
		<HistoryEntry Editor="R.H." TestVersion="0.0.1" Date="2012-10-05">Add "ArrayOfUInt16.IndexOf":
Get the array index of an UInt16 value (return -1 if the value is not defined)

Add "ArrayOfInt32.IndexOf":
Get the array index of a Int32 value (return -1 if the value is not defined)

Add "ArrayOfString.IndexOf":
Get the array index of a String value (return -1 if the value is not defined)

Add "DataTypeIndex.GetBitSize":
Get the BitSize of a defined DataType (index is zero base; return -1 if DataType or BitSize is not defined)

Add "DataTypeName.GetBitSize":
Get the BitSize of a defined DataType (return -1 if DataType or BitSize is not defined)</HistoryEntry>
		<HistoryEntry Editor="R.H." TestVersion="0.0.3" Date="2012-10-08">Add "XmlFile.GetNumberOfElements"
Gets the number of a specific element (referenced via XPath).</HistoryEntry>
		<HistoryEntry Editor="R.H." TestVersion="0.0.4" Date="2012-10-18">New Functions:
- ArrayOfBytes.Compare
- Bool.Compare
- Byte.Compare
- Int32.Compare
- String.Compare
- UInt16.Compare
- VerifyEntryDescription
- CompareObjectDictionary

CompareObjectList: removed (use "CompareObjectDictionary")
VerifyObjectDescription: Parameter "VerifyObjectDescription.LevelWarning" added (warnings instead of errors are dumped)</HistoryEntry>
		<HistoryEntry Editor="R.H." TestVersion="0.0.6" Date="2012-10-23">VerifyEntryDescription:
- skip default Data, MaxData and MinData conparison if the current value is not defined.</HistoryEntry>
		<HistoryEntry Editor="R.H." TestVersion="0.0.6" Date="2012-10-30">New Function: "IsPdoMappingIndex"
CompareObjectDictionary : add Paramter "PdoMappingOffset" and "ObjectOffset"</HistoryEntry>
		<HistoryEntry Editor="D.O." TestVersion="0.0.8" Date="2012-11-06">New Function: "CheckDistributedClocksSupport"
-changed Index + Subindex separator from "." to ":"</HistoryEntry>
		<HistoryEntry Editor="D.O." TestVersion="0.0.9" Date="2012-11-12">Function: BaseDataType.CheckSize - String with length of 0 is valid - STRING(0)</HistoryEntry>
		<HistoryEntry Editor="F.H." TestVersion="0.0.13" Date="2012-11-20">Function: Reset
Delete ESC specific handling for clearing AssignActivate registers. 0x0980:0x0981 are always cleared. If WKC = 0 logger output written.</HistoryEntry>
		<HistoryEntry Editor="D.O." TestVersion="0.0.14" Date="2012-12-04">Function: BaseDataType.CheckSize - New data types added:
WORD
DWORD
ARRAY [0..n] OF INT
ARRAY [0..n] OF SINT
ARRAY [0..n] OF DINT
ARRAY [0..n] OF UDINT</HistoryEntry>
		<HistoryEntry Editor="D.O." TestVersion="0.0.15" Date="2012-12-04">Function: BaseDataType.CheckSize - ARRAY OR STRING length up to 65535 (uint.maxvalue) is valid.</HistoryEntry>
		<HistoryEntry Editor="D.O." TestVersion="0.0.16" Date="2013-04-15">Function: VerifyObjectDescription: DefaultData test skipped if expected DefaultData is "null".</HistoryEntry>
		<HistoryEntry Editor="D.O." TestVersion="0.0.17" Date="2013-04-17">Functions: VerifyEntry-/Object-Description: Parameter added for a case insensitive/sensitive check of the name. Insensitive check of the name now possible.</HistoryEntry>
		<HistoryEntry Editor="D.O." TestVersion="0.0.18" Date="2013-04-23">Functions: VerifyEntry-/Object-Description: Insensitive name check replaced with CompareString Action</HistoryEntry>
		<HistoryEntry Editor="D.O." TestVersion="0.0.18" Date="2013-04-23">Function: VerifyEntryDescription: Skips Default Data Test if expected Data = null</HistoryEntry>
		<HistoryEntry Editor="D.O." TestVersion="0.0.18" Date="2013-04-23">Functions: VerifyEntry-/Object-Description: Write Warning instead of Raise Warning if Names are unequal</HistoryEntry>
		<HistoryEntry Editor="D.O." TestVersion="0.0.19" Date="2013-06-04">Functions: "VerifyEntry-/Object-Description", "CompareObjectDictionary": added String Parameters "DictionaryType", improved Error Messages</HistoryEntry>
		<HistoryEntry Editor="D.O." TestVersion="0.0.20" Date="2013-06-07">BaseDataType checks: Changed Return Parameter to String. Error Message is returned</HistoryEntry>
		<HistoryEntry Editor="R.H." TestVersion="0.0.21" Date="2013-06-21">CompareObjectDictionary: In case of an entry.Bitsize &gt; 65535 or object.BitSize &gt; 65535 (Variable objects) the reference value is set to 65535 because the SDO info bitsize is an UINT16 value.</HistoryEntry>
		<HistoryEntry Editor="R.H." TestVersion="0.0.22" Date="2013-07-12">Add Function "ArrayOfString.AddToLogger" : write all elements of an string array to the CTT logger output (the message level is set via a parameter).</HistoryEntry>
		<HistoryEntry Editor="R.H." TestVersion="0.0.23" Date="2013-07-18">Add Function "ArrayOfInt32.AddToLogger" : write all elements of an int32 array to the CTT logger output (the message level is set via a parameter).</HistoryEntry>
		<HistoryEntry Editor="O.H." TestVersion="0.0.24" Date="2013-08-07">Testfunction 'VerifyObjectDescription': Compare of category flag is skipped if not defined</HistoryEntry>
		<HistoryEntry Editor="R.H." TestVersion="0.0.25" Date="2013-09-09">Testfunction 'VerifyObjectDescription': Add paramter logger verbose output
Testfunction 'VerifyEntryDescription': Add paramter logger verbose output
Testfunction 'VerifyEntryDescription': Skip contition for MinData fixed (DefaultData was checked before)</HistoryEntry>
		<HistoryEntry Editor="R.H." TestVersion="0.0.26" Date="2013-09-10">Add Testfunction :'IsCommandObject' checks if a specific object is a command object either via the Datatype (SDOInfo) or the object structure (offline OD)</HistoryEntry>
		<HistoryEntry Editor="R.H." TestVersion="0.0.27" Date="2013-11-12">"VerifyEntryDescription": add parameter to allow also Enum instead of std datatypes
add "String.CompareCaseInsensitive"
"VerifyEntryDescription":  change parameter type for "Setting" and "Backup" to Int16 (if -1 the comparison will be skipped)
"VerifyEntryDescription": compare Entry access flags case insensitive
"VerifyEntryDescription": if datatype id 0xFFFF the datatype comparison will be skipped)</HistoryEntry>
		<HistoryEntry Editor="R.H." TestVersion="0.0.28" Date="2013-12-17">Add function : "GetDeviceEmulationFlags"</HistoryEntry>
		<HistoryEntry Editor="O.H." TestVersion="0.0.29" Date="2014-02-07">Add new function: "DiagnosisHistory"</HistoryEntry>
		<HistoryEntry Editor="R.H." TestVersion="0.0.30" Date="2014-03-13">VerifyEntryDescription, VerifyObjectDescription : set Reload Description via SDO Info for Profile 5001.3100 and 5001.3101</HistoryEntry>
		<HistoryEntry Editor="D.O." TestVersion="0.0.32" Date="2014-06-24">BaseDataType.CheckSize: Added Base Data Type "GUID" (BitSize 128)</HistoryEntry>
		<HistoryEntry Editor="F.H." TestVersion="0.0.33" Date="2014-06-27">Reset function:
CTT and RunToStat action reset register in corresponding state transitions. No need to do it again in the Reset function. DevEmu check for usage of AckFlag done by CTT.
- replaced RequestState = Init with RunToState = Init (stops also process data)
- delete DevEmu check
- delete clearing FMMU, SyncManager, AssignAcitvate registers</HistoryEntry>
		<HistoryEntry Editor="R.H." TestVersion="0.0.34" Date="2014-08-04">skip compare bitlength for entries with a flexible bitlength</HistoryEntry>
		<HistoryEntry Editor="R.H." TestVersion="0.0.35" Date="2014-08-06">VerifyEntryDescription : skip compare bitoffset if the value is set to -1; add verbose message if compare default data is skipped</HistoryEntry>
		<HistoryEntry Editor="R.H." TestVersion="0.0.36" Date="2014-08-13">VerifyObjectDescription:
- skip "PdoMapping" flags compare if the value "null" or "EmptyString"
- skip compare category if the value is "null" or "EmptyString"</HistoryEntry>
		<HistoryEntry Editor="R.H." TestVersion="0.0.37" Date="2014-08-13">VerifyObjectDescription:
- remove parameter "MaxSubIndex"</HistoryEntry>
		<HistoryEntry Editor="R.H." TestVersion="0.0.38" Date="2014-12-18">CompareEntry/Object description:
write object index (and entry subindex) to the logger in case of an mismatching name</HistoryEntry>
		<HistoryEntry Editor="O.H." TestVersion="0.0.39" Date="2014-12-22">IsCommandObject: suppress of online dictionary reload if "Reload online dictionary before test" is checked.</HistoryEntry>
		<HistoryEntry Editor="R.H." TestVersion="0.0.40" Date="2015-04-28">Add "String.ConvertToByteArray"</HistoryEntry>
		<HistoryEntry Editor="D.O." TestVersion="0.0.41" Date="2015-05-06">VerifyObjectDescription.CompareName: Bugfix Warning Message</HistoryEntry>
		<HistoryEntry Editor="R.H." TestVersion="0.0.42" Date="2015-05-22">VerifyEntryDescription : bugfix handle min/max data</HistoryEntry>
		<HistoryEntry Editor="O.H." TestVersion="0.0.43" Date="2015-09-02">Test schema version set to 1.0.23</HistoryEntry>
		<HistoryEntry Editor="R.H." TestVersion="0.0.44" Date="2015-10-23">CompareOD :
- compare also SI0 for VAR objects
add functions:
- ArrayOfString.IndexOfCaseInsensitive
- CheckObjectDescription
- DataTypeSupportCompleteAccess
- ObjectSupportCompleteAccess
</HistoryEntry>
		<HistoryEntry Editor="O.H." TestVersion="0.0.45" Date="2015-11-18">DiagnosisHistory test function: typo '0x10f03' fixed
All functions: string format of hex values changed from 'x' to 'X'</HistoryEntry>
		<HistoryEntry Editor="O.H." TestVersion="0.0.46" Date="2016-02-16">Where: Testfunction 'CheckIfCurrentConfigRequiresCu2508'
Reason: A new test function is required to check the current OpMode against the availability of the real time extension Cu2508
Solution: Test function added</HistoryEntry>
		<HistoryEntry Editor="B.L." TestVersion="0.0.47" Date="2016-02-17" Id="EN_BF_0001_160217_1" Type="Enhancement">Update to Schema version 1.0.24</HistoryEntry>
		<HistoryEntry Editor="B.L." TestVersion="0.0.48" Date="2016-02-17" Id="EN_BF_0001_160217_2">Editorial changes</HistoryEntry>
		<HistoryEntry Editor="R.H." TestVersion="0.0.49" Date="2016-03-24" Id="">VerifyEntryDescription/CheckEntryDescription : skip MinData and MaxData tests is the expected data is not defined</HistoryEntry>
		<HistoryEntry Editor="R.H." TestVersion="0.0.50" Date="2016-12-05" Id="">Change return type of CheckEntryDescription and CheckObjectDescription (errors will written to logger directly and only the error flag will be returned)</HistoryEntry>
		<HistoryEntry Editor="R.H." TestVersion="0.0.51" Date="2017-01-19" Id="">GetDeviceEmulationFlags : handle not existing EEPROM element</HistoryEntry>
		<HistoryEntry Editor="R.H." TestVersion="0.0.52" Date="2017-05-16" Id="">Enhance 'CompareObjectDictionary' parameter (object ignore list added)</HistoryEntry>
		<HistoryEntry Editor="G.E." TestVersion="0.0.53" Date="2017-07-20">What:
- Change existing target variable "XmlFile" to valid, locally defined variable: "DataTypeSupportCompleteAccess.xmlFile".
Where:
- DataTypeSupportCompleteAccess /TestStep[7]/Compare[2]/Equal/SetVariable/@Target
- ObjectSupportCompleteAccess /TestStep[6]/Compare[2]/Equal/SetVariable/@Target</HistoryEntry>
		<HistoryEntry Editor="R.H." TestVersion="0.0.54" Date="2017-12-08">Add "DataType.ToString", "DataType.Compare" and "ObjectCode.Compare"
CheckEntryDescription/CheckObjectDescription: write datatype name or object code name in case of a mismatch</HistoryEntry>
		<HistoryEntry Editor="R.H." TestVersion="0.0.55" Date="2018-01-29">enhance "string" datatype names with ESI datatype name</HistoryEntry>
		<HistoryEntry Editor="R.H." TestVersion="0.0.56" Date="2018-04-10">compare OD: skip compare bitoffsets and object size in case of skipping bitlength for variable entries</HistoryEntry>
		<HistoryEntry Editor="R.H." TestVersion="0.0.57" Date="2018-05-24">update "ArrayOfString.AddToLogger": raise an error if the output type is not known</HistoryEntry>
		<HistoryEntry Editor="R.H." TestVersion="0.0.58" Date="2018-07-05">Update IsCommandObject</HistoryEntry>
		<HistoryEntry Editor="B.L." TestVersion="0.0.59" Date="2018-09-14">Add output IDs and update Schema version to 1.0.31</HistoryEntry>
		<HistoryEntry Editor="R.H." TestVersion="0.0.60" Date="2018-09-20" Type="Enhancement">CompareObjectDictionary: skip entry tests if the object is not defined.</HistoryEntry>
		<HistoryEntry Editor="B.L." TestVersion="0.0.61" Date="2018-09-27">Skip for offline slaves.</HistoryEntry>
		<HistoryEntry Editor="R.H." TestVersion="0.0.62" Date="2018-11-15" Type="Enhancement">add functions
- 'ArrayOfString.IndexOfExtended'
- 'CreateAccessByte'

'CheckEntryDescription':
- compare access for all states if defined =&gt; less test messages and more meaningful

'CheckXXXXDescription':
- check names less strict: skipped whitespaces are ignored, the specified name just need to be part of the defined name and the strings are compared case insensitive</HistoryEntry>
		<HistoryEntry Editor="R.H." TestVersion="0.0.63" Date="2018-12-14" Type="Enhancement">'CheckEntryDescription': test complete entry also if the category is set to "o"</HistoryEntry>
		<HistoryEntry Editor="R.H." TestVersion="0.0.64" Date="2019-02-05">'CheckEntryDescription': change init values for access strings</HistoryEntry>
		<HistoryEntry Editor="R.H." TestVersion="0.0.65" Date="2019-03-12">add 'ArrayOfUInt32.IndexOf'</HistoryEntry>
		<HistoryEntry Editor="R.H." TestVersion="0.0.66" Date="2019-03-20">add functions to get mailbox timeouts
ArrayOfString.IndexOfExtended: handle brackets in pattern string</HistoryEntry>
		<HistoryEntry Editor="R.H." TestVersion="0.0.67" Date="2019-03-31">CheckEntryDescription: update entry access fixed string handling
ArrayOfString.IndexOfExtended: handle brackets in pattern string (update)</HistoryEntry>
	</History>
	<TestFunctions>
		<TestFunction FunctionId="101" Name="AddMsgToList">
			<?MAX_OUTPUT_ID 0?>
			<Description>
				<Purpose>Adds a message to a array of strings</Purpose>
				<PreCondition></PreCondition>
				<Action>-Add the passed string to the passed array</Action>
				<PostCondition>Throws an error if one if the string cannot be evaluated</PostCondition>
				<ProposalForSolution>true</ProposalForSolution>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>AddMsgToList.StringMsg</Name>
				<Type>String</Type>
				<Comment>Message to be added</Comment>
			</Parameter>
			<OutParameter>
				<Name>AddMsgToList.ReturnList</Name>
				<Type>ArrayOfString</Type>
			</OutParameter>
			<TestStep Name="addString">
				<AddArrayItem TargetArray="AddMsgToList.ReturnList">AddMsgToList.StringMsg</AddArrayItem>
				<RaiseErrorOnFailure Id="0">AddMsgToList: Failed to add {0} to {1}</RaiseErrorOnFailure>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="201" Name="ArrayOfBytes.Compare">
			<?MAX_OUTPUT_ID 1?>
			<Description>
				<Purpose>Compare two ArrayOfBytes</Purpose>
				<PreCondition></PreCondition>
				<Action>if the reference array is null the comparision is abort (without an error text).
else both arrays are compared</Action>
				<PostCondition>return array content information if arrays mismatch. If Arrays are equal the return value is empty</PostCondition>
				<ProposalForSolution>true</ProposalForSolution>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>ArrayOfBytes.Compare.RefArrayOfByte</Name>
				<Type>ArrayOfBytes</Type>
				<Comment>reference ArrayOfByte</Comment>
			</Parameter>
			<Parameter>
				<Name>ArrayOfBytes.Compare.CmpArrayOfByte</Name>
				<Type>ArrayOfBytes</Type>
				<Comment>ArrayOfByte to compare</Comment>
			</Parameter>
			<Parameter>
				<Name>ArrayOfBytes.Compare.InfoText</Name>
				<Type>String</Type>
				<Comment>additional Info text which will be the first part of the error message</Comment>
			</Parameter>
			<OutParameter>
				<Name>ArrayOfBytes.Compare.ErrorText</Name>
				<Type>String</Type>
			</OutParameter>
			<TestStep Name="InitResult">
				<SetVariable Target="ArrayOfBytes.Compare.ErrorText">EmptyString</SetVariable>
			</TestStep>
			<TestStep Name="CheckIfReferenceIsNull">
				<Compare>
					<Equal>
						<Value1>ArrayOfBytes.Compare.RefArrayOfByte</Value1>
						<Value2>null</Value2>
						<Return Id="0"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="ReturnIfEqual">
				<Compare>
					<Equal>
						<Value1>ArrayOfBytes.Compare.RefArrayOfByte</Value1>
						<Value2>ArrayOfBytes.Compare.CmpArrayOfByte</Value2>
						<Return Id="1"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CreateMessage">
				<SetVariable Target="ArrayOfBytes.Compare.ErrorText" Param0="ArrayOfBytes.Compare.InfoText" Param1="ArrayOfBytes.Compare.CmpArrayOfByte" Param2="ArrayOfBytes.Compare.RefArrayOfByte">{0} '{1}' expected: '{2}'.</SetVariable>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="202" Name="ArrayOfBytes.IndexOf">
			<?MAX_OUTPUT_ID 3?>
			<Description>
				<Purpose>Gets the array index of an specified Byte</Purpose>
				<PreCondition></PreCondition>
				<Action>Search for specified data</Action>
				<PostCondition>Return index if data was not found -1 is returned</PostCondition>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>ArrayOfByte.IndexOf.Data</Name>
				<Type>Int32</Type>
				<!--data to search for-->
			</Parameter>
			<Parameter>
				<Name>ArrayOfByte.IndexOf.Array</Name>
				<Type>ArrayOfBytes</Type>
				<!--Source Array-->
			</Parameter>
			<LocalVariables>
				<Name>ArrayOfByte.IndexOf.Cnt</Name>
				<Type>UInt16</Type>
				<!--temp counter variable-->
			</LocalVariables>
			<LocalVariables>
				<Name>ArrayOfByte.IndexOf.ArrayLength</Name>
				<Type>UInt32</Type>
				<!--Length of the source array-->
			</LocalVariables>
			<OutParameter>
				<Name>ArrayOfByte.IndexOf.i32Index</Name>
				<Type>Int32</Type>
			</OutParameter>
			<TestStep>
				<!--If Array is not defined return -1-->
				<Compare>
					<Equal>
						<Value1>ArrayOfByte.IndexOf.Array</Value1>
						<Value2>null</Value2>
						<SetVariable Target="ArrayOfByte.IndexOf.i32Index">-1</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>ArrayOfByte.IndexOf.Array</Value1>
						<Value2>null</Value2>
						<Return Id="0"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Get Size of Source Array-->
				<SizeOf UInt32Var="ArrayOfByte.IndexOf.ArrayLength">ArrayOfByte.IndexOf.Array</SizeOf>
			</TestStep>
			<TestStep>
				<!--Check if array has elements-->
				<Compare>
					<Equal>
						<Value1>ArrayOfByte.IndexOf.ArrayLength</Value1>
						<Value2>0</Value2>
						<SetVariable Target="ArrayOfByte.IndexOf.i32Index">-1</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>ArrayOfByte.IndexOf.ArrayLength</Value1>
						<Value2>0</Value2>
						<Return Id="1"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<SetVariable Target="ArrayOfByte.IndexOf.Cnt">0</SetVariable>
			</TestStep>
			<TestStep Name="LOOPSTART">
				<!--Check if Loop finished-->
				<Compare>
					<GreaterOrEqual>
						<Value1>ArrayOfByte.IndexOf.Cnt</Value1>
						<Value2>ArrayOfByte.IndexOf.ArrayLength</Value2>
						<SetVariable Target="ArrayOfByte.IndexOf.i32Index">-1</SetVariable>
					</GreaterOrEqual>
				</Compare>
				<Compare>
					<GreaterOrEqual>
						<Value1>ArrayOfByte.IndexOf.Cnt</Value1>
						<Value2>ArrayOfByte.IndexOf.ArrayLength</Value2>
						<Return Id="2"></Return>
					</GreaterOrEqual>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Check if current element is matching-->
				<Compare>
					<Equal>
						<Value1>ArrayOfByte.IndexOf.Array[ArrayOfByte.IndexOf.Cnt]</Value1>
						<Value2>ArrayOfByte.IndexOf.Data</Value2>
						<SetVariable Target="ArrayOfByte.IndexOf.i32Index">ArrayOfByte.IndexOf.Cnt</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>ArrayOfByte.IndexOf.Array[ArrayOfByte.IndexOf.Cnt]</Value1>
						<Value2>ArrayOfByte.IndexOf.Data</Value2>
						<Return Id="3"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Increment counter-->
				<SetVariable Target="ArrayOfByte.IndexOf.Cnt">ArrayOfByte.IndexOf.Cnt +1</SetVariable>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>LOOPSTART</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="301" Name="ArrayOfInt32.AddToLogger">
			<?MAX_OUTPUT_ID 10?>
			<Description>
				<Purpose>Add all string array elements to the Tool logger</Purpose>
				<PreCondition></PreCondition>
				<Action></Action>
				<PostCondition></PostCondition>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>ArrayOfInt32.AddToLogger.Array</Name>
				<Type>ArrayOfInt32</Type>
				<!--String array to print-->
			</Parameter>
			<Parameter>
				<Name>ArrayOfInt32.AddToLogger.Level</Name>
				<Type>String</Type>
				<!--Output level of the elements-->
			</Parameter>
			<Parameter>
				<Name>ArrayOfInt32.AddToLogger.PrintInHex</Name>
				<Type>Bool</Type>
				<!--if true the values are written in hex-->
			</Parameter>
			<LocalVariables>
				<Name>ArrayOfInt32.AddToLogger.Cnt</Name>
				<Type>UInt16</Type>
				<!--temp counter variable-->
			</LocalVariables>
			<LocalVariables>
				<Name>ArrayOfInt32.AddToLogger.ArrayLength</Name>
				<Type>UInt32</Type>
				<!--Length of the source array-->
			</LocalVariables>
			<TestStep>
				<!--Retujrn if the array is null-->
				<Compare>
					<Equal>
						<Value1>ArrayOfInt32.AddToLogger.Array</Value1>
						<Value2>null</Value2>
						<Return Id="0"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Get Size of Source Array-->
				<SizeOf UInt32Var="ArrayOfInt32.AddToLogger.ArrayLength">ArrayOfInt32.AddToLogger.Array</SizeOf>
			</TestStep>
			<TestStep>
				<!--Check if the array has elements-->
				<Compare>
					<Equal>
						<Value1>ArrayOfInt32.AddToLogger.ArrayLength</Value1>
						<Value2>0</Value2>
						<Return Id="1"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<SetVariable Target="ArrayOfInt32.AddToLogger.Cnt">0</SetVariable>
			</TestStep>
			<TestStep Name="LOOPSTART">
				<!--Check if Loop finished-->
				<Compare>
					<GreaterOrEqual>
						<Value1>ArrayOfInt32.AddToLogger.Cnt</Value1>
						<Value2>ArrayOfInt32.AddToLogger.ArrayLength</Value2>
						<Return Id="2"></Return>
					</GreaterOrEqual>
				</Compare>
			</TestStep>
			<TestStep Name="HandleLevel">
				<!--Check if current element is matching-->
				<Compare>
					<Equal>
						<Value1>ArrayOfInt32.AddToLogger.Level</Value1>
						<Value2>"Error"</Value2>
						<GotoStep>DumpError</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>ArrayOfInt32.AddToLogger.Level</Value1>
						<Value2>"Warning"</Value2>
						<GotoStep>DumpWarning</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>ArrayOfInt32.AddToLogger.Level</Value1>
						<Value2>"Output"</Value2>
						<GotoStep>DumpOutput</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="DumpVerbose">
				<Compare>
					<Equal>
						<Value1>ArrayOfInt32.AddToLogger.PrintInHex</Value1>
						<Value2>true</Value2>
						<WriteLine Id="3" Param0="ArrayOfInt32.AddToLogger.Array[ArrayOfInt32.AddToLogger.Cnt]" Level="Verbose">0x{0:X8}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>ArrayOfInt32.AddToLogger.PrintInHex</Value1>
						<Value2>false</Value2>
						<WriteLine Id="4" Param0="ArrayOfInt32.AddToLogger.Array[ArrayOfInt32.AddToLogger.Cnt]" Level="Verbose">{0}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>LoopEnd</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="DumpOutput">
				<Compare>
					<Equal>
						<Value1>ArrayOfInt32.AddToLogger.PrintInHex</Value1>
						<Value2>true</Value2>
						<WriteLine Id="5" Param0="ArrayOfInt32.AddToLogger.Array[ArrayOfInt32.AddToLogger.Cnt]" Level="Output">0x{0:X8}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>ArrayOfInt32.AddToLogger.PrintInHex</Value1>
						<Value2>false</Value2>
						<WriteLine Id="6" Param0="ArrayOfInt32.AddToLogger.Array[ArrayOfInt32.AddToLogger.Cnt]" Level="Output">0x{0:X8}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>LoopEnd</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="DumpWarning">
				<Compare>
					<Equal>
						<Value1>ArrayOfInt32.AddToLogger.PrintInHex</Value1>
						<Value2>true</Value2>
						<WriteLine Id="7" Param0="ArrayOfInt32.AddToLogger.Array[ArrayOfInt32.AddToLogger.Cnt]" Level="Warning">0x{0:X8}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>ArrayOfInt32.AddToLogger.PrintInHex</Value1>
						<Value2>false</Value2>
						<WriteLine Id="8" Param0="ArrayOfInt32.AddToLogger.Array[ArrayOfInt32.AddToLogger.Cnt]" Level="Warning">{0}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>LoopEnd</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="DumpError">
				<Compare>
					<Equal>
						<Value1>ArrayOfInt32.AddToLogger.PrintInHex</Value1>
						<Value2>true</Value2>
						<WriteLine Id="9" Param0="ArrayOfInt32.AddToLogger.Array[ArrayOfInt32.AddToLogger.Cnt]" Level="Error">0x{0:X8}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>ArrayOfInt32.AddToLogger.PrintInHex</Value1>
						<Value2>false</Value2>
						<WriteLine Id="10" Param0="ArrayOfInt32.AddToLogger.Array[ArrayOfInt32.AddToLogger.Cnt]" Level="Error">{0}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>LoopEnd</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="LoopEnd">
				<!--Increment counter-->
				<SetVariable Target="ArrayOfInt32.AddToLogger.Cnt">ArrayOfInt32.AddToLogger.Cnt +1</SetVariable>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>LOOPSTART</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="302" Name="ArrayOfInt32.IndexOf">
			<?MAX_OUTPUT_ID 3?>
			<Description>
				<Purpose>Gets the array index of an specified Int32</Purpose>
				<PreCondition></PreCondition>
				<Action>Search for specified data</Action>
				<PostCondition>Return index if data was not found -1 is returned</PostCondition>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>ArrayOfInt32.IndexOf.i32Data</Name>
				<Type>Int32</Type>
				<!--i32 data to search for-->
			</Parameter>
			<Parameter>
				<Name>ArrayOfInt32.IndexOf.Array</Name>
				<Type>ArrayOfInt32</Type>
				<!--Source Array-->
			</Parameter>
			<LocalVariables>
				<Name>ArrayOfInt32.IndexOf.Cnt</Name>
				<Type>UInt16</Type>
				<!--temp counter variable-->
			</LocalVariables>
			<LocalVariables>
				<Name>ArrayOfInt32.IndexOf.ArrayLength</Name>
				<Type>UInt32</Type>
				<!--Length of the source array-->
			</LocalVariables>
			<OutParameter>
				<Name>ArrayOfInt32.IndexOf.i32Index</Name>
				<Type>Int32</Type>
			</OutParameter>
			<TestStep>
				<!--If Array is not defined return -1-->
				<Compare>
					<Equal>
						<Value1>ArrayOfInt32.IndexOf.Array</Value1>
						<Value2>null</Value2>
						<SetVariable Target="ArrayOfInt32.IndexOf.i32Index">-1</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>ArrayOfInt32.IndexOf.Array</Value1>
						<Value2>null</Value2>
						<Return Id="0"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Get Size of Source Array-->
				<SizeOf UInt32Var="ArrayOfInt32.IndexOf.ArrayLength">ArrayOfInt32.IndexOf.Array</SizeOf>
			</TestStep>
			<TestStep>
				<!--Check if array has elements-->
				<Compare>
					<Equal>
						<Value1>ArrayOfInt32.IndexOf.ArrayLength</Value1>
						<Value2>0</Value2>
						<SetVariable Target="ArrayOfInt32.IndexOf.i32Index">-1</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>ArrayOfInt32.IndexOf.ArrayLength</Value1>
						<Value2>0</Value2>
						<Return Id="1"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<SetVariable Target="ArrayOfInt32.IndexOf.Cnt">0</SetVariable>
			</TestStep>
			<TestStep Name="LOOPSTART">
				<!--Check if Loop finished-->
				<Compare>
					<GreaterOrEqual>
						<Value1>ArrayOfInt32.IndexOf.Cnt</Value1>
						<Value2>ArrayOfInt32.IndexOf.ArrayLength</Value2>
						<SetVariable Target="ArrayOfInt32.IndexOf.i32Index">-1</SetVariable>
					</GreaterOrEqual>
				</Compare>
				<Compare>
					<GreaterOrEqual>
						<Value1>ArrayOfInt32.IndexOf.Cnt</Value1>
						<Value2>ArrayOfInt32.IndexOf.ArrayLength</Value2>
						<Return Id="2"></Return>
					</GreaterOrEqual>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Check if current element is matching-->
				<Compare>
					<Equal>
						<Value1>ArrayOfInt32.IndexOf.Array[ArrayOfInt32.IndexOf.Cnt]</Value1>
						<Value2>ArrayOfInt32.IndexOf.i32Data</Value2>
						<SetVariable Target="ArrayOfInt32.IndexOf.i32Index">ArrayOfInt32.IndexOf.Cnt</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>ArrayOfInt32.IndexOf.Array[ArrayOfInt32.IndexOf.Cnt]</Value1>
						<Value2>ArrayOfInt32.IndexOf.i32Data</Value2>
						<Return Id="3"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Increment counter-->
				<SetVariable Target="ArrayOfInt32.IndexOf.Cnt">ArrayOfInt32.IndexOf.Cnt +1</SetVariable>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>LOOPSTART</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="2101" Name="ArrayOfUInt32.IndexOf">
			<?MAX_OUTPUT_ID 3?>
			<Description>
				<Purpose>Gets the array index of an specified UInt32</Purpose>
				<PreCondition></PreCondition>
				<Action>Search for specified data</Action>
				<PostCondition>Return index if data was not found -1 is returned</PostCondition>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>ArrayOfUInt32.IndexOf.i32Data</Name>
				<Type>UInt32</Type>
				<!--i32 data to search for-->
			</Parameter>
			<Parameter>
				<Name>ArrayOfUInt32.IndexOf.Array</Name>
				<Type>ArrayOfUInt32</Type>
				<!--Source Array-->
			</Parameter>
			<LocalVariables>
				<Name>ArrayOfUInt32.IndexOf.Cnt</Name>
				<Type>UInt16</Type>
				<!--temp counter variable-->
			</LocalVariables>
			<LocalVariables>
				<Name>ArrayOfUInt32.IndexOf.ArrayLength</Name>
				<Type>UInt32</Type>
				<!--Length of the source array-->
			</LocalVariables>
			<OutParameter>
				<Name>ArrayOfUInt32.IndexOf.i32Index</Name>
				<Type>Int32</Type>
			</OutParameter>
			<TestStep>
				<!--If Array is not defined return -1-->
				<Compare>
					<Equal>
						<Value1>ArrayOfUInt32.IndexOf.Array</Value1>
						<Value2>null</Value2>
						<SetVariable Target="ArrayOfUInt32.IndexOf.i32Index">-1</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>ArrayOfUInt32.IndexOf.Array</Value1>
						<Value2>null</Value2>
						<Return Id="0"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Get Size of Source Array-->
				<SizeOf UInt32Var="ArrayOfUInt32.IndexOf.ArrayLength">ArrayOfUInt32.IndexOf.Array</SizeOf>
			</TestStep>
			<TestStep>
				<!--Check if array has elements-->
				<Compare>
					<Equal>
						<Value1>ArrayOfUInt32.IndexOf.ArrayLength</Value1>
						<Value2>0</Value2>
						<SetVariable Target="ArrayOfUInt32.IndexOf.i32Index">-1</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>ArrayOfUInt32.IndexOf.ArrayLength</Value1>
						<Value2>0</Value2>
						<Return Id="1"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<SetVariable Target="ArrayOfUInt32.IndexOf.Cnt">0</SetVariable>
			</TestStep>
			<TestStep Name="LOOPSTART">
				<!--Check if Loop finished-->
				<Compare>
					<GreaterOrEqual>
						<Value1>ArrayOfUInt32.IndexOf.Cnt</Value1>
						<Value2>ArrayOfUInt32.IndexOf.ArrayLength</Value2>
						<SetVariable Target="ArrayOfUInt32.IndexOf.i32Index">-1</SetVariable>
					</GreaterOrEqual>
				</Compare>
				<Compare>
					<GreaterOrEqual>
						<Value1>ArrayOfUInt32.IndexOf.Cnt</Value1>
						<Value2>ArrayOfUInt32.IndexOf.ArrayLength</Value2>
						<Return Id="2"></Return>
					</GreaterOrEqual>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Check if current element is matching-->
				<Compare>
					<Equal>
						<Value1>ArrayOfUInt32.IndexOf.Array[ArrayOfUInt32.IndexOf.Cnt]</Value1>
						<Value2>ArrayOfUInt32.IndexOf.i32Data</Value2>
						<SetVariable Target="ArrayOfUInt32.IndexOf.i32Index">ArrayOfUInt32.IndexOf.Cnt</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>ArrayOfUInt32.IndexOf.Array[ArrayOfUInt32.IndexOf.Cnt]</Value1>
						<Value2>ArrayOfUInt32.IndexOf.i32Data</Value2>
						<Return Id="3"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Increment counter-->
				<SetVariable Target="ArrayOfUInt32.IndexOf.Cnt">ArrayOfUInt32.IndexOf.Cnt +1</SetVariable>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>LOOPSTART</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="401" Name="ArrayOfString.AddToLogger">
			<?MAX_OUTPUT_ID 7?>
			<Description>
				<Purpose>Add all string array elements to the Tool logger</Purpose>
				<PreCondition></PreCondition>
				<Action></Action>
				<PostCondition></PostCondition>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>ArrayOfString.AddToLogger.Array</Name>
				<Type>ArrayOfString</Type>
				<!--String array to print-->
			</Parameter>
			<Parameter>
				<Name>ArrayOfString.AddToLogger.Level</Name>
				<Type>String</Type>
				<!--Output level of the elements-->
			</Parameter>
			<LocalVariables>
				<Name>ArrayOfString.AddToLogger.Cnt</Name>
				<Type>UInt16</Type>
				<!--temp counter variable-->
			</LocalVariables>
			<LocalVariables>
				<Name>ArrayOfString.AddToLogger.ArrayLength</Name>
				<Type>UInt32</Type>
				<!--Length of the source array-->
			</LocalVariables>
			<TestStep>
				<!--Retujrn if the array is null-->
				<Compare>
					<Equal>
						<Value1>ArrayOfString.AddToLogger.Array</Value1>
						<Value2>null</Value2>
						<Return Id="0"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Get Size of Source Array-->
				<SizeOf UInt32Var="ArrayOfString.AddToLogger.ArrayLength">ArrayOfString.AddToLogger.Array</SizeOf>
			</TestStep>
			<TestStep>
				<!--Check if the array has elements-->
				<Compare>
					<Equal>
						<Value1>ArrayOfString.AddToLogger.ArrayLength</Value1>
						<Value2>0</Value2>
						<Return Id="1"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<SetVariable Target="ArrayOfString.AddToLogger.Cnt">0</SetVariable>
			</TestStep>
			<TestStep Name="LOOPSTART">
				<!--Check if Loop finished-->
				<Compare>
					<GreaterOrEqual>
						<Value1>ArrayOfString.AddToLogger.Cnt</Value1>
						<Value2>ArrayOfString.AddToLogger.ArrayLength</Value2>
						<Return Id="2"></Return>
					</GreaterOrEqual>
				</Compare>
			</TestStep>
			<TestStep Name="HandleLevel">
				<!--Check if current element is matching-->
				<Compare>
					<Equal>
						<Value1>ArrayOfString.AddToLogger.Level</Value1>
						<Value2>"Error"</Value2>
						<GotoStep>DumpError</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>ArrayOfString.AddToLogger.Level</Value1>
						<Value2>"Warning"</Value2>
						<GotoStep>DumpWarning</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>ArrayOfString.AddToLogger.Level</Value1>
						<Value2>"Output"</Value2>
						<GotoStep>DumpOutput</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>ArrayOfString.AddToLogger.Level</Value1>
						<Value2>"Verbose"</Value2>
						<RaiseError Id="3" Param0="ArrayOfString.AddToLogger.Level">The output type '{0}' is not supported. Use 'Error', 'Warning', 'Output' or 'Verbose'.</RaiseError>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="DumpVerbose">
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="4" Param0="ArrayOfString.AddToLogger.Array[ArrayOfString.AddToLogger.Cnt]" Level="Verbose">{0}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>LoopEnd</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="DumpOutput">
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="5" Param0="ArrayOfString.AddToLogger.Array[ArrayOfString.AddToLogger.Cnt]" Level="Output">{0}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>LoopEnd</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="DumpWarning">
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="6" Param0="ArrayOfString.AddToLogger.Array[ArrayOfString.AddToLogger.Cnt]" Level="Warning">{0}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>LoopEnd</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="DumpError">
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="7" Param0="ArrayOfString.AddToLogger.Array[ArrayOfString.AddToLogger.Cnt]" Level="Error">{0}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>LoopEnd</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="LoopEnd">
				<!--Increment counter-->
				<SetVariable Target="ArrayOfString.AddToLogger.Cnt">ArrayOfString.AddToLogger.Cnt +1</SetVariable>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>LOOPSTART</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="402" Name="ArrayOfString.IndexOf">
			<?MAX_OUTPUT_ID 3?>
			<Description>
				<Purpose>Gets the array index of an specified String (case sensitive)</Purpose>
				<PreCondition></PreCondition>
				<Action>Search for specified data</Action>
				<PostCondition>Return index if data was not found -1 is returned</PostCondition>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>ArrayOfString.IndexOf.strData</Name>
				<Type>String</Type>
				<!--string to search for-->
			</Parameter>
			<Parameter>
				<Name>ArrayOfString.IndexOf.Array</Name>
				<Type>ArrayOfString</Type>
				<!--Source Array-->
			</Parameter>
			<LocalVariables>
				<Name>ArrayOfString.IndexOf.Cnt</Name>
				<Type>UInt16</Type>
				<!--temp counter variable-->
			</LocalVariables>
			<LocalVariables>
				<Name>ArrayOfString.IndexOf.ArrayLength</Name>
				<Type>UInt32</Type>
				<!--Length of the source array-->
			</LocalVariables>
			<OutParameter>
				<Name>ArrayOfString.IndexOf.i32Index</Name>
				<Type>Int32</Type>
			</OutParameter>
			<TestStep>
				<!--If Array is not defined return -1-->
				<Compare>
					<Equal>
						<Value1>ArrayOfString.IndexOf.Array</Value1>
						<Value2>null</Value2>
						<SetVariable Target="ArrayOfString.IndexOf.i32Index">-1</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>ArrayOfString.IndexOf.Array</Value1>
						<Value2>null</Value2>
						<Return Id="0"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Get Size of Source Array-->
				<SizeOf UInt32Var="ArrayOfString.IndexOf.ArrayLength">ArrayOfString.IndexOf.Array</SizeOf>
			</TestStep>
			<TestStep>
				<!--Check if array has elements-->
				<Compare>
					<Equal>
						<Value1>ArrayOfString.IndexOf.ArrayLength</Value1>
						<Value2>0</Value2>
						<SetVariable Target="ArrayOfString.IndexOf.i32Index">-1</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>ArrayOfString.IndexOf.ArrayLength</Value1>
						<Value2>0</Value2>
						<Return Id="1"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<SetVariable Target="ArrayOfString.IndexOf.Cnt">0</SetVariable>
			</TestStep>
			<TestStep Name="LOOPSTART">
				<!--Check if Loop finished-->
				<Compare>
					<GreaterOrEqual>
						<Value1>ArrayOfString.IndexOf.Cnt</Value1>
						<Value2>ArrayOfString.IndexOf.ArrayLength</Value2>
						<SetVariable Target="ArrayOfString.IndexOf.i32Index">-1</SetVariable>
					</GreaterOrEqual>
				</Compare>
				<Compare>
					<GreaterOrEqual>
						<Value1>ArrayOfString.IndexOf.Cnt</Value1>
						<Value2>ArrayOfString.IndexOf.ArrayLength</Value2>
						<Return Id="2"></Return>
					</GreaterOrEqual>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Check if current element is matching-->
				<Compare>
					<Equal>
						<Value1>ArrayOfString.IndexOf.Array[ArrayOfString.IndexOf.Cnt]</Value1>
						<Value2>ArrayOfString.IndexOf.strData</Value2>
						<SetVariable Target="ArrayOfString.IndexOf.i32Index">ArrayOfString.IndexOf.Cnt</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>ArrayOfString.IndexOf.Array[ArrayOfString.IndexOf.Cnt]</Value1>
						<Value2>ArrayOfString.IndexOf.strData</Value2>
						<Return Id="3"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Increment counter-->
				<SetVariable Target="ArrayOfString.IndexOf.Cnt">ArrayOfString.IndexOf.Cnt +1</SetVariable>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>LOOPSTART</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="403" Name="ArrayOfString.IndexOfCaseInsensitive">
			<?MAX_OUTPUT_ID 3?>
			<Description>
				<Purpose>Gets the array index of an specified String (case insensitive</Purpose>
				<PreCondition></PreCondition>
				<Action>Search for specified data</Action>
				<PostCondition>Return index if data was not found -1 is returned</PostCondition>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>ArrayOfString.IndexOfCaseInsensitive.strData</Name>
				<Type>String</Type>
				<!--string to search for-->
			</Parameter>
			<Parameter>
				<Name>ArrayOfString.IndexOfCaseInsensitive.Array</Name>
				<Type>ArrayOfString</Type>
				<!--Source Array-->
			</Parameter>
			<LocalVariables>
				<Name>ArrayOfString.IndexOfCaseInsensitive.Cnt</Name>
				<Type>UInt16</Type>
				<!--temp counter variable-->
			</LocalVariables>
			<LocalVariables>
				<Name>ArrayOfString.IndexOfCaseInsensitive.ArrayLength</Name>
				<Type>UInt32</Type>
				<!--Length of the source array-->
			</LocalVariables>
			<LocalVariables>
				<Name>ArrayOfString.IndexOfCaseInsensitive.cmpResult</Name>
				<Type>Int32</Type>
				<!--String Compare result-->
			</LocalVariables>
			<OutParameter>
				<Name>ArrayOfString.IndexOfCaseInsensitive.i32Index</Name>
				<Type>Int32</Type>
			</OutParameter>
			<TestStep>
				<!--If Array is not defined return -1-->
				<Compare>
					<Equal>
						<Value1>ArrayOfString.IndexOfCaseInsensitive.Array</Value1>
						<Value2>null</Value2>
						<SetVariable Target="ArrayOfString.IndexOfCaseInsensitive.i32Index">-1</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>ArrayOfString.IndexOfCaseInsensitive.Array</Value1>
						<Value2>null</Value2>
						<Return Id="0"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Get Size of Source Array-->
				<SizeOf UInt32Var="ArrayOfString.IndexOfCaseInsensitive.ArrayLength">ArrayOfString.IndexOfCaseInsensitive.Array</SizeOf>
			</TestStep>
			<TestStep>
				<!--Check if array has elements-->
				<Compare>
					<Equal>
						<Value1>ArrayOfString.IndexOfCaseInsensitive.ArrayLength</Value1>
						<Value2>0</Value2>
						<SetVariable Target="ArrayOfString.IndexOfCaseInsensitive.i32Index">-1</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>ArrayOfString.IndexOfCaseInsensitive.ArrayLength</Value1>
						<Value2>0</Value2>
						<Return Id="1"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<SetVariable Target="ArrayOfString.IndexOfCaseInsensitive.Cnt">0</SetVariable>
			</TestStep>
			<TestStep Name="LOOPSTART">
				<!--Check if Loop finished-->
				<Compare>
					<GreaterOrEqual>
						<Value1>ArrayOfString.IndexOfCaseInsensitive.Cnt</Value1>
						<Value2>ArrayOfString.IndexOfCaseInsensitive.ArrayLength</Value2>
						<SetVariable Target="ArrayOfString.IndexOfCaseInsensitive.i32Index">-1</SetVariable>
					</GreaterOrEqual>
				</Compare>
				<Compare>
					<GreaterOrEqual>
						<Value1>ArrayOfString.IndexOfCaseInsensitive.Cnt</Value1>
						<Value2>ArrayOfString.IndexOfCaseInsensitive.ArrayLength</Value2>
						<Return Id="2"></Return>
					</GreaterOrEqual>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Check if current element is matching-->
				<StringCompare ReturnValue="ArrayOfString.IndexOfCaseInsensitive.cmpResult" Options="IgnoreCase">
					<String1>ArrayOfString.IndexOfCaseInsensitive.Array[ArrayOfString.IndexOfCaseInsensitive.Cnt]</String1>
					<String2>ArrayOfString.IndexOfCaseInsensitive.strData</String2>
				</StringCompare>
				<Compare>
					<Equal>
						<Value1>ArrayOfString.IndexOfCaseInsensitive.cmpResult</Value1>
						<Value2>0</Value2>
						<SetVariable Target="ArrayOfString.IndexOfCaseInsensitive.i32Index">ArrayOfString.IndexOfCaseInsensitive.Cnt</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>ArrayOfString.IndexOfCaseInsensitive.cmpResult</Value1>
						<Value2>0</Value2>
						<Return Id="3"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Increment counter-->
				<SetVariable Target="ArrayOfString.IndexOfCaseInsensitive.Cnt">ArrayOfString.IndexOfCaseInsensitive.Cnt +1</SetVariable>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>LOOPSTART</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="404" Name="ArrayOfString.IndexOfExtended">
			<?MAX_OUTPUT_ID 3?>
			<Description>
				<Purpose>Gets the array index of an specified String</Purpose>
				<PreCondition></PreCondition>
				<Action>Search for specified data</Action>
				<PostCondition>Return index if data was not found -1 is returned</PostCondition>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>ArrayOfString.IndexOfExtended.strData</Name>
				<Type>String</Type>
				<!--string to search for-->
			</Parameter>
			<Parameter>
				<Name>ArrayOfString.IndexOfExtended.Array</Name>
				<Type>ArrayOfString</Type>
				<!--Source Array-->
			</Parameter>
			<Parameter>
				<Name>ArrayOfString.IndexOfExtended.CaseSensitive</Name>
				<Type>Bool</Type>
			</Parameter>
			<Parameter>
				<Name>ArrayOfString.IndexOfExtended.IgnoreWhitespace</Name>
				<Type>Bool</Type>
			</Parameter>
			<Parameter>
				<Name>ArrayOfString.IndexOfExtended.PartialMatch</Name>
				<Type>Bool</Type>
			</Parameter>
			<LocalVariables>
				<Name>ArrayOfString.IndexOfExtended.Cnt</Name>
				<Type>UInt16</Type>
				<!--temp counter variable-->
			</LocalVariables>
			<LocalVariables>
				<Name>ArrayOfString.IndexOfExtended.ArrayLength</Name>
				<Type>UInt32</Type>
				<!--Length of the source array-->
			</LocalVariables>
			<LocalVariables>
				<Name>ArrayOfString.IndexOfExtended.match</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>ArrayOfString.IndexOfExtended.WorkingString</Name>
				<Type>String</Type>
				<!--currentArrayElement-->
			</LocalVariables>
			<LocalVariables>
				<Name>ArrayOfString.IndexOfExtended.Pattern</Name>
				<Type>String</Type>
				<!---->
			</LocalVariables>
			<LocalVariables>
				<Name>ArrayOfString.IndexOfExtended.SquareBracketOpen</Name>
				<Type>String</Type>
				<DefaultValue>\[</DefaultValue>
				<!---->
			</LocalVariables>
			<LocalVariables>
				<Name>ArrayOfString.IndexOfExtended.SquareBracketClose</Name>
				<Type>String</Type>
				<DefaultValue>\]</DefaultValue>
				<!---->
			</LocalVariables>
			<OutParameter>
				<Name>ArrayOfString.IndexOfExtended.i32Index</Name>
				<Type>Int32</Type>
			</OutParameter>
			<TestStep>
				<!--If Array is not defined return -1-->
				<Compare>
					<Equal>
						<Value1>ArrayOfString.IndexOfExtended.Array</Value1>
						<Value2>null</Value2>
						<SetVariable Target="ArrayOfString.IndexOfExtended.i32Index">-1</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>ArrayOfString.IndexOfExtended.Array</Value1>
						<Value2>null</Value2>
						<Return Id="0"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Get Size of Source Array-->
				<SizeOf UInt32Var="ArrayOfString.IndexOfExtended.ArrayLength">ArrayOfString.IndexOfExtended.Array</SizeOf>
			</TestStep>
			<TestStep>
				<!--Check if array has elements-->
				<Compare>
					<Equal>
						<Value1>ArrayOfString.IndexOfExtended.ArrayLength</Value1>
						<Value2>0</Value2>
						<SetVariable Target="ArrayOfString.IndexOfExtended.i32Index">-1</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>ArrayOfString.IndexOfExtended.ArrayLength</Value1>
						<Value2>0</Value2>
						<Return Id="1"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<SetVariable Target="ArrayOfString.IndexOfExtended.Cnt">0</SetVariable>
			</TestStep>
			<TestStep Name="LOOPSTART">
				<!--Check if Loop finished-->
				<Compare>
					<GreaterOrEqual>
						<Value1>ArrayOfString.IndexOfExtended.Cnt</Value1>
						<Value2>ArrayOfString.IndexOfExtended.ArrayLength</Value2>
						<SetVariable Target="ArrayOfString.IndexOfExtended.i32Index">-1</SetVariable>
					</GreaterOrEqual>
				</Compare>
				<Compare>
					<GreaterOrEqual>
						<Value1>ArrayOfString.IndexOfExtended.Cnt</Value1>
						<Value2>ArrayOfString.IndexOfExtended.ArrayLength</Value2>
						<Return Id="2"></Return>
					</GreaterOrEqual>
				</Compare>
			</TestStep>
			<TestStep>
				<GetArrayItem SourceArray="ArrayOfString.IndexOfExtended.Array" Target="ArrayOfString.IndexOfExtended.Pattern" Index="ArrayOfString.IndexOfExtended.Cnt"></GetArrayItem>
			</TestStep>
			<TestStep Name="CreatePatternFromString">
				<!--handle regex patterns-->
				<RegexReplace OutputString="ArrayOfString.IndexOfExtended.Pattern">
					<Pattern>[(]</Pattern>
					<InputString>ArrayOfString.IndexOfExtended.Pattern</InputString>
					<ReplacementString>\(</ReplacementString>
				</RegexReplace>
			</TestStep>
			<TestStep>
				<RegexReplace OutputString="ArrayOfString.IndexOfExtended.Pattern">
					<Pattern>[)]</Pattern>
					<InputString>ArrayOfString.IndexOfExtended.Pattern</InputString>
					<ReplacementString>\)</ReplacementString>
				</RegexReplace>
			</TestStep>
			<TestStep>
				<RegexReplace OutputString="ArrayOfString.IndexOfExtended.Pattern">
					<Pattern>[{]</Pattern>
					<InputString>ArrayOfString.IndexOfExtended.Pattern</InputString>
					<ReplacementString>\{</ReplacementString>
				</RegexReplace>
			</TestStep>
			<TestStep>
				<RegexReplace OutputString="ArrayOfString.IndexOfExtended.Pattern">
					<Pattern>[}]</Pattern>
					<InputString>ArrayOfString.IndexOfExtended.Pattern</InputString>
					<ReplacementString>\}</ReplacementString>
				</RegexReplace>
			</TestStep>
			<TestStep>
				<RegexReplace OutputString="ArrayOfString.IndexOfExtended.Pattern">
					<Pattern>[[]</Pattern>
					<InputString>ArrayOfString.IndexOfExtended.Pattern</InputString>
					<ReplacementString>ArrayOfString.IndexOfExtended.SquareBracketOpen</ReplacementString>
				</RegexReplace>
			</TestStep>
			<TestStep>
				<RegexReplace OutputString="ArrayOfString.IndexOfExtended.Pattern">
					<Pattern>[]]</Pattern>
					<InputString>ArrayOfString.IndexOfExtended.Pattern</InputString>
					<ReplacementString>ArrayOfString.IndexOfExtended.SquareBracketClose</ReplacementString>
				</RegexReplace>
			</TestStep>
			<TestStep>
				<Compare>
					<Equal>
						<Value1>ArrayOfString.IndexOfExtended.PartialMatch</Value1>
						<Value2>false</Value2>
						<SetVariable Target="ArrayOfString.IndexOfExtended.Pattern" Param0="ArrayOfString.IndexOfExtended.Pattern">^{0}$</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CheckOptions">
				<Compare>
					<Equal>
						<Value1>ArrayOfString.IndexOfExtended.CaseSensitive</Value1>
						<Value2>true</Value2>
						<GotoStep>CompareCaseSensitive</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>ArrayOfString.IndexOfExtended.CaseSensitive</Value1>
						<Value2>false</Value2>
						<GotoStep>CompareCaseInsensitive</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CompareCaseSensitive">
				<RegexIsMatch ReturnValue="ArrayOfString.IndexOfExtended.match" Options="None">
					<Pattern>ArrayOfString.IndexOfExtended.Pattern</Pattern>
					<InputString>ArrayOfString.IndexOfExtended.strData</InputString>
				</RegexIsMatch>
				<Compare>
					<Equal>
						<Value1>ArrayOfString.IndexOfExtended.match</Value1>
						<Value2>true</Value2>
						<GotoStep>CheckResult</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>ArrayOfString.IndexOfExtended.IgnoreWhitespace</Value1>
						<Value2>true</Value2>
						<GotoStep>CompareIgnoreWhiteSpace</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>CheckResult</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CompareCaseInsensitive">
				<RegexIsMatch ReturnValue="ArrayOfString.IndexOfExtended.match" Options="IgnoreCase">
					<Pattern>ArrayOfString.IndexOfExtended.Pattern</Pattern>
					<InputString>ArrayOfString.IndexOfExtended.strData</InputString>
				</RegexIsMatch>
				<Compare>
					<Equal>
						<Value1>ArrayOfString.IndexOfExtended.match</Value1>
						<Value2>true</Value2>
						<GotoStep>CheckResult</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>ArrayOfString.IndexOfExtended.IgnoreWhitespace</Value1>
						<Value2>true</Value2>
						<GotoStep>CompareIgnoreWhiteSpace</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>CheckResult</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CompareIgnoreWhiteSpace">
				<RegexIsMatch ReturnValue="ArrayOfString.IndexOfExtended.match" Options="IgnorePatternWhitespace">
					<Pattern>ArrayOfString.IndexOfExtended.Pattern</Pattern>
					<InputString>ArrayOfString.IndexOfExtended.strData</InputString>
				</RegexIsMatch>
			</TestStep>
			<TestStep Name="CheckResult">
				<!--Check if current element is matching-->
				<Compare>
					<Equal>
						<Value1>ArrayOfString.IndexOfExtended.match</Value1>
						<Value2>true</Value2>
						<SetVariable Target="ArrayOfString.IndexOfExtended.i32Index">ArrayOfString.IndexOfExtended.Cnt</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>ArrayOfString.IndexOfExtended.match</Value1>
						<Value2>true</Value2>
						<Return Id="3"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Increment counter-->
				<SetVariable Target="ArrayOfString.IndexOfExtended.Cnt">ArrayOfString.IndexOfExtended.Cnt +1</SetVariable>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>LOOPSTART</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="501" Name="ArrayOfUInt16.IndexOf">
			<?MAX_OUTPUT_ID 3?>
			<Description>
				<Purpose>Gets the array index of an specified Uint16</Purpose>
				<PreCondition></PreCondition>
				<Action>Search for specified data</Action>
				<PostCondition>Return index if data was not found -1 is returned</PostCondition>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>ArrayOfUInt16.IndexOf.u16Data</Name>
				<Type>UInt16</Type>
				<!--ui16 data to search for-->
			</Parameter>
			<Parameter>
				<Name>ArrayOfUInt16.IndexOf.Array</Name>
				<Type>ArrayOfUInt16</Type>
				<!--Source Array-->
			</Parameter>
			<LocalVariables>
				<Name>ArrayOfUInt16.IndexOf.Cnt</Name>
				<Type>UInt16</Type>
				<!--temp counter variable-->
			</LocalVariables>
			<LocalVariables>
				<Name>ArrayOfUInt16.IndexOf.ArrayLength</Name>
				<Type>UInt32</Type>
				<!--Length of the source array-->
			</LocalVariables>
			<OutParameter>
				<Name>ArrayOfUInt16.IndexOf.i32Index</Name>
				<Type>Int32</Type>
			</OutParameter>
			<TestStep>
				<!--If Array is not defined return -1-->
				<Compare>
					<Equal>
						<Value1>ArrayOfUInt16.IndexOf.Array</Value1>
						<Value2>null</Value2>
						<SetVariable Target="ArrayOfUInt16.IndexOf.i32Index">-1</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>ArrayOfUInt16.IndexOf.Array</Value1>
						<Value2>null</Value2>
						<Return Id="0"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Get Size of Source Array-->
				<SizeOf UInt32Var="ArrayOfUInt16.IndexOf.ArrayLength">ArrayOfUInt16.IndexOf.Array</SizeOf>
			</TestStep>
			<TestStep>
				<!--Check if array has elements-->
				<Compare>
					<Equal>
						<Value1>ArrayOfUInt16.IndexOf.ArrayLength</Value1>
						<Value2>0</Value2>
						<SetVariable Target="ArrayOfUInt16.IndexOf.i32Index">-1</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>ArrayOfUInt16.IndexOf.ArrayLength</Value1>
						<Value2>0</Value2>
						<Return Id="1"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<SetVariable Target="ArrayOfUInt16.IndexOf.Cnt">0</SetVariable>
			</TestStep>
			<TestStep Name="LOOPSTART">
				<!--Check if Loop finished-->
				<Compare>
					<GreaterOrEqual>
						<Value1>ArrayOfUInt16.IndexOf.Cnt</Value1>
						<Value2>ArrayOfUInt16.IndexOf.ArrayLength</Value2>
						<SetVariable Target="ArrayOfUInt16.IndexOf.i32Index">-1</SetVariable>
					</GreaterOrEqual>
				</Compare>
				<Compare>
					<GreaterOrEqual>
						<Value1>ArrayOfUInt16.IndexOf.Cnt</Value1>
						<Value2>ArrayOfUInt16.IndexOf.ArrayLength</Value2>
						<Return Id="2"></Return>
					</GreaterOrEqual>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Check if current element is matching-->
				<Compare>
					<Equal>
						<Value1>ArrayOfUInt16.IndexOf.Array[ArrayOfUInt16.IndexOf.Cnt]</Value1>
						<Value2>ArrayOfUInt16.IndexOf.u16Data</Value2>
						<SetVariable Target="ArrayOfUInt16.IndexOf.i32Index">ArrayOfUInt16.IndexOf.Cnt</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>ArrayOfUInt16.IndexOf.Array[ArrayOfUInt16.IndexOf.Cnt]</Value1>
						<Value2>ArrayOfUInt16.IndexOf.u16Data</Value2>
						<Return Id="3"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Increment counter-->
				<SetVariable Target="ArrayOfUInt16.IndexOf.Cnt">ArrayOfUInt16.IndexOf.Cnt +1</SetVariable>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>LOOPSTART</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="601" Name="BaseDataType.CheckSize">
			<?MAX_OUTPUT_ID 13?>
			<Parameter>
				<Name>BaseDataType.CheckSize.Int32Expected</Name>
				<Type>Int32</Type>
				<Comment>The expected bitSize</Comment>
			</Parameter>
			<Parameter>
				<Name>BaseDataType.CheckSize.StringName</Name>
				<Type>String</Type>
				<Comment>The name of the base data type</Comment>
			</Parameter>
			<LocalVariables>
				<Name>BaseDataType.CheckSize.ExpBitSize</Name>
				<Type>Int32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>BaseDataType.CheckSize.IntNameLength</Name>
				<Type>UInt32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>BaseDataType.CheckSize.IntPostFixLength</Name>
				<Type>UInt32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>BaseDataType.CheckSize.Int32Factor</Name>
				<Type>Int32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>BaseDataType.CheckSize.StringNameNo</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>BaseDataType.CheckSize.Int32NameNo</Name>
				<Type>Int32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>BaseDataType.CheckSize.StringPrefix</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>BaseDataType.CheckSize.StringExpPrefix</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>BaseDataType.CheckSize.StringExpStPrefix</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>BaseDataType.CheckSize.StringByteExpPostfix</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>BaseDataType.CheckSize.StringUintExpPostfix</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>BaseDataType.CheckSize.StringStringExpPostfix</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>BaseDataType.CheckSize.StringPostfix</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>BaseDataType.CheckSize.StringBaseType</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>BaseDataType.CheckSize.StringIntExpPostfix</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>BaseDataType.CheckSize.StringSintExpPostfix</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>BaseDataType.CheckSize.StringDintExpPostfix</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>BaseDataType.CheckSize.StringUdintExpPostfix</Name>
				<Type>String</Type>
			</LocalVariables>
			<OutParameter>
				<Name>BaseDataType.CheckSize.ErrorText</Name>
				<Type>String</Type>
			</OutParameter>
			<TestStep Name="InitStandardReturn">
				<SetVariable Target="BaseDataType.CheckSize.ErrorText">error</SetVariable>
			</TestStep>
			<TestStep Name="CheckIfNoArrayType">
				<Compare>
					<Equal>
						<Value1>BaseDataType.CheckSize.StringName</Value1>
						<Value2>BOOL</Value2>
						<SetVariable Target="BaseDataType.CheckSize.ExpBitSize">1</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>BaseDataType.CheckSize.StringName</Value1>
						<Value2>BIT</Value2>
						<SetVariable Target="BaseDataType.CheckSize.ExpBitSize">1</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>BaseDataType.CheckSize.StringName</Value1>
						<Value2>BYTE</Value2>
						<SetVariable Target="BaseDataType.CheckSize.ExpBitSize">8</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>BaseDataType.CheckSize.StringName</Value1>
						<Value2>BIT1</Value2>
						<SetVariable Target="BaseDataType.CheckSize.ExpBitSize">1</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>BaseDataType.CheckSize.StringName</Value1>
						<Value2>BIT2</Value2>
						<SetVariable Target="BaseDataType.CheckSize.ExpBitSize">2</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>BaseDataType.CheckSize.StringName</Value1>
						<Value2>BIT3</Value2>
						<SetVariable Target="BaseDataType.CheckSize.ExpBitSize">3</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>BaseDataType.CheckSize.StringName</Value1>
						<Value2>BIT4</Value2>
						<SetVariable Target="BaseDataType.CheckSize.ExpBitSize">4</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>BaseDataType.CheckSize.StringName</Value1>
						<Value2>BIT5</Value2>
						<SetVariable Target="BaseDataType.CheckSize.ExpBitSize">5</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>BaseDataType.CheckSize.StringName</Value1>
						<Value2>BIT6</Value2>
						<SetVariable Target="BaseDataType.CheckSize.ExpBitSize">6</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>BaseDataType.CheckSize.StringName</Value1>
						<Value2>BIT7</Value2>
						<SetVariable Target="BaseDataType.CheckSize.ExpBitSize">7</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>BaseDataType.CheckSize.StringName</Value1>
						<Value2>BIT8</Value2>
						<SetVariable Target="BaseDataType.CheckSize.ExpBitSize">8</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>BaseDataType.CheckSize.StringName</Value1>
						<Value2>BITARR8</Value2>
						<SetVariable Target="BaseDataType.CheckSize.ExpBitSize">8</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>BaseDataType.CheckSize.StringName</Value1>
						<Value2>BITARR16</Value2>
						<SetVariable Target="BaseDataType.CheckSize.ExpBitSize">16</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>BaseDataType.CheckSize.StringName</Value1>
						<Value2>BITARR32</Value2>
						<SetVariable Target="BaseDataType.CheckSize.ExpBitSize">32</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>BaseDataType.CheckSize.StringName</Value1>
						<Value2>SINT</Value2>
						<SetVariable Target="BaseDataType.CheckSize.ExpBitSize">8</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>BaseDataType.CheckSize.StringName</Value1>
						<Value2>INT</Value2>
						<SetVariable Target="BaseDataType.CheckSize.ExpBitSize">16</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>BaseDataType.CheckSize.StringName</Value1>
						<Value2>INT24</Value2>
						<SetVariable Target="BaseDataType.CheckSize.ExpBitSize">24</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>BaseDataType.CheckSize.StringName</Value1>
						<Value2>DINT</Value2>
						<SetVariable Target="BaseDataType.CheckSize.ExpBitSize">32</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>BaseDataType.CheckSize.StringName</Value1>
						<Value2>INT40</Value2>
						<SetVariable Target="BaseDataType.CheckSize.ExpBitSize">40</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>BaseDataType.CheckSize.StringName</Value1>
						<Value2>INT48</Value2>
						<SetVariable Target="BaseDataType.CheckSize.ExpBitSize">48</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>BaseDataType.CheckSize.StringName</Value1>
						<Value2>INT56</Value2>
						<SetVariable Target="BaseDataType.CheckSize.ExpBitSize">56</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>BaseDataType.CheckSize.StringName</Value1>
						<Value2>LINT</Value2>
						<SetVariable Target="BaseDataType.CheckSize.ExpBitSize">64</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>BaseDataType.CheckSize.StringName</Value1>
						<Value2>USINT</Value2>
						<SetVariable Target="BaseDataType.CheckSize.ExpBitSize">8</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>BaseDataType.CheckSize.StringName</Value1>
						<Value2>UINT</Value2>
						<SetVariable Target="BaseDataType.CheckSize.ExpBitSize">16</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>BaseDataType.CheckSize.StringName</Value1>
						<Value2>UINT24</Value2>
						<SetVariable Target="BaseDataType.CheckSize.ExpBitSize">24</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>BaseDataType.CheckSize.StringName</Value1>
						<Value2>UDINT</Value2>
						<SetVariable Target="BaseDataType.CheckSize.ExpBitSize">32</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>BaseDataType.CheckSize.StringName</Value1>
						<Value2>UINT40</Value2>
						<SetVariable Target="BaseDataType.CheckSize.ExpBitSize">40</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>BaseDataType.CheckSize.StringName</Value1>
						<Value2>UINT48</Value2>
						<SetVariable Target="BaseDataType.CheckSize.ExpBitSize">48</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>BaseDataType.CheckSize.StringName</Value1>
						<Value2>UINT56</Value2>
						<SetVariable Target="BaseDataType.CheckSize.ExpBitSize">56</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>BaseDataType.CheckSize.StringName</Value1>
						<Value2>ULINT</Value2>
						<SetVariable Target="BaseDataType.CheckSize.ExpBitSize">64</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>BaseDataType.CheckSize.StringName</Value1>
						<Value2>REAL</Value2>
						<SetVariable Target="BaseDataType.CheckSize.ExpBitSize">32</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>BaseDataType.CheckSize.StringName</Value1>
						<Value2>LREAL</Value2>
						<SetVariable Target="BaseDataType.CheckSize.ExpBitSize">64</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>BaseDataType.CheckSize.StringName</Value1>
						<Value2>WORD</Value2>
						<SetVariable Target="BaseDataType.CheckSize.ExpBitSize">16</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>BaseDataType.CheckSize.StringName</Value1>
						<Value2>DWORD</Value2>
						<SetVariable Target="BaseDataType.CheckSize.ExpBitSize">32</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>BaseDataType.CheckSize.StringName</Value1>
						<Value2>GUID</Value2>
						<SetVariable Target="BaseDataType.CheckSize.ExpBitSize">128</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>BaseDataType.CheckSize.ExpBitSize</Value1>
						<Value2>0</Value2>
						<GotoStep>InitExpPreFix</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>BaseDataType.CheckSize.ExpBitSize</Value1>
						<Value2>BaseDataType.CheckSize.Int32Expected</Value2>
						<SetVariable Target="BaseDataType.CheckSize.ErrorText">EmptyString</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>BaseDataType.CheckSize.ExpBitSize</Value1>
						<Value2>BaseDataType.CheckSize.Int32Expected</Value2>
						<Return Id="0"></Return>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>BaseDataType.CheckSize.ExpBitSize</Value1>
						<Value2>BaseDataType.CheckSize.Int32Expected</Value2>
						<SetVariable Target="BaseDataType.CheckSize.ErrorText" Param0="BaseDataType.CheckSize.Int32Expected" Param1="BaseDataType.CheckSize.StringName">BitSize {0} does not match the base type name term '{1}'</SetVariable>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>BaseDataType.CheckSize.ExpBitSize</Value1>
						<Value2>BaseDataType.CheckSize.Int32Expected</Value2>
						<Return Id="1"></Return>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="InitExpPreFix">
				<SetVariable Target="BaseDataType.CheckSize.StringExpPrefix">ARRAY [0..</SetVariable>
			</TestStep>
			<TestStep Name="InitExpStringPreFix">
				<SetVariable Target="BaseDataType.CheckSize.StringExpStPrefix">STRING(</SetVariable>
			</TestStep>
			<TestStep Name="InitExpBytePostFix">
				<SetVariable Target="BaseDataType.CheckSize.StringByteExpPostfix">] OF BYTE</SetVariable>
			</TestStep>
			<TestStep Name="InitExpUIntPostFix">
				<SetVariable Target="BaseDataType.CheckSize.StringUintExpPostfix">] OF UINT</SetVariable>
			</TestStep>
			<TestStep Name="InitExpIntPostFix">
				<SetVariable Target="BaseDataType.CheckSize.StringIntExpPostfix">] OF INT</SetVariable>
			</TestStep>
			<TestStep Name="InitExpSintPostFix">
				<SetVariable Target="BaseDataType.CheckSize.StringSintExpPostfix">] OF SINT</SetVariable>
			</TestStep>
			<TestStep Name="InitExpDintPostFix">
				<SetVariable Target="BaseDataType.CheckSize.StringDintExpPostfix">] OF DINT</SetVariable>
			</TestStep>
			<TestStep Name="InitExpUdntPostFix">
				<SetVariable Target="BaseDataType.CheckSize.StringUdintExpPostfix">] OF UDINT</SetVariable>
			</TestStep>
			<TestStep Name="InitExpStringPostFix">
				<SetVariable Target="BaseDataType.CheckSize.StringStringExpPostfix">)</SetVariable>
			</TestStep>
			<TestStep Name="GetNameLength">
				<SizeOf UInt32Var="BaseDataType.CheckSize.IntNameLength">BaseDataType.CheckSize.StringName</SizeOf>
				<Compare>
					<Lower>
						<Value1>BaseDataType.CheckSize.IntNameLength</Value1>
						<Value2>9</Value2>
						<SetVariable Target="BaseDataType.CheckSize.ErrorText" Param0="BaseDataType.CheckSize.StringName">Unexpected data type: '{0}'.</SetVariable>
					</Lower>
				</Compare>
				<Compare>
					<Lower>
						<Value1>BaseDataType.CheckSize.IntNameLength</Value1>
						<Value2>9</Value2>
						<Return Id="2"></Return>
					</Lower>
				</Compare>
				<Compare>
					<Lower>
						<Value1>BaseDataType.CheckSize.IntNameLength</Value1>
						<Value2>19</Value2>
						<GotoStep>CheckArrayPrefixString</GotoStep>
					</Lower>
				</Compare>
			</TestStep>
			<TestStep Name="CheckArrayPrefix">
				<GetBits Target="BaseDataType.CheckSize.StringPrefix" Source="BaseDataType.CheckSize.StringName">
					<Offset>0</Offset>
					<Length>10*16</Length>
				</GetBits>
				<Compare>
					<Equal>
						<Value1>BaseDataType.CheckSize.StringPrefix</Value1>
						<Value2>BaseDataType.CheckSize.StringExpPrefix</Value2>
						<GotoStep>GetArrayPostfix</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<SetVariable Target="BaseDataType.CheckSize.ErrorText" Param0="BaseDataType.CheckSize.StringName">Unexpected data type: '{0}'.</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<Return Id="3"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CheckArrayPrefixString">
				<GetBits Target="BaseDataType.CheckSize.StringPrefix" Source="BaseDataType.CheckSize.StringName">
					<Offset>0</Offset>
					<Length>7*16</Length>
				</GetBits>
				<Compare>
					<Equal>
						<Value1>BaseDataType.CheckSize.StringPrefix</Value1>
						<Value2>BaseDataType.CheckSize.StringExpStPrefix</Value2>
						<GotoStep>GetArrayStringPostfix</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<SetVariable Target="BaseDataType.CheckSize.ErrorText" Param0="BaseDataType.CheckSize.StringName">Unexpected data type: '{0}'.</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<Return Id="4"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="GetArrayPostfix">
				<GetBits Target="BaseDataType.CheckSize.StringPostfix" Source="BaseDataType.CheckSize.StringName">
					<Offset>16*(BaseDataType.CheckSize.IntNameLength-9)</Offset>
					<Length>9*16</Length>
				</GetBits>
				<Compare>
					<Equal>
						<Value1>BaseDataType.CheckSize.StringPostfix</Value1>
						<Value2>BaseDataType.CheckSize.StringByteExpPostfix</Value2>
						<SetVariable Target="BaseDataType.CheckSize.Int32Factor">8</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>BaseDataType.CheckSize.StringPostfix</Value1>
						<Value2>BaseDataType.CheckSize.StringUintExpPostfix</Value2>
						<SetVariable Target="BaseDataType.CheckSize.Int32Factor">16</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>BaseDataType.CheckSize.StringPostfix</Value1>
						<Value2>BaseDataType.CheckSize.StringSintExpPostfix</Value2>
						<SetVariable Target="BaseDataType.CheckSize.Int32Factor">8</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>BaseDataType.CheckSize.StringPostfix</Value1>
						<Value2>BaseDataType.CheckSize.StringDintExpPostfix</Value2>
						<SetVariable Target="BaseDataType.CheckSize.Int32Factor">32</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>BaseDataType.CheckSize.Int32Factor</Value1>
						<Value2>0</Value2>
						<GotoStep>GetFigureTerm</GotoStep>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="GetArrayPostFixInt">
				<GetBits Target="BaseDataType.CheckSize.StringPostfix" Source="BaseDataType.CheckSize.StringName">
					<Offset>16*(BaseDataType.CheckSize.IntNameLength-8)</Offset>
					<Length>8*16</Length>
				</GetBits>
				<Compare>
					<Equal>
						<Value1>BaseDataType.CheckSize.StringPostfix</Value1>
						<Value2>BaseDataType.CheckSize.StringIntExpPostfix</Value2>
						<SetVariable Target="BaseDataType.CheckSize.Int32Factor">16</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>BaseDataType.CheckSize.Int32Factor</Value1>
						<Value2>0</Value2>
						<GotoStep>GetFigureTerm</GotoStep>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="GetArrayPostFixUdInt">
				<GetBits Target="BaseDataType.CheckSize.StringPostfix" Source="BaseDataType.CheckSize.StringName">
					<Offset>16*(BaseDataType.CheckSize.IntNameLength-10)</Offset>
					<Length>10*16</Length>
				</GetBits>
				<Compare>
					<Equal>
						<Value1>BaseDataType.CheckSize.StringPostfix</Value1>
						<Value2>BaseDataType.CheckSize.StringUdintExpPostfix</Value2>
						<SetVariable Target="BaseDataType.CheckSize.Int32Factor">32</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>BaseDataType.CheckSize.Int32Factor</Value1>
						<Value2>0</Value2>
						<GotoStep>GetFigureTerm</GotoStep>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<SetVariable Target="BaseDataType.CheckSize.ErrorText" Param0="BaseDataType.CheckSize.StringName">Unexpected data type: '{0}'.</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<Return Id="5"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="GetArrayStringPostfix">
				<GetBits Target="BaseDataType.CheckSize.StringPostfix" Source="BaseDataType.CheckSize.StringName">
					<Offset>16*(BaseDataType.CheckSize.IntNameLength-1)</Offset>
					<Length>1*16</Length>
				</GetBits>
				<Compare>
					<Equal>
						<Value1>BaseDataType.CheckSize.StringPostfix</Value1>
						<Value2>BaseDataType.CheckSize.StringStringExpPostfix</Value2>
						<SetVariable Target="BaseDataType.CheckSize.Int32Factor">8</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="GetFigureTermString">
				<GetBits Target="BaseDataType.CheckSize.StringNameNo" Source="BaseDataType.CheckSize.StringName">
					<Offset>7*16</Offset>
					<Length>16*(BaseDataType.CheckSize.IntNameLength-8)</Length>
				</GetBits>
			</TestStep>
			<TestStep Name="ConvertToIInt32">
				<SetVariable Target="BaseDataType.CheckSize.Int32NameNo">BaseDataType.CheckSize.StringNameNo</SetVariable>
				<GotoOnFailure>ReturnInvalidPrefix</GotoOnFailure>
			</TestStep>
			<TestStep>
				<Compare>
					<Lower>
						<Value1>BaseDataType.CheckSize.Int32NameNo</Value1>
						<Value2>0</Value2>
						<SetVariable Target="BaseDataType.CheckSize.ErrorText">Invalid length of String base type. Length must be greater than zero.</SetVariable>
					</Lower>
				</Compare>
				<Compare>
					<Lower>
						<Value1>BaseDataType.CheckSize.Int32NameNo</Value1>
						<Value2>0</Value2>
						<Return Id="6"></Return>
					</Lower>
				</Compare>
				<Compare>
					<Greater>
						<Value1>BaseDataType.CheckSize.Int32NameNo</Value1>
						<Value2>65535</Value2>
						<SetVariable Target="BaseDataType.CheckSize.ErrorText" Param0="BaseDataType.CheckSize.Int32NameNo">Invalid length of String ({0}) base type. Maximal length is 65535.</SetVariable>
					</Greater>
				</Compare>
				<Compare>
					<Greater>
						<Value1>BaseDataType.CheckSize.Int32NameNo</Value1>
						<Value2>65535</Value2>
						<Return Id="7"></Return>
					</Greater>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>CheckBitSizeString</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="GetFigureTerm">
				<SizeOf UInt32Var="BaseDataType.CheckSize.IntPostFixLength">BaseDataType.CheckSize.StringPostfix</SizeOf>
			</TestStep>
			<TestStep>
				<SetVariable Target="BaseDataType.CheckSize.IntPostFixLength">BaseDataType.CheckSize.IntPostFixLength+10</SetVariable>
			</TestStep>
			<TestStep>
				<SetVariable Target="BaseDataType.CheckSize.IntPostFixLength">BaseDataType.CheckSize.IntNameLength-BaseDataType.CheckSize.IntPostFixLength</SetVariable>
			</TestStep>
			<TestStep>
				<GetBits Target="BaseDataType.CheckSize.StringNameNo" Source="BaseDataType.CheckSize.StringName">
					<Offset>10*16</Offset>
					<Length>16*(BaseDataType.CheckSize.IntPostFixLength)</Length>
				</GetBits>
			</TestStep>
			<TestStep>
				<SetVariable Target="BaseDataType.CheckSize.Int32NameNo">BaseDataType.CheckSize.StringNameNo</SetVariable>
				<GotoOnFailure>ReturnInvalidPrefix</GotoOnFailure>
			</TestStep>
			<TestStep>
				<Compare>
					<Lower>
						<Value1>BaseDataType.CheckSize.Int32NameNo</Value1>
						<Value2>0</Value2>
						<SetVariable Target="BaseDataType.CheckSize.ErrorText">Invalid length of Array base type. Length must be greater than zero.</SetVariable>
					</Lower>
				</Compare>
				<Compare>
					<Lower>
						<Value1>BaseDataType.CheckSize.Int32NameNo</Value1>
						<Value2>0</Value2>
						<Return Id="8"></Return>
					</Lower>
				</Compare>
				<Compare>
					<Greater>
						<Value1>BaseDataType.CheckSize.Int32NameNo</Value1>
						<Value2>65535</Value2>
						<SetVariable Target="BaseDataType.CheckSize.ErrorText" Param0="BaseDataType.CheckSize.Int32NameNo">Invalid length of Array ({0}) base type. Maximal length is 65535.</SetVariable>
					</Greater>
				</Compare>
				<Compare>
					<Greater>
						<Value1>BaseDataType.CheckSize.Int32NameNo</Value1>
						<Value2>65535</Value2>
						<Return Id="9"></Return>
					</Greater>
				</Compare>
			</TestStep>
			<TestStep Name="CheckBitSize">
				<Compare>
					<NotEqual>
						<Value1>BaseDataType.CheckSize.Int32Expected</Value1>
						<Value2>BaseDataType.CheckSize.Int32Factor*(BaseDataType.CheckSize.Int32NameNo+1)</Value2>
						<SetVariable Target="BaseDataType.CheckSize.ErrorText" Param0="BaseDataType.CheckSize.Int32Expected" Param1="BaseDataType.CheckSize.StringName">BitSize {0} does not match the array base type name term '{1}'</SetVariable>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>BaseDataType.CheckSize.Int32Expected</Value1>
						<Value2>BaseDataType.CheckSize.Int32Factor*(BaseDataType.CheckSize.Int32NameNo+1)</Value2>
						<Return Id="10"></Return>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<SetVariable Target="BaseDataType.CheckSize.ErrorText">EmptyString</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<Return Id="11"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="ReturnInvalidPrefix">
				<SetVariable Target="BaseDataType.CheckSize.ErrorText" Param0="BaseDataType.CheckSize.StringNameNo">BaseDataType.CheckSize: Invalid prefix detected. Cannot convert '{0}' to Int32.</SetVariable>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<Return Id="12"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CheckBitSizeString">
				<Compare>
					<NotEqual>
						<Value1>BaseDataType.CheckSize.Int32Expected</Value1>
						<Value2>BaseDataType.CheckSize.Int32Factor*BaseDataType.CheckSize.Int32NameNo</Value2>
						<SetVariable Target="BaseDataType.CheckSize.ErrorText" Param0="BaseDataType.CheckSize.Int32Expected" Param1="BaseDataType.CheckSize.StringName">BitSize {0} does not match the String base type name term '{1}'</SetVariable>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>BaseDataType.CheckSize.Int32Expected</Value1>
						<Value2>BaseDataType.CheckSize.Int32Factor*BaseDataType.CheckSize.Int32NameNo</Value2>
						<Return Id="13"></Return>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<SetVariable Target="BaseDataType.CheckSize.ErrorText">EmptyString</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="602" Name="BaseDataTypeIndex.CheckSize">
			<?MAX_OUTPUT_ID 4?>
			<Parameter>
				<Name>BaseDataTypeIndex.CheckSize.Int32Expected</Name>
				<Type>Int32</Type>
				<Comment>The expected bitSize</Comment>
			</Parameter>
			<Parameter>
				<Name>BaseDataTypeIndex.CheckSize.uint16Name</Name>
				<Type>UInt16</Type>
				<Comment>The index of the base data type</Comment>
			</Parameter>
			<LocalVariables>
				<Name>BaseDataTypeIndex.CheckSize.int32BitSize</Name>
				<Type>Int32</Type>
			</LocalVariables>
			<OutParameter>
				<Name>BaseDataTypeIndex.CheckSize.ErrorText</Name>
				<Type>String</Type>
			</OutParameter>
			<TestStep>
				<SetVariable Target="BaseDataTypeIndex.CheckSize.ErrorText">error</SetVariable>
			</TestStep>
			<TestStep>
				<Compare>
					<Equal>
						<Value1>BaseDataTypeIndex.CheckSize.uint16Name</Value1>
						<Value2>1</Value2>
						<SetVariable Target="BaseDataTypeIndex.CheckSize.int32BitSize">1</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>BaseDataTypeIndex.CheckSize.uint16Name</Value1>
						<Value2>2</Value2>
						<SetVariable Target="BaseDataTypeIndex.CheckSize.int32BitSize">8</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>BaseDataTypeIndex.CheckSize.uint16Name</Value1>
						<Value2>3</Value2>
						<SetVariable Target="BaseDataTypeIndex.CheckSize.int32BitSize">16</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>BaseDataTypeIndex.CheckSize.uint16Name</Value1>
						<Value2>4</Value2>
						<SetVariable Target="BaseDataTypeIndex.CheckSize.int32BitSize">32</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>BaseDataTypeIndex.CheckSize.uint16Name</Value1>
						<Value2>5</Value2>
						<SetVariable Target="BaseDataTypeIndex.CheckSize.int32BitSize">8</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>BaseDataTypeIndex.CheckSize.uint16Name</Value1>
						<Value2>6</Value2>
						<SetVariable Target="BaseDataTypeIndex.CheckSize.int32BitSize">16</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>BaseDataTypeIndex.CheckSize.uint16Name</Value1>
						<Value2>7</Value2>
						<SetVariable Target="BaseDataTypeIndex.CheckSize.int32BitSize">32</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>BaseDataTypeIndex.CheckSize.uint16Name</Value1>
						<Value2>8</Value2>
						<SetVariable Target="BaseDataTypeIndex.CheckSize.int32BitSize">32</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>BaseDataTypeIndex.CheckSize.uint16Name</Value1>
						<Value2>9</Value2>
						<Return Id="0">BaseDataTypeIndex.CheckSize: STRING(n) detected cannot validate data type because it has a variable bit length.</Return>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>BaseDataTypeIndex.CheckSize.uint16Name</Value1>
						<Value2>10</Value2>
						<Return Id="1">BaseDataTypeIndex.CheckSize: ARRAY [0..n] OF BYTE detected cannot validate data type because it has a variable bit length.</Return>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>BaseDataTypeIndex.CheckSize.uint16Name</Value1>
						<Value2>11</Value2>
						<Return Id="2">BaseDataTypeIndex.CheckSize: ARRAY [0..n] OF UINT detected cannot validate data type because it has a variable bit length.</Return>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>BaseDataTypeIndex.CheckSize.uint16Name</Value1>
						<Value2>16</Value2>
						<SetVariable Target="BaseDataTypeIndex.CheckSize.int32BitSize">24</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>BaseDataTypeIndex.CheckSize.uint16Name</Value1>
						<Value2>17</Value2>
						<SetVariable Target="BaseDataTypeIndex.CheckSize.int32BitSize">64</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>BaseDataTypeIndex.CheckSize.uint16Name</Value1>
						<Value2>18</Value2>
						<SetVariable Target="BaseDataTypeIndex.CheckSize.int32BitSize">40</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>BaseDataTypeIndex.CheckSize.uint16Name</Value1>
						<Value2>19</Value2>
						<SetVariable Target="BaseDataTypeIndex.CheckSize.int32BitSize">48</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>BaseDataTypeIndex.CheckSize.uint16Name</Value1>
						<Value2>20</Value2>
						<SetVariable Target="BaseDataTypeIndex.CheckSize.int32BitSize">56</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>BaseDataTypeIndex.CheckSize.uint16Name</Value1>
						<Value2>21</Value2>
						<SetVariable Target="BaseDataTypeIndex.CheckSize.int32BitSize">64</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>BaseDataTypeIndex.CheckSize.uint16Name</Value1>
						<Value2>22</Value2>
						<SetVariable Target="BaseDataTypeIndex.CheckSize.int32BitSize">24</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>BaseDataTypeIndex.CheckSize.uint16Name</Value1>
						<Value2>24</Value2>
						<SetVariable Target="BaseDataTypeIndex.CheckSize.int32BitSize">40</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>BaseDataTypeIndex.CheckSize.uint16Name</Value1>
						<Value2>25</Value2>
						<SetVariable Target="BaseDataTypeIndex.CheckSize.int32BitSize">48</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>BaseDataTypeIndex.CheckSize.uint16Name</Value1>
						<Value2>26</Value2>
						<SetVariable Target="BaseDataTypeIndex.CheckSize.int32BitSize">56</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>BaseDataTypeIndex.CheckSize.uint16Name</Value1>
						<Value2>27</Value2>
						<SetVariable Target="BaseDataTypeIndex.CheckSize.int32BitSize">64</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>BaseDataTypeIndex.CheckSize.uint16Name</Value1>
						<Value2>30</Value2>
						<SetVariable Target="BaseDataTypeIndex.CheckSize.int32BitSize">8</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>BaseDataTypeIndex.CheckSize.uint16Name</Value1>
						<Value2>45</Value2>
						<SetVariable Target="BaseDataTypeIndex.CheckSize.int32BitSize">8</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>BaseDataTypeIndex.CheckSize.uint16Name</Value1>
						<Value2>46</Value2>
						<SetVariable Target="BaseDataTypeIndex.CheckSize.int32BitSize">16</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>BaseDataTypeIndex.CheckSize.uint16Name</Value1>
						<Value2>47</Value2>
						<SetVariable Target="BaseDataTypeIndex.CheckSize.int32BitSize">32</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>BaseDataTypeIndex.CheckSize.uint16Name</Value1>
						<Value2>48</Value2>
						<SetVariable Target="BaseDataTypeIndex.CheckSize.int32BitSize">1</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>BaseDataTypeIndex.CheckSize.uint16Name</Value1>
						<Value2>49</Value2>
						<SetVariable Target="BaseDataTypeIndex.CheckSize.int32BitSize">2</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>BaseDataTypeIndex.CheckSize.uint16Name</Value1>
						<Value2>50</Value2>
						<SetVariable Target="BaseDataTypeIndex.CheckSize.int32BitSize">3</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>BaseDataTypeIndex.CheckSize.uint16Name</Value1>
						<Value2>51</Value2>
						<SetVariable Target="BaseDataTypeIndex.CheckSize.int32BitSize">4</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>BaseDataTypeIndex.CheckSize.uint16Name</Value1>
						<Value2>52</Value2>
						<SetVariable Target="BaseDataTypeIndex.CheckSize.int32BitSize">5</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>BaseDataTypeIndex.CheckSize.uint16Name</Value1>
						<Value2>53</Value2>
						<SetVariable Target="BaseDataTypeIndex.CheckSize.int32BitSize">6</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>BaseDataTypeIndex.CheckSize.uint16Name</Value1>
						<Value2>54</Value2>
						<SetVariable Target="BaseDataTypeIndex.CheckSize.int32BitSize">7</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>BaseDataTypeIndex.CheckSize.uint16Name</Value1>
						<Value2>55</Value2>
						<SetVariable Target="BaseDataTypeIndex.CheckSize.int32BitSize">8</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>BaseDataTypeIndex.CheckSize.int32BitSize</Value1>
						<Value2>0</Value2>
						<GotoStep>CheckLength</GotoStep>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>BaseDataTypeIndex.CheckSize.int32BitSize</Value1>
						<Value2>0</Value2>
						<SetVariable Target="BaseDataTypeIndex.CheckSize.ErrorText" Param0="BaseDataTypeIndex.CheckSize.uint16Name">Index 0x{0:X4} is an unknown Data Type.</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<Return Id="3"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CheckLength">
				<Compare>
					<NotEqual>
						<Value1>BaseDataTypeIndex.CheckSize.int32BitSize</Value1>
						<Value2>BaseDataTypeIndex.CheckSize.Int32Expected</Value2>
						<SetVariable Target="BaseDataTypeIndex.CheckSize.ErrorText" Param0="BaseDataTypeIndex.CheckSize.uint16Name" Param1="BaseDataTypeIndex.CheckSize.Int32Expected" Param2="BaseDataTypeIndex.CheckSize.int32BitSize">Base data type with index 0x{0:X4} has the wrong bit size: {1} - expected: {2}</SetVariable>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>BaseDataTypeIndex.CheckSize.int32BitSize</Value1>
						<Value2>BaseDataTypeIndex.CheckSize.Int32Expected</Value2>
						<Return Id="4"></Return>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<SetVariable Target="BaseDataTypeIndex.CheckSize.ErrorText">EmptyString</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="701" Name="Bool.Compare">
			<?MAX_OUTPUT_ID 1?>
			<Description>
				<Purpose>Compare two Bool Variables</Purpose>
				<PreCondition></PreCondition>
				<Action>if the reference variable is null the comparision is abort (without an error text).
else both variables are compared</Action>
				<PostCondition>return values if variables mismatch. If variables are equal the return value is empty</PostCondition>
				<ProposalForSolution>true</ProposalForSolution>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>Bool.Compare.RefBool</Name>
				<Type>Bool</Type>
				<Comment>reference bool</Comment>
			</Parameter>
			<Parameter>
				<Name>Bool.Compare.CmpBool</Name>
				<Type>Bool</Type>
				<Comment>bool to compare</Comment>
			</Parameter>
			<Parameter>
				<Name>Bool.Compare.InfoText</Name>
				<Type>String</Type>
				<Comment>additional Info text which will be the first part of the error message</Comment>
			</Parameter>
			<OutParameter>
				<Name>Bool.Compare.ErrorText</Name>
				<Type>String</Type>
			</OutParameter>
			<TestStep Name="InitResult">
				<SetVariable Target="Bool.Compare.ErrorText">EmptyString</SetVariable>
			</TestStep>
			<TestStep Name="CheckIfReferenceIsNull">
				<Compare>
					<Equal>
						<Value1>Bool.Compare.RefBool</Value1>
						<Value2>null</Value2>
						<Return Id="0"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="ReturnIfEqual">
				<Compare>
					<Equal>
						<Value1>Bool.Compare.RefBool</Value1>
						<Value2>Bool.Compare.CmpBool</Value2>
						<Return Id="1"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CreateMessage">
				<SetVariable Target="Bool.Compare.ErrorText" Param0="Bool.Compare.InfoText" Param1="Bool.Compare.CmpBool" Param2="Bool.Compare.RefBool">{0} '{1}' expected: '{2}'.</SetVariable>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="702" Name="Byte.Compare">
			<?MAX_OUTPUT_ID 1?>
			<Description>
				<Purpose>Compare two Byte Variables</Purpose>
				<PreCondition></PreCondition>
				<Action>if the reference variable is null the comparision is abort (without an error text).
else both variables are compared</Action>
				<PostCondition>return values if variables mismatch. If variables are equal the return value is empty</PostCondition>
				<ProposalForSolution>true</ProposalForSolution>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>Byte.Compare.RefByte</Name>
				<Type>Byte</Type>
				<Comment>reference Byte</Comment>
			</Parameter>
			<Parameter>
				<Name>Byte.Compare.CmpByte</Name>
				<Type>Byte</Type>
				<Comment>Byte to compare</Comment>
			</Parameter>
			<Parameter>
				<Name>Byte.Compare.InfoText</Name>
				<Type>String</Type>
				<Comment>additional Info text which will be the first part of the error message</Comment>
			</Parameter>
			<OutParameter>
				<Name>Byte.Compare.ErrorText</Name>
				<Type>String</Type>
			</OutParameter>
			<TestStep Name="InitResult">
				<SetVariable Target="Byte.Compare.ErrorText">EmptyString</SetVariable>
			</TestStep>
			<TestStep Name="CheckIfReferenceIsNull">
				<Compare>
					<Equal>
						<Value1>Byte.Compare.RefByte</Value1>
						<Value2>null</Value2>
						<Return Id="0"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="ReturnIfEqual">
				<Compare>
					<Equal>
						<Value1>Byte.Compare.RefByte</Value1>
						<Value2>Byte.Compare.CmpByte</Value2>
						<Return Id="1"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CreateMessage">
				<SetVariable Target="Byte.Compare.ErrorText" Param0="Byte.Compare.InfoText" Param1="Byte.Compare.CmpByte" Param2="Byte.Compare.RefByte">{0} '{1}' expected: '{2}'.</SetVariable>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="801" Name="CheckDistributedClocksSupport">
			<?MAX_OUTPUT_ID 3?>
			<Description>
				<Purpose>Checks if DuT supports distributed clocks.</Purpose>
				<PreCondition>-none</PreCondition>
				<Action>-checks the assign activate of the ESI OpMode element</Action>
				<PostCondition>-if DuT supports distributed clocks the assign activate value shall be bigger than zero</PostCondition>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<LocalVariables>
				<Name>CheckDistributedClocksSupport.uint16Counter</Name>
				<Type>UInt16</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckDistributedClocksSupport.uint16AssignActivate</Name>
				<Type>UInt16</Type>
			</LocalVariables>
			<OutParameter>
				<Name>CheckDistributedClocksSupport.boolDcSupport</Name>
				<Type>Bool</Type>
			</OutParameter>
			<TestStep Name="CheckDcElement">
				<Compare>
					<Equal>
						<Value1>DeviceDescr.DC</Value1>
						<Value2>false</Value2>
						<Return Id="0"></Return>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.DC.OpMode.Count</Value1>
						<Value2>0</Value2>
						<Return Id="1"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CheckOpModeCount">
				<Compare>
					<GreaterOrEqual>
						<Value1>CheckDistributedClocksSupport.uint16Counter</Value1>
						<Value2>DeviceDescr.DC.OpMode.Count</Value2>
						<Return Id="2"></Return>
					</GreaterOrEqual>
				</Compare>
			</TestStep>
			<TestStep Name="CheckAssignValue">
				<Compare>
					<Greater>
						<Value1>DeviceDescr.DC.OpMode[CheckDistributedClocksSupport.uint16Counter].AssignActivate</Value1>
						<Value2>0</Value2>
						<SetVariable Target="CheckDistributedClocksSupport.boolDcSupport">true</SetVariable>
					</Greater>
				</Compare>
				<Compare>
					<Greater>
						<Value1>DeviceDescr.DC.OpMode[CheckDistributedClocksSupport.uint16Counter].AssignActivate</Value1>
						<Value2>0</Value2>
						<Return Id="3"></Return>
					</Greater>
				</Compare>
			</TestStep>
			<TestStep Name="IncrementOpModeCounter">
				<SetVariable Target="CheckDistributedClocksSupport.uint16Counter">CheckDistributedClocksSupport.uint16Counter+1</SetVariable>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>CheckOpModeCount</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="805" Name="CreateAccessByte">
			<Description>
				<Purpose>Create the access byte based on bool variables </Purpose>
				<PreCondition></PreCondition>
				<Action></Action>
				<PostCondition></PostCondition>
				<ProposalForSolution>true</ProposalForSolution>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>CreateAccessByte.ReadPreOp</Name>
				<Type>Bool</Type>
			</Parameter>
			<Parameter>
				<Name>CreateAccessByte.ReadSafeOp</Name>
				<Type>Bool</Type>
			</Parameter>
			<Parameter>
				<Name>CreateAccessByte.ReadOp</Name>
				<Type>Bool</Type>
			</Parameter>
			<Parameter>
				<Name>CreateAccessByte.WritePreOp</Name>
				<Type>Bool</Type>
			</Parameter>
			<Parameter>
				<Name>CreateAccessByte.WriteSafeOp</Name>
				<Type>Bool</Type>
			</Parameter>
			<Parameter>
				<Name>CreateAccessByte.WriteOp</Name>
				<Type>Bool</Type>
			</Parameter>
			<OutParameter>
				<Name>CreateAccessByte.Byte</Name>
				<Type>Byte</Type>
			</OutParameter>
			<TestStep Name="InitResult">
				<SetVariable Target="CreateAccessByte.Byte">0</SetVariable>
			</TestStep>
			<TestStep>
				<SetBits Target="CreateAccessByte.Byte">
					<Offset>0</Offset>
					<Length>1</Length>
					<Value>CreateAccessByte.ReadPreOp</Value>
				</SetBits>
			</TestStep>
			<TestStep>
				<SetBits Target="CreateAccessByte.Byte">
					<Offset>1</Offset>
					<Length>1</Length>
					<Value>CreateAccessByte.ReadSafeOp</Value>
				</SetBits>
			</TestStep>
			<TestStep>
				<SetBits Target="CreateAccessByte.Byte">
					<Offset>2</Offset>
					<Length>1</Length>
					<Value>CreateAccessByte.ReadOp</Value>
				</SetBits>
			</TestStep>
			<TestStep>
				<SetBits Target="CreateAccessByte.Byte">
					<Offset>3</Offset>
					<Length>1</Length>
					<Value>CreateAccessByte.WritePreOp</Value>
				</SetBits>
			</TestStep>
			<TestStep>
				<SetBits Target="CreateAccessByte.Byte">
					<Offset>4</Offset>
					<Length>1</Length>
					<Value>CreateAccessByte.WriteSafeOp</Value>
				</SetBits>
			</TestStep>
			<TestStep>
				<SetBits Target="CreateAccessByte.Byte">
					<Offset>5</Offset>
					<Length>1</Length>
					<Value>CreateAccessByte.WriteOp</Value>
				</SetBits>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="802" Name="CheckEntryDescription">
			<?MAX_OUTPUT_ID 90?>
			<Description>
				<Purpose>Compares the passed values against the passed object description of the passed dictionary</Purpose>
				<PreCondition></PreCondition>
				<Action>-gets the entry description of the passed index and subindex
-comares the values against the passed values</Action>
				<PostCondition>Throws an error if one of the values does not match to the expected value</PostCondition>
				<ProposalForSolution>true</ProposalForSolution>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>CheckEntryDescription.ObjectDictionary</Name>
				<Type>ObjectDictionary</Type>
				<Comment>object dictionary to search for specified object.entry(by index and SubIndex)</Comment>
			</Parameter>
			<Parameter>
				<Name>CheckEntryDescription.DictionaryType</Name>
				<Type>String</Type>
			</Parameter>
			<Parameter>
				<Name>CheckEntryDescription.Index</Name>
				<Type>UInt16</Type>
			</Parameter>
			<Parameter>
				<Name>CheckEntryDescription.SubIndex</Name>
				<Type>UInt16</Type>
			</Parameter>
			<Parameter>
				<Name>CheckEntryDescription.LevelWarning</Name>
				<Type>Bool</Type>
				<Comment>If true raise warnign instead of errors</Comment>
			</Parameter>
			<Parameter>
				<Name>CheckEntryDescription.CaseSensitive</Name>
				<Type>Bool</Type>
				<Comment>If true name ist checked case sensitive</Comment>
			</Parameter>
			<Parameter>
				<Name>CheckEntryDescription.Expected.Names</Name>
				<Type>ArrayOfString</Type>
				<Comment>List of allowed names</Comment>
			</Parameter>
			<Parameter>
				<Name>CheckEntryDescription.Expected.Type</Name>
				<Type>UInt16</Type>
				<Comment>if 0xFFFF the test will be skipped</Comment>
			</Parameter>
			<Parameter>
				<Name>CheckEntryDescription.Expected.Access.ReadInPreOp</Name>
				<Type>Int16</Type>
				<Comment>If -1 test will be skipped</Comment>
			</Parameter>
			<Parameter>
				<Name>CheckEntryDescription.Expected.Access.ReadInSafeOp</Name>
				<Type>Int16</Type>
				<Comment>If -1 test will be skipped</Comment>
			</Parameter>
			<Parameter>
				<Name>CheckEntryDescription.Expected.Access.ReadInOp</Name>
				<Type>Int16</Type>
				<Comment>If -1 test will be skipped</Comment>
			</Parameter>
			<Parameter>
				<Name>CheckEntryDescription.Expected.Access.WriteInPreOp</Name>
				<Type>Int16</Type>
				<Comment>If -1 test will be skipped</Comment>
			</Parameter>
			<Parameter>
				<Name>CheckEntryDescription.Expected.Access.WriteInSafeOp</Name>
				<Type>Int16</Type>
				<Comment>If -1 test will be skipped</Comment>
			</Parameter>
			<Parameter>
				<Name>CheckEntryDescription.Expected.Access.WriteInOp</Name>
				<Type>Int16</Type>
				<Comment>If -1 test will be skipped</Comment>
			</Parameter>
			<Parameter>
				<Name>CheckEntryDescription.Category</Name>
				<Type>String</Type>
				<Comment>The category is not compared.
In case of "o" and a datatype of 0 (padding) only the bitsize is checked</Comment>
			</Parameter>
			<Parameter>
				<Name>CheckEntryDescription.Expected.PdoMapping</Name>
				<Type>String</Type>
			</Parameter>
			<Parameter>
				<Name>CheckEntryDescription.Expected.DefaultData</Name>
				<Type>ArrayOfBytes</Type>
			</Parameter>
			<Parameter>
				<Name>CheckEntryDescription.Expected.MinData</Name>
				<Type>ArrayOfBytes</Type>
			</Parameter>
			<Parameter>
				<Name>CheckEntryDescription.Expected.MaxData</Name>
				<Type>ArrayOfBytes</Type>
			</Parameter>
			<Parameter>
				<Name>CheckEntryDescription.Expected.Settings</Name>
				<Type>Int16</Type>
				<Comment>If -1 test will be skipped</Comment>
			</Parameter>
			<Parameter>
				<Name>CheckEntryDescription.Expected.Backup</Name>
				<Type>Int16</Type>
				<Comment>If -1 test will be skipped</Comment>
			</Parameter>
			<Parameter>
				<Name>CheckEntryDescription.Expected.BitSize</Name>
				<Type>Int32</Type>
			</Parameter>
			<Parameter>
				<Name>CheckEntryDescription.Expected.BitOffs</Name>
				<Type>Int32</Type>
			</Parameter>
			<Parameter>
				<Name>CheckEntryDescription.AllowEnumDataType</Name>
				<Type>Bool</Type>
				<Comment>If true the data type to check may also be an enum data type</Comment>
			</Parameter>
			<LocalVariables>
				<Name>CheckEntryDescription.bTmpVar</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckEntryDescription.Current.Access.ReadInOp</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckEntryDescription.Current.Access.ReadInPreOp</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckEntryDescription.Current.Access.ReadInSafeOp</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckEntryDescription.Current.Access.WriteInOp</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckEntryDescription.Current.Access.WriteInPreOp</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckEntryDescription.Current.Access.WriteInSafeOp</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckEntryDescription.Expected.AccessField</Name>
				<Type>Byte</Type>
				<Comment>Combination of all access bits</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckEntryDescription.Expected.AccessString</Name>
				<Type>String</Type>
				<DefaultValue>"notSet"</DefaultValue>
				<Comment>"read only", "read write" or "write only"</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckEntryDescription.Current.AccessField</Name>
				<Type>Byte</Type>
				<Comment>Combination of all access bits</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckEntryDescription.Current.AccessString</Name>
				<Type>String</Type>
				<DefaultValue>"notSet"</DefaultValue>
				<Comment>"read only", "read write" or "write only"</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckEntryDescription.Current.Backup</Name>
				<Type>Int16</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckEntryDescription.Current.BitOffs</Name>
				<Type>Int32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckEntryDescription.Current.BitSize</Name>
				<Type>Int32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckEntryDescription.Current.Category</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckEntryDescription.Current.DefaultData</Name>
				<Type>ArrayOfBytes</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckEntryDescription.Current.DataCount</Name>
				<Type>UInt32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckEntryDescription.Current.MaxData</Name>
				<Type>ArrayOfBytes</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckEntryDescription.Current.MinData</Name>
				<Type>ArrayOfBytes</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckEntryDescription.Current.Name</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckEntryDescription.Current.PdoMapping</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckEntryDescription.Current.Settings</Name>
				<Type>Int16</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckEntryDescription.Current.Type</Name>
				<Type>UInt16</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckEntryDescription.ErrorMsg</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckEntryDescription.Expected.DataCount</Name>
				<Type>Int32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckEntryDescription.int32CompareResult</Name>
				<Type>Int32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckEntryDescription.u32ExpetedNamesLength</Name>
				<Type>UInt32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckEntryDescription.ReloadDescrSdoInfo</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<OutParameter>
				<Name>CheckEntryDescription.bError</Name>
				<Type>Bool</Type>
			</OutParameter>
			<TestStep Name="InitResult">
				<SetVariable Target="CheckEntryDescription.bError">false</SetVariable>
			</TestStep>
			<TestStep Name="CheckForMailboxCoE">
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Mailbox</Value1>
						<Value2>false</Value2>
						<SkipCase Id="0">Device does not support mailbox communication</SkipCase>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Mailbox.CoE</Value1>
						<Value2>false</Value2>
						<SkipCase Id="1">Device does not support CoE</SkipCase>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="InitReloadFlag">
				<SetVariable Target="CheckEntryDescription.ReloadDescrSdoInfo">false</SetVariable>
			</TestStep>
			<TestStep Name="GetOdType">
				<RegexIsMatch ReturnValue="CheckEntryDescription.bTmpVar" Options="IgnoreCase">
					<Pattern>^online.*</Pattern>
					<InputString>CheckEntryDescription.DictionaryType</InputString>
				</RegexIsMatch>
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.bTmpVar</Value1>
						<Value2>false</Value2>
						<GotoStep>GetObjectDescription</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CheckProfile">
				<!--Load Description via SDO Info for 5001.3100 or 5001.3101-->
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Profile.Count</Value1>
						<Value2>0</Value2>
						<GotoStep>GetObjectDescription</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>DeviceDescr.Profile[0].ProfileNo</Value1>
						<Value2>5001</Value2>
						<GotoStep>GetObjectDescription</GotoStep>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Profile[0].AddInfo</Value1>
						<Value2>3100</Value2>
						<SetVariable Target="CheckEntryDescription.ReloadDescrSdoInfo">true</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Profile[0].AddInfo</Value1>
						<Value2>3101</Value2>
						<SetVariable Target="CheckEntryDescription.ReloadDescrSdoInfo">true</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="GetObjectDescription">
				<Description Id="2" Param0="CheckEntryDescription.Index" Param1="CheckEntryDescription.SubIndex" Level="Verbose">CheckEntryDescription | 0x{0:X4}:{1}</Description>
				<GetObjectDescription Index="CheckEntryDescription.Index" SourceDictionary="CheckEntryDescription.ObjectDictionary" SubIndex="CheckEntryDescription.SubIndex" SDOInfoReload="CheckEntryDescription.ReloadDescrSdoInfo">
					<Name>CheckEntryDescription.Current.Name</Name>
					<Type>CheckEntryDescription.Current.Type</Type>
					<BitSize>CheckEntryDescription.Current.BitSize</BitSize>
					<BitOffs>CheckEntryDescription.Current.BitOffs</BitOffs>
					<DefaultData>CheckEntryDescription.Current.DefaultData</DefaultData>
					<MinData>CheckEntryDescription.Current.MinData</MinData>
					<MaxData>CheckEntryDescription.Current.MaxData</MaxData>
					<Flags>
						<Access Backup="CheckEntryDescription.Current.Backup" ReadInOP="CheckEntryDescription.Current.Access.ReadInOp" ReadInPreop="CheckEntryDescription.Current.Access.ReadInPreOp" ReadInSafeOP="CheckEntryDescription.Current.Access.ReadInSafeOp" WriteinOP="CheckEntryDescription.Current.Access.WriteInOp" WriteInPreOp="CheckEntryDescription.Current.Access.WriteInPreOp" WriteInSafeOp="CheckEntryDescription.Current.Access.WriteInSafeOp" Settings="CheckEntryDescription.Current.Settings"></Access>
						<Category>CheckEntryDescription.Current.Category</Category>
						<PdoMapping>CheckEntryDescription.Current.PdoMapping</PdoMapping>
					</Flags>
				</GetObjectDescription>
				<GotoOnSuccess>CheckBitSize</GotoOnSuccess>
			</TestStep>
			<TestStep Name="EntryNotFound">
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<SetVariable Target="CheckEntryDescription.ErrorMsg" Param0="CheckEntryDescription.Index" Param1="CheckEntryDescription.SubIndex" Param2="CheckEntryDescription.DictionaryType">{2}: 0x{0:X4}:{1} is not defined (failed to get entry description).</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<WriteLine Id="3" Param0="CheckEntryDescription.ErrorMsg" Level="Warning">{0}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<WriteLine Id="4" Param0="CheckEntryDescription.ErrorMsg" Level="Error">{0}</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<SetVariable Target="CheckEntryDescription.bError">true</SetVariable>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<Return Id="5"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CheckBitSize">
				<!--Create Message-->
				<SetVariable Target="CheckEntryDescription.ErrorMsg" Param0="CheckEntryDescription.Index" Param1="CheckEntryDescription.SubIndex" Param2="CheckEntryDescription.DictionaryType">{2}: 0x{0:X4}:{1}.BitSize</SetVariable>
				<!--Skip if BitSize is -1-->
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.Expected.BitSize</Value1>
						<Value2>-1</Value2>
						<WriteLine Id="6" Level="Verbose">CheckEntryDescription | Skip compare 'BitSize'</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.Expected.BitSize</Value1>
						<Value2>-1</Value2>
						<GotoStep>CheckBitOffs</GotoStep>
					</Equal>
				</Compare>
				<!--Run Compare-->
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="7" Level="Verbose" Param0="CheckEntryDescription.Expected.BitSize" Param1="CheckEntryDescription.Current.BitSize">CheckEntryDescription | Compare 'BitSize' expected ({0}) / current ({1})</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<CallTestFunction Name="Int32.Compare">
							<Parameter>CheckEntryDescription.Expected.BitSize</Parameter>
							<Parameter>CheckEntryDescription.Current.BitSize</Parameter>
							<Parameter>CheckEntryDescription.ErrorMsg</Parameter>
							<OutParameter>CheckEntryDescription.ErrorMsg</OutParameter>
						</CallTestFunction>
					</Equal>
				</Compare>
				<!--Handle Compare Result-->
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.ErrorMsg</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>CheckBitOffs</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<WriteLine Id="8" Param0="CheckEntryDescription.ErrorMsg" Level="Warning">{0}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<WriteLine Id="9" Param0="CheckEntryDescription.ErrorMsg" Level="Error">{0}</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<SetVariable Target="CheckEntryDescription.bError">true</SetVariable>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="CheckBitOffs">
				<!--Create Message-->
				<SetVariable Target="CheckEntryDescription.ErrorMsg" Param0="CheckEntryDescription.Index" Param1="CheckEntryDescription.SubIndex" Param2="CheckEntryDescription.DictionaryType">{2}: 0x{0:X4}:{1}.BitOffs</SetVariable>
				<!--Skip Compare if the reference bitoffset is -1-->
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.Expected.BitOffs</Value1>
						<Value2>-1</Value2>
						<WriteLine Id="10" Level="Verbose">CheckEntryDescription | Skip compare 'BitOffset'</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.Expected.BitOffs</Value1>
						<Value2>-1</Value2>
						<GotoStep>Compare_Type</GotoStep>
					</Equal>
				</Compare>
				<!--Run Compare-->
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="11" Level="Verbose" Param0="CheckEntryDescription.Expected.BitOffs" Param1="CheckEntryDescription.Current.BitOffs">CheckEntryDescription | Compare 'BitOffs' expected ({0}) / current ({1})</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<CallTestFunction Name="Int32.Compare">
							<Parameter>CheckEntryDescription.Expected.BitOffs</Parameter>
							<Parameter>CheckEntryDescription.Current.BitOffs</Parameter>
							<Parameter>CheckEntryDescription.ErrorMsg</Parameter>
							<OutParameter>CheckEntryDescription.ErrorMsg</OutParameter>
						</CallTestFunction>
					</Equal>
				</Compare>
				<!--Handle Compare Result-->
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.ErrorMsg</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>Compare_Type</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<WriteLine Id="12" Param0="CheckEntryDescription.ErrorMsg" Level="Warning">{0}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<WriteLine Id="13" Param0="CheckEntryDescription.ErrorMsg" Level="Error">{0}</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<SetVariable Target="CheckEntryDescription.bError">true</SetVariable>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="Compare_Type">
				<!--Create Message-->
				<SetVariable Target="CheckEntryDescription.ErrorMsg" Param0="CheckEntryDescription.Index" Param1="CheckEntryDescription.SubIndex" Param2="CheckEntryDescription.DictionaryType">{2}: 0x{0:X4}:{1}.Type</SetVariable>
				<!--skip if reference dattype is 0xFFFF-->
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.Expected.Type</Value1>
						<Value2>#xFFFF</Value2>
						<WriteLine Id="14" Level="Verbose">CheckEntryDescription | Skip compare 'Type'</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.Expected.Type</Value1>
						<Value2>#xFFFF</Value2>
						<GotoStep>CompareName</GotoStep>
					</Equal>
				</Compare>
				<!--handle not used optional entry (category is "o" and the type is 0) => skip all following tests-->
				<Compare>
					<NotEqual>
						<Value1>"o"</Value1>
						<Value2>CheckEntryDescription.Category</Value2>
						<GotoStep>Run_Compare_Type</GotoStep>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.Current.Type</Value1>
						<Value2>0</Value2>
						<WriteLine Id="15" Level="Verbose" Param0="CheckEntryDescription.Expected.Type" Param1="CheckEntryDescription.Current.Type">CheckEntryDescription | the optional entry is not used (datatype is 0).</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.Current.Type</Value1>
						<Value2>0</Value2>
						<Return Id="16"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="Run_Compare_Type">
				<!--Run Compare-->
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="17" Level="Verbose" Param0="CheckEntryDescription.Expected.Type" Param1="CheckEntryDescription.Current.Type">CheckEntryDescription | Compare 'Type' expected ({0}) / current ({1})</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<CallTestFunction Name="DataType.Compare">
							<Parameter>CheckEntryDescription.Expected.Type</Parameter>
							<Parameter>CheckEntryDescription.Current.Type</Parameter>
							<Parameter>CheckEntryDescription.ErrorMsg</Parameter>
							<OutParameter>CheckEntryDescription.ErrorMsg</OutParameter>
						</CallTestFunction>
					</Equal>
				</Compare>
				<!--Handle Compare Result-->
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.ErrorMsg</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>CompareName</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="HandleEnumDt">
				<!--Only up to 32Bit entires may be replaced by an Enum-->
				<Compare>
					<Greater>
						<Value1>CheckEntryDescription.Current.BitSize</Value1>
						<Value2>32</Value2>
						<GotoStep>HandleCompareResult</GotoStep>
					</Greater>
				</Compare>
				<Compare>
					<Lower>
						<Value1>CheckEntryDescription.Current.Type</Value1>
						<Value2>#x0800</Value2>
						<GotoStep>HandleCompareResult</GotoStep>
					</Lower>
				</Compare>
				<Compare>
					<Greater>
						<Value1>CheckEntryDescription.Current.Type</Value1>
						<Value2>#x0FFF</Value2>
						<GotoStep>HandleCompareResult</GotoStep>
					</Greater>
				</Compare>
				<!--Current DataType is within the enum range => Dt valid-->
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<SetVariable Target="CheckEntryDescription.ErrorMsg">EmptyString</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="18" Level="Verbose" Param0="CheckEntryDescription.Current.Type">CheckEntryDescription | An Enum data type is used.</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>CompareName</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="HandleCompareResult">
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<WriteLine Id="19" Param0="CheckEntryDescription.ErrorMsg" Level="Warning">{0}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<WriteLine Id="20" Param0="CheckEntryDescription.ErrorMsg" Level="Error">{0}</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<SetVariable Target="CheckEntryDescription.bError">true</SetVariable>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="CompareName">
				<SizeOf UInt32Var="CheckEntryDescription.u32ExpetedNamesLength">CheckEntryDescription.Expected.Names</SizeOf>
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.u32ExpetedNamesLength</Value1>
						<Value2>0</Value2>
						<GotoStep>Compare_AccessRights</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.Current.Name</Value1>
						<Value2>null</Value2>
						<GotoStep>Compare_AccessRights</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.Current.Name</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>Compare_AccessRights</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Greater>
						<Value1>CheckEntryDescription.u32ExpetedNamesLength</Value1>
						<Value2>1</Value2>
						<GotoStep>ValidateName</GotoStep>
					</Greater>
				</Compare>
			</TestStep>
			<TestStep Name="CheckSingleName">
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.Expected.Names[0]</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>Compare_AccessRights</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="ValidateName">
				<!--Dump Compare Info-->
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.u32ExpetedNamesLength</Value1>
						<Value2>1</Value2>
						<WriteLine Id="21" Level="Verbose" Param0="CheckEntryDescription.Current.Name" Param1="CheckEntryDescription.Expected.Names[0]" Param2="CheckEntryDescription.CaseSensitive">CheckEntryDescription | Compare 'Name' expected ({1}) / current ({0}) / case sens. {2}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Greater>
						<Value1>CheckEntryDescription.u32ExpetedNamesLength</Value1>
						<Value2>1</Value2>
						<WriteLine Id="22" Level="Verbose" Param0="CheckEntryDescription.Current.Name" Param1="CheckEntryDescription.Expected.Names" Param2="CheckEntryDescription.CaseSensitive">CheckEntryDescription | Compare 'Name' expected names ({1}) / current ({0}) / case sens. {2}</WriteLine>
					</Greater>
				</Compare>
				<!--Call IndexOf function-->
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<CallTestFunction Name="ArrayOfString.IndexOfExtended">
							<Parameter>CheckEntryDescription.Current.Name</Parameter>
							<Parameter>CheckEntryDescription.Expected.Names</Parameter>
							<Parameter>CheckEntryDescription.CaseSensitive</Parameter>
							<Parameter>true</Parameter>
							<Parameter>true</Parameter>
							<OutParameter>CheckEntryDescription.int32CompareResult</OutParameter>
						</CallTestFunction>
					</Equal>
				</Compare>
				<Compare>
					<GreaterOrEqual>
						<Value1>CheckEntryDescription.int32CompareResult</Value1>
						<Value2>0</Value2>
						<GotoStep>Compare_AccessRights</GotoStep>
					</GreaterOrEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.u32ExpetedNamesLength</Value1>
						<Value2>1</Value2>
						<WriteLine Id="23" Level="Warning" Param0="CheckEntryDescription.Current.Name" Param1="CheckEntryDescription.Expected.Names[0]" Param2="CheckEntryDescription.Index" Param3="CheckEntryDescription.SubIndex">0x{2:X4}.{3} Unexpected name '{0}' expected: '{1}'</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Greater>
						<Value1>CheckEntryDescription.u32ExpetedNamesLength</Value1>
						<Value2>1</Value2>
						<WriteLine Id="24" Level="Warning" Param0="CheckEntryDescription.Current.Name" Param1="CheckEntryDescription.Expected.Names" Param2="CheckEntryDescription.Index" Param3="CheckEntryDescription.SubIndex">0x{2:X4}.{3} Unexpected name '{0}' expected one of the following names: {1}</WriteLine>
					</Greater>
				</Compare>
			</TestStep>
			<TestStep Name="Compare_AccessRights">
				<!--Check for ReadOnly/ReadWrite/WriteOnly Access-->
				<!--Skip Combined Test if at least one access right is skipped-->
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.Expected.Access.ReadInPreOp</Value1>
						<Value2>-1</Value2>
						<GotoStep>Compare_ReadInPreOP</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.Expected.Access.ReadInSafeOp</Value1>
						<Value2>-1</Value2>
						<GotoStep>Compare_ReadInPreOP</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.Expected.Access.ReadInOp</Value1>
						<Value2>-1</Value2>
						<GotoStep>Compare_ReadInPreOP</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.Expected.Access.WriteInPreOp</Value1>
						<Value2>-1</Value2>
						<GotoStep>Compare_ReadInPreOP</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.Expected.Access.WriteInSafeOp</Value1>
						<Value2>-1</Value2>
						<GotoStep>Compare_ReadInPreOP</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.Expected.Access.WriteInOp</Value1>
						<Value2>-1</Value2>
						<GotoStep>Compare_ReadInPreOP</GotoStep>
					</Equal>
				</Compare>
				<!--Create Access Flag Variable-->
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<CallTestFunction Name="CreateAccessByte">
							<Parameter>CheckEntryDescription.Expected.Access.ReadInPreOp</Parameter>
							<Parameter>CheckEntryDescription.Expected.Access.ReadInSafeOp</Parameter>
							<Parameter>CheckEntryDescription.Expected.Access.ReadInOp</Parameter>
							<Parameter>CheckEntryDescription.Expected.Access.WriteInPreOp</Parameter>
							<Parameter>CheckEntryDescription.Expected.Access.WriteInSafeOp</Parameter>
							<Parameter>CheckEntryDescription.Expected.Access.WriteInOp</Parameter>
							<OutParameter>CheckEntryDescription.Expected.AccessField</OutParameter>
						</CallTestFunction>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.Expected.AccessField</Value1>
						<Value2>#x3F</Value2>
						<SetVariable Target="CheckEntryDescription.Expected.AccessString">"read write"</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.Expected.AccessField</Value1>
						<Value2>#x07</Value2>
						<SetVariable Target="CheckEntryDescription.Expected.AccessString">"read only"</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.Expected.AccessField</Value1>
						<Value2>#x38</Value2>
						<SetVariable Target="CheckEntryDescription.Expected.AccessString">"write only"</SetVariable>
					</Equal>
				</Compare>
				<!--if no unique access is defined for all states compare all states individual-->
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.Expected.AccessString</Value1>
						<Value2>"notSet"</Value2>
						<GotoStep>Compare_ReadInPreOP</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<CallTestFunction Name="CreateAccessByte">
							<Parameter>CheckEntryDescription.Current.Access.ReadInPreOp</Parameter>
							<Parameter>CheckEntryDescription.Current.Access.ReadInSafeOp</Parameter>
							<Parameter>CheckEntryDescription.Current.Access.ReadInOp</Parameter>
							<Parameter>CheckEntryDescription.Current.Access.WriteInPreOp</Parameter>
							<Parameter>CheckEntryDescription.Current.Access.WriteInSafeOp</Parameter>
							<Parameter>CheckEntryDescription.Current.Access.WriteInOp</Parameter>
							<OutParameter>CheckEntryDescription.Current.AccessField</OutParameter>
						</CallTestFunction>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.Current.AccessField</Value1>
						<Value2>#x3F</Value2>
						<SetVariable Target="CheckEntryDescription.Current.AccessString">"read write"</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.Current.AccessField</Value1>
						<Value2>#x07</Value2>
						<SetVariable Target="CheckEntryDescription.Current.AccessString">"read only"</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.Current.AccessField</Value1>
						<Value2>#x38</Value2>
						<SetVariable Target="CheckEntryDescription.Current.AccessString">"write only"</SetVariable>
					</Equal>
				</Compare>
				<!--if no unique access is defined for all states compare all states individual-->
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.Current.AccessString</Value1>
						<Value2>"notSet"</Value2>
						<GotoStep>Compare_ReadInPreOP</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="RunCompare">
				<SetVariable Target="CheckEntryDescription.ErrorMsg" Param0="CheckEntryDescription.Index" Param1="CheckEntryDescription.SubIndex" Param2="CheckEntryDescription.DictionaryType">{2}: 0x{0:X4}:{1} access</SetVariable>
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.Expected.AccessString</Value1>
						<Value2>CheckEntryDescription.Current.AccessString</Value2>
						<GotoStep>Compare_PdoMapping</GotoStep>
					</Equal>
				</Compare>
				<!--access is not equal => dump error/warning-->
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<WriteLine Id="89" Param0="CheckEntryDescription.ErrorMsg" Param1="CheckEntryDescription.Current.AccessString" Param2="CheckEntryDescription.Expected.AccessString" Level="Warning">{0} is invalid '{1}' expected: '{2}'.</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<WriteLine Id="90" Param0="CheckEntryDescription.ErrorMsg" Param1="CheckEntryDescription.Current.AccessString" Param2="CheckEntryDescription.Expected.AccessString" Level="Error">{0} '{1}' is invalid, expected '{2}'.</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<SetVariable Target="CheckEntryDescription.bError">true</SetVariable>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>Compare_PdoMapping</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="Compare_ReadInPreOP">
				<!--Create Message-->
				<SetVariable Target="CheckEntryDescription.ErrorMsg" Param0="CheckEntryDescription.Index" Param1="CheckEntryDescription.SubIndex" Param2="CheckEntryDescription.DictionaryType">{2}: 0x{0:X4}:{1} read access in PreOP</SetVariable>
				<!--Skip compare if expected ReadInPreOP is -1-->
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.Expected.Access.ReadInPreOp</Value1>
						<Value2>-1</Value2>
						<WriteLine Id="25" Level="Verbose">CheckEntryDescription | Skip compare 'ReadInPreOp'</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.Expected.Access.ReadInPreOp</Value1>
						<Value2>-1</Value2>
						<GotoStep>Compare_ReadInSafeOP</GotoStep>
					</Equal>
				</Compare>
				<!--Run Compare-->
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="26" Level="Verbose" Param0="CheckEntryDescription.Expected.Access.ReadInPreOp" Param1="CheckEntryDescription.Current.Access.ReadInPreOp">CheckEntryDescription | Compare 'ReadInPreOp' expected ({0}) / current ({1})</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<CallTestFunction Name="Bool.Compare">
							<Parameter>CheckEntryDescription.Expected.Access.ReadInPreOp</Parameter>
							<Parameter>CheckEntryDescription.Current.Access.ReadInPreOp</Parameter>
							<Parameter>CheckEntryDescription.ErrorMsg</Parameter>
							<OutParameter>CheckEntryDescription.ErrorMsg</OutParameter>
						</CallTestFunction>
					</Equal>
				</Compare>
				<!--Handle Compare Result-->
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.ErrorMsg</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>Compare_ReadInSafeOP</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<WriteLine Id="27" Param0="CheckEntryDescription.ErrorMsg" Level="Warning">{0}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<WriteLine Id="28" Param0="CheckEntryDescription.ErrorMsg" Level="Error">{0}</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<SetVariable Target="CheckEntryDescription.bError">true</SetVariable>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="Compare_ReadInSafeOP">
				<!--Create Message-->
				<SetVariable Target="CheckEntryDescription.ErrorMsg" Param0="CheckEntryDescription.Index" Param1="CheckEntryDescription.SubIndex" Param2="CheckEntryDescription.DictionaryType">{2}: 0x{0:X4}:{1} read access in SafeOP</SetVariable>
				<!--Skip compare if expected ReadInSafeOP is -1-->
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.Expected.Access.ReadInSafeOp</Value1>
						<Value2>-1</Value2>
						<WriteLine Id="29" Level="Verbose">CheckEntryDescription | Skip compare 'ReadInSafeOp'</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.Expected.Access.ReadInSafeOp</Value1>
						<Value2>-1</Value2>
						<GotoStep>Compare_ReadInOP</GotoStep>
					</Equal>
				</Compare>
				<!--Run Compare-->
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="30" Level="Verbose" Param0="CheckEntryDescription.Expected.Access.ReadInSafeOp" Param1="CheckEntryDescription.Current.Access.ReadInSafeOp">CheckEntryDescription | Compare 'ReadInSafeOp' expected ({0}) / current ({1})</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<CallTestFunction Name="Bool.Compare">
							<Parameter>CheckEntryDescription.Expected.Access.ReadInSafeOp</Parameter>
							<Parameter>CheckEntryDescription.Current.Access.ReadInSafeOp</Parameter>
							<Parameter>CheckEntryDescription.ErrorMsg</Parameter>
							<OutParameter>CheckEntryDescription.ErrorMsg</OutParameter>
						</CallTestFunction>
					</Equal>
				</Compare>
				<!--Handle Compare Result-->
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.ErrorMsg</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>Compare_ReadInOP</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<WriteLine Id="31" Param0="CheckEntryDescription.ErrorMsg" Level="Warning">{0}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<WriteLine Id="32" Param0="CheckEntryDescription.ErrorMsg" Level="Error">{0}</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<SetVariable Target="CheckEntryDescription.bError">true</SetVariable>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="Compare_ReadInOP">
				<!--Create Message-->
				<SetVariable Target="CheckEntryDescription.ErrorMsg" Param0="CheckEntryDescription.Index" Param1="CheckEntryDescription.SubIndex" Param2="CheckEntryDescription.DictionaryType">{2}: 0x{0:X4}:{1} read access in OP</SetVariable>
				<!--Skip compare if expected ReadInOP is -1-->
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.Expected.Access.ReadInOp</Value1>
						<Value2>-1</Value2>
						<WriteLine Id="33" Level="Verbose">CheckEntryDescription | Skip compare 'ReadInOp'</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.Expected.Access.ReadInOp</Value1>
						<Value2>-1</Value2>
						<GotoStep>Compare_WriteInPreOP</GotoStep>
					</Equal>
				</Compare>
				<!--Run Compare-->
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="34" Level="Verbose" Param0="CheckEntryDescription.Expected.Access.ReadInOp" Param1="CheckEntryDescription.Current.Access.ReadInOp">CheckEntryDescription | Compare 'ReadInOp' expected ({0}) / current ({1})</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<CallTestFunction Name="Bool.Compare">
							<Parameter>CheckEntryDescription.Expected.Access.ReadInOp</Parameter>
							<Parameter>CheckEntryDescription.Current.Access.ReadInOp</Parameter>
							<Parameter>CheckEntryDescription.ErrorMsg</Parameter>
							<OutParameter>CheckEntryDescription.ErrorMsg</OutParameter>
						</CallTestFunction>
					</Equal>
				</Compare>
				<!--Handle Compare Result-->
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.ErrorMsg</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>Compare_WriteInPreOP</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<WriteLine Id="35" Param0="CheckEntryDescription.ErrorMsg" Level="Warning">{0}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<WriteLine Id="36" Param0="CheckEntryDescription.ErrorMsg" Level="Error">{0}</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<SetVariable Target="CheckEntryDescription.bError">true</SetVariable>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="Compare_WriteInPreOP">
				<!--Create Message-->
				<SetVariable Target="CheckEntryDescription.ErrorMsg" Param0="CheckEntryDescription.Index" Param1="CheckEntryDescription.SubIndex" Param2="CheckEntryDescription.DictionaryType">{2}: 0x{0:X4}:{1} Write access in PreOP</SetVariable>
				<!--Skip compare if expected WriteInPreOP is -1-->
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.Expected.Access.WriteInPreOp</Value1>
						<Value2>-1</Value2>
						<WriteLine Id="37" Level="Verbose">CheckEntryDescription | Skip compare 'WriteInPreOp'</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.Expected.Access.WriteInPreOp</Value1>
						<Value2>-1</Value2>
						<GotoStep>Compare_WriteInSafeOP</GotoStep>
					</Equal>
				</Compare>
				<!--Run Compare-->
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="38" Level="Verbose" Param0="CheckEntryDescription.Expected.Access.WriteInPreOp" Param1="CheckEntryDescription.Current.Access.WriteInPreOp">CheckEntryDescription | Compare 'WriteInPreOp' expected ({0}) / current ({1})</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<CallTestFunction Name="Bool.Compare">
							<Parameter>CheckEntryDescription.Expected.Access.WriteInPreOp</Parameter>
							<Parameter>CheckEntryDescription.Current.Access.WriteInPreOp</Parameter>
							<Parameter>CheckEntryDescription.ErrorMsg</Parameter>
							<OutParameter>CheckEntryDescription.ErrorMsg</OutParameter>
						</CallTestFunction>
					</Equal>
				</Compare>
				<!--Handle Compare Result-->
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.ErrorMsg</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>Compare_WriteInSafeOP</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<WriteLine Id="39" Param0="CheckEntryDescription.ErrorMsg" Level="Warning">{0}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<WriteLine Id="40" Param0="CheckEntryDescription.ErrorMsg" Level="Error">{0}</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<SetVariable Target="CheckEntryDescription.bError">true</SetVariable>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="Compare_WriteInSafeOP">
				<!--Create Message-->
				<SetVariable Target="CheckEntryDescription.ErrorMsg" Param0="CheckEntryDescription.Index" Param1="CheckEntryDescription.SubIndex" Param2="CheckEntryDescription.DictionaryType">{2}: 0x{0:X4}:{1} Write access in SafeOP</SetVariable>
				<!--Skip compare if expected WriteInSafeOP is -1-->
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.Expected.Access.WriteInSafeOp</Value1>
						<Value2>-1</Value2>
						<WriteLine Id="41" Level="Verbose">CheckEntryDescription | Skip compare 'WriteInSafeOp'</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.Expected.Access.WriteInSafeOp</Value1>
						<Value2>-1</Value2>
						<GotoStep>Compare_WriteInOP</GotoStep>
					</Equal>
				</Compare>
				<!--Run Compare-->
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="42" Level="Verbose" Param0="CheckEntryDescription.Expected.Access.WriteInSafeOp" Param1="CheckEntryDescription.Current.Access.WriteInSafeOp">CheckEntryDescription | Compare 'WriteInSafeOp' expected ({0}) / current ({1})</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<CallTestFunction Name="Bool.Compare">
							<Parameter>CheckEntryDescription.Expected.Access.WriteInSafeOp</Parameter>
							<Parameter>CheckEntryDescription.Current.Access.WriteInSafeOp</Parameter>
							<Parameter>CheckEntryDescription.ErrorMsg</Parameter>
							<OutParameter>CheckEntryDescription.ErrorMsg</OutParameter>
						</CallTestFunction>
					</Equal>
				</Compare>
				<!--Handle Compare Result-->
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.ErrorMsg</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>Compare_WriteInOP</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<WriteLine Id="43" Param0="CheckEntryDescription.ErrorMsg" Level="Warning">{0}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<WriteLine Id="44" Param0="CheckEntryDescription.ErrorMsg" Level="Error">{0}</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<SetVariable Target="CheckEntryDescription.bError">true</SetVariable>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="Compare_WriteInOP">
				<!--Create Message-->
				<SetVariable Target="CheckEntryDescription.ErrorMsg" Param0="CheckEntryDescription.Index" Param1="CheckEntryDescription.SubIndex" Param2="CheckEntryDescription.DictionaryType">{2}: 0x{0:X4}:{1} Write access in OP</SetVariable>
				<!--Skip compare if expected WriteInOP is -1-->
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.Expected.Access.WriteInOp</Value1>
						<Value2>-1</Value2>
						<WriteLine Id="45" Level="Verbose">CheckEntryDescription | Skip compare 'WriteInOp'</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.Expected.Access.WriteInOp</Value1>
						<Value2>-1</Value2>
						<GotoStep>Compare_PdoMapping</GotoStep>
					</Equal>
				</Compare>
				<!--Run Compare-->
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="46" Level="Verbose" Param0="CheckEntryDescription.Expected.Access.WriteInOp" Param1="CheckEntryDescription.Current.Access.WriteInOp">CheckEntryDescription | Compare 'WriteInOp' expected ({0}) / current ({1})</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<CallTestFunction Name="Bool.Compare">
							<Parameter>CheckEntryDescription.Expected.Access.WriteInOp</Parameter>
							<Parameter>CheckEntryDescription.Current.Access.WriteInOp</Parameter>
							<Parameter>CheckEntryDescription.ErrorMsg</Parameter>
							<OutParameter>CheckEntryDescription.ErrorMsg</OutParameter>
						</CallTestFunction>
					</Equal>
				</Compare>
				<!--Handle Compare Result-->
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.ErrorMsg</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>Compare_PdoMapping</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<WriteLine Id="47" Param0="CheckEntryDescription.ErrorMsg" Level="Warning">{0}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<WriteLine Id="48" Param0="CheckEntryDescription.ErrorMsg" Level="Error">{0}</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<SetVariable Target="CheckEntryDescription.bError">true</SetVariable>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="Compare_PdoMapping">
				<!--Create Message-->
				<SetVariable Target="CheckEntryDescription.ErrorMsg" Param0="CheckEntryDescription.Index" Param1="CheckEntryDescription.SubIndex" Param2="CheckEntryDescription.DictionaryType">{2}: 0x{0:X4}:{1} PdoMapping flag</SetVariable>
				<!--Skip compare if expected PDOMapping is null or empty-->
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.Expected.PdoMapping</Value1>
						<Value2>null</Value2>
						<GotoStep>Compare_Settings</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.Expected.PdoMapping</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>Compare_Settings</GotoStep>
					</Equal>
				</Compare>
				<!--Run Compare-->
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="49" Level="Verbose" Param0="CheckEntryDescription.Expected.PdoMapping" Param1="CheckEntryDescription.Current.PdoMapping">CheckEntryDescription | Compare 'PdoMapping' expected ({0}) / current ({1})</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<CallTestFunction Name="String.CompareCaseInsensitive">
							<Parameter>CheckEntryDescription.Expected.PdoMapping</Parameter>
							<Parameter>CheckEntryDescription.Current.PdoMapping</Parameter>
							<Parameter>CheckEntryDescription.ErrorMsg</Parameter>
							<OutParameter>CheckEntryDescription.ErrorMsg</OutParameter>
						</CallTestFunction>
					</Equal>
				</Compare>
				<!--Handle Compare Result-->
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.ErrorMsg</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>Compare_Settings</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<WriteLine Id="50" Param0="CheckEntryDescription.ErrorMsg" Level="Warning">{0}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<WriteLine Id="51" Param0="CheckEntryDescription.ErrorMsg" Level="Error">{0}</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<SetVariable Target="CheckEntryDescription.bError">true</SetVariable>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="Compare_Settings">
				<!--Create Message-->
				<SetVariable Target="CheckEntryDescription.ErrorMsg" Param0="CheckEntryDescription.Index" Param1="CheckEntryDescription.SubIndex" Param2="CheckEntryDescription.DictionaryType">{2}: 0x{0:X4}:{1} Setting flag</SetVariable>
				<!--Check if expected value is -1-->
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.Expected.Settings</Value1>
						<Value2>-1</Value2>
						<WriteLine Id="52" Level="Verbose">CheckEntryDescription | Skip compare 'Settings'</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.Expected.Settings</Value1>
						<Value2>-1</Value2>
						<GotoStep>Compare_Backup</GotoStep>
					</Equal>
				</Compare>
				<!--Run Compare-->
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="53" Level="Verbose" Param0="CheckEntryDescription.Expected.Settings" Param1="CheckEntryDescription.Current.Settings">CheckEntryDescription | Compare 'Settings' expected ({0}) / current ({1})</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<CallTestFunction Name="Bool.Compare">
							<Parameter>CheckEntryDescription.Expected.Settings</Parameter>
							<Parameter>CheckEntryDescription.Current.Settings</Parameter>
							<Parameter>CheckEntryDescription.ErrorMsg</Parameter>
							<OutParameter>CheckEntryDescription.ErrorMsg</OutParameter>
						</CallTestFunction>
					</Equal>
				</Compare>
				<!--Handle Compare Result-->
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.ErrorMsg</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>Compare_Backup</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<WriteLine Id="54" Param0="CheckEntryDescription.ErrorMsg" Level="Warning">{0}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<WriteLine Id="55" Param0="CheckEntryDescription.ErrorMsg" Level="Error">{0}</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<SetVariable Target="CheckEntryDescription.bError">true</SetVariable>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="Compare_Backup">
				<!--Create Message-->
				<SetVariable Target="CheckEntryDescription.ErrorMsg" Param0="CheckEntryDescription.Index" Param1="CheckEntryDescription.SubIndex" Param2="CheckEntryDescription.DictionaryType">{2}: 0x{0:X4}:{1} Backup flag</SetVariable>
				<!--Check if expected value is -1-->
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.Expected.Backup</Value1>
						<Value2>-1</Value2>
						<WriteLine Id="56" Level="Verbose">CheckEntryDescription | Skip compare 'Backup'</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.Expected.Backup</Value1>
						<Value2>-1</Value2>
						<GotoStep>Compare_DefaultData</GotoStep>
					</Equal>
				</Compare>
				<!--Run Compare-->
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="57" Level="Verbose" Param0="CheckEntryDescription.Expected.Backup" Param1="CheckEntryDescription.Current.Backup">CheckEntryDescription | Compare 'Backup' expected ({0}) / current ({1})</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<CallTestFunction Name="Bool.Compare">
							<Parameter>CheckEntryDescription.Expected.Backup</Parameter>
							<Parameter>CheckEntryDescription.Current.Backup</Parameter>
							<Parameter>CheckEntryDescription.ErrorMsg</Parameter>
							<OutParameter>CheckEntryDescription.ErrorMsg</OutParameter>
						</CallTestFunction>
					</Equal>
				</Compare>
				<!--Handle Compare Result-->
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.ErrorMsg</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>Compare_DefaultData</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<WriteLine Id="58" Param0="CheckEntryDescription.ErrorMsg" Level="Warning">{0}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<WriteLine Id="59" Param0="CheckEntryDescription.ErrorMsg" Level="Error">{0}</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<SetVariable Target="CheckEntryDescription.bError">true</SetVariable>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="Compare_DefaultData">
				<SizeOf UInt32Var="CheckEntryDescription.Current.DataCount">CheckEntryDescription.Current.DefaultData</SizeOf>
			</TestStep>
			<TestStep>
				<SizeOf UInt32Var="CheckEntryDescription.Expected.DataCount">CheckEntryDescription.Expected.DefaultData</SizeOf>
				<WriteLine Id="60" Level="Verbose" Param0="CheckEntryDescription.Expected.DefaultData" Param1="CheckEntryDescription.Expected.DataCount">CheckEntryDescription | Expected : Default Data '{0}' ; length {1}</WriteLine>
			</TestStep>
			<TestStep>
				<!--Create Message-->
				<SetVariable Target="CheckEntryDescription.ErrorMsg" Param0="CheckEntryDescription.Index" Param1="CheckEntryDescription.SubIndex" Param2="CheckEntryDescription.DictionaryType">{2}: 0x{0:X4}:{1} Default data</SetVariable>
				<!--Skip Compare if no default data is defined-->
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.Expected.DefaultData</Value1>
						<Value2>null</Value2>
						<WriteLine Id="61" Level="Verbose">CheckEntryDescription | Skip compare 'DefaultData'</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.Expected.DefaultData</Value1>
						<Value2>null</Value2>
						<GotoStep>Compare_MinData</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.Current.DefaultData</Value1>
						<Value2>null</Value2>
						<WriteLine Id="62" Level="Verbose">CheckEntryDescription | Skip compare 'DefaultData'</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.Current.DefaultData</Value1>
						<Value2>null</Value2>
						<GotoStep>Compare_MinData</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.Current.DataCount</Value1>
						<Value2>0</Value2>
						<WriteLine Id="63" Level="Verbose">CheckEntryDescription | Skip compare 'DefaultData'</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.Current.DataCount</Value1>
						<Value2>0</Value2>
						<GotoStep>Compare_MinData</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.Expected.DataCount</Value1>
						<Value2>0</Value2>
						<WriteLine Id="64" Level="Verbose">CheckEntryDescription | Skip compare 'DefaultData'</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.Expected.DataCount</Value1>
						<Value2>0</Value2>
						<GotoStep>Compare_MinData</GotoStep>
					</Equal>
				</Compare>
				<!--Run Compare-->
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="65" Level="Verbose" Param0="CheckEntryDescription.Expected.DefaultData" Param1="CheckEntryDescription.Current.DefaultData">CheckEntryDescription | Compare 'DefaultData' expected ({0}) / current ({1})</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<CallTestFunction Name="ArrayOfBytes.Compare">
							<Parameter>CheckEntryDescription.Expected.DefaultData</Parameter>
							<Parameter>CheckEntryDescription.Current.DefaultData</Parameter>
							<Parameter>CheckEntryDescription.ErrorMsg</Parameter>
							<OutParameter>CheckEntryDescription.ErrorMsg</OutParameter>
						</CallTestFunction>
					</Equal>
				</Compare>
				<!--Handle Compare Result-->
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.ErrorMsg</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>Compare_MinData</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<WriteLine Id="66" Param0="CheckEntryDescription.ErrorMsg" Level="Warning">{0}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<WriteLine Id="67" Param0="CheckEntryDescription.ErrorMsg" Level="Error">{0}</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<SetVariable Target="CheckEntryDescription.bError">true</SetVariable>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="Compare_MinData">
				<SizeOf UInt32Var="CheckEntryDescription.Current.DataCount">CheckEntryDescription.Current.MinData</SizeOf>
			</TestStep>
			<TestStep>
				<SizeOf UInt32Var="CheckEntryDescription.Expected.DataCount">CheckEntryDescription.Expected.MinData</SizeOf>
				<WriteLine Id="68" Level="Verbose" Param0="CheckEntryDescription.Expected.MinData" Param1="CheckEntryDescription.Expected.DataCount">CheckEntryDescription | Expected : Min Data '{0}' ; length {1}</WriteLine>
			</TestStep>
			<TestStep>
				<!--Create Message-->
				<SetVariable Target="CheckEntryDescription.ErrorMsg" Param0="CheckEntryDescription.Index" Param1="CheckEntryDescription.SubIndex" Param2="CheckEntryDescription.DictionaryType">{2}: 0x{0:X4}:{1} MinData </SetVariable>
				<!--Skip Compare if no min data is defined-->
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.Current.MinData</Value1>
						<Value2>null</Value2>
						<WriteLine Id="69" Level="Verbose">CheckEntryDescription | Skip compare 'MinData'</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.Current.MinData</Value1>
						<Value2>null</Value2>
						<GotoStep>Compare_MaxData</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.Current.DataCount</Value1>
						<Value2>0</Value2>
						<WriteLine Id="70" Level="Verbose">CheckEntryDescription | Skip compare 'MinData'</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.Current.DataCount</Value1>
						<Value2>0</Value2>
						<GotoStep>Compare_MaxData</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.Expected.MinData</Value1>
						<Value2>null</Value2>
						<WriteLine Id="71" Level="Verbose">CheckEntryDescription | Skip compare 'MinData'</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.Expected.MinData</Value1>
						<Value2>null</Value2>
						<GotoStep>Compare_MaxData</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.Expected.DataCount</Value1>
						<Value2>0</Value2>
						<WriteLine Id="72" Level="Verbose">CheckEntryDescription | Skip compare 'MinData'</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.Expected.DataCount</Value1>
						<Value2>0</Value2>
						<GotoStep>Compare_MaxData</GotoStep>
					</Equal>
				</Compare>
				<!--Run Compare-->
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="73" Level="Verbose" Param0="CheckEntryDescription.Expected.MinData" Param1="CheckEntryDescription.Current.MinData">CheckEntryDescription | Compare 'MinData' expected ({0}) / current ({1})</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<CallTestFunction Name="ArrayOfBytes.Compare">
							<Parameter>CheckEntryDescription.Expected.MinData</Parameter>
							<Parameter>CheckEntryDescription.Current.MinData</Parameter>
							<Parameter>CheckEntryDescription.ErrorMsg</Parameter>
							<OutParameter>CheckEntryDescription.ErrorMsg</OutParameter>
						</CallTestFunction>
					</Equal>
				</Compare>
				<!--Handle Compare Result-->
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.ErrorMsg</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>Compare_MaxData</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<WriteLine Id="74" Param0="CheckEntryDescription.ErrorMsg" Level="Warning">{0}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<WriteLine Id="75" Param0="CheckEntryDescription.ErrorMsg" Level="Error">{0}</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<SetVariable Target="CheckEntryDescription.bError">true</SetVariable>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="Compare_MaxData">
				<SizeOf UInt32Var="CheckEntryDescription.Current.DataCount">CheckEntryDescription.Current.MaxData</SizeOf>
			</TestStep>
			<TestStep>
				<SizeOf UInt32Var="CheckEntryDescription.Expected.DataCount">CheckEntryDescription.Expected.MaxData</SizeOf>
				<WriteLine Id="76" Level="Verbose" Param0="CheckEntryDescription.Expected.MaxData" Param1="CheckEntryDescription.Expected.DataCount">CheckEntryDescription | Expected : Max Data '{0}' ; length {1}</WriteLine>
			</TestStep>
			<TestStep>
				<!--Create Message-->
				<SetVariable Target="CheckEntryDescription.ErrorMsg" Param0="CheckEntryDescription.Index" Param1="CheckEntryDescription.SubIndex" Param2="CheckEntryDescription.DictionaryType">{2}: 0x{0:X4}:{1} MaxData </SetVariable>
				<!--Skip Compare if no max data is defined-->
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.Current.MaxData</Value1>
						<Value2>null</Value2>
						<WriteLine Id="77" Level="Verbose">CheckEntryDescription | Skip compare 'MaxData'</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.Current.MaxData</Value1>
						<Value2>null</Value2>
						<GotoStep>GetDefaultDataLength</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.Current.DataCount</Value1>
						<Value2>0</Value2>
						<WriteLine Id="78" Level="Verbose">CheckEntryDescription | Skip compare 'MaxData'</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.Current.DataCount</Value1>
						<Value2>0</Value2>
						<GotoStep>GetDefaultDataLength</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.Expected.MaxData</Value1>
						<Value2>null</Value2>
						<WriteLine Id="79" Level="Verbose">CheckEntryDescription | Skip compare 'MaxData'</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.Expected.MaxData</Value1>
						<Value2>null</Value2>
						<GotoStep>GetDefaultDataLength</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.Expected.DataCount</Value1>
						<Value2>0</Value2>
						<WriteLine Id="80" Level="Verbose">CheckEntryDescription | Skip compare 'MaxData'</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.Expected.DataCount</Value1>
						<Value2>0</Value2>
						<GotoStep>GetDefaultDataLength</GotoStep>
					</Equal>
				</Compare>
				<!--Run Compare-->
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="81" Level="Verbose" Param0="CheckEntryDescription.Expected.MaxData" Param1="CheckEntryDescription.Current.MaxData">CheckEntryDescription | Compare 'MaxData' expected ({0}) / current ({1})</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<CallTestFunction Name="ArrayOfBytes.Compare">
							<Parameter>CheckEntryDescription.Expected.MaxData</Parameter>
							<Parameter>CheckEntryDescription.Current.MaxData</Parameter>
							<Parameter>CheckEntryDescription.ErrorMsg</Parameter>
							<OutParameter>CheckEntryDescription.ErrorMsg</OutParameter>
						</CallTestFunction>
					</Equal>
				</Compare>
				<!--Handle Compare Result-->
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.ErrorMsg</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>GetDefaultDataLength</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<WriteLine Id="82" Param0="CheckEntryDescription.ErrorMsg" Level="Warning">{0}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<WriteLine Id="83" Param0="CheckEntryDescription.ErrorMsg" Level="Error">{0}</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<SetVariable Target="CheckEntryDescription.bError">true</SetVariable>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="GetDefaultDataLength">
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.Current.DefaultData</Value1>
						<Value2>null</Value2>
						<Return Id="84"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<SizeOf UInt32Var="CheckEntryDescription.Current.DataCount">CheckEntryDescription.Current.DefaultData</SizeOf>
			</TestStep>
			<TestStep>
				<!--Create Message-->
				<SetVariable Target="CheckEntryDescription.ErrorMsg" Param0="CheckEntryDescription.Current.DataCount" Param1="(CheckEntryDescription.Current.BitSize+7)/8" Param2="CheckEntryDescription.Index" Param3="CheckEntryDescription.SubIndex" Param4="CheckEntryDescription.DictionaryType">{4}: 0x{2:X4}:{3} length of default data '{0}' expected: '{1}' (all bytes shall be defined in the defaultdata)</SetVariable>
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.Current.DataCount</Value1>
						<Value2>0</Value2>
						<Return Id="85"></Return>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.Current.DataCount</Value1>
						<Value2>(CheckEntryDescription.Current.BitSize+7)/8</Value2>
						<Return Id="86"></Return>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<WriteLine Id="87" Param0="CheckEntryDescription.ErrorMsg" Level="Warning">{0}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<WriteLine Id="88" Param0="CheckEntryDescription.ErrorMsg" Level="Error">{0}</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<SetVariable Target="CheckEntryDescription.bError">true</SetVariable>
					</NotEqual>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="803" Name="CheckIfCurrentConfigRequiresCu2508">
			<?MAX_OUTPUT_ID 6?>
			<TestStep Name="LOGGER_INFO_ABOUT_TEST_EVENT">
				<Description Id="0" Level="Verbose">Check if current configuration of DuT has AssignAcitvate == 0x0000 or realtime-enabling hardware connected.</Description>
			</TestStep>
			<TestStep Name="ReturnIfEsiElementDeviceDcNotAvailableOr0">
				<Compare>
					<Equal>
						<Value1>CurrentConfig.Dc</Value1>
						<Value2>false</Value2>
						<WriteLine Id="1" Level="Verbose">DC not supported (ESI element Dc not available)</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CurrentConfig.Dc</Value1>
						<Value2>false</Value2>
						<Return Id="2"></Return>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CurrentConfig.DcAssignActivate</Value1>
						<Value2>0</Value2>
						<WriteLine Id="3" Level="Verbose">DC not supported (Dc:OpMode:AssignActivate = 0x0000)</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CurrentConfig.DcAssignActivate</Value1>
						<Value2>0</Value2>
						<Return Id="4"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="DoNotSkipIfCuAvailable">
				<Compare>
					<Equal>
						<Value1>Master.Realtime</Value1>
						<Value2>true</Value2>
						<Return Id="5">Realtime enabling hardware connected. Slave can be tested with its DC modes.</Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="ReturnError">
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<RaiseError Id="6">DcOpMode of current DuT configuration requires realtime-enabling hardware. Connect CU2508.</RaiseError>
					</Equal>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="804" Name="CheckObjectDescription">
			<?MAX_OUTPUT_ID 22?>
			<Description>
				<Purpose>Compares the passed values against the passed object description of the passed dictionary</Purpose>
				<PreCondition></PreCondition>
				<Action>-gets the object description of the passed index
-comares the values against the passed values</Action>
				<PostCondition>Throws an error if one of the values does not match to the expected value</PostCondition>
				<ProposalForSolution>true</ProposalForSolution>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>CheckObjectDescription.ObjectDictionary</Name>
				<Type>ObjectDictionary</Type>
				<Comment>object dictionary to search for specified object (by index)</Comment>
			</Parameter>
			<Parameter>
				<Name>CheckObjectDescription.DictionaryType</Name>
				<Type>String</Type>
				<Comment>"offline" or "online"</Comment>
			</Parameter>
			<Parameter>
				<Name>CheckObjectDescription.Index</Name>
				<Type>UInt16</Type>
			</Parameter>
			<Parameter>
				<Name>CheckObjectDescription.LevelWarning</Name>
				<Type>Bool</Type>
				<Comment>If true raise warnig instead of errors</Comment>
			</Parameter>
			<Parameter>
				<Name>CheckObjectDescription.CaseSensitive</Name>
				<Type>Bool</Type>
				<Comment>If true name is checked case sensitive</Comment>
			</Parameter>
			<Parameter>
				<Name>CheckObjectDescription.Expected.Names</Name>
				<Type>ArrayOfString</Type>
				<Comment>List of valid names</Comment>
			</Parameter>
			<Parameter>
				<Name>CheckObjectDescription.Expected.Type</Name>
				<Type>UInt16</Type>
			</Parameter>
			<Parameter>
				<Name>CheckObjectDescription.Expected.ObjectCode</Name>
				<Type>Byte</Type>
			</Parameter>
			<Parameter>
				<Name>CheckObjectDescription.Expected.BitSize</Name>
				<Type>Int32</Type>
			</Parameter>
			<LocalVariables>
				<Name>CheckObjectDescription.bTmpVar</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckObjectDescription.Current.BitSize</Name>
				<Type>Int32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckObjectDescription.Current.DefaultData</Name>
				<Type>ArrayOfBytes</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckObjectDescription.Current.DefaultDataCount</Name>
				<Type>Int32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckObjectDescription.Current.Name</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckObjectDescription.Current.ObjectCode</Name>
				<Type>Byte</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckObjectDescription.Current.Type</Name>
				<Type>UInt16</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckObjectDescription.ErrorMsg</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckObjectDescription.int32CompareResult</Name>
				<Type>Int32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckObjectDescription.u32ExpetedNamesLength</Name>
				<Type>UInt32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CheckObjectDescription.ReloadDescrSdoInfo</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<OutParameter>
				<Name>CheckObjectDescription.bError</Name>
				<Type>Bool</Type>
			</OutParameter>
			<TestStep Name="CheckForMailboxCoE">
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Mailbox</Value1>
						<Value2>false</Value2>
						<SkipCase Id="0">Device does not support mailbox communication</SkipCase>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Mailbox.CoE</Value1>
						<Value2>false</Value2>
						<SkipCase Id="1">Device does not support CoE</SkipCase>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="InitResult">
				<SetVariable Target="CheckObjectDescription.bError">false</SetVariable>
			</TestStep>
			<TestStep Name="InitReloadFlag">
				<SetVariable Target="CheckObjectDescription.ReloadDescrSdoInfo">false</SetVariable>
			</TestStep>
			<TestStep Name="GetOdType">
				<RegexIsMatch ReturnValue="CheckObjectDescription.bTmpVar" Options="IgnoreCase">
					<Pattern>^online.*</Pattern>
					<InputString>CheckObjectDescription.DictionaryType</InputString>
				</RegexIsMatch>
				<Compare>
					<Equal>
						<Value1>CheckObjectDescription.bTmpVar</Value1>
						<Value2>false</Value2>
						<GotoStep>GetObjectDescription</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CheckProfile">
				<!--Load Description via SDO Info for 5001.3100 or 5001.3101-->
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Profile.Count</Value1>
						<Value2>0</Value2>
						<GotoStep>GetObjectDescription</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>DeviceDescr.Profile[0].ProfileNo</Value1>
						<Value2>5001</Value2>
						<GotoStep>GetObjectDescription</GotoStep>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Profile[0].AddInfo</Value1>
						<Value2>3100</Value2>
						<SetVariable Target="CheckObjectDescription.ReloadDescrSdoInfo">true</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Profile[0].AddInfo</Value1>
						<Value2>3101</Value2>
						<SetVariable Target="CheckObjectDescription.ReloadDescrSdoInfo">true</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="GetObjectDescription">
				<Description Id="2" Param0="CheckObjectDescription.Index" Level="Verbose">CheckObjectDescription | 0x{0:X4}</Description>
				<GetObjectDescription Index="CheckObjectDescription.Index" SourceDictionary="CheckObjectDescription.ObjectDictionary" SubIndex="-1" SDOInfoReload="CheckObjectDescription.ReloadDescrSdoInfo">
					<Name>CheckObjectDescription.Current.Name</Name>
					<Type>CheckObjectDescription.Current.Type</Type>
					<BitSize>CheckObjectDescription.Current.BitSize</BitSize>
					<DefaultData>CheckObjectDescription.Current.DefaultData</DefaultData>
					<ObjectCode>CheckObjectDescription.Current.ObjectCode</ObjectCode>
				</GetObjectDescription>
				<GotoOnSuccess>CompareBitSize</GotoOnSuccess>
			</TestStep>
			<TestStep Name="ObjectNotFound">
				<!--Create Message-->
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<SetVariable Target="CheckObjectDescription.ErrorMsg" Param0="CheckObjectDescription.Index" Param1="CheckObjectDescription.DictionaryType">{1}: 0x{0:X4} is not defined (failed to get object description).</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckObjectDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<WriteLine Id="3" Param0="CheckObjectDescription.ErrorMsg" Level="Warning">{0}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckObjectDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<WriteLine Id="4" Param0="CheckObjectDescription.ErrorMsg" Level="Error">{0}</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckObjectDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<SetVariable Target="CheckObjectDescription.bError">true</SetVariable>
					</NotEqual>
				</Compare>
				<!--return-->
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<Return Id="5"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CompareBitSize">
				<!--Create Message-->
				<SetVariable Target="CheckObjectDescription.ErrorMsg" Param0="CheckObjectDescription.Index" Param1="CheckObjectDescription.DictionaryType">{1}: 0x{0:X4}.BitSize</SetVariable>
				<!--Skip if BitSize is -1-->
				<Compare>
					<Equal>
						<Value1>CheckObjectDescription.Expected.BitSize</Value1>
						<Value2>-1</Value2>
						<WriteLine Id="6" Level="Verbose">CheckObjectDescription | Skip compare 'BitSize'</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckObjectDescription.Expected.BitSize</Value1>
						<Value2>-1</Value2>
						<GotoStep>CompareName</GotoStep>
					</Equal>
				</Compare>
				<!--Run Compare-->
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="7" Level="Verbose" Param0="CheckObjectDescription.Expected.BitSize" Param1="CheckObjectDescription.Current.BitSize">CheckObjectDescription | Compare 'BitSize' expected ({0}) / current ({1})</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<CallTestFunction Name="Int32.Compare">
							<Parameter>CheckObjectDescription.Expected.BitSize</Parameter>
							<Parameter>CheckObjectDescription.Current.BitSize</Parameter>
							<Parameter>CheckObjectDescription.ErrorMsg</Parameter>
							<OutParameter>CheckObjectDescription.ErrorMsg</OutParameter>
						</CallTestFunction>
					</Equal>
				</Compare>
				<!--Handle Compare Result-->
				<Compare>
					<Equal>
						<Value1>CheckObjectDescription.ErrorMsg</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>CompareName</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckObjectDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<WriteLine Id="8" Param0="CheckObjectDescription.ErrorMsg" Level="Warning">{0}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckObjectDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<WriteLine Id="9" Param0="CheckObjectDescription.ErrorMsg" Level="Error">{0}</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckObjectDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<SetVariable Target="CheckObjectDescription.bError">true</SetVariable>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="CompareName">
				<SizeOf UInt32Var="CheckObjectDescription.u32ExpetedNamesLength">CheckObjectDescription.Expected.Names</SizeOf>
				<Compare>
					<Equal>
						<Value1>CheckObjectDescription.u32ExpetedNamesLength</Value1>
						<Value2>0</Value2>
						<GotoStep>CompareCode</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckObjectDescription.Current.Name</Value1>
						<Value2>null</Value2>
						<GotoStep>CompareCode</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckObjectDescription.Current.Name</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>CompareCode</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Greater>
						<Value1>CheckObjectDescription.u32ExpetedNamesLength</Value1>
						<Value2>1</Value2>
						<GotoStep>ValidateName</GotoStep>
					</Greater>
				</Compare>
			</TestStep>
			<TestStep Name="CheckSingleName">
				<Compare>
					<Equal>
						<Value1>CheckObjectDescription.Expected.Names[0]</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>CompareCode</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="ValidateName">
				<!--Dump Compare Info-->
				<Compare>
					<Equal>
						<Value1>CheckObjectDescription.u32ExpetedNamesLength</Value1>
						<Value2>1</Value2>
						<WriteLine Id="10" Level="Verbose" Param0="CheckObjectDescription.Current.Name" Param1="CheckObjectDescription.Expected.Names[0]" Param2="CheckObjectDescription.CaseSensitive">CheckObjectDescription | Compare 'Name' expected ({1}) / current ({0}) / case sens. {2}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Greater>
						<Value1>CheckObjectDescription.u32ExpetedNamesLength</Value1>
						<Value2>1</Value2>
						<WriteLine Id="11" Level="Verbose" Param0="CheckObjectDescription.Current.Name" Param1="CheckObjectDescription.Expected.Names" Param2="CheckObjectDescription.CaseSensitive">CheckObjectDescription | Compare 'Name' expected names ({1}) / current ({0}) / case sens. {2}</WriteLine>
					</Greater>
				</Compare>
				<!--Call IndexOf function-->
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<CallTestFunction Name="ArrayOfString.IndexOfExtended">
							<Parameter>CheckObjectDescription.Current.Name</Parameter>
							<Parameter>CheckObjectDescription.Expected.Names</Parameter>
							<Parameter>CheckObjectDescription.CaseSensitive</Parameter>
							<Parameter>true</Parameter>
							<Parameter>true</Parameter>
							<OutParameter>CheckObjectDescription.int32CompareResult</OutParameter>
						</CallTestFunction>
					</Equal>
				</Compare>
				<Compare>
					<GreaterOrEqual>
						<Value1>CheckObjectDescription.int32CompareResult</Value1>
						<Value2>0</Value2>
						<GotoStep>CompareCode</GotoStep>
					</GreaterOrEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckObjectDescription.u32ExpetedNamesLength</Value1>
						<Value2>1</Value2>
						<WriteLine Id="12" Level="Warning" Param0="CheckObjectDescription.Current.Name" Param1="CheckObjectDescription.Expected.Names[0]" Param2="CheckObjectDescription.Index">0x{2:X4} Unexpected name '{0}' expected: '{1}'</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Greater>
						<Value1>CheckObjectDescription.u32ExpetedNamesLength</Value1>
						<Value2>1</Value2>
						<WriteLine Id="13" Level="Warning" Param0="CheckObjectDescription.Current.Name" Param1="CheckObjectDescription.Expected.Names" Param2="CheckObjectDescription.Index">0x{2:X4} Unexpected name '{0}' expected one of the following names: {1}</WriteLine>
					</Greater>
				</Compare>
			</TestStep>
			<TestStep Name="CompareCode">
				<!--Create Message-->
				<SetVariable Target="CheckObjectDescription.ErrorMsg" Param0="CheckObjectDescription.Index" Param1="CheckObjectDescription.DictionaryType">{1}: 0x{0:X4}.Code</SetVariable>
				<!--Run Compare-->
				<Compare>
					<Equal>
						<Value1>CheckObjectDescription.Expected.ObjectCode</Value1>
						<Value2>0</Value2>
						<GotoStep>CompareType</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="14" Level="Verbose" Param0="CheckObjectDescription.Expected.ObjectCode" Param1="CheckObjectDescription.Current.ObjectCode">CheckObjectDescription | Compare 'ObjCode' expected ({0}) / current ({1})</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<CallTestFunction Name="ObjectCode.Compare">
							<Parameter>CheckObjectDescription.Expected.ObjectCode</Parameter>
							<Parameter>CheckObjectDescription.Current.ObjectCode</Parameter>
							<Parameter>CheckObjectDescription.ErrorMsg</Parameter>
							<OutParameter>CheckObjectDescription.ErrorMsg</OutParameter>
						</CallTestFunction>
					</Equal>
				</Compare>
				<!--Handle Compare Result-->
				<Compare>
					<Equal>
						<Value1>CheckObjectDescription.ErrorMsg</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>CompareType</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckObjectDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<WriteLine Id="15" Param0="CheckObjectDescription.ErrorMsg" Level="Warning">{0}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckObjectDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<WriteLine Id="16" Param0="CheckObjectDescription.ErrorMsg" Level="Error">{0}</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckObjectDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<SetVariable Target="CheckObjectDescription.bError">true</SetVariable>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="CompareType">
				<!--Create Message-->
				<SetVariable Target="CheckObjectDescription.ErrorMsg" Param0="CheckObjectDescription.Index" Param1="CheckObjectDescription.DictionaryType">{1}: 0x{0:X4}.Type</SetVariable>
				<!--Skip if Reference Type is 0-->
				<Compare>
					<Equal>
						<Value1>CheckObjectDescription.Expected.Type</Value1>
						<Value2>0</Value2>
						<WriteLine Id="17" Level="Verbose">CheckObjectDescription | Skip compare 'Type'</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckObjectDescription.Expected.Type</Value1>
						<Value2>0</Value2>
						<Return Id="18"></Return>
					</Equal>
				</Compare>
				<!--Run Compare-->
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="19" Level="Verbose" Param0="CheckObjectDescription.Expected.Type" Param1="CheckObjectDescription.Current.Type">CheckObjectDescription | Compare 'Type' expected ({0}) / current ({1})</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<CallTestFunction Name="DataType.Compare">
							<Parameter>CheckObjectDescription.Expected.Type</Parameter>
							<Parameter>CheckObjectDescription.Current.Type</Parameter>
							<Parameter>CheckObjectDescription.ErrorMsg</Parameter>
							<OutParameter>CheckObjectDescription.ErrorMsg</OutParameter>
						</CallTestFunction>
					</Equal>
				</Compare>
				<!--Handle Compare Result-->
				<Compare>
					<Equal>
						<Value1>CheckObjectDescription.ErrorMsg</Value1>
						<Value2>EmptyString</Value2>
						<Return Id="20"></Return>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CheckObjectDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<WriteLine Id="21" Param0="CheckObjectDescription.ErrorMsg" Level="Warning">{0}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckObjectDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<WriteLine Id="22" Param0="CheckObjectDescription.ErrorMsg" Level="Error">{0}</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CheckObjectDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<SetVariable Target="CheckObjectDescription.bError">true</SetVariable>
					</NotEqual>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="901" Name="CompareObjectDictionary">
			<?MAX_OUTPUT_ID 13?>
			<Description>
				<Purpose>Compares two object dictionaries</Purpose>
				<PreCondition></PreCondition>
				<Action>Generate an object list from the reference object dictionary and compare the object/entry descriptions against the second dictionary.

Used Functions:
VerifyObjectDictionary
VerifyEntryDictionary</Action>
				<PostCondition>The object descriptions has to be equal otherwise a failure is thrown</PostCondition>
				<ProposalForSolution>true</ProposalForSolution>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>CompareObjectDictionary.Reference.Dictionary</Name>
				<Type>ObjectDictionary</Type>
				<Comment>Reference Object dictionary</Comment>
			</Parameter>
			<Parameter>
				<Name>CompareObjectDictionary.Reference.DictionaryType</Name>
				<Type>String</Type>
				<Comment>Reference Object dictionary type (offline / online)</Comment>
			</Parameter>
			<Parameter>
				<Name>CompareObjectDictionary.Compare.Dictionary</Name>
				<Type>ObjectDictionary</Type>
				<Comment>Object dictionary to compare</Comment>
			</Parameter>
			<Parameter>
				<Name>CompareObjectDictionary.Compare.DictionaryType</Name>
				<Type>String</Type>
				<Comment>Compare Object dictionary type (offline / online)</Comment>
			</Parameter>
			<Parameter>
				<Name>CompareObjectDictionary.Compare.PdoMappingOffset</Name>
				<Type>UInt16</Type>
				<Comment>Index offset of PdoMapping objects</Comment>
			</Parameter>
			<Parameter>
				<Name>CompareObjectDictionary.Compare.ObjectOffset</Name>
				<Type>UInt16</Type>
				<Comment>Index offset of standard objects</Comment>
			</Parameter>
			<Parameter>
				<Name>CompareObjectDictionary.ConflictLevelDependsOnCategory</Name>
				<Type>Bool</Type>
				<Comment>If true warnigs (instead of errors) will be raised in case of conflicts (only for optional and conditional object/entries)</Comment>
			</Parameter>
			<Parameter>
				<Name>CompareObjectDictionary.SkipBitLengthCompareIfDtIsVariable</Name>
				<Type>Bool</Type>
				<Comment>if true the bitsize will not be compared for entries with a flexible bitlength</Comment>
			</Parameter>
			<Parameter>
				<Name>CompareObjectDictionary.IgnoreObjects</Name>
				<Type>ArrayOfUInt16</Type>
				<Comment>Array of object indices to skip</Comment>
			</Parameter>
			<LocalVariables>
				<Name>CompareObjectDictionary.ErrorList</Name>
				<Type>ArrayOfString</Type>
				<Comment>list of errors during the description comparison</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>CompareObjectDictionary.ErrorListCnt</Name>
				<Type>UInt32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CompareObjectDictionary.ErrorListLength</Name>
				<Type>UInt32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CompareObjectDictionary.Int32EntryListIndex</Name>
				<Type>Int32</Type>
				<Comment>Counter to iterate over all reference entries</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>CompareObjectDictionary.Int32ObjListIndex</Name>
				<Type>Int32</Type>
				<Comment>Counter to iterate over all reference objects</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>CompareObjectDictionary.Int32SubIdx</Name>
				<Type>Int32</Type>
				<Comment>Current entry subindex</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>CompareObjectDictionary.bTmpVariable</Name>
				<Type>Bool</Type>
				<Comment>temp bool variable</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>CompareObjectDictionary.RaiseOnlyWarnings</Name>
				<Type>Bool</Type>
				<Comment>Raise Warnings instead of errors (used in the verify functions)</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>CompareObjectDictionary.Reference.BoolBackup</Name>
				<Type>Bool</Type>
				<Comment>reference entry backup flag</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>CompareObjectDictionary.Reference.BoolReadInOp</Name>
				<Type>Bool</Type>
				<Comment>reference entry is readable in OP</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>CompareObjectDictionary.Reference.BoolReadInPreOp</Name>
				<Type>Bool</Type>
				<Comment>reference entry is readable in PreOP</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>CompareObjectDictionary.Reference.BoolReadInSafeOp</Name>
				<Type>Bool</Type>
				<Comment>reference entry is readable in SafeOP</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>CompareObjectDictionary.Reference.BoolSettings</Name>
				<Type>Bool</Type>
				<Comment>reference entry setting flag</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>CompareObjectDictionary.Reference.BoolWriteInOp</Name>
				<Type>Bool</Type>
				<Comment>reference entry is writeable in OP</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>CompareObjectDictionary.Reference.BoolWriteInPreOp</Name>
				<Type>Bool</Type>
				<Comment>reference entry is writeable in PreOP</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>CompareObjectDictionary.Reference.BoolWriteInSafeOp</Name>
				<Type>Bool</Type>
				<Comment>reference entry is writeable in SafeOP</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>CompareObjectDictionary.Reference.ByteArrDefaultData</Name>
				<Type>ArrayOfBytes</Type>
				<Comment>reference entry default data</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>CompareObjectDictionary.Reference.ByteArrMaxData</Name>
				<Type>ArrayOfBytes</Type>
				<Comment>reference entry max data</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>CompareObjectDictionary.Reference.ByteArrMinData</Name>
				<Type>ArrayOfBytes</Type>
				<Comment>reference entry min data</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>CompareObjectDictionary.Reference.ByteObjCode</Name>
				<Type>Byte</Type>
				<Comment>reference object code</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>CompareObjectDictionary.Reference.EntryList</Name>
				<Type>ObjectList</Type>
				<Comment>Reference Entry list</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>CompareObjectDictionary.Reference.EntryListLength</Name>
				<Type>UInt32</Type>
				<Comment>The length of reference entry list</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>CompareObjectDictionary.Reference.Int32BitOffs</Name>
				<Type>Int32</Type>
				<Comment>reference entry bitoffset</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>CompareObjectDictionary.Reference.Int32BitSize</Name>
				<Type>Int32</Type>
				<Comment>reference object/entry bitsize</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>CompareObjectDictionary.Reference.ObjectList</Name>
				<Type>ObjectList</Type>
				<Comment>Reference object list</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>CompareObjectDictionary.Reference.objectListLength</Name>
				<Type>UInt32</Type>
				<Comment>The length of reference objectlist</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>CompareObjectDictionary.Reference.StringCategory</Name>
				<Type>String</Type>
				<Comment>reference object/entry category (o/m/c)</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>CompareObjectDictionary.Reference.StringName</Name>
				<Type>String</Type>
				<Comment>reference object/entry name</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>CompareObjectDictionary.Reference.StringPdoMapping</Name>
				<Type>String</Type>
				<Comment>reference entry Pdo mappable</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>CompareObjectDictionary.Reference.Uint16Type</Name>
				<Type>UInt16</Type>
				<Comment>reference object/entry DataType</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>CompareObjectDictionary.Uint16Index</Name>
				<Type>UInt16</Type>
				<Comment>Current object index</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>CompareObjectDictionary.Uint16TmpVar</Name>
				<Type>UInt16</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>CompareObjectDictionary.Uint32SkipIndex</Name>
				<Type>Int32</Type>
				<Comment>SkipIdx</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>CompareObjectDictionary.bSkipBitOffsetCompare</Name>
				<Type>Bool</Type>
				<Comment>indicates if the bitoffset shall be skipped</Comment>
			</LocalVariables>
			<OutParameter>
				<Name>CompareObjectDictionary.BoolResult</Name>
				<Type>Bool</Type>
				<Comment>if true dictionary comparison was successful</Comment>
			</OutParameter>
			<TestStep Name="WriteDescription">
				<WriteLine Id="0" Level="Output" Param0="CompareObjectDictionary.Reference.DictionaryType" Param1="CompareObjectDictionary.Compare.DictionaryType">Comparing Object Dictionaries.. Reference dictionary type: '{0}' Compare dictionary type: '{1}'</WriteLine>
			</TestStep>
			<TestStep Name="CheckIfObjectCompareDictionaryIsNull">
				<Compare>
					<Equal>
						<Value1>CompareObjectDictionary.Compare.Dictionary</Value1>
						<Value2>null</Value2>
						<Return Id="1">CompareObjectDictionary abort. Object Dictionary to compare is null.</Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CheckIfObjectReferenceDictionaryIsNull">
				<Compare>
					<Equal>
						<Value1>CompareObjectDictionary.Reference.Dictionary</Value1>
						<Value2>null</Value2>
						<Return Id="2">CompareObjectDictionary abort. Reference Dictionary is null.</Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="InitResult">
				<SetVariable Target="CompareObjectDictionary.BoolResult">true</SetVariable>
			</TestStep>
			<TestStep Name="InitConflictLevel">
				<SetVariable Target="CompareObjectDictionary.RaiseOnlyWarnings">false</SetVariable>
			</TestStep>
			<TestStep Name="InitObjListIndex">
				<SetVariable Target="CompareObjectDictionary.Int32ObjListIndex">0</SetVariable>
			</TestStep>
			<TestStep Name="GetObjectDescriptionListFromReferenceOD">
				<GetObjectList SourceDict="CompareObjectDictionary.Reference.Dictionary" Target="CompareObjectDictionary.Reference.ObjectList" Count="CompareObjectDictionary.Reference.objectListLength">
					<SubIdx>-1</SubIdx>
				</GetObjectList>
				<RaiseErrorOnFailure Id="3">Failed to get object descriptions of reference dictionary</RaiseErrorOnFailure>
			</TestStep>
			<TestStep Name="CheckObjectListLength">
				<Compare>
					<Equal>
						<Value1>CompareObjectDictionary.Reference.objectListLength</Value1>
						<Value2>0</Value2>
						<Return Id="4" Param0="CompareObjectDictionary.Reference.objectListLength">Length of reference list {0}.</Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="NextObject">
				<!--Set SubIndex to -1 (to get OD description)-->
				<SetVariable Target="CompareObjectDictionary.Int32SubIdx">-1</SetVariable>
			</TestStep>
			<TestStep Name="ResetErrorList">
				<!--ReInit Error List-->
				<InitArray TargetArray="CompareObjectDictionary.ErrorList" Length="0"></InitArray>
			</TestStep>
			<TestStep Name="GetReferenceObjectDescription">
				<!--Get object description from the reference object list-->
				<GetObjectDescriptionFromList Source="CompareObjectDictionary.Reference.ObjectList" ListIndex="CompareObjectDictionary.Int32ObjListIndex">
					<Index>CompareObjectDictionary.Uint16Index</Index>
					<SubIdx>CompareObjectDictionary.Int32SubIdx</SubIdx>
					<Name>CompareObjectDictionary.Reference.StringName</Name>
					<Type>CompareObjectDictionary.Reference.Uint16Type</Type>
					<BitSize>CompareObjectDictionary.Reference.Int32BitSize</BitSize>
					<BitOffs>CompareObjectDictionary.Reference.Int32BitOffs</BitOffs>
					<DefaultData>CompareObjectDictionary.Reference.ByteArrDefaultData</DefaultData>
					<MinData>CompareObjectDictionary.Reference.ByteArrMinData</MinData>
					<MaxData>CompareObjectDictionary.Reference.ByteArrMaxData</MaxData>
					<Flags>
						<Access Backup="CompareObjectDictionary.Reference.BoolBackup" ReadInPreop="CompareObjectDictionary.Reference.BoolReadInPreOp" ReadInOP="CompareObjectDictionary.Reference.BoolReadInOp" ReadInSafeOP="CompareObjectDictionary.Reference.BoolReadInSafeOp" Settings="CompareObjectDictionary.Reference.BoolSettings" WriteinOP="CompareObjectDictionary.Reference.BoolWriteInOp" WriteInPreOp="CompareObjectDictionary.Reference.BoolWriteInPreOp" WriteInSafeOp="CompareObjectDictionary.Reference.BoolWriteInSafeOp"></Access>
						<Category>CompareObjectDictionary.Reference.StringCategory</Category>
						<PdoMapping>CompareObjectDictionary.Reference.StringPdoMapping</PdoMapping>
					</Flags>
					<MaxSubIndex>CompareObjectDictionary.Reference.Int32MaxSubIndex</MaxSubIndex>
					<ObjectCode>CompareObjectDictionary.Reference.ByteObjCode</ObjectCode>
				</GetObjectDescriptionFromList>
			</TestStep>
			<TestStep Name="AddPdoOffset">
				<!--If Pdo mapping object is selected and Pdo mapping offset is defined add offset-->
				<CallTestFunction Name="IsPdoMappingIndex">
					<Parameter>CompareObjectDictionary.Uint16Index</Parameter>
					<OutParameter>CompareObjectDictionary.bTmpVariable</OutParameter>
				</CallTestFunction>
				<!--skip if Pdo mapping offset is null-->
				<Compare>
					<Equal>
						<Value1>CompareObjectDictionary.Compare.PdoMappingOffset</Value1>
						<Value2>null</Value2>
						<GotoStep>AddObjectOffset</GotoStep>
					</Equal>
				</Compare>
				<!--skip if Pdo mapping offset is 0-->
				<Compare>
					<Equal>
						<Value1>CompareObjectDictionary.Compare.PdoMappingOffset</Value1>
						<Value2>0</Value2>
						<GotoStep>AddObjectOffset</GotoStep>
					</Equal>
				</Compare>
				<!--skip if current index is no Pdo mapping index-->
				<Compare>
					<Equal>
						<Value1>CompareObjectDictionary.bTmpVariable</Value1>
						<Value2>false</Value2>
						<GotoStep>AddObjectOffset</GotoStep>
					</Equal>
				</Compare>
				<!--add offset-->
				<Compare>
					<Equal>
						<Value1>CompareObjectDictionary.bTmpVariable</Value1>
						<Value2>true</Value2>
						<SetVariable Target="CompareObjectDictionary.Uint16Index">CompareObjectDictionary.Uint16Index + CompareObjectDictionary.Compare.PdoMappingOffset</SetVariable>
					</Equal>
				</Compare>
				<!--goto "UpdateConflictLevel_ForObjectTests"-->
				<Compare>
					<Equal>
						<Value1>CompareObjectDictionary.bTmpVariable</Value1>
						<Value2>true</Value2>
						<GotoStep>AddObjectOffset</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="AddObjectOffset">
				<!--skip if object offset is null-->
				<Compare>
					<Equal>
						<Value1>CompareObjectDictionary.Compare.ObjectOffset</Value1>
						<Value2>null</Value2>
						<GotoStep>CheckIfObjectShallBeSkipped</GotoStep>
					</Equal>
				</Compare>
				<!--skip if object offset is 0-->
				<Compare>
					<Equal>
						<Value1>CompareObjectDictionary.Compare.ObjectOffset</Value1>
						<Value2>0</Value2>
						<GotoStep>CheckIfObjectShallBeSkipped</GotoStep>
					</Equal>
				</Compare>
				<!--add offset-->
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<SetVariable Target="CompareObjectDictionary.Uint16Index">CompareObjectDictionary.Uint16Index + CompareObjectDictionary.Compare.ObjectOffset</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CheckIfObjectShallBeSkipped">
				<CallTestFunction Name="ArrayOfUInt16.IndexOf">
					<Parameter>CompareObjectDictionary.Uint16Index</Parameter>
					<Parameter>CompareObjectDictionary.IgnoreObjects</Parameter>
					<OutParameter>CompareObjectDictionary.Uint32SkipIndex</OutParameter>
				</CallTestFunction>
				<Compare>
					<GreaterOrEqual>
						<Value1>CompareObjectDictionary.Uint32SkipIndex</Value1>
						<Value2>0</Value2>
						<WriteLine Id="5" Level="Output" Param0="CompareObjectDictionary.Uint16Index">Compare object 0x{0:X} will be skipped.</WriteLine>
					</GreaterOrEqual>
				</Compare>
				<Compare>
					<GreaterOrEqual>
						<Value1>CompareObjectDictionary.Uint32SkipIndex</Value1>
						<Value2>0</Value2>
						<SetVariable Target="CompareObjectDictionary.Int32ObjListIndex">CompareObjectDictionary.Int32ObjListIndex+1</SetVariable>
					</GreaterOrEqual>
				</Compare>
				<Compare>
					<GreaterOrEqual>
						<Value1>CompareObjectDictionary.Uint32SkipIndex</Value1>
						<Value2>0</Value2>
						<GotoStep>LoopEnd</GotoStep>
					</GreaterOrEqual>
				</Compare>
			</TestStep>
			<TestStep Name="UpdateConflictLevel_ForObjectTests">
				<SetVariable Target="CompareObjectDictionary.RaiseOnlyWarnings">false</SetVariable>
				<!--in case of an mandatory object start with tests-->
				<Compare>
					<Equal>
						<Value1>CompareObjectDictionary.Reference.StringCategory</Value1>
						<Value2>m</Value2>
						<GotoStep>HandleVariableBitLength</GotoStep>
					</Equal>
				</Compare>
				<!--If the category evaluation is disabled (CompareObjectDictionary.ConflictLevelDependsOnCategory == false) start with tests-->
				<Compare>
					<Equal>
						<Value1>CompareObjectDictionary.ConflictLevelDependsOnCategory</Value1>
						<Value2>false</Value2>
						<GotoStep>HandleVariableBitLength</GotoStep>
					</Equal>
				</Compare>
				<!--Set conflict level to warning-->
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<SetVariable Target="CompareObjectDictionary.RaiseOnlyWarnings">true</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="ResetObjTypeIfCodeNot7"></TestStep>
			<TestStep Name="HandleVariableBitLength">
				<!--Check if the bitsize shall not be compared for entries with a flexible bitlength-->
				<Compare>
					<Equal>
						<Value1>CompareObjectDictionary.SkipBitLengthCompareIfDtIsVariable</Value1>
						<Value2>false</Value2>
						<GotoStep>CheckIfObjectIsDefined</GotoStep>
					</Equal>
				</Compare>
				<!--Skip BitLength compare for Non Variable Objects (Record and Array), the object size is the sum of all entries-->
				<Compare>
					<NotEqual>
						<Value1>CompareObjectDictionary.Reference.ByteObjCode</Value1>
						<Value2>7</Value2>
						<SetVariable Target="CompareObjectDictionary.Reference.Int32BitSize">-1</SetVariable>
					</NotEqual>
				</Compare>
				<!--Skip BitLength compare for "VISIBLE_STRING"-->
				<Compare>
					<Equal>
						<Value1>CompareObjectDictionary.Reference.Uint16Type</Value1>
						<Value2>9</Value2>
						<SetVariable Target="CompareObjectDictionary.Reference.Int32BitSize">-1</SetVariable>
					</Equal>
				</Compare>
				<!--Skip BitLength compare for "ARRAY OF BYTE"-->
				<Compare>
					<Equal>
						<Value1>CompareObjectDictionary.Reference.Uint16Type</Value1>
						<Value2>10</Value2>
						<SetVariable Target="CompareObjectDictionary.Reference.Int32BitSize">-1</SetVariable>
					</Equal>
				</Compare>
				<!--Skip BitLength compare for "ARRAY OF UINT"-->
				<Compare>
					<Equal>
						<Value1>CompareObjectDictionary.Reference.Uint16Type</Value1>
						<Value2>11</Value2>
						<SetVariable Target="CompareObjectDictionary.Reference.Int32BitSize">-1</SetVariable>
					</Equal>
				</Compare>
				<!--Skip BitLength compare for "ARRAY OF INT"-->
				<Compare>
					<Equal>
						<Value1>CompareObjectDictionary.Reference.Uint16Type</Value1>
						<Value2>#x260</Value2>
						<SetVariable Target="CompareObjectDictionary.Reference.Int32BitSize">-1</SetVariable>
					</Equal>
				</Compare>
				<!--Skip BitLength compare for "ARRAY OF SINT"-->
				<Compare>
					<Equal>
						<Value1>CompareObjectDictionary.Reference.Uint16Type</Value1>
						<Value2>#x261</Value2>
						<SetVariable Target="CompareObjectDictionary.Reference.Int32BitSize">-1</SetVariable>
					</Equal>
				</Compare>
				<!--Skip BitLength compare for "ARRAY OF DINT"-->
				<Compare>
					<Equal>
						<Value1>CompareObjectDictionary.Reference.Uint16Type</Value1>
						<Value2>#x262</Value2>
						<SetVariable Target="CompareObjectDictionary.Reference.Int32BitSize">-1</SetVariable>
					</Equal>
				</Compare>
				<!--Skip BitLength compare for "ARRAY OF UDINT"-->
				<Compare>
					<Equal>
						<Value1>CompareObjectDictionary.Reference.Uint16Type</Value1>
						<Value2>#x263</Value2>
						<SetVariable Target="CompareObjectDictionary.Reference.Int32BitSize">-1</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CheckIfObjectIsDefined">
				<GetObjectDescription SourceDictionary="CompareObjectDictionary.Compare.Dictionary" Index="CompareObjectDictionary.Uint16Index" SubIndex="-1">
					<Index>CompareObjectDictionary.Uint16TmpVar</Index>
				</GetObjectDescription>
				<GotoOnSuccess>CompareObjectDescriptions</GotoOnSuccess>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<SetVariable Target="CompareObjectDictionary.BoolResult">false</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="6" Level="Error" Param0="CompareObjectDictionary.Reference.StringName" Param1="CompareObjectDictionary.Compare.DictionaryType" Param2="CompareObjectDictionary.Uint16Index">Object '{0}' (0x{2:X4}) is not defined in {1}.</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>IncrementObjectIndex</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CompareObjectDescriptions">
				<!--Code is VARIABLE (7), 8: ARRAY, 9:RECORD-->
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="7" Level="Output" Param0="CompareObjectDictionary.Reference.StringName" Param1="CompareObjectDictionary.Compare.DictionaryType" Param2="CompareObjectDictionary.Uint16Index">Comparing values of '{0}' (0x{2:X4}) to object of {1}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CompareObjectDictionary.Reference.ByteObjCode</Value1>
						<Value2>7</Value2>
						<CallTestFunction Name="VerifyObjectDescription">
							<Parameter>CompareObjectDictionary.Compare.Dictionary</Parameter>
							<Parameter>CompareObjectDictionary.Compare.DictionaryType</Parameter>
							<Parameter>CompareObjectDictionary.Uint16Index</Parameter>
							<Parameter>CompareObjectDictionary.RaiseOnlyWarnings</Parameter>
							<Parameter>false</Parameter>
							<Parameter>CompareObjectDictionary.Reference.StringName</Parameter>
							<Parameter>null</Parameter>
							<!--Type is set to null-->
							<Parameter>CompareObjectDictionary.Reference.ByteObjCode</Parameter>
							<Parameter>CompareObjectDictionary.Reference.BoolReadInPreOp</Parameter>
							<Parameter>CompareObjectDictionary.Reference.BoolReadInSafeOp</Parameter>
							<Parameter>CompareObjectDictionary.Reference.BoolReadInOp</Parameter>
							<Parameter>CompareObjectDictionary.Reference.BoolWriteInPreOp</Parameter>
							<Parameter>CompareObjectDictionary.Reference.BoolWriteInSafeOp</Parameter>
							<Parameter>CompareObjectDictionary.Reference.BoolWriteInOp</Parameter>
							<Parameter>null</Parameter>
							<!--category is set to null-->
							<Parameter>CompareObjectDictionary.Reference.StringPdoMapping</Parameter>
							<Parameter>CompareObjectDictionary.Reference.ByteArrDefaultData</Parameter>
							<Parameter>CompareObjectDictionary.Reference.BoolSettings</Parameter>
							<Parameter>CompareObjectDictionary.Reference.BoolBackup</Parameter>
							<Parameter>CompareObjectDictionary.Reference.Int32BitSize</Parameter>
							<OutParameter>CompareObjectDictionary.ErrorList</OutParameter>
						</CallTestFunction>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>CompareObjectDictionary.Reference.ByteObjCode</Value1>
						<Value2>7</Value2>
						<GotoStep>GetEntryDescriptionListFromReferenceOD</GotoStep>
					</NotEqual>
				</Compare>
				<!--If Entry Bitlength is larger 65535 the value is set to 65535 because the SDO Info service max value is 65535-->
				<Compare>
					<Greater>
						<Value1>CompareObjectDictionary.Reference.Int32BitSize</Value1>
						<Value2>65535</Value2>
						<WriteLine Id="8" Param0="CompareObjectDictionary.Reference.Int32BitSize" Level="Verbose">Entry Bitsize is {0} =&gt; reset to 65535 because the SDO Info service max value is 65535</WriteLine>
					</Greater>
				</Compare>
				<Compare>
					<Greater>
						<Value1>CompareObjectDictionary.Reference.Int32BitSize</Value1>
						<Value2>65535</Value2>
						<SetVariable Target="CompareObjectDictionary.Reference.Int32BitSize">65535</SetVariable>
					</Greater>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CompareObjectDictionary.Reference.ByteObjCode</Value1>
						<Value2>7</Value2>
						<CallTestFunction Name="VerifyObjectDescription">
							<Parameter>CompareObjectDictionary.Compare.Dictionary</Parameter>
							<Parameter>CompareObjectDictionary.Compare.DictionaryType</Parameter>
							<Parameter>CompareObjectDictionary.Uint16Index</Parameter>
							<Parameter>CompareObjectDictionary.RaiseOnlyWarnings</Parameter>
							<Parameter>false</Parameter>
							<Parameter>CompareObjectDictionary.Reference.StringName</Parameter>
							<Parameter>CompareObjectDictionary.Reference.Uint16Type</Parameter>
							<Parameter>CompareObjectDictionary.Reference.ByteObjCode</Parameter>
							<Parameter>CompareObjectDictionary.Reference.BoolReadInPreOp</Parameter>
							<Parameter>CompareObjectDictionary.Reference.BoolReadInSafeOp</Parameter>
							<Parameter>CompareObjectDictionary.Reference.BoolReadInOp</Parameter>
							<Parameter>CompareObjectDictionary.Reference.BoolWriteInPreOp</Parameter>
							<Parameter>CompareObjectDictionary.Reference.BoolWriteInSafeOp</Parameter>
							<Parameter>CompareObjectDictionary.Reference.BoolWriteInOp</Parameter>
							<Parameter>null</Parameter>
							<!--category is set to null-->
							<Parameter>CompareObjectDictionary.Reference.StringPdoMapping</Parameter>
							<Parameter>CompareObjectDictionary.Reference.ByteArrDefaultData</Parameter>
							<Parameter>CompareObjectDictionary.Reference.BoolSettings</Parameter>
							<Parameter>CompareObjectDictionary.Reference.BoolBackup</Parameter>
							<Parameter>CompareObjectDictionary.Reference.Int32BitSize</Parameter>
							<OutParameter>CompareObjectDictionary.ErrorList</OutParameter>
						</CallTestFunction>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="GetEntryDescriptionListFromReferenceOD">
				<GetObjectList SourceDict="CompareObjectDictionary.Reference.Dictionary" Target="CompareObjectDictionary.Reference.EntryList" Count="CompareObjectDictionary.Reference.EntryListLength">
					<Index>CompareObjectDictionary.Uint16Index</Index>
				</GetObjectList>
				<RaiseErrorOnFailure Id="9" Param0="CompareObjectDictionary.Uint16Index">Failed to get reference entry descriptions of object 0x{0:X4}</RaiseErrorOnFailure>
			</TestStep>
			<TestStep Name="CheckEntryListLength">
				<Compare>
					<Equal>
						<Value1>CompareObjectDictionary.Reference.EntryListLength</Value1>
						<Value2>0</Value2>
						<WriteLine Id="10" Param0="CompareObjectDictionary.Uint16Index" Param1="CompareObjectDictionary.Reference.DictionaryType">{1}: 0x{0:X4} entry description list is empty.</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CompareObjectDictionary.Reference.EntryListLength</Value1>
						<Value2>0</Value2>
						<GotoStep>IncrementObjectIndex</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="InitEntryCounter">
				<SetVariable Target="CompareObjectDictionary.Int32EntryListIndex">0</SetVariable>
			</TestStep>
			<TestStep>
				<SetVariable Target="CompareObjectDictionary.bSkipBitOffsetCompare">false</SetVariable>
			</TestStep>
			<TestStep Name="NextEntry">
				<!--Get entry description from the reference object list-->
				<GetObjectDescriptionFromList Source="CompareObjectDictionary.Reference.EntryList" ListIndex="CompareObjectDictionary.Int32EntryListIndex">
					<Index>CompareObjectDictionary.Uint16Index</Index>
					<SubIdx>CompareObjectDictionary.Int32SubIdx</SubIdx>
					<Name>CompareObjectDictionary.Reference.StringName</Name>
					<Type>CompareObjectDictionary.Reference.Uint16Type</Type>
					<BitSize>CompareObjectDictionary.Reference.Int32BitSize</BitSize>
					<BitOffs>CompareObjectDictionary.Reference.Int32BitOffs</BitOffs>
					<DefaultData>CompareObjectDictionary.Reference.ByteArrDefaultData</DefaultData>
					<MinData>CompareObjectDictionary.Reference.ByteArrMinData</MinData>
					<MaxData>CompareObjectDictionary.Reference.ByteArrMaxData</MaxData>
					<Flags>
						<Access Backup="CompareObjectDictionary.Reference.BoolBackup" ReadInPreop="CompareObjectDictionary.Reference.BoolReadInPreOp" ReadInOP="CompareObjectDictionary.Reference.BoolReadInOp" ReadInSafeOP="CompareObjectDictionary.Reference.BoolReadInSafeOp" Settings="CompareObjectDictionary.Reference.BoolSettings" WriteinOP="CompareObjectDictionary.Reference.BoolWriteInOp" WriteInPreOp="CompareObjectDictionary.Reference.BoolWriteInPreOp" WriteInSafeOp="CompareObjectDictionary.Reference.BoolWriteInSafeOp"></Access>
						<Category>CompareObjectDictionary.Reference.StringCategory</Category>
						<PdoMapping>CompareObjectDictionary.Reference.StringPdoMapping</PdoMapping>
					</Flags>
					<MaxSubIndex>CompareObjectDictionary.Reference.Int32MaxSubIndex</MaxSubIndex>
					<ObjectCode>CompareObjectDictionary.Reference.ByteObjCode</ObjectCode>
				</GetObjectDescriptionFromList>
			</TestStep>
			<TestStep Name="UpdateConflictLevel_ForEntryTests">
				<SetVariable Target="CompareObjectDictionary.RaiseOnlyWarnings">false</SetVariable>
				<!--in case of an mandatory object start with tests-->
				<Compare>
					<Equal>
						<Value1>CompareObjectDictionary.Reference.StringCategory</Value1>
						<Value2>m</Value2>
						<GotoStep>CompareEntryDescriptions</GotoStep>
					</Equal>
				</Compare>
				<!--If the category evaluation is disabled (CompareObjectDictionary.ConflictLevelDependsOnCategory == false) start with tests-->
				<Compare>
					<Equal>
						<Value1>CompareObjectDictionary.ConflictLevelDependsOnCategory</Value1>
						<Value2>false</Value2>
						<GotoStep>CompareEntryDescriptions</GotoStep>
					</Equal>
				</Compare>
				<!--Set conflict level to warning-->
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<SetVariable Target="CompareObjectDictionary.RaiseOnlyWarnings">true</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CompareEntryDescriptions">
				<!--Check if the bitsize shall not be compared for entries with a flexible bitlength-->
				<Compare>
					<Equal>
						<Value1>CompareObjectDictionary.SkipBitLengthCompareIfDtIsVariable</Value1>
						<Value2>false</Value2>
						<GotoStep>HandleHugeEntryBitLength</GotoStep>
					</Equal>
				</Compare>
				<!--Skip BitLength compare for "VISIBLE_STRING"-->
				<Compare>
					<Equal>
						<Value1>CompareObjectDictionary.Reference.Uint16Type</Value1>
						<Value2>9</Value2>
						<SetVariable Target="CompareObjectDictionary.Reference.Int32BitSize">-1</SetVariable>
					</Equal>
				</Compare>
				<!--Skip BitLength compare for "ARRAY OF BYTE"-->
				<Compare>
					<Equal>
						<Value1>CompareObjectDictionary.Reference.Uint16Type</Value1>
						<Value2>10</Value2>
						<SetVariable Target="CompareObjectDictionary.Reference.Int32BitSize">-1</SetVariable>
					</Equal>
				</Compare>
				<!--Skip BitLength compare for "ARRAY OF UINT"-->
				<Compare>
					<Equal>
						<Value1>CompareObjectDictionary.Reference.Uint16Type</Value1>
						<Value2>11</Value2>
						<SetVariable Target="CompareObjectDictionary.Reference.Int32BitSize">-1</SetVariable>
					</Equal>
				</Compare>
				<!--Skip BitLength compare for "ARRAY OF INT"-->
				<Compare>
					<Equal>
						<Value1>CompareObjectDictionary.Reference.Uint16Type</Value1>
						<Value2>#x260</Value2>
						<SetVariable Target="CompareObjectDictionary.Reference.Int32BitSize">-1</SetVariable>
					</Equal>
				</Compare>
				<!--Skip BitLength compare for "ARRAY OF SINT"-->
				<Compare>
					<Equal>
						<Value1>CompareObjectDictionary.Reference.Uint16Type</Value1>
						<Value2>#x261</Value2>
						<SetVariable Target="CompareObjectDictionary.Reference.Int32BitSize">-1</SetVariable>
					</Equal>
				</Compare>
				<!--Skip BitLength compare for "ARRAY OF DINT"-->
				<Compare>
					<Equal>
						<Value1>CompareObjectDictionary.Reference.Uint16Type</Value1>
						<Value2>#x262</Value2>
						<SetVariable Target="CompareObjectDictionary.Reference.Int32BitSize">-1</SetVariable>
					</Equal>
				</Compare>
				<!--Skip BitLength compare for "ARRAY OF UDINT"-->
				<Compare>
					<Equal>
						<Value1>CompareObjectDictionary.Reference.Uint16Type</Value1>
						<Value2>#x263</Value2>
						<SetVariable Target="CompareObjectDictionary.Reference.Int32BitSize">-1</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<SetVariable Target="CompareObjectDictionary.bSkipBitOffsetCompare">true</SetVariable>
			</TestStep>
			<TestStep Name="HandleHugeEntryBitLength">
				<!--If Entry Bitlength is larger 65535 the value is set to 65535 because the SDO Info service max value is 65535-->
				<Compare>
					<Greater>
						<Value1>CompareObjectDictionary.Reference.Int32BitSize</Value1>
						<Value2>65535</Value2>
						<WriteLine Id="11" Param0="CompareObjectDictionary.Reference.Int32BitSize" Level="Verbose">Entry Bitsize is {0} =&gt; reset to 65535 because the SDO Info service max value is 65535</WriteLine>
					</Greater>
				</Compare>
				<Compare>
					<Greater>
						<Value1>CompareObjectDictionary.Reference.Int32BitSize</Value1>
						<Value2>65535</Value2>
						<SetVariable Target="CompareObjectDictionary.Reference.Int32BitSize">65535</SetVariable>
					</Greater>
				</Compare>
			</TestStep>
			<TestStep>
				<Compare>
					<Equal>
						<Value1>CompareObjectDictionary.bSkipBitOffsetCompare</Value1>
						<Value2>true</Value2>
						<SetVariable Target="CompareObjectDictionary.Reference.Int32BitOffs">-1</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<CallTestFunction Name="VerifyEntryDescription">
					<Parameter>CompareObjectDictionary.Compare.Dictionary</Parameter>
					<Parameter>CompareObjectDictionary.Compare.DictionaryType</Parameter>
					<Parameter>CompareObjectDictionary.Uint16Index</Parameter>
					<Parameter>CompareObjectDictionary.Int32SubIdx</Parameter>
					<Parameter>CompareObjectDictionary.RaiseOnlyWarnings</Parameter>
					<Parameter>false</Parameter>
					<Parameter>CompareObjectDictionary.Reference.StringName</Parameter>
					<Parameter>CompareObjectDictionary.Reference.Uint16Type</Parameter>
					<Parameter>CompareObjectDictionary.Reference.BoolReadInPreOp</Parameter>
					<Parameter>CompareObjectDictionary.Reference.BoolReadInSafeOp</Parameter>
					<Parameter>CompareObjectDictionary.Reference.BoolReadInOp</Parameter>
					<Parameter>CompareObjectDictionary.Reference.BoolWriteInPreOp</Parameter>
					<Parameter>CompareObjectDictionary.Reference.BoolWriteInSafeOp</Parameter>
					<Parameter>CompareObjectDictionary.Reference.BoolWriteInOp</Parameter>
					<Parameter>null</Parameter>
					<Parameter>CompareObjectDictionary.Reference.StringPdoMapping</Parameter>
					<Parameter>CompareObjectDictionary.Reference.ByteArrDefaultData</Parameter>
					<Parameter>CompareObjectDictionary.Reference.ByteArrMinData</Parameter>
					<Parameter>CompareObjectDictionary.Reference.ByteArrMaxData</Parameter>
					<Parameter>CompareObjectDictionary.Reference.BoolSettings</Parameter>
					<Parameter>CompareObjectDictionary.Reference.BoolBackup</Parameter>
					<Parameter>CompareObjectDictionary.Reference.Int32BitSize</Parameter>
					<Parameter>CompareObjectDictionary.Reference.Int32BitOffs</Parameter>
					<Parameter>false</Parameter>
					<OutParameter>CompareObjectDictionary.ErrorList</OutParameter>
				</CallTestFunction>
			</TestStep>
			<TestStep Name="IncrementEntryIndex">
				<SetVariable Target="CompareObjectDictionary.Int32EntryListIndex">CompareObjectDictionary.Int32EntryListIndex+1</SetVariable>
				<Compare>
					<Lower>
						<Value1>CompareObjectDictionary.Int32EntryListIndex</Value1>
						<Value2>CompareObjectDictionary.Reference.EntryListLength</Value2>
						<GotoStep>NextEntry</GotoStep>
					</Lower>
				</Compare>
			</TestStep>
			<TestStep Name="IncrementObjectIndex">
				<SetVariable Target="CompareObjectDictionary.Int32ObjListIndex">CompareObjectDictionary.Int32ObjListIndex+1</SetVariable>
			</TestStep>
			<TestStep Name="GetNumberOfErrors">
				<SizeOf UInt32Var="CompareObjectDictionary.ErrorListLength">CompareObjectDictionary.ErrorList</SizeOf>
				<Compare>
					<Equal>
						<Value1>CompareObjectDictionary.ErrorListLength</Value1>
						<Value2>0</Value2>
						<WriteLine Id="12" Level="Verbose" Param0="CompareObjectDictionary.Uint16Index">0x{0:X4}: Objects are equal.</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>CompareObjectDictionary.ErrorListLength</Value1>
						<Value2>0</Value2>
						<GotoStep>LoopEnd</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Greater>
						<Value1>CompareObjectDictionary.ErrorListLength</Value1>
						<Value2>0</Value2>
						<SetVariable Target="CompareObjectDictionary.BoolResult">false</SetVariable>
					</Greater>
				</Compare>
			</TestStep>
			<TestStep>
				<SetVariable Target="CompareObjectDictionary.ErrorListCnt">0</SetVariable>
			</TestStep>
			<TestStep Name="DumpErrors">
				<WriteLine Id="13" Level="Error" Param0="CompareObjectDictionary.ErrorList[CompareObjectDictionary.ErrorListCnt]">{0}</WriteLine>
			</TestStep>
			<TestStep>
				<SetVariable Target="CompareObjectDictionary.ErrorListCnt">CompareObjectDictionary.ErrorListCnt + 1</SetVariable>
				<Compare>
					<Lower>
						<Value1>CompareObjectDictionary.ErrorListCnt</Value1>
						<Value2>CompareObjectDictionary.ErrorListLength</Value2>
						<GotoStep>DumpErrors</GotoStep>
					</Lower>
				</Compare>
			</TestStep>
			<TestStep Name="LoopEnd">
				<Compare>
					<Lower>
						<Value1>CompareObjectDictionary.Int32ObjListIndex</Value1>
						<Value2>CompareObjectDictionary.Reference.objectListLength</Value2>
						<GotoStep>NextObject</GotoStep>
					</Lower>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="1001" Name="DataType.Compare">
			<?MAX_OUTPUT_ID 1?>
			<Description>
				<Purpose>Compare two DataType Variables</Purpose>
				<PreCondition></PreCondition>
				<Action>if the reference variable is null the comparision is abort (without an error text).
else both variables are compared</Action>
				<PostCondition>return values if variables mismatch. If variables are equal the return value is empty</PostCondition>
				<ProposalForSolution>true</ProposalForSolution>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>DataType.Compare.RefUInt16</Name>
				<Type>UInt16</Type>
				<Comment>reference DataType</Comment>
			</Parameter>
			<Parameter>
				<Name>DataType.Compare.CmpUInt16</Name>
				<Type>UInt16</Type>
				<Comment>DataType to compare</Comment>
			</Parameter>
			<Parameter>
				<Name>DataType.Compare.InfoText</Name>
				<Type>String</Type>
				<Comment>additional Info text which will be the first part of the error message</Comment>
			</Parameter>
			<LocalVariables>
				<Name>DataType.Compare.RefStr</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>DataType.Compare.CmpStr</Name>
				<Type>String</Type>
			</LocalVariables>
			<OutParameter>
				<Name>DataType.Compare.ErrorText</Name>
				<Type>String</Type>
			</OutParameter>
			<TestStep Name="InitResult">
				<SetVariable Target="DataType.Compare.ErrorText">EmptyString</SetVariable>
			</TestStep>
			<TestStep Name="CheckIfReferenceIsNull">
				<Compare>
					<Equal>
						<Value1>DataType.Compare.RefUInt16</Value1>
						<Value2>null</Value2>
						<Return Id="0"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="ReturnIfEqual">
				<Compare>
					<Equal>
						<Value1>DataType.Compare.RefUInt16</Value1>
						<Value2>DataType.Compare.CmpUInt16</Value2>
						<Return Id="1"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<CallTestFunction Name="DataType.ToString">
					<Parameter>DataType.Compare.RefUInt16</Parameter>
					<OutParameter>DataType.Compare.RefStr</OutParameter>
				</CallTestFunction>
			</TestStep>
			<TestStep>
				<CallTestFunction Name="DataType.ToString">
					<Parameter>DataType.Compare.CmpUInt16</Parameter>
					<OutParameter>DataType.Compare.CmpStr</OutParameter>
				</CallTestFunction>
			</TestStep>
			<TestStep Name="CreateMessage">
				<SetVariable Target="DataType.Compare.ErrorText" Param0="DataType.Compare.InfoText" Param1="DataType.Compare.CmpStr" Param2="DataType.Compare.RefStr">{0} '{1}' expected: '{2}'.</SetVariable>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="1002" Name="DataType.ToString">
			<Description>
				<Purpose>Convert a Data Type Index to String</Purpose>
				<PreCondition></PreCondition>
				<Action></Action>
				<PostCondition></PostCondition>
				<ProposalForSolution>true</ProposalForSolution>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>DataType.ToString.Index</Name>
				<Type>UInt16</Type>
			</Parameter>
			<OutParameter>
				<Name>DataType.ToString.String</Name>
				<Type>String</Type>
			</OutParameter>
			<TestStep Name="InitResult">
				<SetVariable Target="DataType.ToString.String" Param0="DataType.ToString.Index">{0}</SetVariable>
			</TestStep>
			<TestStep>
				<Compare>
					<Equal>
						<Value1>DataType.ToString.Index</Value1>
						<Value2>#x0000</Value2>
						<SetVariable Target="DataType.ToString.String">(padding)</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DataType.ToString.Index</Value1>
						<Value2>#x0001</Value2>
						<SetVariable Target="DataType.ToString.String">BOOLEAN</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DataType.ToString.Index</Value1>
						<Value2>#x001E</Value2>
						<SetVariable Target="DataType.ToString.String">BYTE</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DataType.ToString.Index</Value1>
						<Value2>#x001F</Value2>
						<SetVariable Target="DataType.ToString.String">WORD</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DataType.ToString.Index</Value1>
						<Value2>#x0020</Value2>
						<SetVariable Target="DataType.ToString.String">DWORD</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DataType.ToString.Index</Value1>
						<Value2>#x0030</Value2>
						<SetVariable Target="DataType.ToString.String">BIT1</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DataType.ToString.Index</Value1>
						<Value2>#x0031</Value2>
						<SetVariable Target="DataType.ToString.String">BIT2</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DataType.ToString.Index</Value1>
						<Value2>#x0032</Value2>
						<SetVariable Target="DataType.ToString.String">BIT3</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DataType.ToString.Index</Value1>
						<Value2>#x0033</Value2>
						<SetVariable Target="DataType.ToString.String">BIT4</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DataType.ToString.Index</Value1>
						<Value2>#x0034</Value2>
						<SetVariable Target="DataType.ToString.String">BIT5</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DataType.ToString.Index</Value1>
						<Value2>#x0035</Value2>
						<SetVariable Target="DataType.ToString.String">BIT6</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DataType.ToString.Index</Value1>
						<Value2>#x0036</Value2>
						<SetVariable Target="DataType.ToString.String">BIT7</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DataType.ToString.Index</Value1>
						<Value2>#x0037</Value2>
						<SetVariable Target="DataType.ToString.String">BIT8</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DataType.ToString.Index</Value1>
						<Value2>#x002D</Value2>
						<SetVariable Target="DataType.ToString.String">BITARR8</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DataType.ToString.Index</Value1>
						<Value2>#x002E</Value2>
						<SetVariable Target="DataType.ToString.String">BITARR16</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DataType.ToString.Index</Value1>
						<Value2>#x002F</Value2>
						<SetVariable Target="DataType.ToString.String">BITARR32</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DataType.ToString.Index</Value1>
						<Value2>#x0002</Value2>
						<SetVariable Target="DataType.ToString.String">INTEGER8</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DataType.ToString.Index</Value1>
						<Value2>#x0003</Value2>
						<SetVariable Target="DataType.ToString.String">INTEGER16</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DataType.ToString.Index</Value1>
						<Value2>#x0010</Value2>
						<SetVariable Target="DataType.ToString.String">INTEGER24</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DataType.ToString.Index</Value1>
						<Value2>#x0004</Value2>
						<SetVariable Target="DataType.ToString.String">INTEGER32</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DataType.ToString.Index</Value1>
						<Value2>#x0012</Value2>
						<SetVariable Target="DataType.ToString.String">INTEGER40</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DataType.ToString.Index</Value1>
						<Value2>#x0013</Value2>
						<SetVariable Target="DataType.ToString.String">INTEGER48</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DataType.ToString.Index</Value1>
						<Value2>#x0014</Value2>
						<SetVariable Target="DataType.ToString.String">INTEGER56</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DataType.ToString.Index</Value1>
						<Value2>#x0015</Value2>
						<SetVariable Target="DataType.ToString.String">INTEGER64</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DataType.ToString.Index</Value1>
						<Value2>#x0005</Value2>
						<SetVariable Target="DataType.ToString.String">UNSIGNED8</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DataType.ToString.Index</Value1>
						<Value2>#x0006</Value2>
						<SetVariable Target="DataType.ToString.String">UNSIGNED16</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DataType.ToString.Index</Value1>
						<Value2>#x0016</Value2>
						<SetVariable Target="DataType.ToString.String">UNSIGNED24</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DataType.ToString.Index</Value1>
						<Value2>#x0007</Value2>
						<SetVariable Target="DataType.ToString.String">UNSIGNED32</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DataType.ToString.Index</Value1>
						<Value2>#x0018</Value2>
						<SetVariable Target="DataType.ToString.String">UNSIGNED40</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DataType.ToString.Index</Value1>
						<Value2>#x0019</Value2>
						<SetVariable Target="DataType.ToString.String">UNSIGNED48</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DataType.ToString.Index</Value1>
						<Value2>#x001A</Value2>
						<SetVariable Target="DataType.ToString.String">UNSIGNED56</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DataType.ToString.Index</Value1>
						<Value2>#x001B</Value2>
						<SetVariable Target="DataType.ToString.String">UNSIGNED64</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DataType.ToString.Index</Value1>
						<Value2>#x0008</Value2>
						<SetVariable Target="DataType.ToString.String">REAL32</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DataType.ToString.Index</Value1>
						<Value2>#x0011</Value2>
						<SetVariable Target="DataType.ToString.String">REAL64</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DataType.ToString.Index</Value1>
						<Value2>#x001D</Value2>
						<SetVariable Target="DataType.ToString.String">GUID</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DataType.ToString.Index</Value1>
						<Value2>#x0009</Value2>
						<SetVariable Target="DataType.ToString.String">VISIBLE_STRING (STRING(n))</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DataType.ToString.Index</Value1>
						<Value2>#x000A</Value2>
						<SetVariable Target="DataType.ToString.String">OCTET_STRING (ARRAY [0..n] OF BYTE)</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DataType.ToString.Index</Value1>
						<Value2>#x000B</Value2>
						<SetVariable Target="DataType.ToString.String">UNICODE_STRING (ARRAY [0..n] OF UINT)</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DataType.ToString.Index</Value1>
						<Value2>#x0260</Value2>
						<SetVariable Target="DataType.ToString.String">ARRAY_OF_INT</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DataType.ToString.Index</Value1>
						<Value2>#x0261</Value2>
						<SetVariable Target="DataType.ToString.String">ARRAY_OF_SINT</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DataType.ToString.Index</Value1>
						<Value2>#x0262</Value2>
						<SetVariable Target="DataType.ToString.String">ARRAY_OF_DINT</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DataType.ToString.Index</Value1>
						<Value2>#x0263</Value2>
						<SetVariable Target="DataType.ToString.String">ARRAY_OF_UDINT</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DataType.ToString.Index</Value1>
						<Value2>#x0021</Value2>
						<SetVariable Target="DataType.ToString.String">PDO_MAPPING</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DataType.ToString.Index</Value1>
						<Value2>#x0023</Value2>
						<SetVariable Target="DataType.ToString.String">IDENTITY</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DataType.ToString.Index</Value1>
						<Value2>#x0025</Value2>
						<SetVariable Target="DataType.ToString.String">COMMAND_PAR</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DataType.ToString.Index</Value1>
						<Value2>#x0027</Value2>
						<SetVariable Target="DataType.ToString.String">PDO_PARAMETER</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DataType.ToString.Index</Value1>
						<Value2>#x0028</Value2>
						<SetVariable Target="DataType.ToString.String">ENUM</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DataType.ToString.Index</Value1>
						<Value2>#x0029</Value2>
						<SetVariable Target="DataType.ToString.String">SM_SYNCHRONISATION</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DataType.ToString.Index</Value1>
						<Value2>#x002A</Value2>
						<SetVariable Target="DataType.ToString.String">RECORD</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DataType.ToString.Index</Value1>
						<Value2>#x002B</Value2>
						<SetVariable Target="DataType.ToString.String">BACKUP_PARAMETER</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DataType.ToString.Index</Value1>
						<Value2>#x002C</Value2>
						<SetVariable Target="DataType.ToString.String">MODULAR_DEVICE_PROFILE</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DataType.ToString.Index</Value1>
						<Value2>#x0281</Value2>
						<SetVariable Target="DataType.ToString.String">ERROR_SETTING</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DataType.ToString.Index</Value1>
						<Value2>#x0282</Value2>
						<SetVariable Target="DataType.ToString.String">DIAGNOSIS_HISTORY</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DataType.ToString.Index</Value1>
						<Value2>#x0283</Value2>
						<SetVariable Target="DataType.ToString.String">EXTERNAL_SYNC_STATUS</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DataType.ToString.Index</Value1>
						<Value2>#x0284</Value2>
						<SetVariable Target="DataType.ToString.String">EXTERNAL_SYNC_SETTINGS</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DataType.ToString.Index</Value1>
						<Value2>#x0285</Value2>
						<SetVariable Target="DataType.ToString.String">DEFTYPE_FSOEFRAME</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DataType.ToString.Index</Value1>
						<Value2>#x0286</Value2>
						<SetVariable Target="DataType.ToString.String">DEFTYPE_FSOECOMMPAR</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="1003" Name="DataTypeName.GetBitSize">
			<?MAX_OUTPUT_ID 7?>
			<Description>
				<Action>Gets the BitSize of the Datatype</Action>
				<PostCondition></PostCondition>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>DataTypeName.GetBitSize.Name</Name>
				<Type>String</Type>
				<Comment>Name of the Datatype</Comment>
			</Parameter>
			<Parameter>
				<Name>DataTypeName.GetBitSize.XmlFile</Name>
				<Type>String</Type>
				<Comment>Path of the xml file (absolute or relative to the ESI file).
If the parameter is null or empty the current device description will be referenced.</Comment>
			</Parameter>
			<Parameter>
				<Name>DataTypeName.GetBitSize.XPathDT</Name>
				<Type>String</Type>
				<Comment>XPath of the basic DataType element</Comment>
			</Parameter>
			<LocalVariables>
				<Name>DataTypeName.GetBitSize.stringXmlValue</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>DataTypeName.GetBitSize.IsMatch</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>DataTypeName.GetBitSize.DatatypeName</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>DataTypeName.GetBitSize.LoopCounter</Name>
				<Type>UInt16</Type>
			</LocalVariables>
			<OutParameter>
				<Name>DataTypeName.GetBitSize.i32Size</Name>
				<Type>Int32</Type>
				<!--Size of the Datatype-->
			</OutParameter>
			<TestStep>
				<!--InitLoopCounter-->
				<SetVariable Target="DataTypeName.GetBitSize.LoopCounter">1</SetVariable>
			</TestStep>
			<TestStep>
				<!--Set default BitSize to -1-->
				<SetVariable Target="DataTypeName.GetBitSize.i32Size">-1</SetVariable>
			</TestStep>
			<TestStep>
				<!--if "DataTypeName.GetBitSize.XmlFile" is null set variable to emptyString-->
				<Compare>
					<Equal>
						<Value1>DataTypeName.GetBitSize.XmlFile</Value1>
						<Value2>null</Value2>
						<SetVariable Target="DataTypeName.GetBitSize.XmlFile">EmptyString</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--return if XPath is not defined or empty-->
				<Compare>
					<Equal>
						<Value1>DataTypeName.GetBitSize.XPathDT</Value1>
						<Value2>null</Value2>
						<Return Id="0"></Return>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DataTypeName.GetBitSize.XPathDT</Value1>
						<Value2>EmptyString</Value2>
						<Return Id="1"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CHECK_IF_PATH_IS_VALID">
				<GetXmlValue ReturnValue="DataTypeName.GetBitSize.stringXmlValue" Markup="true" FileName="DataTypeName.GetBitSize.XmlFile">
					<XPath Param0="DataTypeName.GetBitSize.XPathDT">{0}</XPath>
				</GetXmlValue>
				<!--Dumnp an user info if XPath is invalid-->
				<Compare>
					<Equal>
						<Value1>DataTypeName.GetBitSize.stringXmlValue</Value1>
						<Value2>null</Value2>
						<WriteLine Id="2" Level="Verbose" Param0="DataTypeName.GetBitSize.XPathDT" Param1="DataTypeName.GetBitSize.XmlFile">DataTypeName.GetBitSize: Invalid XPath : {0} (File: {1})</WriteLine>
					</Equal>
				</Compare>
				<!--Return-->
				<Compare>
					<Equal>
						<Value1>DataTypeName.GetBitSize.stringXmlValue</Value1>
						<Value2>null</Value2>
						<Return Id="3"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="LoopStart">
				<!--Get datatype name from local dictionary-->
				<GetXmlValue ReturnValue="DataTypeName.GetBitSize.stringXmlValue" Markup="false" FileName="DataTypeName.GetBitSize.XmlFile">
					<XPath Param0="DataTypeName.GetBitSize.XPathDT" Param1="DataTypeName.GetBitSize.LoopCounter">{0}[{1}]/Name</XPath>
				</GetXmlValue>
				<Compare>
					<Equal>
						<Value1>DataTypeName.GetBitSize.stringXmlValue</Value1>
						<Value2>null</Value2>
						<WriteLine Id="4" Level="Verbose" Param0="DataTypeName.GetBitSize.Name" Param1="DataTypeName.GetBitSize.XmlFile" Param2="DataTypeName.GetBitSize.XPathDT">DataTypeName.GetBitSize: "{0}" not found in "{2}" (FILE: {1}).</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DataTypeName.GetBitSize.stringXmlValue</Value1>
						<Value2>null</Value2>
						<Return Id="5"></Return>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>DataTypeName.GetBitSize.stringXmlValue</Value1>
						<Value2>DataTypeName.GetBitSize.Name</Value2>
						<GotoStep>LoopEnd</GotoStep>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Get BitSize-->
				<GetXmlValue ReturnValue="DataTypeName.GetBitSize.i32Size" Markup="false" FileName="DataTypeName.GetBitSize.XmlFile">
					<XPath Param0="DataTypeName.GetBitSize.XPathDT" Param1="DataTypeName.GetBitSize.LoopCounter">{0}[{1}]/BitSize</XPath>
				</GetXmlValue>
				<!--Dump an Info if BitSize not defined-->
				<Compare>
					<Equal>
						<Value1>DataTypeName.GetBitSize.i32Size</Value1>
						<Value2>null</Value2>
						<WriteLine Id="6" Level="Verbose" Param0="DataTypeName.GetBitSize.Name">The Element "BitSize" is not defined for {0}.</WriteLine>
					</Equal>
				</Compare>
				<!--Set return BitSize to -1-->
				<Compare>
					<Equal>
						<Value1>DataTypeName.GetBitSize.i32Size</Value1>
						<Value2>null</Value2>
						<SetVariable Target="DataTypeName.GetBitSize.i32Size">-1</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<Return Id="7"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="LoopEnd">
				<SetVariable Target="DataTypeName.GetBitSize.LoopCounter">DataTypeName.GetBitSize.LoopCounter + 1</SetVariable>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>LoopStart</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="1004" Name="DataTypeSupportCompleteAccess">
			<?MAX_OUTPUT_ID 0?>
			<Description>
				<Purpose>Checks if Complete Access is supported for a DataType (of of the referenced objects support CA)</Purpose>
				<PreCondition>-none</PreCondition>
				<Action>-checks the default SDO access and the exception in the object element</Action>
				<PostCondition></PostCondition>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>DataTypeSupportCompleteAccess.strDtName</Name>
				<Type>String</Type>
				<Comment>Name of the data type</Comment>
			</Parameter>
			<LocalVariables>
				<Name>DataTypeSupportCompleteAccess.xmlFile</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>DataTypeSupportCompleteAccess.ObjCnt</Name>
				<Type>UInt32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>DataTypeSupportCompleteAccess.tmpStr</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>DataTypeSupportCompleteAccess.ObjName</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>DataTypeSupportCompleteAccess.xPathObject</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>DataTypeSupportCompleteAccess.Od</Name>
				<Type>ObjectDictionary</Type>
			</LocalVariables>
			<OutParameter>
				<Name>DataTypeSupportCompleteAccess.boolCaSupport</Name>
				<Type>Bool</Type>
			</OutParameter>
			<TestStep Name="SetDefaultValue">
				<SetVariable Target="DataTypeSupportCompleteAccess.boolCaSupport">false</SetVariable>
			</TestStep>
			<TestStep Name="InitObjCnt">
				<SetVariable Target="DataTypeSupportCompleteAccess.ObjCnt">1</SetVariable>
			</TestStep>
			<TestStep Name="GetDefaultAccess">
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Mailbox</Value1>
						<Value2>false</Value2>
						<GotoStep>GetObjectAccess</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Mailbox.CoE</Value1>
						<Value2>false</Value2>
						<GotoStep>GetObjectAccess</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Mailbox.CoE.CompleteAccess</Value1>
						<Value2>false</Value2>
						<GotoStep>GetObjectAccess</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Mailbox.CoE.CompleteAccess</Value1>
						<Value2>true</Value2>
						<SetVariable Target="DataTypeSupportCompleteAccess.boolCaSupport">true</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="GetObjectAccess">
				<SetVariable Target="DataTypeSupportCompleteAccess.xPathObject">EmptyString</SetVariable>
			</TestStep>
			<TestStep Name="GetInternalOd">
				<GetXmlValue ReturnValue="DataTypeSupportCompleteAccess.tmpStr" Markup="false">
					<XPath>Profile[position()=1]/Dictionary/Objects/Object</XPath>
				</GetXmlValue>
				<Compare>
					<NotEqual>
						<Value1>DataTypeSupportCompleteAccess.tmpStr</Value1>
						<Value2>null</Value2>
						<SetVariable Target="DataTypeSupportCompleteAccess.xPathObject">Profile[position()=1]/Dictionary/Objects/Object</SetVariable>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep>
				<Compare>
					<NotEqual>
						<Value1>DataTypeSupportCompleteAccess.tmpStr</Value1>
						<Value2>null</Value2>
						<GotoStep>CheckXPath</GotoStep>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="GetExternalOD">
				<GetXmlValue ReturnValue="DataTypeSupportCompleteAccess.xmlFile" Markup="false">
					<XPath>Profile[position()=1]/DictionaryFile</XPath>
				</GetXmlValue>
				<Compare>
					<NotEqual>
						<Value1>DataTypeSupportCompleteAccess.xmlFile</Value1>
						<Value2>null</Value2>
						<SetVariable Target="DataTypeSupportCompleteAccess.xPathObject">/EtherCATDict/Dictionary/Objects/Object</SetVariable>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DataTypeSupportCompleteAccess.xmlFile</Value1>
						<Value2>null</Value2>
						<SetVariable Target="DataTypeSupportCompleteAccess.xmlFile">EmptyString</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CheckXPath">
				<Compare>
					<Equal>
						<Value1>DataTypeSupportCompleteAccess.xPathObject</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>END</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="ObjLoopStart">
				<Compare>
					<Lower>
						<Value1>DeviceDescr.Profile[0].Dictionary.Objects.Count</Value1>
						<Value2>DataTypeSupportCompleteAccess.ObjCnt</Value2>
						<GotoStep>END</GotoStep>
					</Lower>
				</Compare>
			</TestStep>
			<TestStep Name="CreateXPath">
				<SetVariable Target="DataTypeSupportCompleteAccess.tmpStr" Param0="DataTypeSupportCompleteAccess.xPathObject" Param1="DataTypeSupportCompleteAccess.ObjCnt">{0}[{1}]/Type</SetVariable>
			</TestStep>
			<TestStep Name="CheckUsedDt">
				<GetXmlValue ReturnValue="DataTypeSupportCompleteAccess.tmpStr" Markup="false" FileName="DataTypeSupportCompleteAccess.xmlFile">
					<XPath Param0="DataTypeSupportCompleteAccess.tmpStr">{0}</XPath>
				</GetXmlValue>
				<Compare>
					<NotEqual>
						<Value1>DataTypeSupportCompleteAccess.tmpStr</Value1>
						<Value2>DataTypeSupportCompleteAccess.strDtName</Value2>
						<GotoStep>ObjLoopEnd</GotoStep>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep>
				<SetVariable Target="DataTypeSupportCompleteAccess.tmpStr" Param0="DataTypeSupportCompleteAccess.xPathObject" Param1="DataTypeSupportCompleteAccess.ObjCnt">{0}[{1}]/Flags/SdoAccess</SetVariable>
			</TestStep>
			<TestStep Name="GetObjectException">
				<GetXmlValue ReturnValue="DataTypeSupportCompleteAccess.tmpStr" Markup="false" FileName="DataTypeSupportCompleteAccess.xmlFile">
					<XPath Param0="DataTypeSupportCompleteAccess.tmpStr">{0}</XPath>
				</GetXmlValue>
				<Compare>
					<Equal>
						<Value1>DataTypeSupportCompleteAccess.tmpStr</Value1>
						<Value2>"CompleteAccess"</Value2>
						<SetVariable Target="DataTypeSupportCompleteAccess.boolCaSupport">true</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DataTypeSupportCompleteAccess.tmpStr</Value1>
						<Value2>"CompleteAccess"</Value2>
						<GotoStep>END</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DataTypeSupportCompleteAccess.tmpStr</Value1>
						<Value2>"SubIndexAccess"</Value2>
						<SetVariable Target="DataTypeSupportCompleteAccess.boolCaSupport">false</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="ObjLoopEnd">
				<SetVariable Target="DataTypeSupportCompleteAccess.ObjCnt">DataTypeSupportCompleteAccess.ObjCnt + 1</SetVariable>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>ObjLoopStart</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="END">
				<WriteLine Id="0" Level="Verbose" Param0="DataTypeSupportCompleteAccess.boolCaSupport" Param1="DataTypeSupportCompleteAccess.strDtName">Complete access for data type {1} : {0}</WriteLine>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="1101" Name="DiagnosisHistory">
			<?MAX_OUTPUT_ID 18?>
			<Description>
				<PreCondition>Mailbox CoE support and DiagnosisHistory</PreCondition>
				<Action>1. SDO Read of object 0x10F3:4 to check if a new message is available
2. SDO Read of object 0x10F3:0 to get the current max subindex
3. SDO Read of object 0x10F3: 2 to get the newest message index x
4. SDO Read of object 0x10F3 indices from x to max subindex to get the message(s)
5. SDO Write of max subindex to 0x10F3:3 to acknowlede the message(s) 
6. Display message(s)</Action>
				<PostCondition>1. If value of 0x10F3:4 is 0 skip case. No abort code allowed
2. DuT shal response the max subindex. No abort code allowed
3. DuT shall response the newest message index. No abort code allowed. Error if value of 0x10F3:2 is lower than 6.
4. Dut shall response one message per subindex. No abort codes allowed.
5. AcknowledeMode = DuT shall acknowlede the read messages. OverwriteMode = DuT can ignore writing if 0x10F3:3.
6. The structure of the messages apply to the ETG 1020 (Diagnosis Message)</PostCondition>
				<References>
					<Reference Chapter="Diagnosis Handling" Specification="ETG 1020"></Reference>
				</References>
			</Description>
			<LocalVariables>
				<Name>DiagnosisHistory.Si0</Name>
				<Type>Byte</Type>
				<Comment>Current max subIndex</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>DiagnosisHistory.NewMsgAvailable</Name>
				<Type>Bool</Type>
				<Comment>Value of 0x10F3:4</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>DiagnosisHistory.CurrentSi</Name>
				<Type>Byte</Type>
				<Comment>Value of the current message index</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>DiagnosisHistory.NewestMsgIdx</Name>
				<Type>Byte</Type>
				<Comment>Value of the newest message index</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>DiagnosisHistory.MessageData</Name>
				<Type>ArrayOfBytes</Type>
				<Comment>Data of the message</Comment>
			</LocalVariables>
			<LocalVariables>
				<Name>DiagnosisHistory.AbortMessage</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>DiagnosisHistory.AbortCode</Name>
				<Type>UInt32</Type>
			</LocalVariables>
			<TestStep Name="Upload0x10F3SI4">
				<UploadCoEObject>
					<Index>#x10F3</Index>
					<SubIndex>4</SubIndex>
					<DataVar>DiagnosisHistory.NewMsgAvailable</DataVar>
					<AbortCode>DiagnosisHistory.AbortCode</AbortCode>
					<AbortMessage>DiagnosisHistory.AbortMessage</AbortMessage>
				</UploadCoEObject>
				<WriteLine Id="0" Level="Verbose" Param0="DiagnosisHistory.NewMsgAvailable">Test Function 'DiagnosisHistory': 0x10F3:4 New message available: {0}</WriteLine>
				<Compare>
					<NotEqual>
						<Value1>DiagnosisHistory.AbortMessage</Value1>
						<Value2>EmptyString</Value2>
						<RaiseError Id="1" Param0="DiagnosisHistory.AbortMessage">TestFunction 'DiagnosisHistory': 0x10F3:4 SDO upload failed: {0}</RaiseError>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>DiagnosisHistory.AbortCode</Value1>
						<Value2>0</Value2>
						<RaiseError Id="2" Param0="DiagnosisHistory.AbortCode">TestFunction 'DiagnosisHistory': 0x10F3:4 SDO upload failed: AbortCode 0x{0:X}</RaiseError>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DiagnosisHistory.NewMsgAvailable</Value1>
						<Value2>false</Value2>
						<Return Id="3">Testfunction 'DiagnosisHistory': No message available</Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="Upload0x10F3SI0">
				<UploadCoEObject>
					<Index>#x10F3</Index>
					<SubIndex>0</SubIndex>
					<DataVar>DiagnosisHistory.Si0</DataVar>
					<AbortCode>DiagnosisHistory.AbortCode</AbortCode>
					<AbortMessage>DiagnosisHistory.AbortMessage</AbortMessage>
				</UploadCoEObject>
				<WriteLine Id="4" Level="Verbose" Param0="DiagnosisHistory.Si0">Test Function 'DiagnosisHistory': 0x10F3:0 max subindex: {0}</WriteLine>
				<Compare>
					<NotEqual>
						<Value1>DiagnosisHistory.AbortMessage</Value1>
						<Value2>EmptyString</Value2>
						<RaiseError Id="5" Param0="DiagnosisHistory.AbortMessage">TestFunction 'DiagnosisHistory': 0x10F3:4 SDO upload failed: {0}</RaiseError>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>DiagnosisHistory.AbortCode</Value1>
						<Value2>0</Value2>
						<RaiseError Id="6" Param0="DiagnosisHistory.AbortCode">TestFunction 'DiagnosisHistory': 0x10F3:4 SDO upload failed: AbortCode 0x{0:X}</RaiseError>
					</NotEqual>
				</Compare>
				<Compare>
					<Lower>
						<Value1>DiagnosisHistory.Si0</Value1>
						<Value2>6</Value2>
						<RaiseError Id="7" Param0="DiagnosisHistory.Si0">TestFunction 'DiagnosisHistory': 0x10F3: 0 Max subindex can not be lower than 6 if a new message is available. Uploaded value: {0}</RaiseError>
					</Lower>
				</Compare>
			</TestStep>
			<TestStep Name="Upload0x10F3SI2">
				<UploadCoEObject>
					<Index>#x10F3</Index>
					<SubIndex>2</SubIndex>
					<DataVar>DiagnosisHistory.NewestMsgIdx</DataVar>
					<AbortCode>DiagnosisHistory.AbortCode</AbortCode>
					<AbortMessage>DiagnosisHistory.AbortMessage</AbortMessage>
				</UploadCoEObject>
				<WriteLine Id="8" Level="Verbose" Param0="DiagnosisHistory.NewestMsgIdx">Test Function 'DiagnosisHistory': 0x10F3:2 Newest Message Index: {0}</WriteLine>
				<Compare>
					<NotEqual>
						<Value1>DiagnosisHistory.AbortMessage</Value1>
						<Value2>EmptyString</Value2>
						<RaiseError Id="9" Param0="DiagnosisHistory.AbortMessage">TestFunction 'DiagnosisHistory': 0x10F3:4 SDO upload failed: {0}</RaiseError>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>DiagnosisHistory.AbortCode</Value1>
						<Value2>0</Value2>
						<RaiseError Id="10" Param0="DiagnosisHistory.AbortCode">TestFunction 'DiagnosisHistory': 0x10F3:4 SDO upload failed: AbortCode 0x{0:X}</RaiseError>
					</NotEqual>
				</Compare>
				<Compare>
					<Lower>
						<Value1>DiagnosisHistory.NewestMsgIdx</Value1>
						<Value2>6</Value2>
						<RaiseError Id="11" Param0="DiagnosisHistory.NewestMsgIdx">TestFunction 'DiagnosisHistory': 0x10F3:2 Newest index can not be lower than 6 if a new message is available. Uploaded value: {0}</RaiseError>
					</Lower>
				</Compare>
				<Compare>
					<Greater>
						<Value1>DiagnosisHistory.NewestMsgIdx</Value1>
						<Value2>DiagnosisHistory.Si0</Value2>
						<RaiseError Id="12" Param0="DiagnosisHistory.NewestMsgIdx" Param1="DiagnosisHistory.Si0">TestFunction 'DiagnosisHistory': 0x10F3: 2 Newest index {0} can not be greater than the max subindex {1}.</RaiseError>
					</Greater>
				</Compare>
			</TestStep>
			<TestStep Name="SetCurrentIndex">
				<SetVariable Target="DiagnosisHistory.CurrentSi">6</SetVariable>
			</TestStep>
			<TestStep Name="Upload0x10F3SIx">
				<UploadCoEObject>
					<Index>#x10F3</Index>
					<SubIndex>DiagnosisHistory.CurrentSi</SubIndex>
					<DataVar>DiagnosisHistory.MessageData</DataVar>
					<AbortCode>DiagnosisHistory.AbortCode</AbortCode>
					<AbortMessage>DiagnosisHistory.AbortMessage</AbortMessage>
				</UploadCoEObject>
				<WriteLine Id="13" Level="Output" Param0="DiagnosisHistory.CurrentSi" Param1="DiagnosisHistory.MessageData">Test Function 'DiagnosisHistory': 0x10F3:{0:X} Message : {1}</WriteLine>
				<Compare>
					<NotEqual>
						<Value1>DiagnosisHistory.AbortMessage</Value1>
						<Value2>EmptyString</Value2>
						<RaiseError Id="14" Param0="DiagnosisHistory.AbortMessage" Param1="DiagnosisHistory.CurrentSi">TestFunction 'DiagnosisHistory': 0x10F3:{1:X} SDO upload failed: {0}</RaiseError>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>DiagnosisHistory.AbortCode</Value1>
						<Value2>0</Value2>
						<RaiseError Id="15" Param0="DiagnosisHistory.AbortCode" Param1="DiagnosisHistory.CurrentSi">TestFunction 'DiagnosisHistory': 0x10F3:{1:X} SDO upload failed: AbortCode 0x{0:X}</RaiseError>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="IncrementCurrentIndex">
				<SetVariable Target="DiagnosisHistory.CurrentSi">DiagnosisHistory.CurrentSi+1</SetVariable>
			</TestStep>
			<TestStep Name="MoreFollows">
				<Compare>
					<LowerOrEqual>
						<Value1>DiagnosisHistory.CurrentSi</Value1>
						<Value2>DiagnosisHistory.NewestMsgIdx</Value2>
						<GotoStep>Upload0x10F3SIx</GotoStep>
					</LowerOrEqual>
				</Compare>
			</TestStep>
			<TestStep Name="ClearObject">
				<DownloadCoEObject>
					<Index>#x10F3</Index>
					<SubIndex>3</SubIndex>
					<DataVar>DiagnosisHistory.NewestMsgIdx</DataVar>
					<AbortCode>DiagnosisHistory.AbortCode</AbortCode>
					<AbortMessage>DiagnosisHistory.AbortMessage</AbortMessage>
				</DownloadCoEObject>
				<WriteLine Id="16" Level="Verbose">Test Function 'DiagnosisHistory': Diagnosis History object cleared</WriteLine>
				<Compare>
					<NotEqual>
						<Value1>DiagnosisHistory.AbortMessage</Value1>
						<Value2>EmptyString</Value2>
						<RaiseError Id="17" Param0="DiagnosisHistory.AbortMessage" Param1="DiagnosisHistory.NewestMsgIdx">TestFunction 'DiagnosisHistory': 0x10F3:3 SDO downloading '0x{1:X2}' failed: {0}</RaiseError>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>DiagnosisHistory.AbortCode</Value1>
						<Value2>0</Value2>
						<RaiseError Id="18" Param0="DiagnosisHistory.AbortCode" Param1="DiagnosisHistory.NewestMsgIdx">TestFunction 'DiagnosisHistory': 0x10F3:3 SDO downloading '0x{1:X2}' failed: AbortCode 0x{0:X}</RaiseError>
					</NotEqual>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="1201" Name="GetBackToInitTimeout">
			<?MAX_OUTPUT_ID 1?>
			<Description>
				<Purpose>Gets the back to INIT timeout.</Purpose>
				<PreCondition>-none</PreCondition>
				<Action>-sets the BackToInitTimeout of the ESI file to the variable at OutParameter
-if not available a default value of 5000ms is returned</Action>
				<PostCondition></PostCondition>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<OutParameter>
				<Name>f_int32BackToInitTimeout</Name>
				<Type>Int32</Type>
			</OutParameter>
			<TestStep Name="DefaultValue">
				<SetVariable Target="f_int32BackToInitTimeout">5000</SetVariable>
			</TestStep>
			<TestStep Name="CheckForEsiValue">
				<!--Timeouts in ESI?-->
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Info</Value1>
						<Value2>false</Value2>
						<Return Id="0"></Return>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Info.StateMachine.Timeout</Value1>
						<Value2>false</Value2>
						<Return Id="1"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="ESIValue">
				<!--Op/SafeOp->Init
SafeOp->Preop-->
				<SetVariable Target="f_int32BackToInitTimeout">DeviceDescr.Info.StateMachine.Timeout.BackToInitTimeout </SetVariable>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="1202" Name="GetCurrentPdLength">
			<?MAX_OUTPUT_ID 3?>
			<Description>
				<Purpose>Set the slave to SafeOP and get the length of all output process data</Purpose>
				<PreCondition>-none</PreCondition>
				<Action></Action>
				<PostCondition></PostCondition>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>GetCurrentPdLength.Type</Name>
				<Type>String</Type>
			</Parameter>
			<LocalVariables>
				<Name>GetCurrentPdLength.PsTimeout</Name>
				<Type>Int32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>GetCurrentPdLength.SmLoopCnt</Name>
				<Type>UInt16</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>GetCurrentPdLength.SmEnabled</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>GetCurrentPdLength.TmpData</Name>
				<Type>Byte</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>GetCurrentPdLength.SmLengthAddr</Name>
				<Type>UInt16</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>GetCurrentPdLength.SmLengthValue</Name>
				<Type>UInt16</Type>
			</LocalVariables>
			<OutParameter>
				<Name>GetCurrentPdLength.PdLength</Name>
				<Type>Int32</Type>
			</OutParameter>
			<TestStep Name="InitLength">
				<SetVariable Target="GetCurrentPdLength.PdLength">-1</SetVariable>
			</TestStep>
			<TestStep Name="Reset">
				<CallTestFunction Name="Reset"></CallTestFunction>
			</TestStep>
			<TestStep Name="RunToSafeOP">
				<CallTestFunction Name="GetSafeOpOpTimeout">
					<OutParameter>GetCurrentPdLength.PsTimeout</OutParameter>
				</CallTestFunction>
			</TestStep>
			<TestStep>
				<RunToState Timeout="GetCurrentPdLength.PsTimeout">
					<State>SAFEOP</State>
				</RunToState>
			</TestStep>
			<TestStep Name="INIT_LOOP_COUNTER">
				<SetVariable Target="GetCurrentPdLength.SmLoopCnt">0</SetVariable>
			</TestStep>
			<TestStep Name="LOOP_START">
				<Compare>
					<GreaterOrEqual>
						<Value1>GetCurrentPdLength.SmLoopCnt</Value1>
						<Value2>DeviceDescr.SM.Count</Value2>
						<Return Id="0" Param0="GetCurrentPdLength.PdLength" Param1="GetCurrentPdLength.Type">Process data type '{1}' length : '{0}'</Return>
					</GreaterOrEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>DeviceDescr.SM[GetCurrentPdLength.SmLoopCnt]</Value1>
						<Value2>GetCurrentPdLength.Type</Value2>
						<WriteLine Id="1" Level="Verbose" Param0="GetCurrentPdLength.SmLoopCnt" Param1="DeviceDescr.SM[GetCurrentPdLength.SmLoopCnt]">SM[{0}].Type '{1}' (skipped)</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>DeviceDescr.SM[GetCurrentPdLength.SmLoopCnt]</Value1>
						<Value2>GetCurrentPdLength.Type</Value2>
						<GotoStep>LOOP_END</GotoStep>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="SetSmxActivatehAddr">
				<SetVariable Target="GetCurrentPdLength.SmLengthAddr">#x806 + (GetCurrentPdLength.SmLoopCnt * 8)</SetVariable>
			</TestStep>
			<TestStep>
				<ReadEscData Target="GetCurrentPdLength.TmpData">
					<Address>GetCurrentPdLength.SmLengthAddr</Address>
				</ReadEscData>
			</TestStep>
			<TestStep>
				<GetBits Target="GetCurrentPdLength.SmEnabled" Source="GetCurrentPdLength.TmpData">
					<Offset>0</Offset>
					<Length>1</Length>
				</GetBits>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="2" Level="Verbose" Param0="GetCurrentPdLength.SmLoopCnt" Param1="GetCurrentPdLength.SmEnabled">SM[{0}].Enable '{1}'</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>GetCurrentPdLength.SmEnabled</Value1>
						<Value2>false</Value2>
						<GotoStep>LOOP_END</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="SetSmxLengthAddr">
				<SetVariable Target="GetCurrentPdLength.SmLengthAddr">#x802 + (GetCurrentPdLength.SmLoopCnt * 8)</SetVariable>
			</TestStep>
			<TestStep>
				<ReadEscData Target="GetCurrentPdLength.SmLengthValue">
					<Address>GetCurrentPdLength.SmLengthAddr</Address>
				</ReadEscData>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="3" Level="Verbose" Param0="GetCurrentPdLength.SmLoopCnt" Param1="GetCurrentPdLength.SmLengthValue">SM[{0}].Length '{1}'</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>GetCurrentPdLength.PdLength</Value1>
						<Value2>-1</Value2>
						<SetVariable Target="GetCurrentPdLength.PdLength">0</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<SetVariable Target="GetCurrentPdLength.PdLength">GetCurrentPdLength.PdLength + GetCurrentPdLength.SmLengthValue</SetVariable>
			</TestStep>
			<TestStep Name="LOOP_END">
				<SetVariable Target="GetCurrentPdLength.SmLoopCnt">GetCurrentPdLength.SmLoopCnt + 1</SetVariable>
				<Compare>
					<Equal>
						<Value1>TRUE</Value1>
						<Value2>TRUE</Value2>
						<GotoStep>LOOP_START</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="1203" Name="GetDeviceEmulationFlags">
			<?MAX_OUTPUT_ID 4?>
			<Description>
				<Purpose>Get the device emulation bit</Purpose>
				<PreCondition>-none</PreCondition>
				<Action>If the Patrameter is true the value will be read out from the ESC otherwise it will be read out from the ESI file</Action>
				<PostCondition></PostCondition>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>GetDeviceEmulationFlags.bOnline</Name>
				<Type>Bool</Type>
				<Comment>if true the device emulation will be read out from the ESC
if false the value will be read out from the ESI file</Comment>
			</Parameter>
			<LocalVariables>
				<Name>GetDeviceEmulationFlags.TmpByte</Name>
				<Type>Byte</Type>
			</LocalVariables>
			<OutParameter>
				<Name>GetDeviceEmulationFlags.bDeviceEmulation</Name>
				<Type>Bool</Type>
			</OutParameter>
			<TestStep Name="InitReturnValue">
				<SetVariable Target="GetDeviceEmulationFlags.bDeviceEmulation">false</SetVariable>
			</TestStep>
			<TestStep Name="HandleParameter">
				<Compare>
					<Equal>
						<Value1>GetDeviceEmulationFlags.bOnline</Value1>
						<Value2>false</Value2>
						<GotoStep>CheckEepromElement</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="ReadFromEsc">
				<!--Get 0x0141-->
				<ReadEscData Target="GetDeviceEmulationFlags.TmpByte">
					<Address>#x141</Address>
				</ReadEscData>
				<RaiseErrorOnFailure Id="0">GetDeviceEmulationFlags | Failed to read register!</RaiseErrorOnFailure>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>GetBit</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CheckEepromElement">
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Eeprom</Value1>
						<Value2>false</Value2>
						<GotoStep>ReadFromMailbox</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="ReadFromEepromConfigData">
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Eeprom.ConfigData</Value1>
						<Value2>null</Value2>
						<GotoStep>ReadFromEepromData</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<GetArrayItem Index="1" SourceArray="DeviceDescr.Eeprom.ConfigData" Target="GetDeviceEmulationFlags.TmpByte"></GetArrayItem>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>GetBit</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="ReadFromEepromData">
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Eeprom.Data</Value1>
						<Value2>null</Value2>
						<RaiseError Id="1">GetDeviceEmulationFlags | Failed to get device emulation bit from ESI (EEPROM.ConfigData and EEPROM.Data not defined).</RaiseError>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<GetArrayItem Index="1" SourceArray="DeviceDescr.Eeprom.Data" Target="GetDeviceEmulationFlags.TmpByte"></GetArrayItem>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>GetBit</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="GetBit">
				<Description Id="2" Param0="GetDeviceEmulationFlags.TmpByte" Level="Verbose">GetDeviceEmulationFlags | Reg 0x141/ESI.EEPROM value 0x{0}.</Description>
				<GetBits Source="GetDeviceEmulationFlags.TmpByte" Target="GetDeviceEmulationFlags.bDeviceEmulation">
					<Offset>0</Offset>
					<Length>1</Length>
				</GetBits>
				<RaiseErrorOnFailure Id="3">GetDeviceEmulationFlags | Failed to get device emulation bit.</RaiseErrorOnFailure>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<Return Id="4"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="ReadFromMailbox">
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Mailbox</Value1>
						<Value2>false</Value2>
						<SetVariable Target="GetDeviceEmulationFlags.bDeviceEmulation">true</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="1204" Name="GetDutModuleIdents">
			<?MAX_OUTPUT_ID 2?>
			<Description>
				<Purpose>Get the list of possible DuT modules</Purpose>
				<PreCondition>-none</PreCondition>
				<Action></Action>
				<PostCondition></PostCondition>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<LocalVariables>
				<Name>GetCurrentPdLength.PsTimeout</Name>
				<Type>Int32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>GetCurrentPdLength.SlotCnt</Name>
				<Type>Int32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>GetCurrentPdLength.ModuleIdentCnt</Name>
				<Type>Int32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>GetCurrentPdLength.IdentValue</Name>
				<Type>Int32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>GetCurrentPdLength.XmlValue</Name>
				<Type>String</Type>
			</LocalVariables>
			<OutParameter>
				<Name>GetDutModuleIdents.IdentList</Name>
				<Type>ArrayOfInt32</Type>
			</OutParameter>
			<TestStep Name="InitList">
				<InitArray TargetArray="GetDutModuleIdents.IdentList" Length="0"></InitArray>
			</TestStep>
			<TestStep Name="InitSlotCnt">
				<SetVariable Target="GetCurrentPdLength.SlotCnt">1</SetVariable>
			</TestStep>
			<TestStep Name="SlotLoopStart">
				<GetXmlValue ReturnValue="GetCurrentPdLength.XmlValue" Markup="false">
					<XPath Param0="GetCurrentPdLength.SlotCnt" Param1="GetCurrentPdLength.ModuleIdentCnt">Slots/Slot[{0}]</XPath>
				</GetXmlValue>
				<Compare>
					<Equal>
						<Value1>GetCurrentPdLength.XmlValue</Value1>
						<Value2>EmptyString</Value2>
						<Return Id="0"></Return>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>GetCurrentPdLength.XmlValue</Value1>
						<Value2>null</Value2>
						<Return Id="1"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="InitModuleIdentCnt">
				<SetVariable Target="GetCurrentPdLength.ModuleIdentCnt">1</SetVariable>
			</TestStep>
			<TestStep Name="ModuleIdentLoopStart">
				<GetXmlValue ReturnValue="GetCurrentPdLength.XmlValue" Markup="false">
					<XPath Param0="GetCurrentPdLength.SlotCnt" Param1="GetCurrentPdLength.ModuleIdentCnt">Slots/Slot[{0}]/ModuleIdent[{1}]</XPath>
				</GetXmlValue>
				<Compare>
					<Equal>
						<Value1>GetCurrentPdLength.XmlValue</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>SlotLoopEnd</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>GetCurrentPdLength.XmlValue</Value1>
						<Value2>null</Value2>
						<GotoStep>SlotLoopEnd</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="DumpModuleInfo"></TestStep>
			<TestStep>
				<GetXmlValue ReturnValue="GetCurrentPdLength.IdentValue" Markup="false">
					<XPath Param0="GetCurrentPdLength.SlotCnt" Param1="GetCurrentPdLength.ModuleIdentCnt">Slots/Slot[{0}]/ModuleIdent[{1}]</XPath>
				</GetXmlValue>
				<WriteLine Id="2" Level="Verbose" Param0="GetCurrentPdLength.SlotCnt" Param1="GetCurrentPdLength.ModuleIdentCnt" Param2="GetCurrentPdLength.IdentValue">Slots/Slot[{0}]/ModuleIdent[{1}] : {2} (0x{2:X})</WriteLine>
			</TestStep>
			<TestStep>
				<AddArrayItem TargetArray="GetDutModuleIdents.IdentList">GetCurrentPdLength.IdentValue</AddArrayItem>
			</TestStep>
			<TestStep Name="ModuleIdentLoopEnd">
				<SetVariable Target="GetCurrentPdLength.ModuleIdentCnt">GetCurrentPdLength.ModuleIdentCnt + 1</SetVariable>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>ModuleIdentLoopStart</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="SlotLoopEnd">
				<SetVariable Target="GetCurrentPdLength.SlotCnt">GetCurrentPdLength.SlotCnt + 1</SetVariable>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>SlotLoopStart</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="1205" Name="GetPreOpTimeout">
			<?MAX_OUTPUT_ID 2?>
			<Description>
				<Purpose>Gets the timeout for IP and IB</Purpose>
				<PreCondition>-none</PreCondition>
				<Action>-sets the PreOpTimeout of the ESI file to the variable at OutParameter
-if not available a default value of 3000ms is returned</Action>
				<PostCondition></PostCondition>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<OutParameter>
				<Name>f_int32GetPreOpTimeout</Name>
				<Type>Int32</Type>
			</OutParameter>
			<TestStep Name="DefaultValue">
				<SetVariable Target="f_int32GetPreOpTimeout">3000</SetVariable>
			</TestStep>
			<TestStep Name="CheckForEsiValue">
				<!--Timeouts in ESI?-->
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Info</Value1>
						<Value2>false</Value2>
						<Return Id="0"></Return>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Info.StateMachine.Timeout</Value1>
						<Value2>false</Value2>
						<Return Id="1"></Return>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Info.StateMachine.Timeout.PreopTimeout</Value1>
						<Value2>null</Value2>
						<Return Id="2"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="ESIValue">
				<!--Init->PreOP
Init->Boot-->
				<SetVariable Target="f_int32GetPreOpTimeout">DeviceDescr.Info.StateMachine.Timeout.PreopTimeout</SetVariable>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="1206" Name="GetSafeOpOpTimeout">
			<?MAX_OUTPUT_ID 2?>
			<Description>
				<Purpose>Gets the timeout for SO and PS</Purpose>
				<PreCondition>-none</PreCondition>
				<Action>-sets the SafeOpOpTimeout of the ESI file to the variable at OutParameter
-if not available a default value of 10000ms is returned</Action>
				<PostCondition></PostCondition>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<OutParameter>
				<Name>f_int32GetSafeOpOpTimeout</Name>
				<Type>Int32</Type>
			</OutParameter>
			<TestStep Name="DefaultValue">
				<SetVariable Target="f_int32GetSafeOpOpTimeout">10000</SetVariable>
			</TestStep>
			<TestStep Name="CheckForEsiValue">
				<!--Timeouts in ESI?-->
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Info</Value1>
						<Value2>false</Value2>
						<Return Id="0"></Return>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Info.StateMachine.Timeout</Value1>
						<Value2>false</Value2>
						<Return Id="1"></Return>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Info.StateMachine.Timeout.SafeopOpTimeout</Value1>
						<Value2>null</Value2>
						<Return Id="2"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="ESIValue">
				<!--PreOp->SafeOp
SafeOp->Op-->
				<SetVariable Target="f_int32GetSafeOpOpTimeout">DeviceDescr.Info.StateMachine.Timeout.SafeopOpTimeout</SetVariable>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="1301" Name="Int32.Compare">
			<?MAX_OUTPUT_ID 1?>
			<Description>
				<Purpose>Compare two Int32 Variables</Purpose>
				<PreCondition></PreCondition>
				<Action>if the reference variable is null the comparision is abort (without an error text).
else both variables are compared</Action>
				<PostCondition>return values if variables mismatch. If variables are equal the return value is empty</PostCondition>
				<ProposalForSolution>true</ProposalForSolution>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>Int32.Compare.RefInt32</Name>
				<Type>Int32</Type>
				<Comment>reference Int32</Comment>
			</Parameter>
			<Parameter>
				<Name>Int32.Compare.CmpInt32</Name>
				<Type>Int32</Type>
				<Comment>Int32 to compare</Comment>
			</Parameter>
			<Parameter>
				<Name>Int32.Compare.InfoText</Name>
				<Type>String</Type>
				<Comment>additional Info text which will be the first part of the error message</Comment>
			</Parameter>
			<OutParameter>
				<Name>Int32.Compare.ErrorText</Name>
				<Type>String</Type>
			</OutParameter>
			<TestStep Name="InitResult">
				<SetVariable Target="Int32.Compare.ErrorText">EmptyString</SetVariable>
			</TestStep>
			<TestStep Name="CheckIfReferenceIsNull">
				<Compare>
					<Equal>
						<Value1>Int32.Compare.RefInt32</Value1>
						<Value2>null</Value2>
						<Return Id="0"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="ReturnIfEqual">
				<Compare>
					<Equal>
						<Value1>Int32.Compare.RefInt32</Value1>
						<Value2>Int32.Compare.CmpInt32</Value2>
						<Return Id="1"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CreateMessage">
				<SetVariable Target="Int32.Compare.ErrorText" Param0="Int32.Compare.InfoText" Param1="Int32.Compare.CmpInt32" Param2="Int32.Compare.RefInt32">{0} '{1}' expected: '{2}'.</SetVariable>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="1401" Name="IsCommandObject">
			<?MAX_OUTPUT_ID 4?>
			<Description>
				<Purpose>Check if a specific object is a command object</Purpose>
				<PreCondition>The device shall support CoE</PreCondition>
				<Action>1. Try to get the Object code via SDO Info
2. check the object structure</Action>
				<PostCondition>1. if the object data type is 0x0025 return true
2. if no SDOInfo is supported check the object structure:
  SI1. 'Command' OCTED_STRING
  SI2. 'Statuc' UNSIGNED8
  SI3. 'Response' OCTED_STRING</PostCondition>
				<ProposalForSolution>true</ProposalForSolution>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>IsCommandObject.Index</Name>
				<Type>UInt16</Type>
				<Comment>Object to check</Comment>
			</Parameter>
			<LocalVariables>
				<Name>IsCommandObject.ObjDataType</Name>
				<Type>UInt16</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>IsCommandObject.OD</Name>
				<Type>ObjectDictionary</Type>
			</LocalVariables>
			<OutParameter>
				<Name>IsCommandObject.Result</Name>
				<Type>Bool</Type>
			</OutParameter>
			<TestStep Name="InitResult">
				<SetVariable Target="IsCommandObject.Result">false</SetVariable>
			</TestStep>
			<TestStep Name="CheckIfSdoInfoSupported">
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Mailbox.CoE.SdoInfo</Value1>
						<Value2>false</Value2>
						<GotoStep>HandleOffline</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="HandleOnline">
				<GetObjectDictionary Target="IsCommandObject.OD" ForceReload="false">
					<DictionaryType>Online</DictionaryType>
				</GetObjectDictionary>
			</TestStep>
			<TestStep Name="GetDataType">
				<GetObjectDescription Index="IsCommandObject.Index" SourceDictionary="IsCommandObject.OD" SubIndex="-1">
					<Type>IsCommandObject.ObjDataType</Type>
				</GetObjectDescription>
				<GotoOnFailure>HandleOffline</GotoOnFailure>
			</TestStep>
			<TestStep>
				<!--check if datatype 0x25 is defined-->
				<Compare>
					<Equal>
						<Value1>IsCommandObject.ObjDataType</Value1>
						<Value2>#x25</Value2>
						<SetVariable Target="IsCommandObject.Result">true</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>END</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="HandleOffline">
				<Description Id="0" Level="Verbose">IsCommandObject | check offline OD for command object structure</Description>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Dictionary</Value1>
						<Value2>false</Value2>
						<GotoStep>Failure</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="GetOfflineOD">
				<GetObjectDictionary Target="IsCommandObject.OD">
					<DictionaryType>Offline</DictionaryType>
				</GetObjectDictionary>
			</TestStep>
			<TestStep Name="GetDataTypeOfSI1">
				<GetObjectDescription Index="IsCommandObject.Index" SourceDictionary="IsCommandObject.OD" SubIndex="1">
					<Type>IsCommandObject.ObjDataType</Type>
				</GetObjectDescription>
				<GotoOnFailure>END</GotoOnFailure>
				<!--SI1 shall be an OCTED_STRING-->
				<Compare>
					<NotEqual>
						<Value1>IsCommandObject.ObjDataType</Value1>
						<Value2>#xA</Value2>
						<GotoStep>END</GotoStep>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="GetDataTypeOfSI2">
				<GetObjectDescription Index="IsCommandObject.Index" SourceDictionary="IsCommandObject.OD" SubIndex="2">
					<Type>IsCommandObject.ObjDataType</Type>
				</GetObjectDescription>
				<GotoOnFailure>END</GotoOnFailure>
				<!--SI2 shall be an UNSIGNED8-->
				<Compare>
					<NotEqual>
						<Value1>IsCommandObject.ObjDataType</Value1>
						<Value2>#x5</Value2>
						<GotoStep>END</GotoStep>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="GetDataTypeOfSI3">
				<GetObjectDescription Index="IsCommandObject.Index" SourceDictionary="IsCommandObject.OD" SubIndex="3">
					<Type>IsCommandObject.ObjDataType</Type>
				</GetObjectDescription>
				<GotoOnFailure>END</GotoOnFailure>
				<!--SI3 shall be an OCTED_STRING-->
				<Compare>
					<NotEqual>
						<Value1>IsCommandObject.ObjDataType</Value1>
						<Value2>#xA</Value2>
						<GotoStep>END</GotoStep>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep>
				<SetVariable Target="IsCommandObject.Result">true</SetVariable>
			</TestStep>
			<TestStep Name="END">
				<Compare>
					<Equal>
						<Value1>IsCommandObject.Result</Value1>
						<Value2>true</Value2>
						<WriteLine Id="1" Param0="IsCommandObject.Index" Level="Verbose">Object 0x{0:X4} is a command object.</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>IsCommandObject.Result</Value1>
						<Value2>false</Value2>
						<WriteLine Id="2" Param0="IsCommandObject.Index" Level="Verbose">Object 0x{0:X4} is no command object.</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<Return Id="3"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="Failure">
				<WriteLine Id="4" Param0="IsCommandObject.Index" Level="Warning">IsCommandObject | Failed to check if 0x{0:X4} is a command object (SdoInfo and no offline OD defined).</WriteLine>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="1402" Name="IsPdoMappingIndex">
			<?MAX_OUTPUT_ID 3?>
			<Description>
				<Purpose>Checks if an UInt16 valu is an Pdo mapping index (either RX or Tx PDO)</Purpose>
				<PreCondition></PreCondition>
				<Action>Check if UInt16 value is within 0x1600 to 0x17FF (RxPDO) or 0x1A00 to 0x1BFF (TxPDO)</Action>
				<PostCondition>return true if value is within specified ranges</PostCondition>
				<ProposalForSolution>true</ProposalForSolution>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>IsPdoMappingIndex.u16Value</Name>
				<Type>UInt16</Type>
				<Comment>UInnt16 value to check</Comment>
			</Parameter>
			<OutParameter>
				<Name>IsPdoMappingIndex.Result</Name>
				<Type>Bool</Type>
			</OutParameter>
			<TestStep Name="InitResult">
				<SetVariable Target="IsPdoMappingIndex.Result">false</SetVariable>
			</TestStep>
			<TestStep Name="CheckIfValueIsLess0x1600">
				<Compare>
					<Lower>
						<Value1>IsPdoMappingIndex.u16Value</Value1>
						<Value2>5632</Value2>
						<Return Id="0"></Return>
					</Lower>
				</Compare>
			</TestStep>
			<TestStep Name="CheckIfValueIsLessOrEqual0x17FF">
				<Compare>
					<LowerOrEqual>
						<Value1>IsPdoMappingIndex.u16Value</Value1>
						<Value2>6143</Value2>
						<SetVariable Target="IsPdoMappingIndex.Result">true</SetVariable>
					</LowerOrEqual>
				</Compare>
				<Compare>
					<LowerOrEqual>
						<Value1>IsPdoMappingIndex.u16Value</Value1>
						<Value2>6143</Value2>
						<Return Id="1"></Return>
					</LowerOrEqual>
				</Compare>
			</TestStep>
			<TestStep Name="CheckIfValueIsGreater0x1BFF">
				<Compare>
					<Greater>
						<Value1>IsPdoMappingIndex.u16Value</Value1>
						<Value2>7167</Value2>
						<Return Id="2"></Return>
					</Greater>
				</Compare>
			</TestStep>
			<TestStep Name="CheckIfValueIsGreaterOrEqual0xA00">
				<Compare>
					<GreaterOrEqual>
						<Value1>IsPdoMappingIndex.u16Value</Value1>
						<Value2>6656</Value2>
						<SetVariable Target="IsPdoMappingIndex.Result">true</SetVariable>
					</GreaterOrEqual>
				</Compare>
				<Compare>
					<GreaterOrEqual>
						<Value1>IsPdoMappingIndex.u16Value</Value1>
						<Value2>6656</Value2>
						<Return Id="3"></Return>
					</GreaterOrEqual>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="1403" Name="IsSimpleDevice">
			<?MAX_OUTPUT_ID 2?>
			<LocalVariables>
				<Name>IsSimpleDevice.uInt16Val</Name>
				<Type>UInt16</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>IsSimpleDevice.EepromByte</Name>
				<Type>Byte</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>IsSimpleDevice.ArrLen</Name>
				<Type>UInt32</Type>
			</LocalVariables>
			<OutParameter>
				<Name>IsSimpleDevice.DeviceEmulation</Name>
				<Type>Bool</Type>
			</OutParameter>
			<TestStep Name="INIT_RESULT">
				<SetVariable Target="IsSimpleDevice.DeviceEmulation">false</SetVariable>
			</TestStep>
			<TestStep Name="CheckSlavesOfflineState">
				<!--Check if slave is added offline.-->
				<Compare>
					<Equal>
						<Value1>Offline</Value1>
						<Value2>false</Value2>
						<GotoStep>ONLINE</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="OFFLINE">
				<!--Check if Data is defined-->
				<SizeOf UInt32Var="IsSimpleDevice.ArrLen">DeviceDescr.Eeprom.Data</SizeOf>
				<Compare>
					<Equal>
						<Value1>IsSimpleDevice.ArrLen</Value1>
						<Value2>0</Value2>
						<GotoStep>OFFLINE_CONFIGDATA</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Get Second Byte (includes values of register 0x141)-->
				<SetVariable Target="IsSimpleDevice.EepromByte">DeviceDescr.Eeprom.Data[1]</SetVariable>
			</TestStep>
			<TestStep>
				<GetBits Source="IsSimpleDevice.EepromByte" Target="IsSimpleDevice.DeviceEmulation">
					<Offset>0</Offset>
					<Length>1</Length>
				</GetBits>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>END</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="OFFLINE_CONFIGDATA">
				<!--Check if Data is defined-->
				<SizeOf UInt32Var="IsSimpleDevice.ArrLen">DeviceDescr.Eeprom.ConfigData</SizeOf>
				<Compare>
					<Equal>
						<Value1>IsSimpleDevice.ArrLen</Value1>
						<Value2>0</Value2>
						<WriteLine Id="0" Level="Verbose">DeviceDescr.EEPROM information missing.</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>IsSimpleDevice.ArrLen</Value1>
						<Value2>0</Value2>
						<GotoStep>END</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--Get Second Byte (includes values of register 0x141)-->
				<SetVariable Target="IsSimpleDevice.EepromByte">DeviceDescr.Eeprom.ConfigData[1]</SetVariable>
			</TestStep>
			<TestStep>
				<GetBits Source="IsSimpleDevice.EepromByte" Target="IsSimpleDevice.DeviceEmulation">
					<Offset>0</Offset>
					<Length>1</Length>
				</GetBits>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>END</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="ONLINE">
				<ReadEscData Target="IsSimpleDevice.uInt16Val">
					<Address>#x0140</Address>
				</ReadEscData>
				<RaiseErrorOnFailure Id="1">Failed to read register!</RaiseErrorOnFailure>
			</TestStep>
			<TestStep>
				<GetBits Source="IsSimpleDevice.uInt16Val" Target="IsSimpleDevice.DeviceEmulation">
					<Offset>8</Offset>
					<Length>1</Length>
				</GetBits>
			</TestStep>
			<TestStep Name="END">
				<WriteLine Id="2" Param0="IsSimpleDevice.DeviceEmulation" Level="Verbose">Device emulation (0x140:8) : {0}</WriteLine>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="1501" Name="ObjectCode.Compare">
			<?MAX_OUTPUT_ID 1?>
			<Description>
				<Purpose>CompareToObjectCodes</Purpose>
				<PreCondition></PreCondition>
				<Action>if the reference variable is null the comparision is abort (without an error text).
else both variables are compared</Action>
				<PostCondition>return values if variables mismatch. If variables are equal the return value is empty</PostCondition>
				<ProposalForSolution>true</ProposalForSolution>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>ObjectCode.Compare.RefCode</Name>
				<Type>Byte</Type>
				<Comment>reference ObjectCode</Comment>
			</Parameter>
			<Parameter>
				<Name>ObjectCode.Compare.CmpCode</Name>
				<Type>Byte</Type>
				<Comment>ObjectCode to compare</Comment>
			</Parameter>
			<Parameter>
				<Name>ObjectCode.Compare.InfoText</Name>
				<Type>String</Type>
				<Comment>additional Info text which will be the first part of the error message</Comment>
			</Parameter>
			<LocalVariables>
				<Name>ObjectCode.Compare.RefCodeStr</Name>
				<Type>String</Type>
				<DefaultValue>EmptyString</DefaultValue>
			</LocalVariables>
			<LocalVariables>
				<Name>ObjectCode.Compare.CmpCodeStr</Name>
				<Type>String</Type>
				<DefaultValue>EmptyString</DefaultValue>
			</LocalVariables>
			<OutParameter>
				<Name>ObjectCode.Compare.ErrorText</Name>
				<Type>String</Type>
			</OutParameter>
			<TestStep Name="InitResult">
				<SetVariable Target="ObjectCode.Compare.ErrorText">EmptyString</SetVariable>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<SetVariable Target="ObjectCode.Compare.RefCodeStr" Param0="ObjectCode.Compare.RefCode">{0}</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<SetVariable Target="ObjectCode.Compare.CmpCodeStr" Param0="ObjectCode.Compare.CmpCode">{0}</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CheckIfReferenceIsNull">
				<Compare>
					<Equal>
						<Value1>ObjectCode.Compare.RefCode</Value1>
						<Value2>null</Value2>
						<Return Id="0"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="ReturnIfEqual">
				<Compare>
					<Equal>
						<Value1>ObjectCode.Compare.RefCode</Value1>
						<Value2>ObjectCode.Compare.CmpCode</Value2>
						<Return Id="1"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<!--REF: Convert Byte Code to String-->
				<Compare>
					<Equal>
						<Value1>ObjectCode.Compare.RefCode</Value1>
						<Value2>7</Value2>
						<SetVariable Target="ObjectCode.Compare.RefCodeStr">VARIABLE</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>ObjectCode.Compare.RefCode</Value1>
						<Value2>8</Value2>
						<SetVariable Target="ObjectCode.Compare.RefCodeStr">ARRAY</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>ObjectCode.Compare.RefCode</Value1>
						<Value2>9</Value2>
						<SetVariable Target="ObjectCode.Compare.RefCodeStr">RECORD</SetVariable>
					</Equal>
				</Compare>
				<!--CMP: Convert Byte Code to String-->
				<Compare>
					<Equal>
						<Value1>ObjectCode.Compare.CmpCode</Value1>
						<Value2>7</Value2>
						<SetVariable Target="ObjectCode.Compare.CmpCodeStr">VARIABLE</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>ObjectCode.Compare.CmpCode</Value1>
						<Value2>8</Value2>
						<SetVariable Target="ObjectCode.Compare.CmpCodeStr">ARRAY</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>ObjectCode.Compare.CmpCode</Value1>
						<Value2>9</Value2>
						<SetVariable Target="ObjectCode.Compare.CmpCodeStr">RECORD</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CreateMessage">
				<SetVariable Target="ObjectCode.Compare.ErrorText" Param0="ObjectCode.Compare.InfoText" Param1="ObjectCode.Compare.CmpCodeStr" Param2="ObjectCode.Compare.RefCodeStr">{0} '{1}' expected: '{2}'.</SetVariable>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="1502" Name="ObjectSupportCompleteAccess">
			<?MAX_OUTPUT_ID 0?>
			<Description>
				<Purpose>Checks if Complete Access is supported for a specific object</Purpose>
				<PreCondition>-none</PreCondition>
				<Action>-checks the default SDO access and the exception in the object element</Action>
				<PostCondition></PostCondition>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>ObjectSupportCompleteAccess.u16Index</Name>
				<Type>UInt16</Type>
				<Comment>Object (if 0 the generic SDO access is returned)</Comment>
			</Parameter>
			<LocalVariables>
				<Name>ObjectSupportCompleteAccess.xmlFile</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>ObjectSupportCompleteAccess.tmpStr</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>ObjectSupportCompleteAccess.ObjName</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>ObjectSupportCompleteAccess.xPathObject</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>ObjectSupportCompleteAccess.Od</Name>
				<Type>ObjectDictionary</Type>
			</LocalVariables>
			<OutParameter>
				<Name>ObjectSupportCompleteAccess.boolCaSupport</Name>
				<Type>Bool</Type>
			</OutParameter>
			<TestStep Name="SetDefaultValue">
				<SetVariable Target="ObjectSupportCompleteAccess.boolCaSupport">false</SetVariable>
			</TestStep>
			<TestStep Name="GetDefaultAccess">
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Mailbox</Value1>
						<Value2>false</Value2>
						<GotoStep>GetObjectAccess</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Mailbox.CoE</Value1>
						<Value2>false</Value2>
						<GotoStep>GetObjectAccess</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Mailbox.CoE.CompleteAccess</Value1>
						<Value2>false</Value2>
						<GotoStep>GetObjectAccess</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Mailbox.CoE.CompleteAccess</Value1>
						<Value2>true</Value2>
						<SetVariable Target="ObjectSupportCompleteAccess.boolCaSupport">true</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="GetObjectAccess">
				<SetVariable Target="ObjectSupportCompleteAccess.xPathObject">EmptyString</SetVariable>
				<Compare>
					<Equal>
						<Value1>ObjectSupportCompleteAccess.u16Index</Value1>
						<Value2>0</Value2>
						<GotoStep>END</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="GetInternalOd">
				<GetXmlValue ReturnValue="ObjectSupportCompleteAccess.tmpStr" Markup="false">
					<XPath>Profile[position()=1]/Dictionary/Objects/Object</XPath>
				</GetXmlValue>
				<Compare>
					<NotEqual>
						<Value1>ObjectSupportCompleteAccess.tmpStr</Value1>
						<Value2>null</Value2>
						<SetVariable Target="ObjectSupportCompleteAccess.xPathObject">Profile[position()=1]/Dictionary/Objects/Object</SetVariable>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep>
				<Compare>
					<NotEqual>
						<Value1>ObjectSupportCompleteAccess.tmpStr</Value1>
						<Value2>null</Value2>
						<GotoStep>CheckXPath</GotoStep>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="GetExternalOD">
				<GetXmlValue ReturnValue="ObjectSupportCompleteAccess.xmlFile" Markup="false">
					<XPath>Profile[position()=1]/DictionaryFile</XPath>
				</GetXmlValue>
				<Compare>
					<NotEqual>
						<Value1>ObjectSupportCompleteAccess.xmlFile</Value1>
						<Value2>null</Value2>
						<SetVariable Target="ObjectSupportCompleteAccess.xPathObject">/EtherCATDict/Dictionary/Objects/Object</SetVariable>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>ObjectSupportCompleteAccess.xmlFile</Value1>
						<Value2>null</Value2>
						<SetVariable Target="DataTypeSupportCompleteAccess.xmlFile">EmptyString</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CheckXPath">
				<Compare>
					<Equal>
						<Value1>ObjectSupportCompleteAccess.xPathObject</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>END</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="GetOfflineOd">
				<GetObjectDictionary Target="ObjectSupportCompleteAccess.Od">
					<DictionaryType>Offline</DictionaryType>
				</GetObjectDictionary>
			</TestStep>
			<TestStep Name="GetObjName">
				<GetObjectDescription SourceDictionary="ObjectSupportCompleteAccess.Od" Index="ObjectSupportCompleteAccess.u16Index" SubIndex="-1">
					<Name>ObjectSupportCompleteAccess.ObjName</Name>
				</GetObjectDescription>
				<Compare>
					<Equal>
						<Value1>ObjectSupportCompleteAccess.ObjName</Value1>
						<Value2>null</Value2>
						<GotoStep>END</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>ObjectSupportCompleteAccess.ObjName</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>END</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CreateXPath">
				<SetVariable Target="ObjectSupportCompleteAccess.xPathObject" Param0="ObjectSupportCompleteAccess.xPathObject" Param1="ObjectSupportCompleteAccess.ObjName">{0}[Name='{1}']/Flags/SdoAccess</SetVariable>
			</TestStep>
			<TestStep Name="GetObjectException">
				<GetXmlValue ReturnValue="ObjectSupportCompleteAccess.tmpStr" Markup="false" FileName="ObjectSupportCompleteAccess.xmlFile">
					<XPath Param0="ObjectSupportCompleteAccess.xPathObject">{0}</XPath>
				</GetXmlValue>
				<Compare>
					<Equal>
						<Value1>ObjectSupportCompleteAccess.tmpStr</Value1>
						<Value2>"CompleteAccess"</Value2>
						<SetVariable Target="ObjectSupportCompleteAccess.boolCaSupport">true</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>ObjectSupportCompleteAccess.tmpStr</Value1>
						<Value2>"SubIndexAccess"</Value2>
						<SetVariable Target="ObjectSupportCompleteAccess.boolCaSupport">false</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="END">
				<WriteLine Id="0" Level="Verbose" Param0="ObjectSupportCompleteAccess.boolCaSupport" Param1="ObjectSupportCompleteAccess.u16Index">Complete access for object 0x{1:X} : {0}</WriteLine>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="1601" Name="Reset">
			<?MAX_OUTPUT_ID 6?>
			<Description>
				<Purpose>Should be called to reset the DuT</Purpose>
				<PreCondition>-none</PreCondition>
				<Action>- Check if the AL Status Code Register is supported
- Set DuT to Init 
- acknowledge error (for devcies with device emulation activated ErrorAck = 0)
- Clear SyncManager registers
- Clear FMMU register
- Clear AssigneActivate registers (0x0981:0x0981 to 0) when registers available</Action>
				<PostCondition></PostCondition>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<LocalVariables>
				<Name>Reset_Int32_BackToInitTimeout</Name>
				<Type>Int32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>Reset_Byte_EscType</Name>
				<Type>Byte</Type>
			</LocalVariables>
			<TestStep Name="CheckSlavesOfflineState">
				<Compare>
					<Equal>
						<Value1>Offline</Value1>
						<Value2>true</Value2>
						<SkipCase Id="0">Test Function Reset: DuT is not connected to CTT. Test is skipped. | Online test required!</SkipCase>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CheckIf134SupportedByEsc">
				<ReadEscData Target="Reset_Byte_EscType">
					<Address>#x0000</Address>
				</ReadEscData>
				<RaiseErrorOnFailure Id="1">Test Function 'Reset': Failed to read ESC Type from register 0x0000</RaiseErrorOnFailure>
				<Compare>
					<Equal>
						<Value1>Reset_Byte_EscType</Value1>
						<Value2>#x1</Value2>
						<RaiseWarning Id="2" Param0="Reset_Byte_EscType">ESC does not support the AL Status Code register 0x0134 | Info: ESC Type read from register 0x00000 = 0x{0}</RaiseWarning>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="SetConfiguredAddress">
				<WriteEscData Source="EcatAddress">
					<Address>#x10</Address>
				</WriteEscData>
				<RaiseErrorOnFailure Id="3">Test Function 'Reset': Failed to write set the configured address (register 0x10)</RaiseErrorOnFailure>
			</TestStep>
			<TestStep Name="GetBackToInitTimeout">
				<Description Id="4">Set ESM BackToInit timeout: If available use value from ESI, otherwise set default value</Description>
				<CallTestFunction Name="GetBackToInitTimeout">
					<OutParameter>Reset_Int32_BackToInitTimeout</OutParameter>
				</CallTestFunction>
			</TestStep>
			<TestStep Name="RunToInit">
				<RunToState Timeout="Reset_Int32_BackToInitTimeout">
					<State>INIT</State>
				</RunToState>
				<RaiseErrorOnFailure Id="5">Test Function 'Reset': Failed to go to Init!</RaiseErrorOnFailure>
			</TestStep>
			<TestStep Name="DONE">
				<WriteLine Id="6" Level="Verbose">FUNCTION | Test Function 'Reset' done.</WriteLine>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="1701" Name="String.Compare">
			<?MAX_OUTPUT_ID 1?>
			<Description>
				<Purpose>Compare two String Variables (case sensitive)</Purpose>
				<PreCondition></PreCondition>
				<Action>if the reference variable is null the comparision is abort (without an error text).
else both variables are compared</Action>
				<PostCondition>return values if variables mismatch. If variables are equal the return value is empty</PostCondition>
				<ProposalForSolution>true</ProposalForSolution>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>String.Compare.RefString</Name>
				<Type>String</Type>
				<Comment>reference string</Comment>
			</Parameter>
			<Parameter>
				<Name>String.Compare.CmpString</Name>
				<Type>String</Type>
				<Comment>string to compare</Comment>
			</Parameter>
			<Parameter>
				<Name>String.Compare.InfoText</Name>
				<Type>String</Type>
				<Comment>additional Info text which will be the first part of the error message</Comment>
			</Parameter>
			<OutParameter>
				<Name>String.Compare.ErrorText</Name>
				<Type>String</Type>
			</OutParameter>
			<TestStep Name="InitResult">
				<SetVariable Target="String.Compare.ErrorText">EmptyString</SetVariable>
			</TestStep>
			<TestStep Name="CheckIfRefStringIsNull">
				<Compare>
					<Equal>
						<Value1>String.Compare.RefString</Value1>
						<Value2>null</Value2>
						<Return Id="0"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="ReturnIfEqual">
				<Compare>
					<Equal>
						<Value1>String.Compare.RefString</Value1>
						<Value2>String.Compare.CmpString</Value2>
						<Return Id="1"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CreateMessage">
				<SetVariable Target="String.Compare.ErrorText" Param0="String.Compare.InfoText" Param1="String.Compare.CmpString" Param2="String.Compare.RefString">{0} '{1}' expected: '{2}'.</SetVariable>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="1702" Name="String.CompareCaseInsensitive">
			<?MAX_OUTPUT_ID 1?>
			<Description>
				<Purpose>Compare two String Variables (case insensitive)</Purpose>
				<PreCondition></PreCondition>
				<Action>if the reference variable is null the comparision is abort (without an error text).
else both variables are compared</Action>
				<PostCondition>return values if variables mismatch. If variables are equal the return value is empty</PostCondition>
				<ProposalForSolution>true</ProposalForSolution>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>String.CompareCaseInsensitive.RefString</Name>
				<Type>String</Type>
				<Comment>reference string</Comment>
			</Parameter>
			<Parameter>
				<Name>String.CompareCaseInsensitive.CmpString</Name>
				<Type>String</Type>
				<Comment>string to compare</Comment>
			</Parameter>
			<Parameter>
				<Name>String.CompareCaseInsensitive.InfoText</Name>
				<Type>String</Type>
				<Comment>additional Info text which will be the first part of the error message</Comment>
			</Parameter>
			<LocalVariables>
				<Name>String.CompareCaseInsensitive.bIsMatch</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<OutParameter>
				<Name>String.CompareCaseInsensitive.ErrorText</Name>
				<Type>String</Type>
			</OutParameter>
			<TestStep Name="InitResult">
				<SetVariable Target="String.CompareCaseInsensitive.ErrorText">EmptyString</SetVariable>
			</TestStep>
			<TestStep Name="CheckIfRefStringIsNull">
				<Compare>
					<Equal>
						<Value1>String.CompareCaseInsensitive.RefString</Value1>
						<Value2>null</Value2>
						<Return Id="0"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="ReturnIfEqual">
				<RegexIsMatch ReturnValue="String.CompareCaseInsensitive.bIsMatch" Options="IgnoreCase">
					<Pattern>String.CompareCaseInsensitive.RefString</Pattern>
					<InputString>String.CompareCaseInsensitive.CmpString</InputString>
				</RegexIsMatch>
				<Compare>
					<Equal>
						<Value1>String.CompareCaseInsensitive.bIsMatch</Value1>
						<Value2>true</Value2>
						<Return Id="1"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CreateMessage">
				<SetVariable Target="String.CompareCaseInsensitive.ErrorText" Param0="String.CompareCaseInsensitive.InfoText" Param1="String.CompareCaseInsensitive.CmpString" Param2="String.CompareCaseInsensitive.RefString">{0} '{1}' expected: '{2}'.</SetVariable>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="1703" Name="String.ConvertToByteArray">
			<?MAX_OUTPUT_ID 0?>
			<Parameter>
				<Name>String.ConvertToByteArray.InputString</Name>
				<Type>String</Type>
			</Parameter>
			<Parameter>
				<Name>String.ConvertToByteArray.breverse</Name>
				<Type>Bool</Type>
			</Parameter>
			<LocalVariables>
				<Name>String.ConvertToByteArray.ArrayStringsSplit</Name>
				<Type>ArrayOfString</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>String.ConvertToByteArray.bytePart</Name>
				<Type>Byte</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>String.ConvertToByteArray.uint32StringLength</Name>
				<Type>UInt32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>String.ConvertToByteArray.uint16CurrGetIndex</Name>
				<Type>UInt16</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>String.ConvertToByteArray.uint16CurrSetIndex</Name>
				<Type>UInt16</Type>
			</LocalVariables>
			<OutParameter>
				<Name>String.ConvertToByteArray.ArrayBytesResult</Name>
				<Type>ArrayOfBytes</Type>
			</OutParameter>
			<TestStep Name="IsNullorEmptyString">
				<Compare>
					<Equal>
						<Value1>String.ConvertToByteArray.InputString</Value1>
						<Value2>null</Value2>
						<GotoStep>HandleNullorEmptyString</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>String.ConvertToByteArray.InputString</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>HandleNullorEmptyString</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="GetStringLength">
				<SizeOf UInt32Var="String.ConvertToByteArray.uint32StringLength">String.ConvertToByteArray.InputString</SizeOf>
			</TestStep>
			<TestStep Name="InitReturnArray">
				<InitArray Length="String.ConvertToByteArray.uint32StringLength" TargetArray="String.ConvertToByteArray.ArrayBytesResult"></InitArray>
			</TestStep>
			<TestStep Name="CalcStringBitLength">
				<!--Each Char uses 16Bit memory-->
				<SetVariable Target="String.ConvertToByteArray.uint32StringLength">String.ConvertToByteArray.uint32StringLength * 16</SetVariable>
			</TestStep>
			<TestStep Name="GetArrayStartIndex">
				<Compare>
					<Equal>
						<Value1>String.ConvertToByteArray.breverse</Value1>
						<Value2>true</Value2>
						<SetVariable Target="String.ConvertToByteArray.uint16CurrSetIndex">String.ConvertToByteArray.uint32StringLength - 1</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>String.ConvertToByteArray.breverse</Value1>
						<Value2>false</Value2>
						<SetVariable Target="String.ConvertToByteArray.uint16CurrSetIndex">0</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="InitStartOffset">
				<SetVariable Target="String.ConvertToByteArray.uint16CurrGetIndex">0</SetVariable>
			</TestStep>
			<TestStep Name="GetChar">
				<GetBits Source="String.ConvertToByteArray.InputString" Target="String.ConvertToByteArray.bytePart">
					<Offset>String.ConvertToByteArray.uint16CurrGetIndex</Offset>
					<Length>8</Length>
				</GetBits>
			</TestStep>
			<TestStep Name="AddCharToByteArray">
				<SetArrayItem Index="String.ConvertToByteArray.uint16CurrSetIndex" TargetArray="String.ConvertToByteArray.ArrayBytesResult">String.ConvertToByteArray.bytePart</SetArrayItem>
			</TestStep>
			<TestStep Name="CalcNextSetIndex">
				<Compare>
					<Equal>
						<Value1>String.ConvertToByteArray.breverse</Value1>
						<Value2>true</Value2>
						<SetVariable Target="String.ConvertToByteArray.uint16CurrSetIndex">String.ConvertToByteArray.uint16CurrSetIndex - 1</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>String.ConvertToByteArray.breverse</Value1>
						<Value2>false</Value2>
						<SetVariable Target="String.ConvertToByteArray.uint16CurrSetIndex">String.ConvertToByteArray.uint16CurrSetIndex + 1</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CalcNextGetIndex">
				<SetVariable Target="String.ConvertToByteArray.uint16CurrGetIndex">String.ConvertToByteArray.uint16CurrGetIndex + 16</SetVariable>
			</TestStep>
			<TestStep Name="NextCycle">
				<Compare>
					<Lower>
						<Value1>String.ConvertToByteArray.uint16CurrGetIndex</Value1>
						<Value2>String.ConvertToByteArray.uint32StringLength</Value2>
						<GotoStep>GetChar</GotoStep>
					</Lower>
				</Compare>
			</TestStep>
			<TestStep Name="Exit">
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<Return Id="0"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="HandleNullorEmptyString">
				<InitArray Length="1" TargetArray="String.ConvertToByteArray.ArrayBytesResult"></InitArray>
			</TestStep>
			<TestStep>
				<SetArrayItem TargetArray="String.ConvertToByteArray.ArrayBytesResult" Index="0">#x00</SetArrayItem>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="1801" Name="UInt16.Compare">
			<?MAX_OUTPUT_ID 1?>
			<Description>
				<Purpose>Compare two UInt16 Variables</Purpose>
				<PreCondition></PreCondition>
				<Action>if the reference variable is null the comparision is abort (without an error text).
else both variables are compared</Action>
				<PostCondition>return values if variables mismatch. If variables are equal the return value is empty</PostCondition>
				<ProposalForSolution>true</ProposalForSolution>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>UInt16.Compare.RefUInt16</Name>
				<Type>UInt16</Type>
				<Comment>reference UInt16</Comment>
			</Parameter>
			<Parameter>
				<Name>UInt16.Compare.CmpUInt16</Name>
				<Type>UInt16</Type>
				<Comment>UInt16 to compare</Comment>
			</Parameter>
			<Parameter>
				<Name>UInt16.Compare.InfoText</Name>
				<Type>String</Type>
				<Comment>additional Info text which will be the first part of the error message</Comment>
			</Parameter>
			<OutParameter>
				<Name>UInt16.Compare.ErrorText</Name>
				<Type>String</Type>
			</OutParameter>
			<TestStep Name="InitResult">
				<SetVariable Target="UInt16.Compare.ErrorText">EmptyString</SetVariable>
			</TestStep>
			<TestStep Name="CheckIfReferenceIsNull">
				<Compare>
					<Equal>
						<Value1>UInt16.Compare.RefUInt16</Value1>
						<Value2>null</Value2>
						<Return Id="0"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="ReturnIfEqual">
				<Compare>
					<Equal>
						<Value1>UInt16.Compare.RefUInt16</Value1>
						<Value2>UInt16.Compare.CmpUInt16</Value2>
						<Return Id="1"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CreateMessage">
				<SetVariable Target="UInt16.Compare.ErrorText" Param0="UInt16.Compare.InfoText" Param1="UInt16.Compare.CmpUInt16" Param2="UInt16.Compare.RefUInt16">{0} '{1}' expected: '{2}'.</SetVariable>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="1902" Name="VerifyEntryDescription">
			<?MAX_OUTPUT_ID 71?>
			<Description>
				<Purpose>OBSOLETE : use 'CheckEntryDescription' instead
Compares the passed values against the passed object description of the passed dictionary</Purpose>
				<PreCondition></PreCondition>
				<Action>-gets the entry description of the passed index and subindex
-comares the values against the passed values</Action>
				<PostCondition>Throws an error if one of the values does not match to the expected value</PostCondition>
				<ProposalForSolution>true</ProposalForSolution>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>VerifyEntryDescription.ObjectDictionary</Name>
				<Type>ObjectDictionary</Type>
				<Comment>object dictionary to searach for specified object.entry(by index and SubIndex)</Comment>
			</Parameter>
			<Parameter>
				<Name>VerifyEntryDescription.DictionaryType</Name>
				<Type>String</Type>
			</Parameter>
			<Parameter>
				<Name>VerifyEntryDescription.Index</Name>
				<Type>UInt16</Type>
			</Parameter>
			<Parameter>
				<Name>VerifyEntryDescription.SubIndex</Name>
				<Type>UInt16</Type>
			</Parameter>
			<Parameter>
				<Name>VerifyEntryDescription.LevelWarning</Name>
				<Type>Bool</Type>
				<Comment>If true raise warnign instead of errors</Comment>
			</Parameter>
			<Parameter>
				<Name>VerifyEntryDescription.CaseSensitive</Name>
				<Type>Bool</Type>
				<Comment>If true name ist checked case sensitive</Comment>
			</Parameter>
			<Parameter>
				<Name>VerifyEntryDescription.Expected.Name</Name>
				<Type>String</Type>
			</Parameter>
			<Parameter>
				<Name>VerifyEntryDescription.Expected.Type</Name>
				<Type>UInt16</Type>
				<Comment>if 0xFFFF the test will be skipped</Comment>
			</Parameter>
			<Parameter>
				<Name>VerifyEntryDescription.Expected.Access.ReadInPreOp</Name>
				<Type>Int16</Type>
				<Comment>If -1 test will be skipped</Comment>
			</Parameter>
			<Parameter>
				<Name>VerifyEntryDescription.Expected.Access.ReadInSafeOp</Name>
				<Type>Int16</Type>
				<Comment>If -1 test will be skipped</Comment>
			</Parameter>
			<Parameter>
				<Name>VerifyEntryDescription.Expected.Access.ReadInOp</Name>
				<Type>Int16</Type>
				<Comment>If -1 test will be skipped</Comment>
			</Parameter>
			<Parameter>
				<Name>VerifyEntryDescription.Expected.Access.WriteInPreOp</Name>
				<Type>Int16</Type>
				<Comment>If -1 test will be skipped</Comment>
			</Parameter>
			<Parameter>
				<Name>VerifyEntryDescription.Expected.Access.WriteInSafeOp</Name>
				<Type>Int16</Type>
				<Comment>If -1 test will be skipped</Comment>
			</Parameter>
			<Parameter>
				<Name>VerifyEntryDescription.Expected.Access.WriteInOp</Name>
				<Type>Int16</Type>
				<Comment>If -1 test will be skipped</Comment>
			</Parameter>
			<Parameter>
				<Name>VerifyEntryDescription.Expected.Category</Name>
				<Type>String</Type>
			</Parameter>
			<Parameter>
				<Name>VerifyEntryDescription.Expected.PdoMapping</Name>
				<Type>String</Type>
			</Parameter>
			<Parameter>
				<Name>VerifyEntryDescription.Expected.DefaultData</Name>
				<Type>ArrayOfBytes</Type>
			</Parameter>
			<Parameter>
				<Name>VerifyEntryDescription.Expected.MinData</Name>
				<Type>ArrayOfBytes</Type>
			</Parameter>
			<Parameter>
				<Name>VerifyEntryDescription.Expected.MaxData</Name>
				<Type>ArrayOfBytes</Type>
			</Parameter>
			<Parameter>
				<Name>VerifyEntryDescription.Expected.Settings</Name>
				<Type>Int16</Type>
				<Comment>If -1 test will be skipped</Comment>
			</Parameter>
			<Parameter>
				<Name>VerifyEntryDescription.Expected.Backup</Name>
				<Type>Int16</Type>
				<Comment>If -1 test will be skipped</Comment>
			</Parameter>
			<Parameter>
				<Name>VerifyEntryDescription.Expected.BitSize</Name>
				<Type>Int32</Type>
			</Parameter>
			<Parameter>
				<Name>VerifyEntryDescription.Expected.BitOffs</Name>
				<Type>Int32</Type>
			</Parameter>
			<Parameter>
				<Name>VerifyEntryDescription.AllowEnumDataType</Name>
				<Type>Bool</Type>
				<Comment>If true the data type to check may also be an enum data type</Comment>
			</Parameter>
			<LocalVariables>
				<Name>VerifyEntryDescription.bTmpVar</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>VerifyEntryDescription.Current.Access.ReadInOp</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>VerifyEntryDescription.Current.Access.ReadInPreOp</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>VerifyEntryDescription.Current.Access.ReadInSafeOp</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>VerifyEntryDescription.Current.Access.WriteInOp</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>VerifyEntryDescription.Current.Access.WriteInPreOp</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>VerifyEntryDescription.Current.Access.WriteInSafeOp</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>VerifyEntryDescription.Current.Backup</Name>
				<Type>Int16</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>VerifyEntryDescription.Current.BitOffs</Name>
				<Type>Int32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>VerifyEntryDescription.Current.BitSize</Name>
				<Type>Int32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>VerifyEntryDescription.Current.Category</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>VerifyEntryDescription.Current.DefaultData</Name>
				<Type>ArrayOfBytes</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>VerifyEntryDescription.Current.DataCount</Name>
				<Type>UInt32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>VerifyEntryDescription.Current.MaxData</Name>
				<Type>ArrayOfBytes</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>VerifyEntryDescription.Current.MinData</Name>
				<Type>ArrayOfBytes</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>VerifyEntryDescription.Current.Name</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>VerifyEntryDescription.Current.PdoMapping</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>VerifyEntryDescription.Current.Settings</Name>
				<Type>Int16</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>VerifyEntryDescription.Current.Type</Name>
				<Type>UInt16</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>VerifyEntryDescription.ErrorMsg</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>VerifyEntryDescription.Expected.DataCount</Name>
				<Type>Int32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>VerifyEntryDescription.int32InsensitiveCompareResult</Name>
				<Type>Int32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>VerifyEntryDescription.ReloadDescrSdoInfo</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<OutParameter>
				<Name>VerifyEntryDescription.ErrorList</Name>
				<Type>ArrayOfString</Type>
			</OutParameter>
			<TestStep Name="CheckForMailboxCoE">
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Mailbox</Value1>
						<Value2>false</Value2>
						<SkipCase Id="0">Device does not support mailbox communication</SkipCase>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Mailbox.CoE</Value1>
						<Value2>false</Value2>
						<SkipCase Id="1">Device does not support CoE</SkipCase>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="InitReloadFlag">
				<SetVariable Target="VerifyEntryDescription.ReloadDescrSdoInfo">false</SetVariable>
			</TestStep>
			<TestStep Name="GetOdType">
				<RegexIsMatch ReturnValue="VerifyEntryDescription.bTmpVar" Options="IgnoreCase">
					<Pattern>^online.*</Pattern>
					<InputString>VerifyEntryDescription.DictionaryType</InputString>
				</RegexIsMatch>
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.bTmpVar</Value1>
						<Value2>false</Value2>
						<GotoStep>GetObjectDescription</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CheckProfile">
				<!--Load Description via SDO Info for 5001.3100 or 5001.3101-->
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Profile.Count</Value1>
						<Value2>0</Value2>
						<GotoStep>GetObjectDescription</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>DeviceDescr.Profile[0].ProfileNo</Value1>
						<Value2>5001</Value2>
						<GotoStep>GetObjectDescription</GotoStep>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Profile[0].AddInfo</Value1>
						<Value2>3100</Value2>
						<SetVariable Target="VerifyEntryDescription.ReloadDescrSdoInfo">true</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Profile[0].AddInfo</Value1>
						<Value2>3101</Value2>
						<SetVariable Target="VerifyEntryDescription.ReloadDescrSdoInfo">true</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="GetObjectDescription">
				<Description Id="2" Param0="VerifyEntryDescription.Index" Param1="VerifyEntryDescription.SubIndex" Level="Verbose">VerifyEntryDescription | 0x{0:X4}:{1}</Description>
				<GetObjectDescription Index="VerifyEntryDescription.Index" SourceDictionary="VerifyEntryDescription.ObjectDictionary" SubIndex="VerifyEntryDescription.SubIndex" SDOInfoReload="VerifyEntryDescription.ReloadDescrSdoInfo">
					<Name>VerifyEntryDescription.Current.Name</Name>
					<Type>VerifyEntryDescription.Current.Type</Type>
					<BitSize>VerifyEntryDescription.Current.BitSize</BitSize>
					<BitOffs>VerifyEntryDescription.Current.BitOffs</BitOffs>
					<DefaultData>VerifyEntryDescription.Current.DefaultData</DefaultData>
					<MinData>VerifyEntryDescription.Current.MinData</MinData>
					<MaxData>VerifyEntryDescription.Current.MaxData</MaxData>
					<Flags>
						<Access Backup="VerifyEntryDescription.Current.Backup" ReadInOP="VerifyEntryDescription.Current.Access.ReadInOp" ReadInPreop="VerifyEntryDescription.Current.Access.ReadInPreOp" ReadInSafeOP="VerifyEntryDescription.Current.Access.ReadInSafeOp" WriteinOP="VerifyEntryDescription.Current.Access.WriteInOp" WriteInPreOp="VerifyEntryDescription.Current.Access.WriteInPreOp" WriteInSafeOp="VerifyEntryDescription.Current.Access.WriteInSafeOp" Settings="VerifyEntryDescription.Current.Settings"></Access>
						<Category>VerifyEntryDescription.Current.Category</Category>
						<PdoMapping>VerifyEntryDescription.Current.PdoMapping</PdoMapping>
					</Flags>
				</GetObjectDescription>
				<GotoOnSuccess>CheckBitSize</GotoOnSuccess>
			</TestStep>
			<TestStep Name="EntryNotFound">
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<SetVariable Target="VerifyEntryDescription.ErrorMsg" Param0="VerifyEntryDescription.Index" Param1="VerifyEntryDescription.SubIndex" Param2="VerifyEntryDescription.DictionaryType">{2}: Failed to get entry description of 0x{0:X4}:{1}</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<RaiseWarning Id="3" Param0="VerifyEntryDescription.ErrorMsg">{0}</RaiseWarning>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>VerifyEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<CallTestFunction Name="AddMsgToList">
							<Parameter>VerifyEntryDescription.ErrorMsg</Parameter>
							<OutParameter>VerifyEntryDescription.ErrorList</OutParameter>
						</CallTestFunction>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<Return Id="4"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CheckBitSize">
				<!--Create Message-->
				<SetVariable Target="VerifyEntryDescription.ErrorMsg" Param0="VerifyEntryDescription.Index" Param1="VerifyEntryDescription.SubIndex" Param2="VerifyEntryDescription.DictionaryType">{2}: 0x{0:X4}:{1}.BitSize</SetVariable>
				<!--Skip if BitSize is -1-->
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.Expected.BitSize</Value1>
						<Value2>-1</Value2>
						<WriteLine Id="5" Level="Verbose">VerifyEntryDescription | Skip compare 'BitSize'</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.Expected.BitSize</Value1>
						<Value2>-1</Value2>
						<GotoStep>CheckBitOffs</GotoStep>
					</Equal>
				</Compare>
				<!--Run Compare-->
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="6" Level="Verbose" Param0="VerifyEntryDescription.Expected.BitSize" Param1="VerifyEntryDescription.Current.BitSize">VerifyEntryDescription | Compare 'BitSize' expected ({0}) / current ({1})</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<CallTestFunction Name="Int32.Compare">
							<Parameter>VerifyEntryDescription.Expected.BitSize</Parameter>
							<Parameter>VerifyEntryDescription.Current.BitSize</Parameter>
							<Parameter>VerifyEntryDescription.ErrorMsg</Parameter>
							<OutParameter>VerifyEntryDescription.ErrorMsg</OutParameter>
						</CallTestFunction>
					</Equal>
				</Compare>
				<!--Handle Compare Result-->
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.ErrorMsg</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>CheckBitOffs</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<RaiseWarning Id="7" Param0="VerifyEntryDescription.ErrorMsg">{0}</RaiseWarning>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>VerifyEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<CallTestFunction Name="AddMsgToList">
							<Parameter>VerifyEntryDescription.ErrorMsg</Parameter>
							<OutParameter>VerifyEntryDescription.ErrorList</OutParameter>
						</CallTestFunction>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="CheckBitOffs">
				<!--Create Message-->
				<SetVariable Target="VerifyEntryDescription.ErrorMsg" Param0="VerifyEntryDescription.Index" Param1="VerifyEntryDescription.SubIndex" Param2="VerifyEntryDescription.DictionaryType">{2}: 0x{0:X4}:{1}.BitOffs</SetVariable>
				<!--Skip Compare if the reference bitoffset is -1-->
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.Expected.BitOffs</Value1>
						<Value2>-1</Value2>
						<WriteLine Id="8" Level="Verbose">VerifyEntryDescription | Skip compare 'BitOffset'</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.Expected.BitOffs</Value1>
						<Value2>-1</Value2>
						<GotoStep>CompareName</GotoStep>
					</Equal>
				</Compare>
				<!--Run Compare-->
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="9" Level="Verbose" Param0="VerifyEntryDescription.Expected.BitOffs" Param1="VerifyEntryDescription.Current.BitOffs">VerifyEntryDescription | Compare 'BitOffs' expected ({0}) / current ({1})</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<CallTestFunction Name="Int32.Compare">
							<Parameter>VerifyEntryDescription.Expected.BitOffs</Parameter>
							<Parameter>VerifyEntryDescription.Current.BitOffs</Parameter>
							<Parameter>VerifyEntryDescription.ErrorMsg</Parameter>
							<OutParameter>VerifyEntryDescription.ErrorMsg</OutParameter>
						</CallTestFunction>
					</Equal>
				</Compare>
				<!--Handle Compare Result-->
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.ErrorMsg</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>CompareName</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<RaiseWarning Id="10" Param0="VerifyEntryDescription.ErrorMsg">{0}</RaiseWarning>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>VerifyEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<CallTestFunction Name="AddMsgToList">
							<Parameter>VerifyEntryDescription.ErrorMsg</Parameter>
							<OutParameter>VerifyEntryDescription.ErrorList</OutParameter>
						</CallTestFunction>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="CompareName">
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.Expected.Name</Value1>
						<Value2>null</Value2>
						<GotoStep>Compare_ReadInPreOP</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.Expected.Name</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>Compare_ReadInPreOP</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.Current.Name</Value1>
						<Value2>null</Value2>
						<GotoStep>Compare_ReadInPreOP</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.Current.Name</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>Compare_ReadInPreOP</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="11" Level="Verbose" Param0="VerifyEntryDescription.Expected.Name" Param1="VerifyEntryDescription.Current.Name" Param2="VerifyEntryDescription.CaseSensitive">VerifyEntryDescription | Compare 'Name' expected ({0}) / current ({1}) / case sens. {2}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>VerifyEntryDescription.CaseSensitive</Value1>
						<Value2>true</Value2>
						<GotoStep>Compare_Name_Insensitive</GotoStep>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>VerifyEntryDescription.Current.Name</Value1>
						<Value2>VerifyEntryDescription.Expected.Name</Value2>
						<WriteLine Id="12" Level="Warning" Param0="VerifyEntryDescription.Current.Name" Param1="VerifyEntryDescription.Expected.Name" Param2="VerifyEntryDescription.Index" Param3="VerifyEntryDescription.SubIndex">0x{2:X4}.{3} Unexpected name '{0}' expected: '{1}'</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>Compare_ReadInPreOP</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="Compare_Name_Insensitive">
				<StringCompare ReturnValue="VerifyEntryDescription.int32InsensitiveCompareResult" Options="IgnoreCase">
					<String1>VerifyEntryDescription.Expected.Name</String1>
					<String2>VerifyEntryDescription.Current.Name</String2>
				</StringCompare>
				<Compare>
					<NotEqual>
						<Value1>VerifyEntryDescription.int32InsensitiveCompareResult</Value1>
						<Value2>0</Value2>
						<WriteLine Id="13" Level="Warning" Param0="VerifyEntryDescription.Current.Name" Param1="VerifyEntryDescription.Expected.Name" Param2="VerifyEntryDescription.Index" Param3="VerifyEntryDescription.SubIndex">0x{2:X4}.{3} Unexpected name '{0}' expected: '{1}'</WriteLine>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="Compare_ReadInPreOP">
				<!--Create Message-->
				<SetVariable Target="VerifyEntryDescription.ErrorMsg" Param0="VerifyEntryDescription.Index" Param1="VerifyEntryDescription.SubIndex" Param2="VerifyEntryDescription.DictionaryType">{2}: 0x{0:X4}:{1} read access in PreOP</SetVariable>
				<!--Skip compare if expected ReadInPreOP is -1-->
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.Expected.Access.ReadInPreOp</Value1>
						<Value2>-1</Value2>
						<WriteLine Id="14" Level="Verbose">VerifyEntryDescription | Skip compare 'ReadInPreOp'</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.Expected.Access.ReadInPreOp</Value1>
						<Value2>-1</Value2>
						<GotoStep>Compare_ReadInSafeOP</GotoStep>
					</Equal>
				</Compare>
				<!--Run Compare-->
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="15" Level="Verbose" Param0="VerifyEntryDescription.Expected.Access.ReadInPreOp" Param1="VerifyEntryDescription.Current.Access.ReadInPreOp">VerifyEntryDescription | Compare 'ReadInPreOp' expected ({0}) / current ({1})</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<CallTestFunction Name="Bool.Compare">
							<Parameter>VerifyEntryDescription.Expected.Access.ReadInPreOp</Parameter>
							<Parameter>VerifyEntryDescription.Current.Access.ReadInPreOp</Parameter>
							<Parameter>VerifyEntryDescription.ErrorMsg</Parameter>
							<OutParameter>VerifyEntryDescription.ErrorMsg</OutParameter>
						</CallTestFunction>
					</Equal>
				</Compare>
				<!--Handle Compare Result-->
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.ErrorMsg</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>Compare_ReadInSafeOP</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<RaiseWarning Id="16" Param0="VerifyEntryDescription.ErrorMsg">{0}</RaiseWarning>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>VerifyEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<CallTestFunction Name="AddMsgToList">
							<Parameter>VerifyEntryDescription.ErrorMsg</Parameter>
							<OutParameter>VerifyEntryDescription.ErrorList</OutParameter>
						</CallTestFunction>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="Compare_ReadInSafeOP">
				<!--Create Message-->
				<SetVariable Target="VerifyEntryDescription.ErrorMsg" Param0="VerifyEntryDescription.Index" Param1="VerifyEntryDescription.SubIndex" Param2="VerifyEntryDescription.DictionaryType">{2}: 0x{0:X4}:{1} read access in SafeOP</SetVariable>
				<!--Skip compare if expected ReadInSafeOP is -1-->
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.Expected.Access.ReadInSafeOp</Value1>
						<Value2>-1</Value2>
						<WriteLine Id="17" Level="Verbose">VerifyEntryDescription | Skip compare 'ReadInSafeOp'</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.Expected.Access.ReadInSafeOp</Value1>
						<Value2>-1</Value2>
						<GotoStep>Compare_ReadInOP</GotoStep>
					</Equal>
				</Compare>
				<!--Run Compare-->
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="18" Level="Verbose" Param0="VerifyEntryDescription.Expected.Access.ReadInSafeOp" Param1="VerifyEntryDescription.Current.Access.ReadInSafeOp">VerifyEntryDescription | Compare 'ReadInSafeOp' expected ({0}) / current ({1})</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<CallTestFunction Name="Bool.Compare">
							<Parameter>VerifyEntryDescription.Expected.Access.ReadInSafeOp</Parameter>
							<Parameter>VerifyEntryDescription.Current.Access.ReadInSafeOp</Parameter>
							<Parameter>VerifyEntryDescription.ErrorMsg</Parameter>
							<OutParameter>VerifyEntryDescription.ErrorMsg</OutParameter>
						</CallTestFunction>
					</Equal>
				</Compare>
				<!--Handle Compare Result-->
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.ErrorMsg</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>Compare_ReadInOP</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<RaiseWarning Id="19" Param0="VerifyEntryDescription.ErrorMsg">{0}</RaiseWarning>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>VerifyEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<CallTestFunction Name="AddMsgToList">
							<Parameter>VerifyEntryDescription.ErrorMsg</Parameter>
							<OutParameter>VerifyEntryDescription.ErrorList</OutParameter>
						</CallTestFunction>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="Compare_ReadInOP">
				<!--Create Message-->
				<SetVariable Target="VerifyEntryDescription.ErrorMsg" Param0="VerifyEntryDescription.Index" Param1="VerifyEntryDescription.SubIndex" Param2="VerifyEntryDescription.DictionaryType">{2}: 0x{0:X4}:{1} read access in OP</SetVariable>
				<!--Skip compare if expected ReadInOP is -1-->
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.Expected.Access.ReadInOp</Value1>
						<Value2>-1</Value2>
						<WriteLine Id="20" Level="Verbose">VerifyEntryDescription | Skip compare 'ReadInOp'</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.Expected.Access.ReadInOp</Value1>
						<Value2>-1</Value2>
						<GotoStep>Compare_WriteInPreOP</GotoStep>
					</Equal>
				</Compare>
				<!--Run Compare-->
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="21" Level="Verbose" Param0="VerifyEntryDescription.Expected.Access.ReadInOp" Param1="VerifyEntryDescription.Current.Access.ReadInOp">VerifyEntryDescription | Compare 'ReadInOp' expected ({0}) / current ({1})</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<CallTestFunction Name="Bool.Compare">
							<Parameter>VerifyEntryDescription.Expected.Access.ReadInOp</Parameter>
							<Parameter>VerifyEntryDescription.Current.Access.ReadInOp</Parameter>
							<Parameter>VerifyEntryDescription.ErrorMsg</Parameter>
							<OutParameter>VerifyEntryDescription.ErrorMsg</OutParameter>
						</CallTestFunction>
					</Equal>
				</Compare>
				<!--Handle Compare Result-->
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.ErrorMsg</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>Compare_WriteInPreOP</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<RaiseWarning Id="22" Param0="VerifyEntryDescription.ErrorMsg">{0}</RaiseWarning>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>VerifyEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<CallTestFunction Name="AddMsgToList">
							<Parameter>VerifyEntryDescription.ErrorMsg</Parameter>
							<OutParameter>VerifyEntryDescription.ErrorList</OutParameter>
						</CallTestFunction>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="Compare_WriteInPreOP">
				<!--Create Message-->
				<SetVariable Target="VerifyEntryDescription.ErrorMsg" Param0="VerifyEntryDescription.Index" Param1="VerifyEntryDescription.SubIndex" Param2="VerifyEntryDescription.DictionaryType">{2}: 0x{0:X4}:{1} Write access in PreOP</SetVariable>
				<!--Skip compare if expected WriteInPreOP is -1-->
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.Expected.Access.WriteInPreOp</Value1>
						<Value2>-1</Value2>
						<WriteLine Id="23" Level="Verbose">VerifyEntryDescription | Skip compare 'WriteInPreOp'</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.Expected.Access.WriteInPreOp</Value1>
						<Value2>-1</Value2>
						<GotoStep>Compare_WriteInSafeOP</GotoStep>
					</Equal>
				</Compare>
				<!--Run Compare-->
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="24" Level="Verbose" Param0="VerifyEntryDescription.Expected.Access.WriteInPreOp" Param1="VerifyEntryDescription.Current.Access.WriteInPreOp">VerifyEntryDescription | Compare 'WriteInPreOp' expected ({0}) / current ({1})</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<CallTestFunction Name="Bool.Compare">
							<Parameter>VerifyEntryDescription.Expected.Access.WriteInPreOp</Parameter>
							<Parameter>VerifyEntryDescription.Current.Access.WriteInPreOp</Parameter>
							<Parameter>VerifyEntryDescription.ErrorMsg</Parameter>
							<OutParameter>VerifyEntryDescription.ErrorMsg</OutParameter>
						</CallTestFunction>
					</Equal>
				</Compare>
				<!--Handle Compare Result-->
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.ErrorMsg</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>Compare_WriteInSafeOP</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<RaiseWarning Id="25" Param0="VerifyEntryDescription.ErrorMsg">{0}</RaiseWarning>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>VerifyEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<CallTestFunction Name="AddMsgToList">
							<Parameter>VerifyEntryDescription.ErrorMsg</Parameter>
							<OutParameter>VerifyEntryDescription.ErrorList</OutParameter>
						</CallTestFunction>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="Compare_WriteInSafeOP">
				<!--Create Message-->
				<SetVariable Target="VerifyEntryDescription.ErrorMsg" Param0="VerifyEntryDescription.Index" Param1="VerifyEntryDescription.SubIndex" Param2="VerifyEntryDescription.DictionaryType">{2}: 0x{0:X4}:{1} Write access in SafeOP</SetVariable>
				<!--Skip compare if expected WriteInSafeOP is -1-->
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.Expected.Access.WriteInSafeOp</Value1>
						<Value2>-1</Value2>
						<WriteLine Id="26" Level="Verbose">VerifyEntryDescription | Skip compare 'WriteInSafeOp'</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.Expected.Access.WriteInSafeOp</Value1>
						<Value2>-1</Value2>
						<GotoStep>Compare_WriteInOP</GotoStep>
					</Equal>
				</Compare>
				<!--Run Compare-->
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="27" Level="Verbose" Param0="VerifyEntryDescription.Expected.Access.WriteInSafeOp" Param1="VerifyEntryDescription.Current.Access.WriteInSafeOp">VerifyEntryDescription | Compare 'WriteInSafeOp' expected ({0}) / current ({1})</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<CallTestFunction Name="Bool.Compare">
							<Parameter>VerifyEntryDescription.Expected.Access.WriteInSafeOp</Parameter>
							<Parameter>VerifyEntryDescription.Current.Access.WriteInSafeOp</Parameter>
							<Parameter>VerifyEntryDescription.ErrorMsg</Parameter>
							<OutParameter>VerifyEntryDescription.ErrorMsg</OutParameter>
						</CallTestFunction>
					</Equal>
				</Compare>
				<!--Handle Compare Result-->
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.ErrorMsg</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>Compare_WriteInOP</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<RaiseWarning Id="28" Param0="VerifyEntryDescription.ErrorMsg">{0}</RaiseWarning>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>VerifyEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<CallTestFunction Name="AddMsgToList">
							<Parameter>VerifyEntryDescription.ErrorMsg</Parameter>
							<OutParameter>VerifyEntryDescription.ErrorList</OutParameter>
						</CallTestFunction>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="Compare_WriteInOP">
				<!--Create Message-->
				<SetVariable Target="VerifyEntryDescription.ErrorMsg" Param0="VerifyEntryDescription.Index" Param1="VerifyEntryDescription.SubIndex" Param2="VerifyEntryDescription.DictionaryType">{2}: 0x{0:X4}:{1} Write access in OP</SetVariable>
				<!--Skip compare if expected WriteInOP is -1-->
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.Expected.Access.WriteInOp</Value1>
						<Value2>-1</Value2>
						<WriteLine Id="29" Level="Verbose">VerifyEntryDescription | Skip compare 'WriteInOp'</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.Expected.Access.WriteInOp</Value1>
						<Value2>-1</Value2>
						<GotoStep>Compare_PdoMapping</GotoStep>
					</Equal>
				</Compare>
				<!--Run Compare-->
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="30" Level="Verbose" Param0="VerifyEntryDescription.Expected.Access.WriteInOp" Param1="VerifyEntryDescription.Current.Access.WriteInOp">VerifyEntryDescription | Compare 'WriteInOp' expected ({0}) / current ({1})</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<CallTestFunction Name="Bool.Compare">
							<Parameter>VerifyEntryDescription.Expected.Access.WriteInOp</Parameter>
							<Parameter>VerifyEntryDescription.Current.Access.WriteInOp</Parameter>
							<Parameter>VerifyEntryDescription.ErrorMsg</Parameter>
							<OutParameter>VerifyEntryDescription.ErrorMsg</OutParameter>
						</CallTestFunction>
					</Equal>
				</Compare>
				<!--Handle Compare Result-->
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.ErrorMsg</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>Compare_PdoMapping</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<RaiseWarning Id="31" Param0="VerifyEntryDescription.ErrorMsg">{0}</RaiseWarning>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>VerifyEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<CallTestFunction Name="AddMsgToList">
							<Parameter>VerifyEntryDescription.ErrorMsg</Parameter>
							<OutParameter>VerifyEntryDescription.ErrorList</OutParameter>
						</CallTestFunction>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="Compare_PdoMapping">
				<!--Create Message-->
				<SetVariable Target="VerifyEntryDescription.ErrorMsg" Param0="VerifyEntryDescription.Index" Param1="VerifyEntryDescription.SubIndex" Param2="VerifyEntryDescription.DictionaryType">{2}: 0x{0:X4}:{1} PdoMapping flag</SetVariable>
				<!--Skip compare if expected PDOMapping is null or empty-->
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.Expected.PdoMapping</Value1>
						<Value2>null</Value2>
						<GotoStep>Compare_Type</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.Expected.PdoMapping</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>Compare_Type</GotoStep>
					</Equal>
				</Compare>
				<!--Run Compare-->
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="32" Level="Verbose" Param0="VerifyEntryDescription.Expected.PdoMapping" Param1="VerifyEntryDescription.Current.PdoMapping">VerifyEntryDescription | Compare 'PdoMapping' expected ({0}) / current ({1})</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<CallTestFunction Name="String.CompareCaseInsensitive">
							<Parameter>VerifyEntryDescription.Expected.PdoMapping</Parameter>
							<Parameter>VerifyEntryDescription.Current.PdoMapping</Parameter>
							<Parameter>VerifyEntryDescription.ErrorMsg</Parameter>
							<OutParameter>VerifyEntryDescription.ErrorMsg</OutParameter>
						</CallTestFunction>
					</Equal>
				</Compare>
				<!--Handle Compare Result-->
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.ErrorMsg</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>Compare_Type</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<RaiseWarning Id="33" Param0="VerifyEntryDescription.ErrorMsg">{0}</RaiseWarning>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>VerifyEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<CallTestFunction Name="AddMsgToList">
							<Parameter>VerifyEntryDescription.ErrorMsg</Parameter>
							<OutParameter>VerifyEntryDescription.ErrorList</OutParameter>
						</CallTestFunction>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="Compare_Type">
				<!--Create Message-->
				<SetVariable Target="VerifyEntryDescription.ErrorMsg" Param0="VerifyEntryDescription.Index" Param1="VerifyEntryDescription.SubIndex" Param2="VerifyEntryDescription.DictionaryType">{2}: 0x{0:X4}:{1}.Type</SetVariable>
				<!--skip if reference dattype is 0xFFFF-->
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.Expected.Type</Value1>
						<Value2>#xFFFF</Value2>
						<WriteLine Id="34" Level="Verbose">VerifyEntryDescription | Skip compare 'Type'</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.Expected.Type</Value1>
						<Value2>#xFFFF</Value2>
						<GotoStep>Compare_Category</GotoStep>
					</Equal>
				</Compare>
				<!--Run Compare-->
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="35" Level="Verbose" Param0="VerifyEntryDescription.Expected.Type" Param1="VerifyEntryDescription.Current.Type">VerifyEntryDescription | Compare 'Type' expected ({0}) / current ({1})</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<CallTestFunction Name="UInt16.Compare">
							<Parameter>VerifyEntryDescription.Expected.Type</Parameter>
							<Parameter>VerifyEntryDescription.Current.Type</Parameter>
							<Parameter>VerifyEntryDescription.ErrorMsg</Parameter>
							<OutParameter>VerifyEntryDescription.ErrorMsg</OutParameter>
						</CallTestFunction>
					</Equal>
				</Compare>
				<!--Handle Compare Result-->
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.ErrorMsg</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>Compare_Category</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="HandleEnumDt">
				<!--Only up to 32Bit entires may be replaced by an Enum-->
				<Compare>
					<Greater>
						<Value1>VerifyEntryDescription.Current.BitSize</Value1>
						<Value2>32</Value2>
						<GotoStep>HandleCompareResult</GotoStep>
					</Greater>
				</Compare>
				<Compare>
					<Lower>
						<Value1>VerifyEntryDescription.Current.Type</Value1>
						<Value2>#x0800</Value2>
						<GotoStep>HandleCompareResult</GotoStep>
					</Lower>
				</Compare>
				<Compare>
					<Greater>
						<Value1>VerifyEntryDescription.Current.Type</Value1>
						<Value2>#x0FFF</Value2>
						<GotoStep>HandleCompareResult</GotoStep>
					</Greater>
				</Compare>
				<!--Current DataType is within the enum range => Dt valid-->
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<SetVariable Target="VerifyEntryDescription.ErrorMsg">EmptyString</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="36" Level="Verbose" Param0="VerifyEntryDescription.Current.Type">VerifyEntryDescription | An Enum data type is used.</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>Compare_Category</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="HandleCompareResult">
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<RaiseWarning Id="37" Param0="VerifyEntryDescription.ErrorMsg">{0}</RaiseWarning>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>VerifyEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<CallTestFunction Name="AddMsgToList">
							<Parameter>VerifyEntryDescription.ErrorMsg</Parameter>
							<OutParameter>VerifyEntryDescription.ErrorList</OutParameter>
						</CallTestFunction>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="Compare_Category">
				<!--Create Message-->
				<SetVariable Target="VerifyEntryDescription.ErrorMsg" Param0="VerifyEntryDescription.Index" Param1="VerifyEntryDescription.SubIndex" Param2="VerifyEntryDescription.DictionaryType">{2}: 0x{0:X4}:{1}.Category</SetVariable>
				<!--Skip Compare if category is empty string-->
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.Expected.Category</Value1>
						<Value2>EmptyString</Value2>
						<WriteLine Id="38" Level="Verbose">VerifyEntryDescription | Skip compare 'Category'</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.Expected.Category</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>Compare_Settings</GotoStep>
					</Equal>
				</Compare>
				<!--Run Compare-->
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="39" Level="Verbose" Param0="VerifyEntryDescription.Expected.Category" Param1="VerifyEntryDescription.Current.Category">VerifyEntryDescription | Compare 'Category' expected ({0}) / current ({1})</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<CallTestFunction Name="String.CompareCaseInsensitive">
							<Parameter>VerifyEntryDescription.Expected.Category</Parameter>
							<Parameter>VerifyEntryDescription.Current.Category</Parameter>
							<Parameter>VerifyEntryDescription.ErrorMsg</Parameter>
							<OutParameter>VerifyEntryDescription.ErrorMsg</OutParameter>
						</CallTestFunction>
					</Equal>
				</Compare>
				<!--Handle Compare Result-->
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.ErrorMsg</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>Compare_Settings</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<RaiseWarning Id="40" Param0="VerifyEntryDescription.ErrorMsg">{0}</RaiseWarning>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>VerifyEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<CallTestFunction Name="AddMsgToList">
							<Parameter>VerifyEntryDescription.ErrorMsg</Parameter>
							<OutParameter>VerifyEntryDescription.ErrorList</OutParameter>
						</CallTestFunction>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="Compare_Settings">
				<!--Create Message-->
				<SetVariable Target="VerifyEntryDescription.ErrorMsg" Param0="VerifyEntryDescription.Index" Param1="VerifyEntryDescription.SubIndex" Param2="VerifyEntryDescription.DictionaryType">{2}: 0x{0:X4}:{1} Setting flag</SetVariable>
				<!--Check if expected value is -1-->
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.Expected.Settings</Value1>
						<Value2>-1</Value2>
						<WriteLine Id="41" Level="Verbose">VerifyEntryDescription | Skip compare 'Settings'</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.Expected.Settings</Value1>
						<Value2>-1</Value2>
						<GotoStep>Compare_Backup</GotoStep>
					</Equal>
				</Compare>
				<!--Run Compare-->
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="42" Level="Verbose" Param0="VerifyEntryDescription.Expected.Settings" Param1="VerifyEntryDescription.Current.Settings">VerifyEntryDescription | Compare 'Settings' expected ({0}) / current ({1})</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<CallTestFunction Name="Bool.Compare">
							<Parameter>VerifyEntryDescription.Expected.Settings</Parameter>
							<Parameter>VerifyEntryDescription.Current.Settings</Parameter>
							<Parameter>VerifyEntryDescription.ErrorMsg</Parameter>
							<OutParameter>VerifyEntryDescription.ErrorMsg</OutParameter>
						</CallTestFunction>
					</Equal>
				</Compare>
				<!--Handle Compare Result-->
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.ErrorMsg</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>Compare_Backup</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<RaiseWarning Id="43" Param0="VerifyEntryDescription.ErrorMsg">{0}</RaiseWarning>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>VerifyEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<CallTestFunction Name="AddMsgToList">
							<Parameter>VerifyEntryDescription.ErrorMsg</Parameter>
							<OutParameter>VerifyEntryDescription.ErrorList</OutParameter>
						</CallTestFunction>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="Compare_Backup">
				<!--Create Message-->
				<SetVariable Target="VerifyEntryDescription.ErrorMsg" Param0="VerifyEntryDescription.Index" Param1="VerifyEntryDescription.SubIndex" Param2="VerifyEntryDescription.DictionaryType">{2}: 0x{0:X4}:{1} Backup flag</SetVariable>
				<!--Check if expected value is -1-->
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.Expected.Backup</Value1>
						<Value2>-1</Value2>
						<WriteLine Id="44" Level="Verbose">VerifyEntryDescription | Skip compare 'Backup'</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.Expected.Backup</Value1>
						<Value2>-1</Value2>
						<GotoStep>Compare_DefaultData</GotoStep>
					</Equal>
				</Compare>
				<!--Run Compare-->
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="45" Level="Verbose" Param0="VerifyEntryDescription.Expected.Backup" Param1="VerifyEntryDescription.Current.Backup">VerifyEntryDescription | Compare 'Backup' expected ({0}) / current ({1})</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<CallTestFunction Name="Bool.Compare">
							<Parameter>VerifyEntryDescription.Expected.Backup</Parameter>
							<Parameter>VerifyEntryDescription.Current.Backup</Parameter>
							<Parameter>VerifyEntryDescription.ErrorMsg</Parameter>
							<OutParameter>VerifyEntryDescription.ErrorMsg</OutParameter>
						</CallTestFunction>
					</Equal>
				</Compare>
				<!--Handle Compare Result-->
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.ErrorMsg</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>Compare_DefaultData</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<RaiseWarning Id="46" Param0="VerifyEntryDescription.ErrorMsg">{0}</RaiseWarning>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>VerifyEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<CallTestFunction Name="AddMsgToList">
							<Parameter>VerifyEntryDescription.ErrorMsg</Parameter>
							<OutParameter>VerifyEntryDescription.ErrorList</OutParameter>
						</CallTestFunction>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="Compare_DefaultData">
				<SizeOf UInt32Var="VerifyEntryDescription.Current.DataCount">VerifyEntryDescription.Current.DefaultData</SizeOf>
			</TestStep>
			<TestStep>
				<SizeOf UInt32Var="VerifyEntryDescription.Expected.DataCount">VerifyEntryDescription.Expected.DefaultData</SizeOf>
				<WriteLine Id="47" Level="Verbose" Param0="VerifyEntryDescription.Expected.DefaultData" Param1="VerifyEntryDescription.Expected.DataCount">Expected : Default Data '{0}' ; length {1}</WriteLine>
			</TestStep>
			<TestStep>
				<!--Create Message-->
				<SetVariable Target="VerifyEntryDescription.ErrorMsg" Param0="VerifyEntryDescription.Index" Param1="VerifyEntryDescription.SubIndex" Param2="VerifyEntryDescription.DictionaryType">{2}: 0x{0:X4}:{1} Default data</SetVariable>
				<!--Skip Compare if no default data is defined-->
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.Expected.DefaultData</Value1>
						<Value2>null</Value2>
						<WriteLine Id="48" Level="Verbose">Skip compare 'DefaultData'</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.Expected.DefaultData</Value1>
						<Value2>null</Value2>
						<GotoStep>Compare_MinData</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.Current.DefaultData</Value1>
						<Value2>null</Value2>
						<WriteLine Id="49" Level="Verbose">Skip compare 'DefaultData'</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.Current.DefaultData</Value1>
						<Value2>null</Value2>
						<GotoStep>Compare_MinData</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.Current.DataCount</Value1>
						<Value2>0</Value2>
						<WriteLine Id="50" Level="Verbose">Skip compare 'DefaultData'</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.Current.DataCount</Value1>
						<Value2>0</Value2>
						<GotoStep>Compare_MinData</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.Expected.DataCount</Value1>
						<Value2>0</Value2>
						<WriteLine Id="51" Level="Verbose">Skip compare 'DefaultData'</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.Expected.DataCount</Value1>
						<Value2>0</Value2>
						<GotoStep>Compare_MinData</GotoStep>
					</Equal>
				</Compare>
				<!--Run Compare-->
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="52" Level="Verbose" Param0="VerifyEntryDescription.Expected.DefaultData" Param1="VerifyEntryDescription.Current.DefaultData">VerifyEntryDescription | Compare 'DefaultData' expected ({0}) / current ({1})</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<CallTestFunction Name="ArrayOfBytes.Compare">
							<Parameter>VerifyEntryDescription.Expected.DefaultData</Parameter>
							<Parameter>VerifyEntryDescription.Current.DefaultData</Parameter>
							<Parameter>VerifyEntryDescription.ErrorMsg</Parameter>
							<OutParameter>VerifyEntryDescription.ErrorMsg</OutParameter>
						</CallTestFunction>
					</Equal>
				</Compare>
				<!--Handle Compare Result-->
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.ErrorMsg</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>Compare_MinData</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<RaiseWarning Id="53" Param0="VerifyEntryDescription.ErrorMsg">{0}</RaiseWarning>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>VerifyEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<CallTestFunction Name="AddMsgToList">
							<Parameter>VerifyEntryDescription.ErrorMsg</Parameter>
							<OutParameter>VerifyEntryDescription.ErrorList</OutParameter>
						</CallTestFunction>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="Compare_MinData">
				<SizeOf UInt32Var="VerifyEntryDescription.Current.DataCount">VerifyEntryDescription.Current.MinData</SizeOf>
			</TestStep>
			<TestStep>
				<SizeOf UInt32Var="VerifyEntryDescription.Expected.DataCount">VerifyEntryDescription.Expected.MinData</SizeOf>
				<WriteLine Id="54" Level="Verbose" Param0="VerifyEntryDescription.Expected.MinData" Param1="VerifyEntryDescription.Expected.DataCount">Expected : Min Data '{0}' ; length {1}</WriteLine>
			</TestStep>
			<TestStep>
				<!--Create Message-->
				<SetVariable Target="VerifyEntryDescription.ErrorMsg" Param0="VerifyEntryDescription.Index" Param1="VerifyEntryDescription.SubIndex" Param2="VerifyEntryDescription.DictionaryType">{2}: 0x{0:X4}:{1} MinData </SetVariable>
				<!--Skip Compare if no min data is defined-->
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.Current.MinData</Value1>
						<Value2>null</Value2>
						<WriteLine Id="55" Level="Verbose">Skip compare 'MinData'</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.Current.MinData</Value1>
						<Value2>null</Value2>
						<GotoStep>Compare_MaxData</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.Current.DataCount</Value1>
						<Value2>0</Value2>
						<WriteLine Id="56" Level="Verbose">Skip compare 'MinData'</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.Current.DataCount</Value1>
						<Value2>0</Value2>
						<GotoStep>Compare_MaxData</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.Expected.MinData</Value1>
						<Value2>null</Value2>
						<WriteLine Id="57" Level="Verbose">Skip compare 'MinData'</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.Expected.MinData</Value1>
						<Value2>null</Value2>
						<GotoStep>Compare_MaxData</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.Expected.DataCount</Value1>
						<Value2>0</Value2>
						<WriteLine Id="58" Level="Verbose">Skip compare 'MinData'</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.Expected.DataCount</Value1>
						<Value2>0</Value2>
						<GotoStep>Compare_MaxData</GotoStep>
					</Equal>
				</Compare>
				<!--Run Compare-->
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="59" Level="Verbose" Param0="VerifyEntryDescription.Expected.MinData" Param1="VerifyEntryDescription.Current.MinData">VerifyEntryDescription | Compare 'MinData' expected ({0}) / current ({1})</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<CallTestFunction Name="ArrayOfBytes.Compare">
							<Parameter>VerifyEntryDescription.Expected.MinData</Parameter>
							<Parameter>VerifyEntryDescription.Current.MinData</Parameter>
							<Parameter>VerifyEntryDescription.ErrorMsg</Parameter>
							<OutParameter>VerifyEntryDescription.ErrorMsg</OutParameter>
						</CallTestFunction>
					</Equal>
				</Compare>
				<!--Handle Compare Result-->
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.ErrorMsg</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>Compare_MaxData</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<RaiseWarning Id="60" Param0="VerifyEntryDescription.ErrorMsg">{0}</RaiseWarning>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>VerifyEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<CallTestFunction Name="AddMsgToList">
							<Parameter>VerifyEntryDescription.ErrorMsg</Parameter>
							<OutParameter>VerifyEntryDescription.ErrorList</OutParameter>
						</CallTestFunction>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="Compare_MaxData">
				<SizeOf UInt32Var="VerifyEntryDescription.Current.DataCount">VerifyEntryDescription.Current.MaxData</SizeOf>
			</TestStep>
			<TestStep>
				<SizeOf UInt32Var="VerifyEntryDescription.Expected.DataCount">VerifyEntryDescription.Expected.MaxData</SizeOf>
				<WriteLine Id="61" Level="Verbose" Param0="VerifyEntryDescription.Expected.MaxData" Param1="VerifyEntryDescription.Expected.DataCount">Expected : Max Data '{0}' ; length {1}</WriteLine>
			</TestStep>
			<TestStep>
				<!--Create Message-->
				<SetVariable Target="VerifyEntryDescription.ErrorMsg" Param0="VerifyEntryDescription.Index" Param1="VerifyEntryDescription.SubIndex" Param2="VerifyEntryDescription.DictionaryType">{2}: 0x{0:X4}:{1} MaxData </SetVariable>
				<!--Skip Compare if no max data is defined-->
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.Current.MaxData</Value1>
						<Value2>null</Value2>
						<WriteLine Id="62" Level="Verbose">Skip compare 'MaxData'</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.Current.MaxData</Value1>
						<Value2>null</Value2>
						<GotoStep>GetDefaultDataLength</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.Current.DataCount</Value1>
						<Value2>0</Value2>
						<WriteLine Id="63" Level="Verbose">Skip compare 'MaxData'</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.Current.DataCount</Value1>
						<Value2>0</Value2>
						<GotoStep>GetDefaultDataLength</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.Expected.MaxData</Value1>
						<Value2>null</Value2>
						<WriteLine Id="64" Level="Verbose">Skip compare 'MaxData'</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.Expected.MaxData</Value1>
						<Value2>null</Value2>
						<GotoStep>GetDefaultDataLength</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.Expected.DataCount</Value1>
						<Value2>0</Value2>
						<WriteLine Id="65" Level="Verbose">Skip compare 'MaxData'</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.Expected.DataCount</Value1>
						<Value2>0</Value2>
						<GotoStep>GetDefaultDataLength</GotoStep>
					</Equal>
				</Compare>
				<!--Run Compare-->
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="66" Level="Verbose" Param0="VerifyEntryDescription.Expected.MaxData" Param1="VerifyEntryDescription.Current.MaxData">VerifyEntryDescription | Compare 'MaxData' expected ({0}) / current ({1})</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<CallTestFunction Name="ArrayOfBytes.Compare">
							<Parameter>VerifyEntryDescription.Expected.MaxData</Parameter>
							<Parameter>VerifyEntryDescription.Current.MaxData</Parameter>
							<Parameter>VerifyEntryDescription.ErrorMsg</Parameter>
							<OutParameter>VerifyEntryDescription.ErrorMsg</OutParameter>
						</CallTestFunction>
					</Equal>
				</Compare>
				<!--Handle Compare Result-->
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.ErrorMsg</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>GetDefaultDataLength</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<RaiseWarning Id="67" Param0="VerifyEntryDescription.ErrorMsg">{0}</RaiseWarning>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>VerifyEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<CallTestFunction Name="AddMsgToList">
							<Parameter>VerifyEntryDescription.ErrorMsg</Parameter>
							<OutParameter>VerifyEntryDescription.ErrorList</OutParameter>
						</CallTestFunction>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="GetDefaultDataLength">
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.Current.DefaultData</Value1>
						<Value2>null</Value2>
						<Return Id="68"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<SizeOf UInt32Var="VerifyEntryDescription.Current.DataCount">VerifyEntryDescription.Current.DefaultData</SizeOf>
			</TestStep>
			<TestStep>
				<!--Create Message-->
				<SetVariable Target="VerifyEntryDescription.ErrorMsg" Param0="VerifyEntryDescription.Current.DataCount" Param1="(VerifyEntryDescription.Current.BitSize+7)/8" Param2="VerifyEntryDescription.Index" Param3="VerifyEntryDescription.SubIndex" Param4="VerifyEntryDescription.DictionaryType">{4}: 0x{2:X4}:{3} length of default data '{0}' expected: '{1}' (all bytes shall be defined in the defaultdata)</SetVariable>
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.Current.DataCount</Value1>
						<Value2>0</Value2>
						<Return Id="69"></Return>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.Current.DataCount</Value1>
						<Value2>(VerifyEntryDescription.Current.BitSize+7)/8</Value2>
						<Return Id="70"></Return>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<RaiseWarning Id="71" Param0="VerifyEntryDescription.ErrorMsg">{0}</RaiseWarning>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>VerifyEntryDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<CallTestFunction Name="AddMsgToList">
							<Parameter>VerifyEntryDescription.ErrorMsg</Parameter>
							<OutParameter>VerifyEntryDescription.ErrorList</OutParameter>
						</CallTestFunction>
					</NotEqual>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="1901" Name="VerifyObjectDescription">
			<?MAX_OUTPUT_ID 29?>
			<Description>
				<Purpose>OBSOLETE : use 'CheckObjectDescription' instead
Compares the passed values against the passed object description of the passed dictionary</Purpose>
				<PreCondition></PreCondition>
				<Action>-gets the object description of the passed index
-comares the values against the passed values</Action>
				<PostCondition>Throws an error if one of the values does not match to the expected value</PostCondition>
				<ProposalForSolution>true</ProposalForSolution>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>VerifyObjectDescription.ObjectDictionary</Name>
				<Type>ObjectDictionary</Type>
				<Comment>object dictionary to searach for specified object (by index)</Comment>
			</Parameter>
			<Parameter>
				<Name>VerifyObjectDescription.DictionaryType</Name>
				<Type>String</Type>
			</Parameter>
			<Parameter>
				<Name>VerifyObjectDescription.Index</Name>
				<Type>UInt16</Type>
			</Parameter>
			<Parameter>
				<Name>VerifyObjectDescription.LevelWarning</Name>
				<Type>Bool</Type>
				<Comment>If true raise warnign instead of errors</Comment>
			</Parameter>
			<Parameter>
				<Name>VerifyObjectDescription.CaseSensitive</Name>
				<Type>Bool</Type>
				<Comment>If true name ist checked case sensitive</Comment>
			</Parameter>
			<Parameter>
				<Name>VerifyObjectDescription.Expected.Name</Name>
				<Type>String</Type>
			</Parameter>
			<Parameter>
				<Name>VerifyObjectDescription.Expected.Type</Name>
				<Type>UInt16</Type>
			</Parameter>
			<Parameter>
				<Name>VerifyObjectDescription.Expected.ObjectCode</Name>
				<Type>Byte</Type>
			</Parameter>
			<Parameter>
				<Name>VerifyObjectDescription.Expected.Access.ReadInPreOp</Name>
				<Type>Bool</Type>
			</Parameter>
			<Parameter>
				<Name>VerifyObjectDescription.Expected.Access.ReadInSafeOp</Name>
				<Type>Bool</Type>
			</Parameter>
			<Parameter>
				<Name>VerifyObjectDescription.Expected.Access.ReadInOp</Name>
				<Type>Bool</Type>
			</Parameter>
			<Parameter>
				<Name>VerifyObjectDescription.Expected.Access.WriteInPreOp</Name>
				<Type>Bool</Type>
			</Parameter>
			<Parameter>
				<Name>VerifyObjectDescription.Expected.Access.WriteInSafeOp</Name>
				<Type>Bool</Type>
			</Parameter>
			<Parameter>
				<Name>VerifyObjectDescription.Expected.Access.WriteInOp</Name>
				<Type>Bool</Type>
			</Parameter>
			<Parameter>
				<Name>VerifyObjectDescription.Expected.Category</Name>
				<Type>String</Type>
			</Parameter>
			<Parameter>
				<Name>VerifyObjectDescription.Expected.PdoMapping</Name>
				<Type>String</Type>
			</Parameter>
			<Parameter>
				<Name>VerifyObjectDescription.Expected.DefaultData</Name>
				<Type>ArrayOfBytes</Type>
			</Parameter>
			<Parameter>
				<Name>VerifyObjectDescription.Expected.Settings</Name>
				<Type>Int16</Type>
			</Parameter>
			<Parameter>
				<Name>VerifyObjectDescription.Expected.Backup</Name>
				<Type>Int16</Type>
			</Parameter>
			<Parameter>
				<Name>VerifyObjectDescription.Expected.BitSize</Name>
				<Type>Int32</Type>
			</Parameter>
			<LocalVariables>
				<Name>VerifyObjectDescription.bTmpVar</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>VerifyObjectDescription.Current.Access.ReadInOp</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>VerifyObjectDescription.Current.Access.ReadInPreOp</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>VerifyObjectDescription.Current.Access.ReadInSafeOp</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>VerifyObjectDescription.Current.Access.WriteInOp</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>VerifyObjectDescription.Current.Access.WriteInPreOp</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>VerifyObjectDescription.Current.Access.WriteInSafeOp</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>VerifyObjectDescription.Current.Backup</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>VerifyObjectDescription.Current.BitSize</Name>
				<Type>Int32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>VerifyObjectDescription.Current.Category</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>VerifyObjectDescription.Current.DefaultData</Name>
				<Type>ArrayOfBytes</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>VerifyObjectDescription.Current.DefaultDataCount</Name>
				<Type>Int32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>VerifyObjectDescription.Current.Name</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>VerifyObjectDescription.Current.ObjectCode</Name>
				<Type>Byte</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>VerifyObjectDescription.Current.PdoMapping</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>VerifyObjectDescription.Current.Settings</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>VerifyObjectDescription.Current.Type</Name>
				<Type>UInt16</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>VerifyObjectDescription.ErrorMsg</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>VerifyObjectDescription.int32InsensitiveCompareResult</Name>
				<Type>Int32</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>VerifyObjectDescription.ReloadDescrSdoInfo</Name>
				<Type>Bool</Type>
			</LocalVariables>
			<OutParameter>
				<Name>VerifyObjectDescription.ErrorList</Name>
				<Type>ArrayOfString</Type>
			</OutParameter>
			<TestStep Name="CheckForMailboxCoE">
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Mailbox</Value1>
						<Value2>false</Value2>
						<SkipCase Id="0">Device does not support mailbox communication</SkipCase>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Mailbox.CoE</Value1>
						<Value2>false</Value2>
						<SkipCase Id="1">Device does not support CoE</SkipCase>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="InitReloadFlag">
				<SetVariable Target="VerifyObjectDescription.ReloadDescrSdoInfo">false</SetVariable>
			</TestStep>
			<TestStep Name="GetOdType">
				<RegexIsMatch ReturnValue="VerifyObjectDescription.bTmpVar" Options="IgnoreCase">
					<Pattern>^online.*</Pattern>
					<InputString>VerifyObjectDescription.DictionaryType</InputString>
				</RegexIsMatch>
				<Compare>
					<Equal>
						<Value1>VerifyObjectDescription.bTmpVar</Value1>
						<Value2>false</Value2>
						<GotoStep>GetObjectDescription</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CheckProfile">
				<!--Load Description via SDO Info for 5001.3100 or 5001.3101-->
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Profile.Count</Value1>
						<Value2>0</Value2>
						<GotoStep>GetObjectDescription</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>DeviceDescr.Profile[0].ProfileNo</Value1>
						<Value2>5001</Value2>
						<GotoStep>GetObjectDescription</GotoStep>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Profile[0].AddInfo</Value1>
						<Value2>3100</Value2>
						<SetVariable Target="VerifyObjectDescription.ReloadDescrSdoInfo">true</SetVariable>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Profile[0].AddInfo</Value1>
						<Value2>3101</Value2>
						<SetVariable Target="VerifyObjectDescription.ReloadDescrSdoInfo">true</SetVariable>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="GetObjectDescription">
				<Description Id="2" Param0="VerifyObjectDescription.Index" Level="Verbose">VerifyObjectDescription | 0x{0:X4}</Description>
				<GetObjectDescription Index="VerifyObjectDescription.Index" SourceDictionary="VerifyObjectDescription.ObjectDictionary" SubIndex="-1" SDOInfoReload="VerifyObjectDescription.ReloadDescrSdoInfo">
					<Name>VerifyObjectDescription.Current.Name</Name>
					<Type>VerifyObjectDescription.Current.Type</Type>
					<BitSize>VerifyObjectDescription.Current.BitSize</BitSize>
					<DefaultData>VerifyObjectDescription.Current.DefaultData</DefaultData>
					<Flags>
						<Access Backup="VerifyObjectDescription.Current.Backup" ReadInOP="VerifyObjectDescription.Current.Access.ReadInOp" ReadInPreop="VerifyObjectDescription.Current.Access.ReadInPreOp" ReadInSafeOP="VerifyObjectDescription.Current.Access.ReadInSafeOp" WriteinOP="VerifyObjectDescription.Current.Access.WriteInOp" WriteInPreOp="VerifyObjectDescription.Current.Access.WriteInPreOp" WriteInSafeOp="VerifyObjectDescription.Current.Access.WriteInSafeOp" Settings="VerifyObjectDescription.Current.Settings"></Access>
						<Category>VerifyObjectDescription.Current.Category</Category>
						<PdoMapping>VerifyObjectDescription.Current.PdoMapping</PdoMapping>
					</Flags>
					<ObjectCode>VerifyObjectDescription.Current.ObjectCode</ObjectCode>
				</GetObjectDescription>
				<GotoOnSuccess>CompareBitSize</GotoOnSuccess>
			</TestStep>
			<TestStep Name="ObjectNotFound">
				<!--Create Message-->
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<SetVariable Target="VerifyObjectDescription.ErrorMsg" Param0="VerifyObjectDescription.Index" Param1="VerifyObjectDescription.DictionaryType">{1}: 0x{0:X4} no description found.</SetVariable>
					</Equal>
				</Compare>
				<!--check LevelWarning-->
				<Compare>
					<Equal>
						<Value1>VerifyObjectDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<RaiseWarning Id="3" Param0="VerifyObjectDescription.ErrorMsg">{0}</RaiseWarning>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyObjectDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<GotoStep>CompareBitSize</GotoStep>
					</Equal>
				</Compare>
				<!--Add Message to Error list-->
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<CallTestFunction Name="AddMsgToList">
							<Parameter>VerifyObjectDescription.ErrorMsg</Parameter>
							<OutParameter>VerifyObjectDescription.ErrorList</OutParameter>
						</CallTestFunction>
					</Equal>
				</Compare>
				<!--return-->
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<Return Id="4"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CompareBitSize">
				<!--Create Message-->
				<SetVariable Target="VerifyObjectDescription.ErrorMsg" Param0="VerifyObjectDescription.Index" Param1="VerifyObjectDescription.DictionaryType">{1}: 0x{0:X4}.BitSize</SetVariable>
				<!--Skip if BitSize is -1-->
				<Compare>
					<Equal>
						<Value1>VerifyObjectDescription.Expected.BitSize</Value1>
						<Value2>-1</Value2>
						<WriteLine Id="5" Level="Verbose">VerifyObjectDescription | Skip compare 'BitSize'</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyObjectDescription.Expected.BitSize</Value1>
						<Value2>-1</Value2>
						<GotoStep>CompareName</GotoStep>
					</Equal>
				</Compare>
				<!--Run Compare-->
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="6" Level="Verbose" Param0="VerifyObjectDescription.Expected.BitSize" Param1="VerifyObjectDescription.Current.BitSize">VerifyObjectDescription | Compare 'BitSize' expected ({0}) / current ({1})</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<CallTestFunction Name="Int32.Compare">
							<Parameter>VerifyObjectDescription.Expected.BitSize</Parameter>
							<Parameter>VerifyObjectDescription.Current.BitSize</Parameter>
							<Parameter>VerifyObjectDescription.ErrorMsg</Parameter>
							<OutParameter>VerifyObjectDescription.ErrorMsg</OutParameter>
						</CallTestFunction>
					</Equal>
				</Compare>
				<!--Handle Compare Result-->
				<Compare>
					<Equal>
						<Value1>VerifyObjectDescription.ErrorMsg</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>CompareName</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyObjectDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<RaiseWarning Id="7" Param0="VerifyObjectDescription.ErrorMsg">{0}</RaiseWarning>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>VerifyObjectDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<CallTestFunction Name="AddMsgToList">
							<Parameter>VerifyObjectDescription.ErrorMsg</Parameter>
							<OutParameter>VerifyObjectDescription.ErrorList</OutParameter>
						</CallTestFunction>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="CompareName">
				<Compare>
					<Equal>
						<Value1>VerifyObjectDescription.Expected.Name</Value1>
						<Value2>null</Value2>
						<GotoStep>CompareCode</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyObjectDescription.Expected.Name</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>CompareCode</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyObjectDescription.Current.Name</Value1>
						<Value2>null</Value2>
						<GotoStep>CompareCode</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyObjectDescription.Current.Name</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>CompareCode</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="8" Level="Verbose" Param0="VerifyObjectDescription.Current.Name" Param1="VerifyObjectDescription.Expected.Name" Param2="VerifyObjectDescription.CaseSensitive">VerifyObjectDescription | Compare 'Name' expected ({1}) / current ({0}) / case sens. {2}</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>VerifyObjectDescription.CaseSensitive</Value1>
						<Value2>true</Value2>
						<GotoStep>CompareNameInsensitive</GotoStep>
					</NotEqual>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>VerifyObjectDescription.Current.Name</Value1>
						<Value2>VerifyObjectDescription.Expected.Name</Value2>
						<WriteLine Id="9" Level="Warning" Param0="VerifyObjectDescription.Current.Name" Param1="VerifyObjectDescription.Expected.Name" Param2="VerifyObjectDescription.Index">0x{2:X4} Unexpected name '{0}' expected: '{1}'</WriteLine>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<GotoStep>CompareCode</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="CompareNameInsensitive">
				<StringCompare ReturnValue="VerifyObjectDescription.int32InsensitiveCompareResult" Options="IgnoreCase">
					<String1>VerifyObjectDescription.Current.Name</String1>
					<String2>VerifyObjectDescription.Expected.Name</String2>
				</StringCompare>
				<Compare>
					<NotEqual>
						<Value1>VerifyObjectDescription.int32InsensitiveCompareResult</Value1>
						<Value2>0</Value2>
						<WriteLine Id="10" Level="Warning" Param0="VerifyObjectDescription.Current.Name" Param1="VerifyObjectDescription.Expected.Name" Param2="VerifyObjectDescription.Index">0x{2:X4} Unexpected name '{0}' expected: '{1}'</WriteLine>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="CompareCode">
				<!--Create Message-->
				<SetVariable Target="VerifyObjectDescription.ErrorMsg" Param0="VerifyObjectDescription.Index" Param1="VerifyObjectDescription.DictionaryType">{1}: 0x{0:X4}.Code</SetVariable>
				<!--Run Compare-->
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="11" Level="Verbose" Param0="VerifyObjectDescription.Expected.ObjectCode" Param1="VerifyObjectDescription.Current.ObjectCode">VerifyObjectDescription | Compare 'ObjCode' expected ({0}) / current ({1})</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<CallTestFunction Name="Byte.Compare">
							<Parameter>VerifyObjectDescription.Expected.ObjectCode</Parameter>
							<Parameter>VerifyObjectDescription.Current.ObjectCode</Parameter>
							<Parameter>VerifyObjectDescription.ErrorMsg</Parameter>
							<OutParameter>VerifyObjectDescription.ErrorMsg</OutParameter>
						</CallTestFunction>
					</Equal>
				</Compare>
				<!--Handle Compare Result-->
				<Compare>
					<Equal>
						<Value1>VerifyObjectDescription.ErrorMsg</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>ComparePdoMapping</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyObjectDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<RaiseWarning Id="12" Param0="VerifyObjectDescription.ErrorMsg">{0}</RaiseWarning>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>VerifyObjectDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<CallTestFunction Name="AddMsgToList">
							<Parameter>VerifyObjectDescription.ErrorMsg</Parameter>
							<OutParameter>VerifyObjectDescription.ErrorList</OutParameter>
						</CallTestFunction>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="ComparePdoMapping">
				<!--Create Message-->
				<SetVariable Target="VerifyObjectDescription.ErrorMsg" Param0="VerifyObjectDescription.Index" Param1="VerifyObjectDescription.DictionaryType">{1}: 0x{0:X4} PdoMapping flag </SetVariable>
				<!--Run Compare-->
				<Compare>
					<Equal>
						<Value1>VerifyObjectDescription.Expected.PdoMapping</Value1>
						<Value2>null</Value2>
						<WriteLine Id="13" Level="Verbose" Param0="VerifyObjectDescription.Expected.PdoMapping" Param1="VerifyObjectDescription.Current.PdoMapping">VerifyObjectDescription | Skip compare 'PdoMapping'</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyObjectDescription.Expected.PdoMapping</Value1>
						<Value2>null</Value2>
						<GotoStep>CompareType</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyObjectDescription.Expected.PdoMapping</Value1>
						<Value2>EmptyString</Value2>
						<WriteLine Id="14" Level="Verbose" Param0="VerifyObjectDescription.Expected.PdoMapping" Param1="VerifyObjectDescription.Current.PdoMapping">VerifyObjectDescription | Skip compare 'PdoMapping'</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyObjectDescription.Expected.PdoMapping</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>CompareType</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="15" Level="Verbose" Param0="VerifyObjectDescription.Expected.PdoMapping" Param1="VerifyObjectDescription.Current.PdoMapping">VerifyObjectDescription | Compare 'PdoMapping' expected ({0}) / current ({1})</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<CallTestFunction Name="String.CompareCaseInsensitive">
							<Parameter>VerifyObjectDescription.Expected.PdoMapping</Parameter>
							<Parameter>VerifyObjectDescription.Current.PdoMapping</Parameter>
							<Parameter>VerifyObjectDescription.ErrorMsg</Parameter>
							<OutParameter>VerifyObjectDescription.ErrorMsg</OutParameter>
						</CallTestFunction>
					</Equal>
				</Compare>
				<!--Handle Compare Result-->
				<Compare>
					<Equal>
						<Value1>VerifyObjectDescription.ErrorMsg</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>CompareType</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyObjectDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<RaiseWarning Id="16" Param0="VerifyObjectDescription.ErrorMsg">{0}</RaiseWarning>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>VerifyObjectDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<CallTestFunction Name="AddMsgToList">
							<Parameter>VerifyObjectDescription.ErrorMsg</Parameter>
							<OutParameter>VerifyObjectDescription.ErrorList</OutParameter>
						</CallTestFunction>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="CompareType">
				<!--Create Message-->
				<SetVariable Target="VerifyObjectDescription.ErrorMsg" Param0="VerifyObjectDescription.Index" Param1="VerifyObjectDescription.DictionaryType">{1}: 0x{0:X4}.Type</SetVariable>
				<!--Skip if Reference Type is 0-->
				<Compare>
					<Equal>
						<Value1>VerifyObjectDescription.Expected.Type</Value1>
						<Value2>0</Value2>
						<WriteLine Id="17" Level="Verbose">VerifyObjectDescription | Skip compare 'Type'</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyObjectDescription.Expected.Type</Value1>
						<Value2>0</Value2>
						<GotoStep>CompareCategory</GotoStep>
					</Equal>
				</Compare>
				<!--Run Compare-->
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="18" Level="Verbose" Param0="VerifyObjectDescription.Expected.Type" Param1="VerifyObjectDescription.Current.Type">VerifyObjectDescription | Compare 'Type' expected ({0}) / current ({1})</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<CallTestFunction Name="UInt16.Compare">
							<Parameter>VerifyObjectDescription.Expected.Type</Parameter>
							<Parameter>VerifyObjectDescription.Current.Type</Parameter>
							<Parameter>VerifyObjectDescription.ErrorMsg</Parameter>
							<OutParameter>VerifyObjectDescription.ErrorMsg</OutParameter>
						</CallTestFunction>
					</Equal>
				</Compare>
				<!--Handle Compare Result-->
				<Compare>
					<Equal>
						<Value1>VerifyObjectDescription.ErrorMsg</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>CompareCategory</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyObjectDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<RaiseWarning Id="19" Param0="VerifyObjectDescription.ErrorMsg">{0}</RaiseWarning>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>VerifyObjectDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<CallTestFunction Name="AddMsgToList">
							<Parameter>VerifyObjectDescription.ErrorMsg</Parameter>
							<OutParameter>VerifyObjectDescription.ErrorList</OutParameter>
						</CallTestFunction>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="CompareCategory">
				<!--Create Message-->
				<SetVariable Target="VerifyObjectDescription.ErrorMsg" Param0="VerifyObjectDescription.Index" Param1="VerifyObjectDescription.DictionaryType">{1}: 0x{0:X4} Category</SetVariable>
				<!--Skip Compare if category is null-->
				<Compare>
					<Equal>
						<Value1>VerifyObjectDescription.Expected.Category</Value1>
						<Value2>null</Value2>
						<WriteLine Id="20" Level="Verbose">VerifyObjectDescription | Skip compare 'Category'</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyObjectDescription.Expected.Category</Value1>
						<Value2>null</Value2>
						<GotoStep>CompareDefaultData</GotoStep>
					</Equal>
				</Compare>
				<!--Skip Compare if category is empty string-->
				<Compare>
					<Equal>
						<Value1>VerifyObjectDescription.Expected.Category</Value1>
						<Value2>EmptyString</Value2>
						<WriteLine Id="21" Level="Verbose">VerifyObjectDescription | Skip compare 'Category'</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyObjectDescription.Expected.Category</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>CompareDefaultData</GotoStep>
					</Equal>
				</Compare>
				<!--Skip Compare if category is not defined-->
				<Compare>
					<Equal>
						<Value1>VerifyObjectDescription.Current.Category</Value1>
						<Value2>"None"</Value2>
						<GotoStep>CompareDefaultData</GotoStep>
					</Equal>
				</Compare>
				<!--Run Compare-->
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<WriteLine Id="22" Level="Verbose" Param0="VerifyObjectDescription.Expected.Category" Param1="VerifyObjectDescription.Current.Category">VerifyObjectDescription | Compare 'Category' expected ({0}) / current ({1})</WriteLine>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>true</Value1>
						<Value2>true</Value2>
						<CallTestFunction Name="String.CompareCaseInsensitive">
							<Parameter>VerifyObjectDescription.Expected.Category</Parameter>
							<Parameter>VerifyObjectDescription.Current.Category</Parameter>
							<Parameter>VerifyObjectDescription.ErrorMsg</Parameter>
							<OutParameter>VerifyObjectDescription.ErrorMsg</OutParameter>
						</CallTestFunction>
					</Equal>
				</Compare>
				<!--Handle Compare Result-->
				<Compare>
					<Equal>
						<Value1>VerifyObjectDescription.ErrorMsg</Value1>
						<Value2>EmptyString</Value2>
						<GotoStep>CompareDefaultData</GotoStep>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyObjectDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<RaiseWarning Id="23" Param0="VerifyObjectDescription.ErrorMsg">{0}</RaiseWarning>
					</Equal>
				</Compare>
				<Compare>
					<NotEqual>
						<Value1>VerifyObjectDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<CallTestFunction Name="AddMsgToList">
							<Parameter>VerifyObjectDescription.ErrorMsg</Parameter>
							<OutParameter>VerifyObjectDescription.ErrorList</OutParameter>
						</CallTestFunction>
					</NotEqual>
				</Compare>
			</TestStep>
			<TestStep Name="CompareDefaultData">
				<Compare>
					<Equal>
						<Value1>VerifyObjectDescription.Expected.DefaultData</Value1>
						<Value2>null</Value2>
						<Return Id="24"></Return>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyObjectDescription.Current.DefaultData</Value1>
						<Value2>null</Value2>
						<Return Id="25"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="GetDefaultDataLength">
				<SizeOf UInt32Var="VerifyObjectDescription.Current.DefaultDataCount">VerifyObjectDescription.Current.DefaultData</SizeOf>
				<Compare>
					<Equal>
						<Value1>VerifyObjectDescription.Current.DefaultDataCount</Value1>
						<Value2>0</Value2>
						<Return Id="26"></Return>
					</Equal>
				</Compare>
				<!--If valid proceed with next test-->
				<Compare>
					<Equal>
						<Value1>VerifyObjectDescription.Current.DefaultDataCount</Value1>
						<Value2>(VerifyObjectDescription.Current.BitSize+7)/8</Value2>
						<Return Id="27"></Return>
					</Equal>
				</Compare>
				<!--Create Message-->
				<Compare>
					<NotEqual>
						<Value1>VerifyObjectDescription.Current.DefaultDataCount</Value1>
						<Value2>(VerifyObjectDescription.Current.BitSize+7)/8</Value2>
						<SetVariable Target="VerifyObjectDescription.ErrorMsg" Param0="VerifyObjectDescription.Current.DefaultDataCount" Param1="(VerifyObjectDescription.Expected.BitSize+7)/8" Param2="VerifyObjectDescription.Index">0x{2:X4} length of default data '{0}' expected: '{1}'</SetVariable>
					</NotEqual>
				</Compare>
				<!--check LevelWarning-->
				<Compare>
					<Equal>
						<Value1>VerifyObjectDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<RaiseWarning Id="28" Param0="VerifyObjectDescription.ErrorMsg">{0}</RaiseWarning>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>VerifyObjectDescription.LevelWarning</Value1>
						<Value2>true</Value2>
						<Return Id="29"></Return>
					</Equal>
				</Compare>
				<!--Add Message to Error list-->
				<Compare>
					<NotEqual>
						<Value1>VerifyObjectDescription.Current.DefaultDataCount</Value1>
						<Value2>(VerifyObjectDescription.Current.BitSize+7)/8</Value2>
						<CallTestFunction Name="AddMsgToList">
							<Parameter>VerifyObjectDescription.ErrorMsg</Parameter>
							<OutParameter>VerifyObjectDescription.ErrorList</OutParameter>
						</CallTestFunction>
					</NotEqual>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction FunctionId="2001" Name="XmlFile.GetNumberOfElements">
			<?MAX_OUTPUT_ID 1?>
			<Description>
				<Purpose>Gets the number of Elements referenced by the parameter XPath</Purpose>
				<PreCondition>-none</PreCondition>
				<Action></Action>
				<PostCondition></PostCondition>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>XmlFile.GetNumberOfElements.XPath</Name>
				<Type>String</Type>
				<Comment>Path of the Element</Comment>
			</Parameter>
			<Parameter>
				<Name>XmlFile.GetNumberOfElements.File</Name>
				<Type>String</Type>
				<Comment>If empty current ESI file will be used</Comment>
			</Parameter>
			<LocalVariables>
				<Name>XmlFile.GetNumberOfElements.stringXmlValue</Name>
				<Type>String</Type>
			</LocalVariables>
			<LocalVariables>
				<Name>XmlFile.GetNumberOfElements.LoopCounter</Name>
				<Type>UInt16</Type>
			</LocalVariables>
			<OutParameter>
				<Name>XmlFile.GetNumberOfElements.Count</Name>
				<Type>Int32</Type>
			</OutParameter>
			<TestStep Name="SET_COUNT_NEGATIVE">
				<SetVariable Target="XmlFile.GetNumberOfElements.Count">-1</SetVariable>
			</TestStep>
			<TestStep Name="INIT_LOOP_COUNTER">
				<SetVariable Target="XmlFile.GetNumberOfElements.LoopCounter">2</SetVariable>
			</TestStep>
			<TestStep Name="CHECK_FIRST_ELEMENT">
				<GetXmlValue ReturnValue="XmlFile.GetNumberOfElements.stringXmlValue" Markup="false" FileName="XmlFile.GetNumberOfElements.File">
					<XPath Param0="XmlFile.GetNumberOfElements.XPath">{0}</XPath>
				</GetXmlValue>
				<Compare>
					<NotEqual>
						<Value1>XmlFile.GetNumberOfElements.stringXmlValue</Value1>
						<Value2>null</Value2>
						<SetVariable Target="XmlFile.GetNumberOfElements.Count">1</SetVariable>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>XmlFile.GetNumberOfElements.stringXmlValue</Value1>
						<Value2>null</Value2>
						<Return Id="0"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="LOOP_START">
				<GetXmlValue ReturnValue="XmlFile.GetNumberOfElements.stringXmlValue" Markup="false" FileName="XmlFile.GetNumberOfElements.File">
					<XPath Param0="XmlFile.GetNumberOfElements.XPath" Param1="XmlFile.GetNumberOfElements.LoopCounter">{0}[{1}]</XPath>
				</GetXmlValue>
				<Compare>
					<NotEqual>
						<Value1>XmlFile.GetNumberOfElements.stringXmlValue</Value1>
						<Value2>null</Value2>
						<SetVariable Target="XmlFile.GetNumberOfElements.Count">XmlFile.GetNumberOfElements.Count + 1</SetVariable>
					</NotEqual>
				</Compare>
				<Compare>
					<Equal>
						<Value1>XmlFile.GetNumberOfElements.stringXmlValue</Value1>
						<Value2>null</Value2>
						<Return Id="1"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep Name="LOOP_END">
				<SetVariable Target="XmlFile.GetNumberOfElements.LoopCounter">XmlFile.GetNumberOfElements.LoopCounter + 1</SetVariable>
				<Compare>
					<Equal>
						<Value1>TRUE</Value1>
						<Value2>TRUE</Value2>
						<GotoStep>LOOP_START</GotoStep>
					</Equal>
				</Compare>
			</TestStep>
		</TestFunction>
		<TestFunction Name="Mailbox.GetRequestTimeout" FunctionId="2002">
			<?MAX_OUTPUT_ID 1?>
			<OutParameter>
				<Name>Mailbox.GetRequestTimeout.i32ReturnValue</Name>
				<Type>Int32</Type>
				<Comment>timeout in ms</Comment>
			</OutParameter>
			<TestStep>
				<SetVariable Target="Mailbox.GetRequestTimeout.i32ReturnValue">100</SetVariable>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Info</Value1>
						<Value2>false</Value2>
						<Return Id="0"></Return>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Info.Mailbox</Value1>
						<Value2>false</Value2>
						<Return Id="1"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<SetVariable Target="Mailbox.GetRequestTimeout.i32ReturnValue">DeviceDescr.Info.Mailbox.RequestTimeout</SetVariable>
			</TestStep>
		</TestFunction>
		<TestFunction Name="Mailbox.GetResponseTimeout" FunctionId="2003">
			<?MAX_OUTPUT_ID 1?>
			<OutParameter>
				<Name>Mailbox.GetResponseTimeout.i32ReturnValue</Name>
				<Type>Int32</Type>
				<Comment>timeout in ms</Comment>
			</OutParameter>
			<TestStep>
				<SetVariable Target="Mailbox.GetResponseTimeout.i32ReturnValue">1000</SetVariable>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Info</Value1>
						<Value2>false</Value2>
						<Return Id="0"></Return>
					</Equal>
				</Compare>
				<Compare>
					<Equal>
						<Value1>DeviceDescr.Info.Mailbox</Value1>
						<Value2>false</Value2>
						<Return Id="1"></Return>
					</Equal>
				</Compare>
			</TestStep>
			<TestStep>
				<SetVariable Target="Mailbox.GetResponseTimeout.i32ReturnValue">DeviceDescr.Info.Mailbox.ResponseTimeout</SetVariable>
			</TestStep>
		</TestFunction>
		<TestFunction Name="UInt32.AbsoluteDif" FunctionId="3003">
			<Description>
				<Purpose>Gets the absolute difference between two UInt32 variables</Purpose>
				<PreCondition></PreCondition>
				<Action></Action>
				<PostCondition></PostCondition>
				<References>
					<Reference></Reference>
				</References>
			</Description>
			<Parameter>
				<Name>UInt32AbsoluteDif.u32Val1</Name>
				<Type>UInt32</Type>
			</Parameter>
			<Parameter>
				<Name>UInt32AbsoluteDif.u32Val2</Name>
				<Type>UInt32</Type>
			</Parameter>
			<LocalVariables>
				<Name>UInt32AbsoluteDif.u32tmp</Name>
				<Type>UInt32</Type>
				<DefaultValue>#xFFFFFFFF</DefaultValue>
			</LocalVariables>
			<OutParameter>
				<Name>UInt32AbsoluteDif.u32Dif</Name>
				<Type>UInt32</Type>
			</OutParameter>
			<TestStep>
				<Compare>
					<LowerOrEqual>
						<Value1>UInt32AbsoluteDif.u32Val2</Value1>
						<Value2>UInt32AbsoluteDif.u32Val1</Value2>
						<SetVariable Target="UInt32AbsoluteDif.u32Dif">UInt32AbsoluteDif.u32Val1 - UInt32AbsoluteDif.u32Val2</SetVariable>
					</LowerOrEqual>
				</Compare>
				<Compare>
					<LowerOrEqual>
						<Value1>UInt32AbsoluteDif.u32Val2</Value1>
						<Value2>UInt32AbsoluteDif.u32Val1</Value2>
						<Return></Return>
					</LowerOrEqual>
				</Compare>
			</TestStep>
			<TestStep>
				<Compare>
					<Greater>
						<Value1>UInt32AbsoluteDif.u32Val2</Value1>
						<Value2>UInt32AbsoluteDif.u32Val1</Value2>
						<SetVariable Target="UInt32AbsoluteDif.u32Dif">UInt32AbsoluteDif.u32tmp - UInt32AbsoluteDif.u32Val1</SetVariable>
					</Greater>
				</Compare>
				<Compare>
					<Greater>
						<Value1>UInt32AbsoluteDif.u32Val2</Value1>
						<Value2>UInt32AbsoluteDif.u32Val1</Value2>
						<SetVariable Target="UInt32AbsoluteDif.u32Dif">UInt32AbsoluteDif.u32Dif + UInt32AbsoluteDif.u32Val2</SetVariable>
					</Greater>
				</Compare>
			</TestStep>
		</TestFunction>
	</TestFunctions>
</EtherCATTest>